<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Web-Based Corpus Analyzer (WBCA)</title>
  <style>
    body {
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      margin: 0;
      background: #ffffff;
      color: #111827;
    }
    .container {
      width: 90%;
      margin: 0 auto;
      padding: 1.5rem;
    }
    h1 {
      font-size: 1.5rem;
      margin-bottom: 0.5rem;
    }
    .subtitle {
      font-size: 0.9rem;
      color: #4b5563;
      margin-bottom: 1rem;
    }
    .card {
      background: #ffffff;
      padding: 1rem 1.25rem;
      margin-bottom: 1rem;
    }
    .card h2 {
      font-size: 1.1rem;
      margin-top: 0;
      margin-bottom: 0.75rem;
    }
    .section-row {
      display: flex;
      flex-wrap: wrap;
      gap: 1rem;
    }
    .section-row > .card {
      flex: 1 1 360px;
    }
    label {
      font-size: 0.9rem;
      display: inline-block;
      margin-right: 0.5rem;
    }
    .radio-group {
      display: flex;
      gap: 1rem;
      flex-wrap: wrap;
      margin-bottom: 0.5rem;
    }
    .help-text {
      font-size: 0.8rem;
      color: #6b7280;
    }
    input[type="file"] {
      margin: 0.25rem 0;
    }
    button {
      padding: 0.4rem 0.75rem;
      border-radius: 999px;
      border: none;
      cursor: pointer;
      font-size: 0.9rem;
      background: #3b82f6;
      color: #ffffff;
      display: inline-flex;
      align-items: center;
      gap: 0.35rem;
    }
    button:disabled {
      opacity: 0.6;
      cursor: default;
    }
    button.secondary {
      background: #6b7280;
    }
    button.small {
      padding: 0.25rem 0.6rem;
      font-size: 0.8rem;
      border-radius: 999px;
    }
    button.export {
      background: #16a34a;
    }
    button.btn-clear {
      background: #dc2626;
    }
    button.btn-clear:hover {
      background: #b91c1c;
    }
    button.btn-filter {
      background: #f97316;
    }
    button.btn-filter:hover {
      background: #ea580c;
    }
    button.btn-sort {
      background: #7c3aed;
    }
    button.btn-sort:hover {
      background: #6d28d9;
    }
    .badge {
      display: inline-block;
      padding: 0.1rem 0.45rem;
      border-radius: 999px;
      font-size: 0.75rem;
      background: #e5e7eb;
      color: #374151;
    }
    .badge.tagged {
      background: #f97316;
      color: #fff;
    }
    .badge.plain {
      background: #10b981;
      color: #fff;
    }
    .badge.folder {
      background: #6366f1;
      color: #fff;
    }
    .status {
      font-size: 0.85rem;
      color: #4b5563;
      margin-top: 0.25rem;
    }
    table {
      width: 100%;
      border-collapse: collapse;
      font-size: 0.85rem;
      table-layout: fixed;
    }
    th, td {
      padding: 0.3rem 0.4rem;
      border-bottom: 1px solid #e5e7eb;
      text-align: left;
      vertical-align: top;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }
    th {
      background: #f9fafb;
      font-weight: 600;
    }
    tr:nth-child(even) td {
      background: #f9fafb;
    }
    .table-wrapper {
      max-height: 360px;
      overflow: auto;
      border-radius: 0.5rem;
      border: 1px solid #e5e7eb;
      background: #ffffff;
    }
    .flex {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      flex-wrap: wrap;
    }
    .flex-between {
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 0.5rem;
      flex-wrap: wrap;
    }
    input[type="number"],
    input[type="text"],
    select {
      font-size: 0.85rem;
      padding: 0.2rem 0.4rem;
      border-radius: 0.4rem;
      border: 1px solid #d1d5db;
      min-width: 0;
    }
    .mono {
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
    }
    .pill {
      border-radius: 999px;
      padding: 0.15rem 0.5rem;
      font-size: 0.75rem;
      background: #eff6ff;
      color: #1d4ed8;
    }
    .mt-05 { margin-top: 0.25rem; }
    .mt-1 { margin-top: 0.5rem; }
    .mt-2 { margin-top: 1rem; }
    .mb-0 { margin-bottom: 0; }
    .text-right { text-align: right; }
    .text-center { text-align: center; }
    .text-sm { font-size: 0.85rem; }
    .text-xs { font-size: 0.75rem; }
    .hf-divider { border-right: 2px solid #9ca3af; }


    .col-resizer {
      position: absolute;
      top: 0;
      right: 0;
      width: 4px;
      cursor: col-resize;
      user-select: none;
      height: 100%;
    }

    /* Constituent Pattern Table resizer */
    #constPatternTable {
      table-layout: fixed;
    }
    #constPatternTable th.resizable {
      position: relative;
    }
    #constPatternTable th .col-resizer {
      position: absolute;
      top: 0;
      right: 0;
      width: 5px;
      height: 100%;
      cursor: col-resize;
      background: transparent;
    }
    #constPatternTable th .col-resizer:hover {
      background: #3b82f6;
    }

    /* Constituent Concordance Table resizer */
    #constConcordanceTable {
      table-layout: fixed;
    }
    #constConcordanceTable th.resizable {
      position: relative;
    }
    #constConcordanceTable th .col-resizer {
      position: absolute;
      top: 0;
      right: 0;
      width: 5px;
      height: 100%;
      cursor: col-resize;
      background: transparent;
    }
    #constConcordanceTable th .col-resizer:hover {
      background: #3b82f6;
    }

    /* KWIC style for concordance */
    .kwic-left { text-align: right; color: #374151; }
    .kwic-center { text-align: center; font-weight: 600; color: #dc2626; background: #fef3c7; }
    .kwic-right { text-align: left; color: #374151; }

    /* HF Table column resizer */
    #hfTable {
      table-layout: auto;
    }
    #hfTable th .hf-col-resizer {
      position: absolute;
      top: 0;
      right: 0;
      width: 5px;
      height: 100%;
      cursor: col-resize;
      background: transparent;
    }
    #hfTable th .hf-col-resizer:hover {
      background: #3b82f6;
    }

    /* Keyness Table column resizer */
    #keyTable {
      table-layout: auto;
    }
    #keyTable th .key-col-resizer {
      position: absolute;
      top: 0;
      right: 0;
      width: 5px;
      height: 100%;
      cursor: col-resize;
      background: transparent;
    }
    #keyTable th .key-col-resizer:hover {
      background: #3b82f6;
    }

    /* Frequency Table Specific Styles */
    #freqTable {
      table-layout: auto;
      border-collapse: collapse;
    }
    #freqTable th,
    #freqTable td {
      white-space: nowrap;
      padding: 0.25rem 0.5rem;
      border: 1px solid #e5e7eb;
    }
    #freqTable th {
      position: relative;
      background: #f3f4f6;
      user-select: none;
    }
    #freqTable th .freq-col-resizer {
      position: absolute;
      top: 0;
      right: 0;
      width: 5px;
      height: 100%;
      cursor: col-resize;
      background: transparent;
    }
    #freqTable th .freq-col-resizer:hover {
      background: #3b82f6;
    }
    #chiSquareResultsTable th .chi-col-resizer,
    #chiSquareDetailTable th .chi-detail-resizer {
      position: absolute;
      top: 0;
      right: 0;
      width: 5px;
      height: 100%;
      cursor: col-resize;
      background: transparent;
    }
    #chiSquareResultsTable th .chi-col-resizer:hover,
    #chiSquareDetailTable th .chi-detail-resizer:hover {
      background: #3b82f6;
    }
    #freqTableWrapper {
      overflow-x: auto;
      overflow-y: auto;
    }

    th.sortable {
      cursor: pointer;
    }
    th.sortable::after {
      content: " ⇅";
      font-size: 0.7rem;
      color: #9ca3af;
    }
    th.sortable.sorted-asc::after {
      content: " ↑";
      color: #2563eb;
    }
    th.sortable.sorted-desc::after {
      content: " ↓";
      color: #2563eb;
    }

    /* HF feature link style (black, no underline, like Keyness) */
    .hf-feature-link {
      cursor: pointer;
      color: #000;
      text-decoration: none;
    }
    .hf-feature-link:hover {
      background: #f0f0f0;
    }

    /* Fillers horizontal scroll - セル内でスクロール可能 */
    td.fillers-cell {
      min-width: 280px !important;
      max-width: 350px !important;
      overflow-x: auto !important;
      overflow-y: hidden !important;
      white-space: nowrap !important;
      text-overflow: clip !important;
      vertical-align: middle !important;
    }
    td.fillers-cell::-webkit-scrollbar {
      height: 8px;
    }
    td.fillers-cell::-webkit-scrollbar-track {
      background: #e5e7eb;
      border-radius: 4px;
    }
    td.fillers-cell::-webkit-scrollbar-thumb {
      background: #9ca3af;
      border-radius: 4px;
    }
    td.fillers-cell::-webkit-scrollbar-thumb:hover {
      background: #6b7280;
    }
    .filler-item {
      cursor: pointer;
      color: #1d4ed8;
      text-decoration: underline;
      margin-right: 0.5rem;
      display: inline;
      white-space: nowrap;
    }
    .filler-item:hover {
      color: #1e40af;
      background: #eff6ff;
      border-radius: 2px;
    }
    .filler-item:hover {
      color: #1e40af;
      background: #eff6ff;
    }
    
    /* Collocate Tables - New Format */
    .collocate-section-title {
      font-size: 1rem;
      margin: 0 0 0.5rem 0;
      padding-bottom: 0.25rem;
      border-bottom: 2px solid;
    }
    .collocate-section-title.target {
      color: #2563eb;
      border-color: #2563eb;
    }
    .collocate-section-title.reference {
      color: #dc2626;
      border-color: #dc2626;
    }
    .collocate-tables-container {
      display: flex;
      flex-wrap: nowrap;
      gap: 0.5rem;
      overflow-x: auto;
      padding: 0.5rem 0;
    }
    .collocate-box {
      flex: 0 0 auto;
      border: 1px solid #d1d5db;
      border-radius: 0.375rem;
      background: #fff;
      font-size: 0.75rem;
      overflow: hidden;
    }
    .collocate-box-title {
      background: #f3f4f6;
      padding: 0.3rem 0.5rem;
      font-weight: 600;
      font-size: 0.8rem;
      text-align: center;
      border-bottom: 1px solid #d1d5db;
    }
    .collocate-box table {
      border-collapse: collapse;
      table-layout: auto;
    }
    .collocate-box th {
      background: #f9fafb;
      font-weight: 600;
      font-size: 0.7rem;
      padding: 0.25rem 0.4rem;
      border-bottom: 1px solid #e5e7eb;
      text-align: center;
      white-space: nowrap;
      cursor: pointer;
      user-select: none;
      position: relative;
    }
    .collocate-box th:hover {
      background: #e5e7eb;
    }
    .collocate-box th.col-word {
      min-width: 80px;
      text-align: left;
    }
    .collocate-box th.col-rank {
      min-width: 30px;
    }
    .collocate-box th.col-freq {
      min-width: 40px;
    }
    .collocate-box th.col-score {
      min-width: 50px;
    }
    .collocate-box th .sort-icon {
      margin-left: 2px;
      font-size: 0.6rem;
      opacity: 0.5;
    }
    .collocate-box th.sorted-asc .sort-icon,
    .collocate-box th.sorted-desc .sort-icon {
      opacity: 1;
    }
    .collocate-box td {
      padding: 0.2rem 0.4rem;
      border-bottom: 1px solid #f3f4f6;
      text-align: center;
      white-space: nowrap;
    }
    .collocate-box td:nth-child(2) {
      text-align: left;
    }
    .collocate-box tr:last-child td {
      border-bottom: none;
    }
    
    /* Filter Status Bar */
    .filter-status-bar {
      background: linear-gradient(135deg, #fef3c7 0%, #fde68a 100%);
      border: 1px solid #f59e0b;
      border-radius: 0.375rem;
      padding: 0.35rem 0.75rem;
      font-size: 0.75rem;
      color: #92400e;
      margin-bottom: 0.5rem;
      display: none;
    }
    .filter-status-bar.active {
      display: block;
    }
    .filter-status-bar .label {
      font-weight: 600;
      color: #78350f;
    }
    .filter-status-bar .value {
      background: #fff;
      padding: 0.1rem 0.35rem;
      border-radius: 0.25rem;
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace;
      border: 1px solid #fbbf24;
      margin: 0 0.15rem;
    }
    .filter-status-bar .separator {
      color: #b45309;
      margin: 0 0.5rem;
    }
    .btn-reset-filter {
      background: #f97316;
      color: #fff;
      border: none;
      border-radius: 999px;
      padding: 0.15rem 0.5rem;
      font-size: 0.7rem;
      cursor: pointer;
      font-weight: 500;
    }
    .btn-reset-filter:hover {
      background: #ea580c;
    }
    .collocate-word-link {
      cursor: pointer;
      color: #1d4ed8;
      text-decoration: underline;
    }
    .collocate-word-link:hover {
      color: #1e40af;
      background: #eff6ff;
    }
    /* Purple highlight for collocate word in KWIC */
    .kwic-collocate {
      background-color: #e9d5ff !important; /* light purple highlight */
      font-weight: bold;
      color: inherit;
    }
  
    .card.adv11b, .card.adv11c { margin-top:0.5rem; }
    
    /* 11) Dependency Grammar styles */
    #depPatternTable tbody tr:hover { background-color: #f0f9ff; }
    #depConcordanceTable tbody tr:hover { background-color: #f0f9ff; }
    .dep-node { color: #2563eb; font-weight: 600; }
    .dep-mod1 { color: #ea580c; font-weight: 600; }
    .dep-mod2 { color: #ca8a04; font-weight: 600; }
    .dep-mod3 { color: #16a34a; font-weight: 600; }
    
    /* 11a) Dependency Pattern Table column resizer */
    #depPatternTable { table-layout: fixed; }
    #depPatternTable th { position: relative; }
    #depPatternTable th .dep-col-resizer {
      position: absolute;
      right: 0;
      top: 0;
      width: 6px;
      height: 100%;
      cursor: col-resize;
      z-index: 10;
    }
    #depPatternTable th .dep-col-resizer:hover {
      background: #60a5fa;
    }
    
    /* 11b) Dependency Concordance Table column resizer */
    #depConcordanceTable { table-layout: fixed; }
    #depConcordanceTable th { position: relative; }
    #depConcordanceTable th .dep-conc-resizer {
      position: absolute;
      right: 0;
      top: 0;
      width: 6px;
      height: 100%;
      cursor: col-resize;
      z-index: 10;
    }
    #depConcordanceTable th .dep-conc-resizer:hover {
      background: #60a5fa;
    }
    /* Concordance列を全文表示（折り返しあり） */
    #depConcordanceTable td:last-child {
      white-space: normal;
      word-wrap: break-word;
    }
    #depConcordanceTable td:last-child::-webkit-scrollbar {
      height: 6px;
    }
    #depConcordanceTable td:last-child::-webkit-scrollbar-track {
      background: #f1f5f9;
    }
    #depConcordanceTable td:last-child::-webkit-scrollbar-thumb {
      background: #94a3b8;
      border-radius: 3px;
    }

    /* 12b) Constituent Concordance Table column resizer */
    #constConcordanceTable { table-layout: fixed; }
    #constConcordanceTable th { position: relative; }
    #constConcordanceTable th .const-conc-resizer {
      position: absolute;
      right: 0;
      top: 0;
      width: 6px;
      height: 100%;
      cursor: col-resize;
      z-index: 10;
    }
    #constConcordanceTable th .const-conc-resizer:hover {
      background: #60a5fa;
    }
    /* Concordance列を全文表示（折り返しあり） */
    #constConcordanceTable td:last-child {
      white-space: normal;
      word-wrap: break-word;
    }
</style>
<style>
.jsd-cell-baseline { outline: 2px solid #f97316; outline-offset: -2px; }
</style>
</head>
<body>
<div class="container">
  <h1>Web-Based Corpus Analyzer (WBCA)</h1>
  <div class="subtitle">
    Upload folders (Moves) or multiple files, select Target / Reference by folder,<br>
    and compute Freq-LL / Text-LL / Mean Text Keyness for word / word(lemma) / n-gram / p-frame / POS (simple / detailed).<br>
    Hidden files (<code>.DS_Store</code> / <code>__MACOSX</code> etc.) are automatically excluded, and punctuation / SPACE are ignored.<br>
    For Tagged mode, use <a href="https://www.laurenceanthony.net/software/tagant/" target="_blank" style="color:#2563eb;">TagAnt</a> for tagging.
  </div>

  <!-- Upload & Settings -->
  <div class="card">
    <h2>1) Data Type &amp; Upload (Folder / Files)</h2>
    <div class="section-row">
      <div class="card" style="margin-bottom:0;">
        <h2 class="mb-0" style="font-size:1rem;">Data Type</h2>
        <div class="radio-group mt-05">
          <label>
            <input type="radio" name="dataType" value="plain" checked>
            Plain text (no tags)
          </label>
          <label>
            <input type="radio" name="dataType" value="tagged">
            Tagged corpus (<span class="mono">word_POSd_POSs_lemma</span>)
          </label>
          <label>
            <input type="radio" name="dataType" value="auto">
            Auto-detect (sample first file)
          </label>
        </div>
        <div class="help-text">
          In Tagged mode, formats like <code>chronic_kidney_disease_NN_NOUN_disease</code> are parsed<br>
          from the right as 3 elements (POSd / POSs / lemma).
        </div>
        <div class="mt-1" id="plainTextOptions">
          <strong>Tokenization options (plain text only)</strong><br>
          <label>
            <input type="checkbox" id="includeHyphen" checked>
            Treat "-" as part of word (e.g. <span class="mono">state-of-the-art</span>)
          </label><br>
          <label>
            <input type="checkbox" id="includeAposS" checked>
            Treat apostrophe as part of word (e.g. <span class="mono">patient's</span>, <span class="mono">I\'m</span>, <span class="mono">I\'ve</span>, <span class="mono">I\'ll</span>)
          </label>
        </div>
        <div class="mt-1">
          <strong>Text preprocessing options (for all modes)</strong><br>
          <label>
            <input type="checkbox" id="mergeShortLines">
            Merge short lines into paragraphs (for subtitles/transcripts)
          </label>
          <div class="help-text" style="margin-left:1.5rem;">
            Useful for YouTube subtitles: combines lines separated by empty lines into continuous text.<br>
            Improves KWIC display. N-gram analysis is not affected (sentence boundaries are preserved).
          </div>
        </div>
        <div class="mt-1">
          <strong>N-gram boundary options</strong><br>
          <label>
            <input type="checkbox" id="respectSentenceBoundary" checked>
            Respect sentence boundaries for n-grams/p-frames/pos-grams (<span class="mono">. ? !</span>)
          </label>
          <div class="help-text" style="margin-left:1.5rem;">
            Checked: n-grams do not cross sentence-ending punctuation.<br>
            Unchecked: ignore <span class="mono">. ? !</span> (commas are always ignored).
          </div>
        </div>
      </div>

      <div class="card" style="margin-bottom:0;">
        <h2 class="mb-0" style="font-size:1rem;">Upload (Folder / Files)</h2>
        <div class="mt-05">
          <label><strong>Folder upload (webkitdirectory)</strong></label><br>
          <input type="file" id="folderInput" webkitdirectory multiple>
          <div class="help-text">
            Use this if you already have a folder structure like Move1 / Move2.<br>
            <code>__MACOSX</code> and files starting with <code>.</code> are ignored.
          </div>
        </div>
        <div class="mt-1">
          <label><strong>Multiple files upload</strong></label><br>
          <input type="file" id="fileInput" multiple>
          <div class="help-text">
            Use this to test a few text files. Since there is no folder info, files are treated as virtual folder
            <span class="badge folder">Ungrouped</span>.
          </div>
        </div>
      </div>
    </div>
    <div class="flex-between mt-1">
      <div>
        <button id="analyzeBtn">
          <span>Load &amp; Parse Corpus</span>
        </button>
        <button id="corpusClearBtn" class="small btn-clear" style="margin-left:0.5rem;">Clear</button>
        <span id="selectedFilesInfo" class="status"></span>
      </div>
      <div class="help-text">
        ※ Data is processed only in your browser and is not sent to any server.
      </div>
    </div>
    <div id="statusMessage" class="status mt-05"></div>
    <!-- CSV Loading Progress -->
    <div id="csvProgressContainer" class="mt-05" style="display:none;">
      <div style="display:flex; align-items:center; gap:0.5rem;">
        <div style="flex:1; background:#e5e7eb; border-radius:4px; height:20px; overflow:hidden;">
          <div id="csvProgressBar" style="width:0%; height:100%; background:linear-gradient(90deg, #0ea5e9, #38bdf8); transition:width 0.1s;"></div>
        </div>
        <span id="csvProgressText" style="font-size:0.8rem; color:#4b5563; min-width:60px;">0%</span>
      </div>
      <div id="csvProgressDetail" style="font-size:0.75rem; color:#6b7280; margin-top:0.25rem;"></div>
    </div>
  </div>

  <!-- Summary -->
  <div class="card">
    <div class="flex-between">
      <h2 style="margin:0;">2) Corpus Summary</h2>
      <button id="summaryClearBtn" class="small btn-clear">Clear</button>
    </div>
    <div class="flex-between mt-05">
      <div class="flex">
        <div>Mode: <span id="modeBadge" class="badge">-</span></div>
        <div class="pill">Files: <span id="summaryFileCount">0</span></div>
        <div class="pill">Tokens: <span id="summaryTokenCount">0</span></div>
      </div>
      <div class="text-xs help-text">
        Tokens are approximate counts after excluding punctuation and SPACE.
      </div>
    </div>
    <div class="table-wrapper mt-1">
      <table id="corpusSummaryTable">
        <thead>
        <tr>
          <th>#</th>
          <th style="cursor:pointer;" onclick="sortCorpusSummary('folder')">Folder <span id="corpusSortFolder">⇅</span></th>
          <th style="cursor:pointer;" onclick="sortCorpusSummary('file')">File <span id="corpusSortFile">⇅</span></th>
          <th class="text-right" style="cursor:pointer;" onclick="sortCorpusSummary('tokens')">Tokens <span id="corpusSortTokens">⇅</span></th>
        </tr>
        </thead>
        <tbody id="fileSummaryBody">
        <tr><td colspan="4" class="text-xs">No corpus loaded.</td></tr>
        </tbody>
      </table>
    </div>
  </div>

  <!-- Folder -> Target / Reference -->
  <div class="card">
    <div class="flex-between">
      <h2 style="margin:0;">3) Target / Reference (by Folder / Move)</h2>
      <button id="folderClearBtn" class="small btn-clear">Clear</button>
    </div>
    <div class="help-text mt-05">
      Select Target / Reference for each folder (Move). You can assign the same folder to both.<br>
      Press "All" to toggle all checkboxes in that column ON/OFF. Token / Type / TTR are word-based, excluding punctuation and SPACE.
    </div>
    <div id="folderSelectionArea" class="mt-1 text-xs">
      Folder list will appear here after loading a corpus.
    </div>
  </div>


  <!-- KWIC -->
  <div class="card" id="kwicCard">
    <h2>4) KWIC</h2>
    <!-- Filter Status Bar -->
    <div id="kwicFilterStatusBar" class="filter-status-bar">
      <!-- Content will be dynamically updated -->
    </div>
    <!-- Simple Mode (default) -->
    <div id="kwicSimpleMode">
    <div class="flex mt-05">
      <label>Selected feature:</label>
      <input type="text" id="kwicFeatureInput" style="width:260px;" placeholder="study|research or *ing or stud(y|ies)">
      <label>Feature type:</label>
      <select id="kwicFeatureTypeSelect"></select>
      <label>Search mode:</label>
      <select id="kwicSearchMode" style="width:100px;">
        <option value="exact" selected>Exact</option>
        <option value="wildcard">Wildcard (*?)</option>
        <option value="regex">Regex</option>
      </select>
      <label style="margin-left:0.5rem;">
        <input type="checkbox" id="kwicCaseInsensitive" checked>
        Case-insensitive
      </label>
      <button id="kwicRecomputeBtn" class="small">Recompute KWIC</button>
      <button id="kwicClearBtn" class="small btn-clear">Clear</button>
      <button id="exportKwicBtn" class="small export">Export to Excel</button>
    </div>
    </div>
    <!-- Advanced Mode (Word+POS filtered search) -->
    <div id="kwicAdvancedMode" style="display:none;">
      <div class="flex mt-05" style="align-items:center; gap:0.5rem; flex-wrap:wrap;">
        <label style="font-weight:bold;">Pattern:</label>
        <div style="flex:1; min-width:300px; max-width:600px; overflow-x:auto; white-space:nowrap;">
          <input type="text" id="kwicAdvancedNode" style="width:100%; min-width:400px; font-family:monospace; font-size:0.8rem; padding:0.3rem;" placeholder="e.g. as_IN_ADP_* *_DT_DET_* *_NN|NNS_NOUN_*" onchange="parseAdvancedPatternToTokens()">
        </div>
        <label class="text-xs">
          <input type="checkbox" id="kwicAdvancedCaseInsensitive" checked>
          Case-insensitive
        </label>
        <button id="kwicAdvancedRecomputeBtn" class="small">Recompute KWIC</button>
        <button id="kwicAdvancedClearBtn" class="small btn-clear">Clear All</button>
        <button id="exportKwicAdvancedBtn" class="small export">Export to Excel</button>
      </div>
      <div style="display:flex; align-items:center; justify-content:flex-end; margin-top:0.35rem;">
        <button id="kwicAdvancedToggleTokensBtn" class="small" style="font-size:0.75rem; padding:0.2rem 0.5rem;" onclick="toggleAdvancedTokensVisibility()">Hide Token Inputs</button>
      </div>
      <div id="kwicAdvancedInputs" class="mt-05" style="background:#f8fafc; padding:0.5rem; border-radius:4px; max-height:300px; overflow-y:auto;">
        <!-- Token inputs will be generated here -->
      </div>
      <div class="help-text mt-025" style="font-size:10px;">
        <strong>Advanced mode</strong>: Pattern format: <code>surface_POSdetailed_POSsimple_lemma</code> (use <code>*</code> for any, <code>|</code> for multiple values)<br>
        Examples: <code>as_IN_ADP_*</code> (surface=as, POSd=IN, POSs=ADP), <code>*_NN|NNS_NOUN_*</code> (POSd=NN or NNS, POSs=NOUN)
      </div>
    </div>
    <!-- Mode Toggle -->
    <div class="flex mt-025" style="align-items:center; gap:0.5rem;">
      <label class="text-xs">
        <input type="checkbox" id="kwicAdvancedModeToggle">
        Advanced mode (Tagged corpus only: surface_POSd_POSs_lemma pattern search)
      </label>
    </div>
    <div class="help-text mt-025" style="font-size:10px;">
      <strong>Exact</strong>: Exact match (pipe-separated for multiple words: cell|cells)　
      <strong>Wildcard</strong>: * matches any string, ? matches any single character (*ing, un*, b?t)　
      <strong>Regex</strong>: Regular expression (stud(y|ies|ied), [A-Z]+ing)
    </div>
    <div class="flex mt-05">
      <label for="kwicMaxHits">Max lines (table):</label>
      <input type="number" id="kwicMaxHits" value="300" min="1" max="5000" style="width:5rem;">

      <label for="kwicLeftWidth">Left words (L):</label>
      <input type="number" id="kwicLeftWidth" value="15" min="1" max="100" style="width:4rem;">

      <label for="kwicRightWidth">Right words (R):</label>
      <input type="number" id="kwicRightWidth" value="15" min="1" max="100" style="width:4rem;">

      <label>Scope:</label>
      <label class="text-xs">
        <input type="radio" name="kwicScope" value="target" checked> Target only
      </label>
      <label class="text-xs">
        <input type="radio" name="kwicScope" value="reference"> Reference only
      </label>
      <label class="text-xs">
        <input type="radio" name="kwicScope" value="all"> All folders
      </label>
      <label class="text-xs">
        <input type="radio" name="kwicScope" value="specific"> Specific folder
      </label>
      <div id="kwicFolderSelector" style="display:none; position:relative; margin-left:0.5rem;">
        <button type="button" id="kwicFolderBtn" class="small" style="font-size:0.75rem; padding:0.2rem 0.5rem; min-width:120px; text-align:left; background:#f0f8ff; border:1px solid #4a90d9;">
          <span id="kwicFolderLabel">(select folders)</span> ▼
        </button>
        <div id="kwicFolderDropdown" style="display:none; position:absolute; z-index:100; background:#fff; border:1px solid #4a90d9; border-radius:4px; padding:0.5rem; max-height:200px; overflow-y:auto; min-width:200px; box-shadow:0 4px 12px rgba(0,0,0,0.2);">
          <div style="display:flex; gap:0.5rem; margin-bottom:0.4rem; border-bottom:1px solid #ddd; padding-bottom:0.4rem;">
            <button type="button" class="small" style="font-size:0.7rem; padding:0.15rem 0.4rem;" onclick="selectAllKwicFolders()">Select All</button>
            <button type="button" class="small" style="font-size:0.7rem; padding:0.15rem 0.4rem;" onclick="clearAllKwicFolders()">Clear All</button>
            <button type="button" class="small" style="font-size:0.7rem; padding:0.15rem 0.4rem; margin-left:auto;" onclick="toggleKwicFolderDropdown()">Close</button>
          </div>
          <div id="kwicFolderCheckboxes" style="display:grid; grid-template-columns:repeat(2, 1fr); gap:0.25rem;">
            <!-- Folder checkboxes will be populated dynamically -->
          </div>
        </div>
      </div>

      <label>View:</label>
      <label>
        <input type="radio" name="kwicView" value="surface" checked>
        Surface only
      </label>
      <label>
        <input type="radio" name="kwicView" value="tagged">
        Tagged (word_POSd_POSs_lemma)
      </label>
    </div>
    <!-- Biber Tag Filter (CSV mode only) -->
    <div id="kwicBiberFilterContainer" class="mt-05" style="display:none; background:#fff8e6; padding:0.5rem; border-radius:4px; border:1px solid #f0d080;">
      <div style="display:flex; align-items:center; gap:0.5rem; flex-wrap:wrap;">
        <label class="text-xs" style="font-weight:bold; color:#805500;">Biber Tag Filter:</label>
        <!-- Single tag selector -->
        <div id="kwicBiberNgramSlots" style="display:flex; align-items:center; gap:0.25rem; flex-wrap:wrap;">
          <div class="biber-ngram-slot" data-slot="0">
            <select class="biber-slot-select" style="font-size:0.75rem; padding:0.2rem; min-width:100px; background:#fffbf0; border:1px solid #d9a030; border-radius:3px;" onchange="updateBiberNgramDisplay()">
              <option value="">(select)</option>
            </select>
          </div>
        </div>
        
        <!-- Sensitive mode checkbox -->
        <label class="text-xs" style="margin-left:0.5rem; color:#805500;" title="When ON: token must have ONLY the selected tag(s). When OFF: token matches if it has ANY of the selected tags.">
          <input type="checkbox" id="kwicBiberSensitive"> Sensitive
        </label>
        
        <button type="button" class="small btn-clear" style="font-size:0.7rem; padding:0.15rem 0.4rem; margin-left:auto;" onclick="clearBiberNgramSlots()">Clear</button>
      </div>
    </div>
    <div class="flex mt-05">
      <span class="text-xs">Color scheme (Blue / Red / Green → L1–L5 / Node / R1–R5):</span>
      <label class="text-xs">
        Blue:
        <select id="bluePosSelect">
          <option value="L1" selected>L1</option>
          <option value="L2">L2</option>
          <option value="L3">L3</option>
          <option value="L4">L4</option>
          <option value="L5">L5</option>
          <option value="Node">Node</option>
          <option value="R1">R1</option>
          <option value="R2">R2</option>
          <option value="R3">R3</option>
          <option value="R4">R4</option>
          <option value="R5">R5</option>
        </select>
      </label>
      <label class="text-xs">
        Red:
        <select id="redPosSelect">
          <option value="L1">L1</option>
          <option value="L2">L2</option>
          <option value="L3">L3</option>
          <option value="L4">L4</option>
          <option value="L5">L5</option>
          <option value="Node" selected>Node</option>
          <option value="R1">R1</option>
          <option value="R2">R2</option>
          <option value="R3">R3</option>
          <option value="R4">R4</option>
          <option value="R5">R5</option>
        </select>
      </label>
      <label class="text-xs">
        Green:
        <select id="greenPosSelect">
          <option value="L1">L1</option>
          <option value="L2">L2</option>
          <option value="L3">L3</option>
          <option value="L4">L4</option>
          <option value="L5">L5</option>
          <option value="Node">Node</option>
          <option value="R1" selected>R1</option>
          <option value="R2">R2</option>
          <option value="R3">R3</option>
          <option value="R4">R4</option>
          <option value="R5">R5</option>
        </select>
      </label>
      <label class="text-xs" title="Highlight L1/R1 through selected position" style="margin-left:0.5rem;">
        <input type="checkbox" id="colorPosRange" onchange="renderKwicRows()"> Range
      </label>
    </div>
    <div class="flex flex-wrap mt-05 items-center gap-2">
      <!-- Left filter -->
      <label class="text-xs mr-1">
        Left filter:
        <input type="text" id="kwicLeftFilter" class="border px-1 py-025 text-xs" style="min-width: 80px;">
      </label>
      <label class="text-xs mr-1">
        Match:
        <select id="kwicLeftFilterMode" class="border px-1 py-025 text-xs">
          <option value="exact" selected>Exact match (any word)</option>
          <option value="partial">Partial match (substring)</option>
          <option value="wildcard">Wildcard (*?)</option>
          <option value="pos_simple">POS (simple)</option>
          <option value="pos_detailed">POS (detailed)</option>
          <option value="posgram_simple">POS-gram (simple)</option>
          <option value="posgram_detailed">POS-gram (detailed)</option>
        </select>
      </label>
      <label class="text-xs mr-1">
        Pos:
        <select id="kwicLeftFilterPos" class="border px-1 py-025 text-xs">
          <option value="any" selected>Any</option>
          <option value="1">L1</option>
          <option value="2">L2</option>
          <option value="3">L3</option>
          <option value="4">L4</option>
          <option value="5">L5</option>
        </select>
      </label>
      <label class="text-xs mr-1" title="Check to match L1 through selected position">
        <input type="checkbox" id="kwicLeftFilterRange"> Range
      </label>
      <label class="text-xs mr-2" title="Exclude matches instead of include" style="color:#dc2626;">
        <input type="checkbox" id="kwicLeftFilterExclude"> Exclude
      </label>

      <!-- Node filter -->
      <label class="text-xs mr-1">
        Node filter:
        <input type="text" id="kwicNodeFilter" class="border px-1 py-025 text-xs" style="min-width: 80px;">
      </label>
      <label class="text-xs mr-1">
        Match:
        <select id="kwicNodeFilterMode" class="border px-1 py-025 text-xs">
          <option value="exact" selected>Exact match (any word)</option>
          <option value="partial">Partial match (substring)</option>
          <option value="wildcard">Wildcard (*?)</option>
          <option value="pos_simple">POS (simple)</option>
          <option value="pos_detailed">POS (detailed)</option>
          <option value="posgram_simple">POS-gram (simple)</option>
          <option value="posgram_detailed">POS-gram (detailed)</option>
        </select>
      </label>
      <label class="text-xs mr-2" title="Exclude matches instead of include" style="color:#dc2626;">
        <input type="checkbox" id="kwicNodeFilterExclude"> Exclude
      </label>

      <!-- Right filter -->
      <label class="text-xs mr-1">
        Right filter:
        <input type="text" id="kwicRightFilter" class="border px-1 py-025 text-xs" style="min-width: 80px;">
      </label>
      <label class="text-xs mr-1">
        Match:
        <select id="kwicRightFilterMode" class="border px-1 py-025 text-xs">
          <option value="exact" selected>Exact match (any word)</option>
          <option value="partial">Partial match (substring)</option>
          <option value="wildcard">Wildcard (*?)</option>
          <option value="pos_simple">POS (simple)</option>
          <option value="pos_detailed">POS (detailed)</option>
          <option value="posgram_simple">POS-gram (simple)</option>
          <option value="posgram_detailed">POS-gram (detailed)</option>
        </select>
      </label>
      <label class="text-xs mr-1">
        Pos:
        <select id="kwicRightFilterPos" class="border px-1 py-025 text-xs">
          <option value="any" selected>Any</option>
          <option value="1">R1</option>
          <option value="2">R2</option>
          <option value="3">R3</option>
          <option value="4">R4</option>
          <option value="5">R5</option>
        </select>
      </label>
      <label class="text-xs mr-1" title="Check to match R1 through selected position">
        <input type="checkbox" id="kwicRightFilterRange"> Range
      </label>
      <label class="text-xs mr-2" title="Exclude matches instead of include" style="color:#dc2626;">
        <input type="checkbox" id="kwicRightFilterExclude"> Exclude
      </label>

      <button type="button" class="btn btn-xs btn-filter" onclick="applyKwicFilter()">Apply filter</button>
      <button type="button" class="btn btn-xs btn-clear" onclick="clearKwicFiltersUI()" style="margin-left:0.25rem; background:#dc2626; color:white;">Clear filter</button>
    </div>
    <div class="help-text mt-05">
      Click a row in 8) Keyness to auto-fill the feature above and display KWIC for Target / Reference combined (sentence-based).<br>
      You can also manually enter a feature and type, then press "Recompute KWIC". Tagged display options are only available in Tagged mode.<br>
      In Filter Match, select POS (simple) / POS (detailed) to filter by POS tags (Tagged corpus required). Check "Exclude" to exclude matches.<br>
      The table shows up to Max lines, but Export to Excel outputs <strong>all rows</strong>.
    </div>
    <div id="kwicStatus" class="status mt-05"></div>
    <div id="kwicWildcardMatches" class="mt-05" style="display:none; padding:0.5rem; background:#f8fafc; border:1px solid #e2e8f0; border-radius:0.25rem; font-size:0.75rem;">
      <!-- Wildcard/Character match frequencies will be displayed here -->
    </div>
    <div class="flex mt-05" style="align-items:center; gap:0.5rem;">
      <span class="text-xs">Sort position (N):</span>
      <input type="number" id="kwicSortPos" value="1" min="1" max="20" style="width:3rem; font-size:0.75rem;">
      <label class="text-xs">Column:</label>
      <select id="kwicSortColumn" style="font-size:0.75rem; margin-left:0.25rem;">
        <option value="1">Left</option>
        <option value="2" selected>Node</option>
        <option value="3">Right</option>
      </select>
      <select id="kwicSortDir" style="font-size:0.75rem;">
        <option value="asc">A→Z</option>
        <option value="desc">Z→A</option>
      </select>
      <button id="kwicSortBtn" class="small btn-sort" style="margin-left:0.25rem;">Sort</button>
      <button type="button" class="small btn-clear" onclick="clearKwicSort()" style="margin-left:0.25rem;">Clear</button>
      <span class="text-xs" style="color:#6b7280; margin-left:0.5rem;">(Sort by Nth word. For Left, count from the end)</span>
    </div>
    <div id="kwicSortFreqArea" class="mt-05" style="display:none; padding:0.5rem; background:#f0fdf4; border:1px solid #bbf7d0; border-radius:0.25rem; font-size:0.75rem;">
      <div style="font-weight:bold; margin-bottom:0.25rem;">Sort Key Frequencies (<span id="kwicSortFreqColumn">-</span>, position <span id="kwicSortFreqPos">1</span>):</div>
      <div id="kwicSortFreqList"></div>
      <div id="kwicSortFreqMore" style="display:none; margin-top:0.25rem;">
        <a href="#" id="kwicSortFreqShowMore" style="color:#2563eb; text-decoration:underline;">Show more...</a>
      </div>
    </div>
    <div class="table-wrapper mt-1">
      <table id="kwicTable">
        <colgroup>
          <col data-col="0" style="width:40px">
          <col data-col="1" style="width:260px">
          <col data-col="2" style="width:200px">
          <col data-col="3" style="width:260px">
          <col data-col="4" style="width:140px">
          <col data-col="5" style="width:160px">
        </colgroup>
        <thead>
        <tr>
          <th style="width:40px">#</th>
          <th class="sortable text-right" data-col="1">Left</th>
          <th class="sortable text-center" data-col="2">Node</th>
          <th class="sortable" data-col="3">Right</th>
          <th class="sortable" data-col="4">Folder</th>
          <th class="sortable" data-col="5">File</th>
        </tr>
        </thead>
        <tbody id="kwicTableBody">
        <tr><td colspan="6" class="text-xs">No KWIC yet. Click a row in 8) Keyness or enter a feature manually.</td></tr>
        </tbody>
      </table>
    </div>
  </div>

  <!-- 5) Text Data -->
  <div class="card" id="textDataCard">
    <h2>5) Text Data</h2>
    
    <!-- 5a) Original Text -->
    <div class="subsection mt-05" style="border:1px solid #cce5ff; border-radius:6px; padding:0.75rem; background:#f8fbff;">
      <div class="flex" style="justify-content: space-between; align-items: center;">
        <h3 style="margin:0; font-size:1rem;">5a) Original Text</h3>
        <div class="flex" style="align-items:center; gap:0.5rem;">
          <label class="text-xs">View:</label>
          <label class="text-xs">
            <input type="radio" name="originalView" value="surface" checked>
            Surface only
          </label>
          <label class="text-xs">
            <input type="radio" name="originalView" value="tagged">
            Tagged (word_POSd_POSs_lemma)
          </label>
          <button id="clearOriginalBtn" class="small btn-clear">Clear</button>
        </div>
      </div>
      <div id="originalMeta" class="text-xs help-text">
        Click a row in 4) KWIC to display the entire source file below (color coding follows the same rules as 4)).<br>
        Tokens are displayed word-based excluding punctuation, with only the matched portion colored according to L1–L5 / Node / R1–R5.
      </div>
      <div id="originalText" class="mt-1 mono" style="white-space:normal; overflow-x:visible; border:1px solid #e5e7eb; border-radius:0.5rem; padding:0.75rem 1rem; background:#fafafa; line-height:1.7; font-size:0.95rem;">
        No text selected.
      </div>
    </div>

    <!-- 5b) Concordance Plot -->
    <div class="subsection mt-1" style="border:1px solid #cce5ff; border-radius:6px; padding:0.75rem; background:#f8fbff;">
      <h3 style="margin:0 0 0.5rem 0; font-size:1rem;">5b) Concordance Plot</h3>
    <!-- Simple mode -->
    <div id="plotSimpleMode">
    <div class="flex mt-05" style="flex-wrap:wrap; gap:0.5rem; align-items:center;">
      <label>Selected feature:</label>
      <input type="text" id="plotFeatureInput" style="width:180px;" placeholder="e.g. result">
      <label>Feature type:</label>
      <select id="plotFeatureTypeSelect" style="width:150px;"></select>
      <label>Search mode:</label>
      <select id="plotSearchMode" style="width:100px;">
        <option value="exact" selected>Exact</option>
        <option value="wildcard">Wildcard</option>
        <option value="regex">Regex</option>
      </select>
      <label>
        <input type="checkbox" id="plotCaseInsensitive" checked>
        Case-insensitive
      </label>
      <label>Scope:</label>
      <label class="text-xs"><input type="radio" name="plotScope" value="target" checked> Target</label>
      <label class="text-xs"><input type="radio" name="plotScope" value="reference"> Reference</label>
      <label class="text-xs"><input type="radio" name="plotScope" value="all"> All folders</label>
      <label>Group by:</label>
      <select id="plotGroupBy" style="width:100px;">
        <option value="file" selected>File</option>
        <option value="folder">Folder</option>
      </select>
      <label class="text-xs">
        <input type="checkbox" id="plotHideZeroGroups">
        Hide files/folders with no hits
      </label>
      <button id="plotComputeBtn" class="small">Plot</button>
      <button id="plotClearBtn" class="small btn-clear">Clear</button>
      <button id="plotDownloadBtn" class="small export">Download (JPEG)</button>
    </div>
    </div>
    <!-- Advanced mode (synced with KWIC) -->
    <div id="plotAdvancedMode" style="display:none;">
      <div class="flex mt-05" style="flex-wrap:wrap; gap:0.5rem; align-items:center;">
        <label>Pattern:</label>
        <span id="plotAdvancedPattern" style="font-weight:bold; color:#059669;">(synced from KWIC)</span>
        <label>Scope:</label>
        <label class="text-xs"><input type="radio" name="plotScope" value="target" checked> Target</label>
        <label class="text-xs"><input type="radio" name="plotScope" value="reference"> Reference</label>
        <label class="text-xs"><input type="radio" name="plotScope" value="all"> All folders</label>
        <label>Group by:</label>
        <select id="plotGroupByAdv" style="width:100px;">
          <option value="file" selected>File</option>
          <option value="folder">Folder</option>
        </select>
        <label class="text-xs">
          <input type="checkbox" id="plotHideZeroGroupsAdv">
          Hide files/folders with no hits
        </label>
        <button id="plotComputeAdvBtn" class="small">Plot</button>
        <button id="plotClearAdvBtn" class="small btn-clear">Clear</button>
        <button id="plotDownloadAdvBtn" class="small export">Download (JPEG)</button>
      </div>
    </div>
    <!-- Mode Toggle -->
    <div class="flex mt-025" style="align-items:center; gap:0.5rem;">
      <label class="text-xs">
        <input type="checkbox" id="plotAdvancedModeToggle" onchange="togglePlotAdvancedMode()">
        Advanced mode (synced with KWIC)
      </label>
    </div>
    <div class="help-text mt-025" style="font-size:10px;">
      Visualizes the distribution of search terms in text. Vertical lines indicate occurrence positions.<br>
      Click a bar to display KWIC for that file/folder. Feature input is synced with KWIC/Collocate/HF/Keyness.
    </div>
    <div id="plotStatus" class="status mt-05"></div>
    <div id="plotContainer" class="mt-05" style="max-height:500px; overflow-y:auto; background:#fff; padding:10px; border:1px solid #e5e7eb; border-radius:4px;">
      <div class="text-xs text-gray-500">No plot yet.</div>
    </div>
    </div>
  </div>

  <!-- Collocate Tables -->
  <div class="card" id="collocateCard">
    <h2>6) Collocate Tables (Target vs Reference)</h2>
    <!-- Simple mode -->
    <div id="collocateSimpleMode">
    <div class="flex mt-05" style="flex-wrap:wrap; gap:0.5rem; align-items:center;">
      <label>Node:</label>
      <input type="text" id="collocateNodeInput" style="width:200px;" placeholder="word or p-frame (e.g. in the *)">
      <label>Feature type:</label>
      <select id="collocateFeatureTypeSelect" style="width:150px;"></select>
      <label>Collocate:</label>
      <label class="text-xs">
        <input type="radio" name="collocateCalcMode" value="surface" checked> Surface
      </label>
      <label class="text-xs">
        <input type="radio" name="collocateCalcMode" value="lemma"> Lemma
      </label>
      <label class="text-xs collocate-pos-option" style="display:none;">
        <input type="radio" name="collocateCalcMode" value="pos_simple"> POS(Simple)
      </label>
      <label class="text-xs collocate-pos-option" style="display:none;">
        <input type="radio" name="collocateCalcMode" value="pos_detailed"> POS(Detailed)
      </label>
      <button id="collocateComputeBtn" class="small">Compute</button>
      <label>Left window:</label>
      <select id="collocateSpanL" style="width:50px;">
        <option value="1">1</option>
        <option value="2">2</option>
        <option value="3">3</option>
        <option value="4">4</option>
        <option value="5" selected>5</option>
      </select>
      <label>Right window:</label>
      <select id="collocateSpanR" style="width:50px;">
        <option value="1">1</option>
        <option value="2">2</option>
        <option value="3">3</option>
        <option value="4">4</option>
        <option value="5" selected>5</option>
      </select>
      <label>Top N:</label>
      <input type="number" id="collocateTopN" value="20" min="1" style="width:60px;">
      <label>Statistic:</label>
      <select id="collocateStatSelect" style="width:120px;">
        <option value="frequency" selected>Frequency</option>
        <option value="tscore">t-score</option>
        <option value="zscore">z-score</option>
        <option value="mi">MI</option>
        <option value="mi2">MI²</option>
        <option value="mi3">MI³</option>
        <option value="ll">LL (G²)</option>
        <option value="logdice">LogDice</option>
        <option value="dice">Dice</option>
        <option value="deltap">Delta P</option>
      </select>
      <label style="margin-left:0.5rem;">
        <input type="checkbox" id="collocateCaseInsensitive" checked>
        Case-insensitive
      </label>
      <button id="collocateClearBtn" class="small btn-clear">Clear</button>
      <button id="exportCollocateBtn" class="small export">Export to Excel</button>
    </div>
    </div>
    <!-- Advanced mode (synced with KWIC) -->
    <div id="collocateAdvancedMode" style="display:none;">
      <div class="flex mt-05" style="flex-wrap:wrap; gap:0.5rem; align-items:center;">
        <label>Node pattern:</label>
        <span id="collocateAdvancedPattern" style="font-weight:bold; color:#059669;">(synced from KWIC)</span>
        <label>Collocate:</label>
        <label class="text-xs">
          <input type="radio" name="collocateCalcModeAdv" value="surface" checked> Surface
        </label>
        <label class="text-xs">
          <input type="radio" name="collocateCalcModeAdv" value="lemma"> Lemma
        </label>
        <label class="text-xs collocate-pos-option-adv" style="display:none;">
          <input type="radio" name="collocateCalcModeAdv" value="pos_simple"> POS(Simple)
        </label>
        <label class="text-xs collocate-pos-option-adv" style="display:none;">
          <input type="radio" name="collocateCalcModeAdv" value="pos_detailed"> POS(Detailed)
        </label>
        <button id="collocateComputeAdvBtn" class="small">Compute</button>
        <label>Left/Right:</label>
        <select id="collocateSpanLAdv" style="width:50px;">
          <option value="1">1</option><option value="2">2</option><option value="3">3</option><option value="4">4</option><option value="5" selected>5</option>
        </select>
        /
        <select id="collocateSpanRAdv" style="width:50px;">
          <option value="1">1</option><option value="2">2</option><option value="3">3</option><option value="4">4</option><option value="5" selected>5</option>
        </select>
        <label>Top N:</label>
        <input type="number" id="collocateTopNAdv" value="20" min="1" style="width:60px;">
        <label>Stat:</label>
        <select id="collocateStatSelectAdv" style="width:100px;">
          <option value="frequency" selected>Frequency</option>
          <option value="tscore">t-score</option>
          <option value="mi">MI</option>
          <option value="ll">LL (G²)</option>
          <option value="logdice">LogDice</option>
        </select>
        <button id="collocateClearAdvBtn" class="small btn-clear">Clear</button>
        <button id="exportCollocateAdvBtn" class="small export">Export to Excel</button>
      </div>
    </div>
    <!-- Mode Toggle -->
    <div class="flex mt-025" style="align-items:center; gap:0.5rem;">
      <label class="text-xs">
        <input type="checkbox" id="collocateAdvancedModeToggle" onchange="toggleCollocateAdvancedMode()">
        Advanced mode (synced with KWIC)
      </label>
    </div>
    <div class="help-text mt-05">
      Enter a Node manually and press "Compute" to calculate collocations from the entire corpus (p-frame format like <code>in the *</code> is also supported).<br>
      Word click: Filters KWIC rows by specified range/position (highlighted in purple).
    </div>
    <div id="collocateStatus" class="status mt-05"></div>
    
    <!-- Target Section -->
    <div class="mt-1">
      <h3 class="collocate-section-title target">Target Collocates</h3>
      <div class="collocate-tables-container" id="targetLeftContainer"></div>
      <div class="collocate-tables-container" id="targetRightContainer" style="margin-top:1rem;"></div>
    </div>
    
    <!-- Reference Section -->
    <div class="mt-1">
      <h3 class="collocate-section-title reference">Reference Collocates</h3>
      <div class="collocate-tables-container" id="refLeftContainer"></div>
      <div class="collocate-tables-container" id="refRightContainer" style="margin-top:1rem;"></div>
    </div>
  </div>

  <!-- High-Frequency Features -->
  <div class="card" id="hfCard">
    <h2>7) High-Frequency Features (Target vs Reference)</h2>
    <div class="flex-between">
      <div class="flex mt-05">
        <label for="hfFeatureTypeSelect">Feature type:</label>
        <select id="hfFeatureTypeSelect"></select>

        <label for="hfNInput">n for n-gram / p-frame / POS-gram / cluster:</label>
        <input type="number" id="hfNInput" value="4" min="1" style="width:60px;">

        <label for="hfMinFreqInput">Min freq (per side):</label>
        <input type="number" id="hfMinFreqInput" value="2" min="1" style="width:70px;">

        <label for="hfTopNInput">Top N features:</label>
        <input type="number" id="hfTopNInput" value="200" min="1" style="width:80px;">

        <label style="margin-left:0.75rem;">
          <input type="checkbox" id="hfCaseInsensitive" checked>
          Case-insensitive
        </label>

        <label style="margin-left:0.75rem;">
          <input type="checkbox" id="hfExcludeStopwords">
          Exclude stopwords
        </label>
        
        <!-- 96 BiberPlus only checkbox (for biber_tag type) -->
        <label id="hfBiberPlusContainer" style="margin-left:0.5rem; display:none; background:#fff8e6; padding:0.25rem 0.5rem; border-radius:3px; border:1px solid #f0d080;">
          <input type="checkbox" id="hfBiberPlusOnly">
          <span class="text-xs" style="color:#805500;">96 BiberPlus only</span>
        </label>

        <button id="hfComputeBtn" class="btn-primary" style="margin-left:0.75rem;">Compute</button>
        <button id="hfClearBtn" class="small btn-clear" style="margin-left:0.5rem;">Clear</button>
        <button id="exportHfBtn" class="btn-primary export" style="margin-left:0.5rem;">Export to Excel</button>
      </div>
    </div>
    <!-- Cluster-specific UI -->
    <div id="hfClusterUI" class="flex mt-05" style="display:none; gap:0.5rem; align-items:center; background:#f0f8ff; padding:0.5rem; border-radius:4px;">
      <label>Search word (* ? | supported):</label>
      <input type="text" id="hfClusterWord" style="width:150px;" placeholder="e.g. study">
      <label>Position:</label>
      <select id="hfClusterPosition" style="width:100px;">
        <option value="all">All folders</option>
        <option value="left">Left (start)</option>
        <option value="right">Right (end)</option>
      </select>
      <span class="help-text text-xs" style="margin-left:0.5rem;">Extract n-grams containing the search word</span>
    </div>
    <!-- Feature Filter UI (matching Keyness style) -->
    <div class="flex mt-05">
      <label class="text-xs mr-2">
        Feature filter:
        <input type="text" id="hfFilterInput" class="border px-1 py-025 text-xs" style="min-width: 160px;">
      </label>
      <label class="text-xs mr-2">
        Match:
        <select id="hfFilterMode" class="border px-1 py-025 text-xs">
          <option value="exact" selected>Exact match (any word)</option>
          <option value="partial">Partial match (substring)</option>
        </select>
      </label>
      <label class="text-xs mr-2" title="Exclude matches instead of include" style="color:#dc2626;">
        <input type="checkbox" id="hfFilterExclude"> Exclude
      </label>
      <label class="text-xs mr-2">
        Apply to:
        <select id="hfFilterScope" class="border px-1 py-025 text-xs">
          <option value="all" selected>All folders</option>
          <option value="target">Target only</option>
          <option value="reference">Reference only</option>
        </select>
      </label>
      <button type="button" class="btn btn-xs btn-filter" id="hfFilterApplyBtn">Apply filter</button>
      <button type="button" class="btn btn-xs" id="hfFilterClearBtn" style="margin-left:0.25rem; background:#dc2626; color:white;">Clear filter</button>
    </div>
    <div id="hfStatus" class="status mt-05"></div>
    <div class="table-wrapper mt-1">
      <table id="hfTable">
        <colgroup>
          <col style="width:3rem;">
          <col style="width:14rem;">
          <col style="width:6rem;">
          <col style="width:7rem;">
          <col style="width:5rem;">
          <col style="width:3rem;">
          <col style="width:14rem;">
          <col style="width:6rem;">
          <col style="width:7rem;">
          <col style="width:5rem;">
        </colgroup>
        <thead>
          <tr>
            <th class="text-right sortable" data-col="0" style="position:relative;"># (T)<div class="hf-col-resizer" data-col="0"></div></th>
            <th class="sortable" data-col="1" style="position:relative;">Feature<div class="hf-col-resizer" data-col="1"></div></th>
            <th class="text-right sortable" data-col="2" style="position:relative;">freq_T<div class="hf-col-resizer" data-col="2"></div></th>
            <th class="text-right sortable" data-col="3" style="position:relative;">norm_T (pm)<div class="hf-col-resizer" data-col="3"></div></th>
            <th class="text-right sortable hf-divider" data-col="4" style="position:relative;">files_T<div class="hf-col-resizer" data-col="4"></div></th>
            <th class="text-right sortable" data-col="5" style="position:relative;"># (R)<div class="hf-col-resizer" data-col="5"></div></th>
            <th class="sortable" data-col="6" style="position:relative;">Feature<div class="hf-col-resizer" data-col="6"></div></th>
            <th class="text-right sortable" data-col="7" style="position:relative;">freq_R<div class="hf-col-resizer" data-col="7"></div></th>
            <th class="text-right sortable" data-col="8" style="position:relative;">norm_R (pm)<div class="hf-col-resizer" data-col="8"></div></th>
            <th class="text-right sortable" data-col="9" style="position:relative;">files_R<div class="hf-col-resizer" data-col="9"></div></th>
          </tr>
        </thead>
        <tbody id="hfTableBody">
          <tr><td colspan="10" class="text-xs">No high-frequency features yet.</td></tr>
        </tbody>
      </table>
    </div>
  </div>


  <!-- Keyness -->
  <div class="card" id="keyCard">
    <h2>8) Keyness (Freq-LL / Text-LL / Mean Text Keyness)</h2>
    <div class="flex mt-05">
      <label for="featureTypeSelect">Feature type:</label>
      <select id="featureTypeSelect"></select>

      <label for="nInput">n for n-gram / p-frame / POS-gram / cluster:</label>
      <input type="number" id="nInput" value="4" min="1" max="10" style="width:4rem;">

      <label for="minFreqInput">Min total freq:</label>
      <input type="number" id="minFreqInput" value="2" min="1" max="1000000" style="width:5rem;">

      <label for="topNKeyInput">Top N (table):</label>
      <input type="number" id="topNKeyInput" value="200" min="1" max="10000" style="width:5rem;">

      <label style="margin-left:0.5rem;">
        <input type="checkbox" id="keyCaseInsensitive" checked>
        Case-insensitive
      </label>

      <label style="margin-left:0.5rem;">
        <input type="checkbox" id="keyUseMTK">
        Use MTK
      </label>

      <label style="margin-left:0.5rem;">
        <input type="checkbox" id="keyWeightedPooledSD" disabled>
        Weighted pooled SD (MTK)
      </label>

      <label style="margin-left:0.5rem;">
        <input type="checkbox" id="keyAdvancedStats">
        Advanced Statistics (Dispersion)
      </label>
      
      <!-- 96 BiberPlus only checkbox (for biber_tag type) -->
      <label id="keyBiberPlusContainer" style="margin-left:0.5rem; display:none; background:#fff8e6; padding:0.25rem 0.5rem; border-radius:3px; border:1px solid #f0d080;">
        <input type="checkbox" id="keyBiberPlusOnly">
        <span class="text-xs" style="color:#805500;">96 BiberPlus only</span>
      </label>

      <button id="keynessBtn" class="small">Compute Keyness / Frequency</button>
      <button id="keyCancelBtn" class="small btn-clear" style="margin-left:0.25rem; display:none;">Cancel</button>
      <button id="keyClearBtn" class="small btn-clear" style="margin-left:0.25rem;">Clear</button>
      <button id="exportKeynessBtn" class="small export">Export to Excel</button>
    </div>
    <!-- Progress bar for computation -->
    <div id="keyProgressContainer" class="mt-05" style="display:none;">
      <div style="display:flex; align-items:center; gap:0.5rem;">
        <div style="flex:1; background:#e5e7eb; border-radius:4px; height:20px; overflow:hidden;">
          <div id="keyProgressBar" style="width:0%; height:100%; background:linear-gradient(90deg, #3b82f6, #60a5fa); transition:width 0.1s;"></div>
        </div>
        <span id="keyProgressText" style="font-size:0.8rem; color:#4b5563; min-width:60px;">0%</span>
      </div>
      <div id="keyProgressDetail" style="font-size:0.75rem; color:#6b7280; margin-top:0.25rem;"></div>
    </div>
    <!-- Cluster-specific UI -->
    <div id="keyClusterUI" class="flex mt-05" style="display:none; gap:0.5rem; align-items:center; background:#f0f8ff; padding:0.5rem; border-radius:4px;">
      <label>Search word (* ? | supported):</label>
      <input type="text" id="keyClusterWord" style="width:150px;" placeholder="e.g. study">
      <label>Position:</label>
      <select id="keyClusterPosition" style="width:100px;">
        <option value="all">All folders</option>
        <option value="left">Left (start)</option>
        <option value="right">Right (end)</option>
      </select>
      <span class="help-text text-xs" style="margin-left:0.5rem;">Extract n-grams containing the search word (Left=start, Right=end, Both=any position)</span>
    </div>
    <div class="flex mt-05">
      <label class="text-xs mr-2">
        Feature filter:
        <input type="text" id="keyFeatureFilter" class="border px-1 py-025 text-xs" style="min-width: 160px;">
      </label>
      <label class="text-xs mr-2">
        Match:
        <select id="keyFilterMode" class="border px-1 py-025 text-xs">
          <option value="exact" selected>Exact match (any word)</option>
          <option value="partial">Partial match (substring)</option>
        </select>
      </label>
      <label class="text-xs mr-2" title="Exclude matches instead of include" style="color:#dc2626;">
        <input type="checkbox" id="keyFilterExclude"> Exclude
      </label>
      <button type="button" class="btn btn-xs btn-filter" onclick="applyKeynessFilter()">Apply filter</button>
      <button type="button" class="btn btn-xs" onclick="clearKeynessFilter()" style="margin-left:0.25rem; background:#dc2626; color:white;">Clear filter</button>
    </div>
    <div class="help-text mt-05">
      For p-frames (e.g., 4 words), patterns like <code>1 * 34</code>, <code>12 * 4</code>, <code>123 *</code> are generated with <code>*</code> at any position except the leftmost (same for other n).<br>
      The distribution of words filling <code>*</code> is shown separately for Target / Reference. Tokens with only punctuation or SPACE are excluded from all counts (same for POS).<br>
      <strong>Freq-LL (T) / Text-LL (T) / MTK (T)</strong> are Target-perspective values (positive=Target dominant, negative=Reference dominant). Click Feature to show Target KWIC.<br>
      <strong>file_T / file_R</strong>: Number of files (texts) containing the feature in Target / Reference. Used as input for Text-LL calculation.<br>
      <strong>Fillers_T / Fillers_R</strong>: Click word(frequency) to display KWIC for n-gram containing that word (Target / Reference only).<br>
      <strong>Use MTK</strong>: When checked, uses Mean Text Keyness based on Larsson, T., Kim, T., &amp; Egbert, J. (2025). Calculated as (mean_T - mean_R) / pooled_SD, where mean is the average normalized frequency (per 1000 words) across texts. When unchecked, MTK column is not calculated (faster). Unweighted: SD_pooled = √((SD₁² + SD₂²) / 2); Weighted: SD_pooled = √(((n₁-1)SD₁² + (n₂-1)SD₂²) / (n₁+n₂-2)).<br>
      <strong>Advanced Statistics</strong>: When checked, dispersion measures (Range, Juilland's D, Gries's DP) are displayed. Range=proportion of files containing the feature, Juilland's D (1=even), DP (0=even).<br>
      <strong>Cluster</strong>: Extracts n-grams containing the search word (you can use * ? | in the Search word field).
    </div>
    <div id="keyStatus" class="status mt-05"></div>
    <div class="table-wrapper mt-1">
      <table id="keyTable">
        <colgroup id="keyTableColgroup">
          <col data-col="0" style="width:40px">
          <col data-col="1" style="width:200px">
          <col data-col="2" style="width:70px">
          <col data-col="3" style="width:90px">
          <col data-col="4" style="width:55px">
          <col data-col="5" style="width:70px">
          <col data-col="6" style="width:90px">
          <col data-col="7" style="width:55px">
          <col data-col="8" style="width:70px">
          <col data-col="9" style="width:70px">
          <col data-col="10" style="width:70px">
          <col data-col="11" style="width:150px">
          <col data-col="12" style="width:150px">
        </colgroup>
        <thead id="keyTableHead">
        <tr>
          <th style="position:relative;">#<div class="key-col-resizer" data-col="0"></div></th>
          <th class="sortable" data-col="1" style="position:relative;">Feature<div class="key-col-resizer" data-col="1"></div></th>
          <th class="text-right sortable" data-col="2" style="position:relative;">freq_T<div class="key-col-resizer" data-col="2"></div></th>
          <th class="text-right sortable" data-col="3" style="position:relative;">norm_T (pm)<div class="key-col-resizer" data-col="3"></div></th>
          <th class="text-right sortable" data-col="4" style="position:relative;">file_T<div class="key-col-resizer" data-col="4"></div></th>
          <th class="text-right sortable" data-col="5" style="position:relative;">freq_R<div class="key-col-resizer" data-col="5"></div></th>
          <th class="text-right sortable" data-col="6" style="position:relative;">norm_R (pm)<div class="key-col-resizer" data-col="6"></div></th>
          <th class="text-right sortable" data-col="7" style="position:relative;">file_R<div class="key-col-resizer" data-col="7"></div></th>
          <th class="text-right sortable" data-col="8" style="position:relative;">Freq-LL (T)<div class="key-col-resizer" data-col="8"></div></th>
          <th class="text-right sortable" data-col="9" style="position:relative;">Text-LL (T)<div class="key-col-resizer" data-col="9"></div></th>
          <th class="text-right sortable" data-col="10" style="position:relative;">MTK (T)<div class="key-col-resizer" data-col="10"></div></th>
          <th style="position:relative;">Fillers_T (for *)<div class="key-col-resizer" data-col="11"></div></th>
          <th style="position:relative;">Fillers_R (for *)<div class="key-col-resizer" data-col="12"></div></th>
        </tr>
        </thead>
        <tbody id="keyTableBody">
        <tr><td colspan="13" class="text-xs">No keyness results.</td></tr>
        </tbody>
      </table>
    </div>
  </div>

  <!-- Frequency Analysis -->

</div><!-- end container -->

<script>
// ===== Collapsible Section Toggle =====
function toggleCollapsibleSection(sectionId) {
  const content = document.getElementById(sectionId + '-content');
  const arrow = document.getElementById(sectionId + '-arrow');
  if (!content || !arrow) return;
  
  if (content.style.display === 'none') {
    content.style.display = 'block';
    arrow.textContent = '▼';
  } else {
    content.style.display = 'none';
    arrow.textContent = '▶';
  }
}

// ===== Global State
// =====
let corpus = null;
let fileIdCounter = 1;
let targetFolders = new Set();
let referenceFolders = new Set();

// Keyness state
let allKeynessRows = [];
let lastKeynessRows = [];
let lastKeynessIsPframe = false;
let allHfRows = [];
let lastHfRows = [];
let lastHfSort = { col: 2, dir: 'desc' };
let lastHfFeatureType = 'word';

let lastTargetFillers = null;
let lastReferenceFillers = null;
let lastSort = { col: 8, dir: 'desc' };
let lastKeyFeatureType = null;
let lastKeyAllCount = 0;  // 8) Keyness: total rows before filter
let lastKeyAdvancedStats = false;  // Track if advanced stats are shown

// KWIC state
let allKwicRows = [];
let lastKwicRows = [];
let lastKwicSort = { col: 0, dir: 'asc' };
let currentKwicFeature = null;
let currentKwicFeatureType = null;
let lastOriginalIndex = null;
let lastKwicAllCount = 0;  // total hits before Node filter

// KWIC file/folder filters (for 5b Concordance Plot → 6) KWIC)
let currentKwicFileFilter = null;   // when set, restrict KWIC to this file name
let currentKwicFolderFilter = null; // when set, restrict KWIC to this folder
let lastWildcardMatchCounts = {}; // wildcard/character match frequencies

// Collocate word for purple highlight in KWIC
let currentCollocateWord = null;
let currentCollocateInfo = null; // { word, direction, position, scope } for precise highlight

// 12) Dependency Grammar state
let allDepPatternRows = [];
let lastDepPatternRows = [];
let keynessDepPatternRows = [];  // 8) Keyness DEP results (separate from 11a)
let lastDepSort = { col: 6, dir: 'desc' };
let lastDepAdvancedStats = false;
let currentDepFeature = null;
let currentDepInstances = [];
let depConcSortCol = 'position';  // Sort column for 11b) Concordance
let depConcSortDir = 'asc';       // Sort direction for 11b) Concordance
let depHasDependencyData = false;  // whether corpus has dependency columns

// Dependency presets (28 patterns)
const DEP_PRESETS = {
  // Category 1: Noun Modification (11)
  N01: { id: 'N01', cat: 'noun', name: 'ADJ + NOUN', desc: 'amod: "large cells", "significant effect"', 
         mode: 'chain', rels: [{rel: 'amod', nodePos: 'NOUN', modPos: 'ADJ'}] },
  N02: { id: 'N02', cat: 'noun', name: 'NOUN + NOUN (compound)', desc: 'compound: "stem cells", "gene expression"',
         mode: 'chain', rels: [{rel: 'compound', nodePos: 'NOUN', modPos: 'NOUN'}] },
  N03: { id: 'N03', cat: 'noun', name: 'NOUN + of + NOUN', desc: 'nmod + case:of: "analysis of data"',
         mode: 'chain', rels: [{rel: 'nmod', nodePos: 'NOUN', modPos: 'NOUN'}], caseFilter: 'of', includeCase: true },
  N04: { id: 'N04', cat: 'noun', name: 'DET + NOUN', desc: 'det: "the study", "a method"',
         mode: 'chain', rels: [{rel: 'det', nodePos: 'NOUN', modPos: 'DET'}] },
  N05: { id: 'N05', cat: 'noun', name: 'ADV + ADJ + NOUN', desc: 'advmod + amod: "significantly higher level"',
         mode: 'chain', rels: [{rel: 'amod', nodePos: 'NOUN', modPos: 'ADJ'}, {rel: 'advmod', nodePos: 'ADJ', modPos: 'ADV'}] },
  N06: { id: 'N06', cat: 'noun', name: 'NOUN + REL.CLAUSE', desc: 'acl:relcl: "cells that express"',
         mode: 'chain', rels: [{rel: 'acl:relcl', nodePos: 'NOUN', modPos: 'VERB'}], ppFilter: 'include' },
  N07: { id: 'N07', cat: 'noun', name: '-ing + NOUN / NOUN + -ing', desc: 'amod/acl(VBG): "increasing demand", "cells expressing"',
         mode: 'or', rels: [{rel: 'amod', nodePos: 'NOUN'}, {rel: 'acl', nodePos: 'NOUN', modPos: 'VERB'}], verbFormFilter: 'ing', positionFilter: 'both' },
  N08: { id: 'N08', cat: 'noun', name: '-ed + NOUN / NOUN + -ed', desc: 'amod/acl(VBN): "reduced activity", "data obtained"',
         mode: 'or', rels: [{rel: 'amod', nodePos: 'NOUN'}, {rel: 'acl', nodePos: 'NOUN', modPos: 'VERB'}], verbFormFilter: 'ed', positionFilter: 'both' },
  N09: { id: 'N09', cat: 'noun', name: 'NOUN + to V', desc: 'acl:to: "ability to perform"',
         mode: 'chain', rels: [{rel: 'acl', nodePos: 'NOUN', modPos: 'VERB'}], toInfFilter: true },
  N10: { id: 'N10', cat: 'noun', name: 'Multiple ADJ + NOUN', desc: 'amod + amod: "large epithelial cells"',
         mode: 'chain', rels: [{rel: 'amod', nodePos: 'NOUN', modPos: 'ADJ'}, {rel: 'amod', nodePos: 'NOUN', modPos: 'ADJ'}] },
  N11: { id: 'N11', cat: 'noun', name: 'NOUN + PP', desc: 'nmod: "effect on growth"',
         mode: 'chain', rels: [{rel: 'nmod', nodePos: 'NOUN', modPos: 'NOUN'}] },
  
  // Category 2: Verb Patterns (10)
  V01: { id: 'V01', cat: 'verb', name: 'VERB + OBJ', desc: 'obj: "perform analysis"',
         mode: 'chain', rels: [{rel: 'obj', nodePos: 'VERB', modPos: 'NOUN'}] },
  V02: { id: 'V02', cat: 'verb', name: 'VERB + ADV', desc: 'advmod: "significantly increased"',
         mode: 'chain', rels: [{rel: 'advmod', nodePos: 'VERB', modPos: 'ADV'}] },
  V03: { id: 'V03', cat: 'verb', name: 'VERB + to-INF', desc: 'xcomp: "tend to increase"',
         mode: 'chain', rels: [{rel: 'xcomp', nodePos: 'VERB', modPos: 'VERB'}], toInfFilter: true },
  V04: { id: 'V04', cat: 'verb', name: 'VERB + -ing', desc: 'xcomp: "started expressing"',
         mode: 'chain', rels: [{rel: 'xcomp', nodePos: 'VERB', modPos: 'VERB'}], verbFormFilter: 'ing' },
  V05: { id: 'V05', cat: 'verb', name: 'AUX + VERB', desc: 'aux: "has been shown"',
         mode: 'chain', rels: [{rel: 'aux', nodePos: 'VERB', modPos: 'AUX'}] },
  V06: { id: 'V06', cat: 'verb', name: 'VERB + OBJ + OBJ.MOD', desc: 'obj + amod: "show significant results"',
         mode: 'chain', rels: [{rel: 'obj', nodePos: 'VERB', modPos: 'NOUN'}, {rel: 'amod', nodePos: 'NOUN', modPos: 'ADJ'}] },
  V07: { id: 'V07', cat: 'verb', name: 'VERB + IOBJ + DOBJ', desc: 'iobj + obj: "provide researchers tools"',
         mode: 'chain', rels: [{rel: 'iobj', nodePos: 'VERB', modPos: 'NOUN'}, {rel: 'obj', nodePos: 'VERB', modPos: 'NOUN'}] },
  V08: { id: 'V08', cat: 'verb', name: 'NEG + VERB', desc: 'advmod:neg: "did not show"',
         mode: 'chain', rels: [{rel: 'advmod', nodePos: 'VERB', modPos: 'PART'}] },
  V09: { id: 'V09', cat: 'verb', name: 'MODAL + VERB', desc: 'aux:modal: "can be used"',
         mode: 'chain', rels: [{rel: 'aux', nodePos: 'VERB', modPos: 'AUX'}] },
  V10: { id: 'V10', cat: 'verb', name: 'VERB + COMP', desc: 'ccomp: "suggest that..."',
         mode: 'chain', rels: [{rel: 'ccomp', nodePos: 'VERB', modPos: 'VERB'}] },
  
  // Category 3: Sentence Patterns (9)
  S01: { id: 'S01', cat: 'sentence', name: 'SUBJ + VERB (/ + PP) (SV)', desc: 'nsubj (no obj): "results remain", "cells exist in tissues"',
         mode: 'chain', rels: [{rel: 'nsubj', nodePos: 'VERB', modPos: 'NOUN'}], noObjFilter: true },
  S02: { id: 'S02', cat: 'sentence', name: 'SUBJ + VERB + COMP (SVC)', desc: 'nsubj + xcomp: "results seem clear", "cells become active"',
         mode: 'chain', rels: [{rel: 'nsubj', nodePos: 'VERB', modPos: 'NOUN'}, {rel: 'xcomp', nodePos: 'VERB', modPos: ''}] },
  S03: { id: 'S03', cat: 'sentence', name: 'SUBJ + VERB + OBJ (SVO)', desc: 'nsubj + obj: "study examined effects"',
         mode: 'chain', rels: [{rel: 'nsubj', nodePos: 'VERB', modPos: 'NOUN'}, {rel: 'obj', nodePos: 'VERB', modPos: 'NOUN'}] },
  S04: { id: 'S04', cat: 'sentence', name: 'SUBJ + VERB + IOBJ + DOBJ (SVOO)', desc: 'nsubj + iobj + obj: "method provides researchers tools"',
         mode: 'chain', rels: [{rel: 'nsubj', nodePos: 'VERB', modPos: 'NOUN'}, {rel: 'iobj', nodePos: 'VERB', modPos: 'NOUN'}, {rel: 'obj', nodePos: 'VERB', modPos: 'NOUN'}] },
  S05: { id: 'S05', cat: 'sentence', name: 'SUBJ + VERB + OBJ + COMP (SVOC)', desc: 'nsubj + obj + xcomp: "results make conclusion clear"',
         mode: 'chain', rels: [{rel: 'nsubj', nodePos: 'VERB', modPos: 'NOUN'}, {rel: 'obj', nodePos: 'VERB', modPos: 'NOUN'}, {rel: 'xcomp', nodePos: 'VERB', modPos: 'ADJ'}] },
  S06: { id: 'S06', cat: 'sentence', name: 'PASSIVE (be + Vpp)', desc: 'nsubj:pass + aux:pass: "was/is/has been examined"',
         mode: 'chain', rels: [{rel: 'nsubj:pass', nodePos: 'VERB', modPos: 'NOUN'}, {rel: 'aux:pass', nodePos: 'VERB', modPos: 'AUX'}] },
  S07: { id: 'S07', cat: 'sentence', name: 'THERE + BE + NP', desc: 'expl + nsubj: "there is/was/has been evidence"',
         mode: 'chain', rels: [{rel: 'expl', nodePos: 'VERB', modPos: ''}, {rel: 'nsubj', nodePos: 'VERB', modPos: 'NOUN'}] },
  S08: { id: 'S08', cat: 'sentence', name: 'IT + BE + ADJ + to-INF', desc: 'expl + xcomp: "it is/was important to"',
         mode: 'chain', rels: [{rel: 'expl', nodePos: 'VERB', modPos: ''}, {rel: 'xcomp', nodePos: 'VERB', modPos: 'VERB'}] },
  S09: { id: 'S09', cat: 'sentence', name: 'SUBJ + VERB + OBJ + to-INF', desc: 'nsubj + obj + xcomp: "we found cells to express"',
         mode: 'chain', rels: [{rel: 'nsubj', nodePos: 'VERB', modPos: 'NOUN'}, {rel: 'obj', nodePos: 'VERB', modPos: 'NOUN'}, {rel: 'xcomp', nodePos: 'VERB', modPos: 'VERB'}], toInfFilter: true }
};

// Universal dependency relations
const DEP_RELATIONS = [
  '', // NA
  'nsubj', 'nsubj:pass', 'obj', 'iobj', 'csubj', 'ccomp', 'xcomp',
  'nmod', 'appos', 'nummod', 'amod', 'det', 'case',
  'advcl', 'acl', 'acl:relcl',
  'advmod', 'discourse', 'mark',
  'conj', 'cc',
  'compound', 'flat', 'fixed', 'punct', 'root',
  'aux', 'aux:pass', 'cop', 'expl', 'dep', 'parataxis', 'vocative', 'obl'
];

// Universal POS tags
const UNIVERSAL_POS = [
  '', 'ADJ', 'ADP', 'ADV', 'AUX', 'CCONJ', 'DET', 'INTJ', 'NOUN', 'NUM',
  'PART', 'PRON', 'PROPN', 'PUNCT', 'SCONJ', 'SYM', 'VERB', 'X'
];

// Penn Treebank POS tags
const PENN_POS = [
  '', 'CC', 'CD', 'DT', 'EX', 'FW', 'IN', 'JJ', 'JJR', 'JJS',
  'LS', 'MD', 'NN', 'NNS', 'NNP', 'NNPS', 'PDT', 'POS', 'PRP', 'PRP$',
  'RB', 'RBR', 'RBS', 'RP', 'SYM', 'TO', 'UH', 'VB', 'VBD', 'VBG',
  'VBN', 'VBP', 'VBZ', 'WDT', 'WP', 'WP$', 'WRB'
];

// punctuation regex
// Punctuation regex - covers common punctuation and symbols
// Does NOT match: words with hyphens (anti-microbial), contractions (don't), numbers
const PUNCT_RE = /^[.,!?;:()\[\]{}"'`\-–—…/\\@#$%^&*+=~|<>]+$/;

// Stopword list (common English stopwords, ~200 words)
const STOPWORDS = new Set([
  // Articles
  'a', 'an', 'the',
  // Pronouns
  'i', 'me', 'my', 'myself', 'we', 'our', 'ours', 'ourselves',
  'you', 'your', 'yours', 'yourself', 'yourselves',
  'he', 'him', 'his', 'himself', 'she', 'her', 'hers', 'herself',
  'it', 'its', 'itself', 'they', 'them', 'their', 'theirs', 'themselves',
  'what', 'which', 'who', 'whom', 'this', 'that', 'these', 'those',
  // Be verbs
  'am', 'is', 'are', 'was', 'were', 'be', 'been', 'being',
  // Have verbs
  'have', 'has', 'had', 'having',
  // Do verbs
  'do', 'does', 'did', 'doing',
  // Modal verbs
  'will', 'would', 'shall', 'should', 'may', 'might', 'must', 'can', 'could',
  // Other common verbs
  'get', 'got', 'getting', 'make', 'made', 'making',
  // Prepositions
  'about', 'above', 'across', 'after', 'against', 'along', 'among', 'around',
  'at', 'before', 'behind', 'below', 'beneath', 'beside', 'besides', 'between',
  'beyond', 'by', 'down', 'during', 'except', 'for', 'from', 'in', 'inside',
  'into', 'like', 'near', 'of', 'off', 'on', 'onto', 'out', 'outside', 'over',
  'past', 'since', 'through', 'throughout', 'till', 'to', 'toward', 'towards',
  'under', 'underneath', 'until', 'up', 'upon', 'with', 'within', 'without',
  // Conjunctions
  'and', 'but', 'or', 'nor', 'for', 'yet', 'so', 'both', 'either', 'neither',
  'not', 'only', 'whether', 'while', 'although', 'though', 'because', 'if',
  'when', 'where', 'unless', 'than', 'as', 'once', 'whereas',
  // Adverbs
  'again', 'already', 'also', 'always', 'ever', 'here', 'how', 'however',
  'just', 'more', 'most', 'never', 'no', 'now', 'often', 'only', 'quite',
  'rather', 'really', 'so', 'some', 'sometimes', 'soon', 'still', 'such',
  'then', 'there', 'therefore', 'thus', 'too', 'very', 'well', 'why', 'yes',
  // Determiners & Quantifiers
  'all', 'another', 'any', 'anything', 'each', 'enough', 'every', 'everybody',
  'everyone', 'everything', 'few', 'fewer', 'first', 'last', 'least', 'less',
  'little', 'many', 'more', 'most', 'much', 'no', 'none', 'nothing', 'one',
  'other', 'others', 'own', 'same', 'several', 'some', 'somebody', 'someone',
  'something', 'such', 'whole',
  // Other function words
  'after', 'again', 'even', 'further', 'hence', 'here', 'hereafter', 'hereby',
  'herein', 'hereupon', 'hers', 'indeed', 'moreover', 'namely', 'nonetheless',
  'otherwise', 'per', 'perhaps', 'please', 're', 'seem', 'seemed', 'seeming',
  'seems', 'thence', 'thereafter', 'thereby', 'therefore', 'therein', 'thereupon',
  'thru', 'via', 'whatever', 'whenever', 'whereafter', 'whereas', 'whereby',
  'wherein', 'whereupon', 'wherever', 'whither', 'whoever', 'whomever', 'whose',
  // Contractions (common forms)
  "'s", "'re", "'ve", "'ll", "'d", "'m", "n't",
  // Numbers (as words)
  'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight', 'nine', 'ten'
]);

// Excel export utility functions
function downloadExcel(data, filename, sheetName = 'Sheet1') {
  // Create Excel XML (SpreadsheetML format)
  const escapeXml = (str) => {
    if (str === null || str === undefined) return '';
    return String(str)
      .replace(/&/g, '&amp;')
      .replace(/</g, '&lt;')
      .replace(/>/g, '&gt;')
      .replace(/"/g, '&quot;');
  };
  
  let xml = '<?xml version="1.0" encoding="UTF-8"?>\n';
  xml += '<?mso-application progid="Excel.Sheet"?>\n';
  xml += '<Workbook xmlns="urn:schemas-microsoft-com:office:spreadsheet"\n';
  xml += '  xmlns:ss="urn:schemas-microsoft-com:office:spreadsheet">\n';
  xml += `  <Worksheet ss:Name="${escapeXml(sheetName)}">\n`;
  xml += '    <Table>\n';
  
  for (const row of data) {
    xml += '      <Row>\n';
    for (const cell of row) {
      const cellVal = cell === null || cell === undefined ? '' : cell;
      const isNum = typeof cellVal === 'number' && !isNaN(cellVal);
      const type = isNum ? 'Number' : 'String';
      const val = isNum ? cellVal : escapeXml(cellVal);
      xml += `        <Cell><Data ss:Type="${type}">${val}</Data></Cell>\n`;
    }
    xml += '      </Row>\n';
  }
  
  xml += '    </Table>\n';
  xml += '  </Worksheet>\n';
  xml += '</Workbook>';
  
  const blob = new Blob([xml], { type: 'application/vnd.ms-excel' });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = filename.endsWith('.xls') ? filename : filename + '.xls';
  a.click();
  URL.revokeObjectURL(url);
}

// Download Excel with multiple sheets
function downloadExcelMultiSheet(sheets, filename) {
  // sheets: array of { name: string, data: 2D array }
  const escapeXml = (str) => {
    if (str === null || str === undefined) return '';
    return String(str)
      .replace(/&/g, '&amp;')
      .replace(/</g, '&lt;')
      .replace(/>/g, '&gt;')
      .replace(/"/g, '&quot;');
  };
  
  let xml = '<?xml version="1.0" encoding="UTF-8"?>\n';
  xml += '<?mso-application progid="Excel.Sheet"?>\n';
  xml += '<Workbook xmlns="urn:schemas-microsoft-com:office:spreadsheet"\n';
  xml += '  xmlns:ss="urn:schemas-microsoft-com:office:spreadsheet">\n';
  
  for (const sheet of sheets) {
    // Sanitize sheet name (max 31 chars, no special chars)
    let sheetName = sheet.name.replace(/[\\\/\?\*\[\]]/g, '_').slice(0, 31);
    xml += `  <Worksheet ss:Name="${escapeXml(sheetName)}">\n`;
    xml += '    <Table>\n';
    
    for (const row of sheet.data) {
      xml += '      <Row>\n';
      for (const cell of row) {
        const cellVal = cell === null || cell === undefined ? '' : cell;
        const isNum = typeof cellVal === 'number' && !isNaN(cellVal);
        const type = isNum ? 'Number' : 'String';
        const val = isNum ? cellVal : escapeXml(cellVal);
        xml += `        <Cell><Data ss:Type="${type}">${val}</Data></Cell>\n`;
      }
      xml += '      </Row>\n';
    }
    
    xml += '    </Table>\n';
    xml += '  </Worksheet>\n';
  }
  
  xml += '</Workbook>';
  
  const blob = new Blob([xml], { type: 'application/vnd.ms-excel' });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = filename.endsWith('.xls') ? filename : filename + '.xls';
  a.click();
  URL.revokeObjectURL(url);
}

function downloadCSV(csv, filename) {
  const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = filename;
  a.click();
  URL.revokeObjectURL(url);
}

// ===== Utility =====
function isHiddenPath(path) {
  if (!path) return false;
  const parts = path.split('/');
  for (const part of parts) {
    if (!part) continue;
    if (part === '__MACOSX') return true;
    if (part.startsWith('.')) return true;
  }
  return false;
}

function isHiddenFile(file) {
  const rel = file.webkitRelativePath || file.name;
  return isHiddenPath(rel);
}

function getFolderName(file) {
  const rel = file.webkitRelativePath;
  if (!rel) return 'Ungrouped';
  const parts = rel.split('/');
  if (parts.length > 1) {
    return parts[parts.length - 2] || 'Ungrouped';
  }
  return 'Ungrouped';
}

function readFileAsText(file) {
  return new Promise((resolve, reject) => {
    const reader = new FileReader();
    reader.onload = () => resolve(reader.result || '');
    reader.onerror = () => reject(reader.error);
    reader.readAsText(file);
  });
}

// ===== CSV (Stanza/Biber) Processing =====
// CSV進捗更新
function updateCsvProgress(percent, detail) {
  const container = document.getElementById('csvProgressContainer');
  const bar = document.getElementById('csvProgressBar');
  const text = document.getElementById('csvProgressText');
  const detailEl = document.getElementById('csvProgressDetail');
  
  if (container) container.style.display = 'block';
  if (bar) bar.style.width = percent + '%';
  if (text) text.textContent = Math.round(percent) + '%';
  if (detailEl) detailEl.textContent = detail || '';
}

function hideCsvProgress() {
  const container = document.getElementById('csvProgressContainer');
  if (container) container.style.display = 'none';
}

// ZIPからCSVを抽出
async function extractCSVFromZip(file) {
  // JSZipを動的に読み込む
  if (typeof JSZip === 'undefined') {
    await loadJSZip();
  }
  
  const arrayBuffer = await file.arrayBuffer();
  const zip = await JSZip.loadAsync(arrayBuffer);
  
  // CSVファイルを探す
  let csvContent = null;
  let csvFileName = null;
  
  for (const [filename, zipEntry] of Object.entries(zip.files)) {
    if (!zipEntry.dir && filename.toLowerCase().endsWith('.csv') && !filename.includes('__MACOSX') && !filename.startsWith('.')) {
      csvContent = await zipEntry.async('string');
      csvFileName = filename;
      break;
    }
  }
  
  if (!csvContent) {
    throw new Error('No CSV file found in ZIP');
  }
  
  return { content: csvContent, fileName: csvFileName };
}

// JSZipライブラリを動的に読み込む
function loadJSZip() {
  return new Promise((resolve, reject) => {
    if (typeof JSZip !== 'undefined') {
      resolve();
      return;
    }
    const script = document.createElement('script');
    script.src = 'https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js';
    script.onload = resolve;
    script.onerror = () => reject(new Error('Failed to load JSZip'));
    document.head.appendChild(script);
  });
}

// CSVからコーパスを構築
async function parseCorpusFromCSV(csvText, options = {}) {
  const useSearchToken = options.useSearchToken !== false;
  const preserveSentence = options.preserveSentence !== false;
  
  updateCsvProgress(2, 'Parsing CSV...');
  await new Promise(r => setTimeout(r, 0));
  
  // BOMを除去
  if (csvText.charCodeAt(0) === 0xFEFF) {
    csvText = csvText.slice(1);
  }
  
  // クォート内改行対応のCSVパース
  updateCsvProgress(3, 'Splitting CSV lines (handling quoted newlines)...');
  await new Promise(r => setTimeout(r, 0));
  
  const lines = splitCSVLines(csvText);
  if (lines.length < 2) {
    throw new Error('CSV file is empty or has no data rows');
  }
  
  // ヘッダー解析（高速版）
  const headers = parseCSVLineFast(lines[0]);
  const headerMap = {};
  for (let i = 0; i < headers.length; i++) {
    // Remove BOM from first column if present
    let header = headers[i].trim().toLowerCase();
    if (i === 0) {
      header = header.replace(/^\ufeff/, '');
    }
    headerMap[header] = i;
  }
  
  // Debug: log all headers with indices
  console.log('[CSV] Header map:', headerMap);
  
  // 必須カラムの確認
  if (headerMap['file'] === undefined || headerMap['token'] === undefined) {
    throw new Error('Required columns "file" and "token" not found in CSV');
  }
  
  // カラムインデックス（高速アクセス用にローカル変数化）
  const COL_FILE = headerMap['file'];
  const COL_MOVE = headerMap['move'];
  const COL_SENT_ID = headerMap['sent_id'];
  const COL_SENT_TEXT = headerMap['sent_text'];
  const COL_TOKEN = headerMap['token'];
  const COL_TOKEN_ID = headerMap['token_id'];
  const COL_LEMMA = headerMap['lemma'];
  const COL_POS = headerMap['pos'];
  const COL_XPOS = headerMap['xpos'];
  const COL_IS_PUNCT = headerMap['is_punct'];
  const COL_IS_SPACE = headerMap['is_space'];
  const COL_SEARCH_TOKEN = headerMap['search_token'];
  const COL_SEARCH_LEMMA = headerMap['search_lemma'];
  // Biberタグはtags_rawカラムに格納されている（tagsはcpathと同じ構文パス）
  const COL_TAGS = headerMap['tags_raw'] !== undefined ? headerMap['tags_raw'] : headerMap['tags'];
  const COL_DEP = headerMap['dep'] !== undefined ? headerMap['dep'] : headerMap['deprel'];
  const COL_HEAD_ID = headerMap['head_id'];
  const COL_HEAD_TEXT = headerMap['head_text'];
  const COL_HEAD_LEMMA = headerMap['head_lemma'];
  const COL_HEAD_POS = headerMap['head_pos'];
  const COL_IS_ROOT = headerMap['is_root'];
  const COL_CHUNK = headerMap['chunk'];
  const COL_CPATH = headerMap['cpath'];
  const COL_CPATH_NORM = headerMap['cpath_norm'];
  const COL_IS_CHUNK_HEAD = headerMap['is_chunk_head'];
  const COL_CSPAN_START = headerMap['cspan_start'];
  const COL_CSPAN_END = headerMap['cspan_end'];
  
  // Debug: log constituent column detection
  console.log('[CSV] Constituent columns detected:');
  console.log('  chunk:', COL_CHUNK);
  console.log('  cpath:', COL_CPATH);
  console.log('  cpath_norm:', COL_CPATH_NORM);
  console.log('  is_chunk_head:', COL_IS_CHUNK_HEAD);
  console.log('  cspan_start:', COL_CSPAN_START);
  console.log('  cspan_end:', COL_CSPAN_END);
  
  const totalRows = lines.length - 1;
  updateCsvProgress(5, `Processing ${totalRows.toLocaleString()} tokens...`);
  await new Promise(r => setTimeout(r, 0));
  
  // ファイルごとにグループ化（高速版 - オブジェクトプール使用）
  const fileGroups = new Map();
  const BATCH_SIZE = 10000;
  
  for (let i = 1; i < lines.length; i++) {
    const line = lines[i];
    if (!line || !line.trim()) continue;
    
    const row = parseCSVLineFast(line);
    
    // Debug first few rows
    if (i <= 3) {
      console.log(`[CSV] Row ${i}: length=${row.length}, chunk=[${COL_CHUNK}]=${row[COL_CHUNK]}, cpath_norm=[${COL_CPATH_NORM}]=${row[COL_CPATH_NORM]?.substring(0,30)}, is_chunk_head=[${COL_IS_CHUNK_HEAD}]=${row[COL_IS_CHUNK_HEAD]}`);
    }
    
    const fileName = (row[COL_FILE] || '').trim();
    
    // ファイル名が空または無効な場合はスキップ
    if (!fileName || fileName === 'file') continue;
    
    let group = fileGroups.get(fileName);
    if (!group) {
      group = {
        fileName,
        move: COL_MOVE !== undefined ? (row[COL_MOVE] || 'Ungrouped') : 'Ungrouped',
        rows: []
      };
      fileGroups.set(fileName, group);
    }
    group.rows.push(row);
    
    // 進捗更新（バッチごと）
    if (i % BATCH_SIZE === 0) {
      const progress = 5 + Math.round((i / totalRows) * 45);
      updateCsvProgress(progress, `Reading: ${i.toLocaleString()} / ${totalRows.toLocaleString()}`);
      await new Promise(r => setTimeout(r, 0));
    }
  }
  
  updateCsvProgress(52, 'Building corpus structure...');
  await new Promise(r => setTimeout(r, 0));
  
  // コーパス構造を構築
  const result = {
    mode: 'csv',
    files: {},
    folders: {},
    csvMetadata: {
      hasLemma: COL_LEMMA !== undefined,
      hasPos: COL_POS !== undefined,
      hasXpos: COL_XPOS !== undefined,
      hasDep: COL_DEP !== undefined,
      hasHeadId: COL_HEAD_ID !== undefined,
      hasChunk: COL_CHUNK !== undefined,
      hasCpath: COL_CPATH !== undefined,
      hasCpathNorm: COL_CPATH_NORM !== undefined,
      hasIsChunkHead: COL_IS_CHUNK_HEAD !== undefined,
      hasTags: COL_TAGS !== undefined,
      hasSearchToken: COL_SEARCH_TOKEN !== undefined
    }
  };
  
  let fileIdCounter = 1;
  const fileNames = Array.from(fileGroups.keys());
  const totalFiles = fileNames.length;
  
  for (let fi = 0; fi < totalFiles; fi++) {
    const fileName = fileNames[fi];
    const group = fileGroups.get(fileName);
    const folderName = group.move;
    const fileId = String(fileIdCounter++);
    const groupRows = group.rows;
    const rowCount = groupRows.length;
    
    // 配列を事前確保
    const tokens = new Array(rowCount);
    const sentences = [];
    
    let currentSentId = null;
    let sentenceStartIdx = 0;
    let tokenIdx = 0;
    
    for (let ri = 0; ri < rowCount; ri++) {
      const row = groupRows[ri];
      const tokenText = row[COL_TOKEN] || '';
      if (!tokenText) continue;
      
      const sentId = COL_SENT_ID !== undefined ? row[COL_SENT_ID] : null;
      
      // 句読点・空白の判定（高速化）
      const isPunctVal = COL_IS_PUNCT !== undefined ? row[COL_IS_PUNCT] : '';
      const isSpaceVal = COL_IS_SPACE !== undefined ? row[COL_IS_SPACE] : '';
      const isPunct = isPunctVal === 'True' || isPunctVal === 'true' || isPunctVal === '1';
      const isSpace = isSpaceVal === 'True' || isSpaceVal === 'true' || isSpaceVal === '1';
      
      // 文境界の検出
      if (preserveSentence && sentId !== null && sentId !== currentSentId) {
        if (currentSentId !== null && tokenIdx > sentenceStartIdx) {
          sentences.push({ tokenStart: sentenceStartIdx, tokenEnd: tokenIdx });
        }
        currentSentId = sentId;
        sentenceStartIdx = tokenIdx;
      }
      
      // トークンデータ（最小限のデータのみ）
      const lemma = COL_LEMMA !== undefined ? (row[COL_LEMMA] || tokenText) : tokenText;
      const pos = COL_POS !== undefined ? (row[COL_POS] || '') : '';
      const xpos = COL_XPOS !== undefined ? (row[COL_XPOS] || '') : '';
      
      let searchWord = tokenText;
      let searchLemma = lemma;
      if (useSearchToken) {
        if (COL_SEARCH_TOKEN !== undefined && row[COL_SEARCH_TOKEN]) {
          searchWord = row[COL_SEARCH_TOKEN];
        }
        if (COL_SEARCH_LEMMA !== undefined && row[COL_SEARCH_LEMMA]) {
          searchLemma = row[COL_SEARCH_LEMMA];
        }
      }
      
      // Biberタグを配列に変換（|で区切られている）
      let biberTags = [];
      if (COL_TAGS !== undefined && row[COL_TAGS]) {
        const tagsStr = row[COL_TAGS].trim();
        if (tagsStr && !tagsStr.match(/^[0-9-]+$/) && !tagsStr.startsWith('"')) {
          biberTags = tagsStr.split('|').filter(t => t && t.length > 0 && t !== 'False');
        }
      }
      
      // Dependency情報
      const dep = COL_DEP !== undefined ? (row[COL_DEP] || '') : '';
      const parsedTokenId = COL_TOKEN_ID !== undefined ? parseInt(row[COL_TOKEN_ID], 10) : NaN;
      const tokenId = !isNaN(parsedTokenId) ? parsedTokenId : tokenIdx;
      const headId = COL_HEAD_ID !== undefined ? parseInt(row[COL_HEAD_ID]) : -1;
      const headText = COL_HEAD_TEXT !== undefined ? (row[COL_HEAD_TEXT] || '') : '';
      const headLemma = COL_HEAD_LEMMA !== undefined ? (row[COL_HEAD_LEMMA] || '') : '';
      const headPos = COL_HEAD_POS !== undefined ? (row[COL_HEAD_POS] || '') : '';
      const isRoot = COL_IS_ROOT !== undefined ? (row[COL_IS_ROOT] === 'True' || row[COL_IS_ROOT] === 'true' || row[COL_IS_ROOT] === '1') : (headId === -1);
      
      // Sentence情報
      const sentText = COL_SENT_TEXT !== undefined ? (row[COL_SENT_TEXT] || '') : '';
      
      // Chunk情報
      const chunk = COL_CHUNK !== undefined ? (row[COL_CHUNK] || '') : '';
      const cpath = COL_CPATH !== undefined ? (row[COL_CPATH] || '') : '';
      const cpath_norm = COL_CPATH_NORM !== undefined ? (row[COL_CPATH_NORM] || '') : '';
      const is_chunk_head = COL_IS_CHUNK_HEAD !== undefined ? (row[COL_IS_CHUNK_HEAD] || '') : '';
      const cspan_start = COL_CSPAN_START !== undefined ? parseInt(row[COL_CSPAN_START]) : undefined;
      const cspan_end = COL_CSPAN_END !== undefined ? parseInt(row[COL_CSPAN_END]) : undefined;
      
      // Debug first few tokens
      if (tokenIdx < 3 && fi === 0) {
        console.log(`[CSV] Token ${tokenIdx}:`, {
          word: tokenText,
          chunk,
          cpath_norm,
          is_chunk_head,
          rowLength: row.length
        });
      }
      
      tokens[tokenIdx] = {
        word: tokenText,
        lemma: lemma,
        posd: xpos,
        poss: pos,
        searchWord: searchWord.toLowerCase(),
        searchLemma: searchLemma.toLowerCase(),
        isPunct,
        isSpace,
        biberTags,
        dep,
        deprel: dep, // Alias for dep
        token_id: tokenId,
        head_id: headId,
        head_text: headText,
        head_lemma: headLemma,
        head_pos: headPos,
        is_root: isRoot,
        sent_id: sentId,
        sent_text: sentText,
        chunk,
        cpath,
        cpath_norm,
        is_chunk_head,
        cspan_start,
        cspan_end
      };
      tokenIdx++;
    }
    
    // 配列をトリム
    tokens.length = tokenIdx;
    
    // 最後の文を追加
    if (tokenIdx > sentenceStartIdx) {
      sentences.push({ tokenStart: sentenceStartIdx, tokenEnd: tokenIdx });
    }
    
    if (tokenIdx === 0) continue;
    
    result.files[fileId] = {
      id: fileId,
      name: fileName,
      folder: folderName,
      text: '',  // 必要時に生成
      tokens,
      sentences
    };
    
    if (!result.folders[folderName]) {
      result.folders[folderName] = [];
    }
    result.folders[folderName].push(fileId);
    
    // 進捗更新
    if (fi % 50 === 0 || fi === totalFiles - 1) {
      const progress = 52 + Math.round((fi / totalFiles) * 45);
      updateCsvProgress(progress, `Building: ${fi + 1} / ${totalFiles} files`);
      await new Promise(r => setTimeout(r, 0));
    }
  }
  
  updateCsvProgress(98, 'Finalizing...');
  await new Promise(r => setTimeout(r, 0));
  
  return result;
}

// クォート内改行対応のCSV行分割（高速版）
function splitCSVLines(csvText) {
  const lines = [];
  let currentLine = '';
  let inQuotes = false;
  const len = csvText.length;
  
  for (let i = 0; i < len; i++) {
    const char = csvText[i];
    
    if (char === '"') {
      // ダブルクォートのエスケープ処理
      if (inQuotes && i + 1 < len && csvText[i + 1] === '"') {
        currentLine += '""';
        i++;
      } else {
        inQuotes = !inQuotes;
        currentLine += char;
      }
    } else if ((char === '\n' || char === '\r') && !inQuotes) {
      // クォート外の改行は行区切り
      if (currentLine.length > 0) {
        lines.push(currentLine);
      }
      currentLine = '';
      // \r\nの場合は\nをスキップ
      if (char === '\r' && i + 1 < len && csvText[i + 1] === '\n') {
        i++;
      }
    } else {
      currentLine += char;
    }
  }
  
  // 最後の行を追加
  if (currentLine.length > 0) {
    lines.push(currentLine);
  }
  
  return lines;
}

// 高速CSVラインパーサー
function parseCSVLineFast(line) {
  const result = [];
  let current = '';
  let inQuotes = false;
  const len = line.length;
  
  for (let i = 0; i < len; i++) {
    const char = line[i];
    
    if (inQuotes) {
      if (char === '"') {
        if (i + 1 < len && line[i + 1] === '"') {
          current += '"';
          i++;
        } else {
          inQuotes = false;
        }
      } else {
        current += char;
      }
    } else {
      if (char === '"') {
        inQuotes = true;
      } else if (char === ',') {
        result.push(current);
        current = '';
      } else {
        current += char;
      }
    }
  }
  result.push(current);
  return result;
}

// CSVモード用の拡張トークンフィルタリング（句読点・空白を除外）
function getValidTokensFromCSV(tokens) {
  return tokens.filter(t => !t.isPunct && !t.isSpace && t.word.trim());
}

function detectModeFromText(text) {
  const tokens = text.split(/\s+/).slice(0, 200);
  if (tokens.length === 0) return 'plain';
  let taggedLike = 0;
  for (const t of tokens) {
    const m = t.match(/_/g);
    const count = m ? m.length : 0;
    if (count >= 3) taggedLike++;
  }
  const ratio = taggedLike / tokens.length;
  return ratio >= 0.3 ? 'tagged' : 'plain';
}

function parseTaggedToken(tok) {
  const parts = tok.split('_');
  
  // Format 1: word_POSd_POSs_lemma (4+ parts)
  if (parts.length >= 4) {
    const lemma = parts.pop();
    const poss = parts.pop();
    const posd = parts.pop();
    const word = parts.join('_');
    return { word, lemma, posd, poss };
  }
  
  // Format 2: word_POS_lemma (3 parts)
  if (parts.length === 3) {
    const lemma = parts[2];
    const pos = parts[1];
    const word = parts[0];
    return { word, lemma, posd: pos, poss: pos };
  }
  
  // Format 3: word_POS (2 parts)
  if (parts.length === 2) {
    const pos = parts[1];
    const word = parts[0];
    return { word, lemma: word, posd: pos, poss: pos };
  }
  
  // Fallback: no underscore or single part
  return { word: tok, lemma: tok, posd: '', poss: '' };
}

function cleanPlainToken(tok) {
  const cleaned = tok.replace(/^[^A-Za-z0-9]+|[^A-Za-z0-9]+$/g, '');
  if (!cleaned) return '';
  return cleaned;
}

function tokenizePlainLine(line, tokenizeOptions) {
  const includeHyphen = tokenizeOptions && tokenizeOptions.includeHyphen !== undefined
    ? tokenizeOptions.includeHyphen
    : true;
  const includeAposS = tokenizeOptions && tokenizeOptions.includeAposS !== undefined
    ? tokenizeOptions.includeAposS
    : true;

  const result = [];
  const rawTokens = line.trim().split(/\s+/);
  for (let raw of rawTokens) {
    if (!raw) continue;
    let pieces = [raw];

    if (!includeHyphen) {
      const tmp = [];
      for (const p of pieces) {
        const split = p.split('-');
        for (const s of split) {
          if (s) tmp.push(s);
        }
      }
      pieces = tmp;
    }

    const pieces2 = [];
    for (const p of pieces) {
      if (!includeAposS && /('s|'s)$/i.test(p)) {
        const base = p.slice(0, -2);
        const suffix = p.slice(-2);
        if (base) pieces2.push(base);
        pieces2.push(suffix);
      } else {
        pieces2.push(p);
      }
    }
    pieces = pieces2;

    for (const p of pieces) {
      // Separate leading punctuation
      const leadingMatch = p.match(/^([^A-Za-z0-9]+)/);
      if (leadingMatch) {
        result.push({ word: leadingMatch[1], isPunct: true });
      }
      
      // Extract the word part
      const cleaned = p.replace(/^[^A-Za-z0-9]+|[^A-Za-z0-9]+$/g, '');
      if (cleaned) {
        result.push({ word: cleaned, isPunct: false });
      }
      
      // Separate trailing punctuation
      const trailingMatch = p.match(/([^A-Za-z0-9]+)$/);
      if (trailingMatch && cleaned) { // Only if there was a word before it
        result.push({ word: trailingMatch[1], isPunct: true });
      } else if (trailingMatch && !cleaned && !leadingMatch) {
        // Pure punctuation token
        result.push({ word: trailingMatch[1], isPunct: true });
      }
    }
  }
  return result;
}

function isPunctuationWord(word) {
  if (!word) return false;
  return PUNCT_RE.test(word);
}

function isPuncOrSpaceTag(tag) {
  if (!tag) return false;
  const t = String(tag).toUpperCase();
  if (t === 'PUNCT' || t === 'SYM' || t === 'SPACE') return true;
  const punctLike = ['.', ',', ':', ';', '!', '?', '``', "''", '-LRB-', '-RRB-', '-LSB-', '-RSB-', '-LCB-', '-RCB-', 'HYPH', 'NFP', 'SP'];
  return punctLike.includes(t);
}

// Check if a token is sentence-ending punctuation (., !, ?)
function isSentenceEndingToken(tok) {
  if (!tok) return false;
  const word = tok.word || '';
  // Check for sentence-ending punctuation
  if (/^[.!?]+$/.test(word)) return true;
  // Also check POS tags for sentence-ending punctuation
  const posd = (tok.posd || '').toUpperCase();
  const poss = (tok.poss || '').toUpperCase();
  if (posd === '.' || poss === '.') return true;
  return false;
}

// Split token indices array at sentence-ending punctuation
// Returns array of sub-sentence arrays, each containing { tokens: [...], indices: [...] }
function splitBySentenceEnd(tokens, startIdx, endIdx) {
  const subSentences = [];
  let currentTokens = [];
  let currentIndices = [];
  
  for (let i = startIdx; i < endIdx; i++) {
    const tok = tokens[i];
    if (isPunctuationOrSpaceToken(tok)) {
      // If it's sentence-ending punctuation, finalize current sub-sentence
      if (isSentenceEndingToken(tok) && currentTokens.length > 0) {
        subSentences.push({ tokens: currentTokens, indices: currentIndices });
        currentTokens = [];
        currentIndices = [];
      }
      continue;
    }
    currentTokens.push(tok);
    currentIndices.push(i);
  }
  
  // Add remaining tokens as final sub-sentence
  if (currentTokens.length > 0) {
    subSentences.push({ tokens: currentTokens, indices: currentIndices });
  }
  
  return subSentences;
}

// Get sentence segments based on user preference (respect sentence boundary or not)
// When respectBoundary is false, returns all non-punctuation tokens as a single segment
function getSentenceSegments(tokens, startIdx, endIdx) {
  const respectBoundary = document.getElementById('respectSentenceBoundary')?.checked ?? true;
  
  if (respectBoundary) {
    return splitBySentenceEnd(tokens, startIdx, endIdx);
  } else {
    // Ignore sentence boundaries - return all content tokens as one segment
    const allTokens = [];
    const allIndices = [];
    for (let i = startIdx; i < endIdx; i++) {
      const tok = tokens[i];
      if (isPunctuationOrSpaceToken(tok)) continue;
      allTokens.push(tok);
      allIndices.push(i);
    }
    if (allTokens.length > 0) {
      return [{ tokens: allTokens, indices: allIndices }];
    }
    return [];
  }
}

function isPunctuationOrSpaceToken(tok) {
  if (!tok) return false;
  
  // 1. CSVモードのフラグをチェック
  if (tok.isPunct === true || tok.isSpace === true) return true;
  
  // 2. POSタグで判定（全モード共通）
  //    これによりCSVでもSYM等が除外される
  if (isPuncOrSpaceTag(tok.poss) || isPuncOrSpaceTag(tok.posd)) return true;
  
  // 3. 単語の形で判定（フォールバック）
  if (isPunctuationWord(tok.word)) return true;
  
  return false;
}

function escapeHtml(str) {
  if (str == null) return '';
  return String(str)
    .replace(/&/g, '&amp;')
    .replace(/</g, '&lt;')
    .replace(/>/g, '&gt;')
    .replace(/"/g, '&quot;')
    .replace(/'/g, '&#039;');
}

// ===== Corpus Parsing =====
function parseCorpus(mode, fileContents, tokenizeOptions) {
  const result = {
    mode,
    files: {},
    folders: {}
  };
  fileIdCounter = 1;

  for (const { file, text } of fileContents) {
    const trimmed = text.replace(/\r\n/g, '\n');
    if (!trimmed.trim()) continue;

    const folderName = getFolderName(file);
    const fileId = String(fileIdCounter++);
    const tokens = [];
    const sentences = [];

    let lines = trimmed.split('\n');
    let displayText = trimmed; // Default: use original text
    
    // Merge short lines if option is enabled (useful for subtitles/transcripts)
    if (tokenizeOptions && tokenizeOptions.mergeShortLines) {
      // YouTube subtitles often have one short line per timestamp
      // Merge all non-empty lines into continuous text for better KWIC display
      const allText = lines
        .map(line => line.trim())
        .filter(line => line.length > 0)
        .join(' ');
      
      // Don't split into segments here - just use the whole text as one line
      // We'll handle sentence boundaries during tokenization
      lines = [allText];
      displayText = allText; // Use merged text for display
    }

    for (const line of lines) {
      const lineTrim = line.trim();
      if (!lineTrim) continue;

      const tokenStart = tokens.length;

      if (mode === 'tagged') {
        const rawTokens = lineTrim.split(/\s+/);
        for (const rawTok of rawTokens) {
          if (!rawTok) continue;
          const parsed = parseTaggedToken(rawTok);
          if (!parsed.word) continue;
          // Check if this token is punctuation based on POS tags
          const isPunctToken = isPuncOrSpaceTag(parsed.poss) || isPuncOrSpaceTag(parsed.posd);
          tokens.push({
            word: parsed.word,
            lemma: parsed.lemma || parsed.word,
            posd: parsed.posd,
            poss: parsed.poss,
            isPunct: isPunctToken
          });
        }
      } else {
        const plainTokens = tokenizePlainLine(lineTrim, tokenizeOptions || {});
        for (const tok of plainTokens) {
          // tokenizePlainLine now returns objects with {word, isPunct}
          if (typeof tok === 'object') {
            tokens.push({
              word: tok.word,
              lemma: tok.word,
              posd: '',
              poss: '',
              isPunct: tok.isPunct
            });
          } else {
            // Backward compatibility: string token
            tokens.push({
              word: tok,
              lemma: tok,
              posd: '',
              poss: ''
            });
          }
        }
      }

      // For merged lines, we need to create sentence boundaries within the line
      // based on sentence-ending punctuation (. ! ?)
      if (tokenizeOptions && tokenizeOptions.mergeShortLines && tokens.length > tokenStart) {
        let sentStart = tokenStart;
        for (let i = tokenStart; i < tokens.length; i++) {
          const tok = tokens[i];
          // Check if this token is sentence-ending punctuation
          if (tok.word === '.' || tok.word === '!' || tok.word === '?') {
            // Create sentence from sentStart to current position (inclusive)
            sentences.push({ tokenStart: sentStart, tokenEnd: i + 1 });
            sentStart = i + 1;
          }
        }
        // Add remaining tokens as final sentence
        if (sentStart < tokens.length) {
          sentences.push({ tokenStart: sentStart, tokenEnd: tokens.length });
        }
      } else {
        // Normal behavior: one sentence per line
        const tokenEnd = tokens.length;
        if (tokenEnd > tokenStart) {
          sentences.push({ tokenStart, tokenEnd });
        }
      }
    }

    if (tokens.length === 0) continue;

    result.files[fileId] = {
      id: fileId,
      name: file.name,
      folder: folderName,
      text: displayText,
      tokens,
      sentences
    };

    if (!result.folders[folderName]) {
      result.folders[folderName] = [];
    }
    result.folders[folderName].push(fileId);
  }

  return result;
}

// ===== Corpus Summary Sorting =====
let corpusSummaryData = [];
let corpusSummarySortKey = null;
let corpusSummarySortAsc = true;

function sortCorpusSummary(key) {
  if (corpusSummarySortKey === key) {
    corpusSummarySortAsc = !corpusSummarySortAsc;
  } else {
    corpusSummarySortKey = key;
    corpusSummarySortAsc = true;
  }
  
  // Update sort indicators
  document.getElementById('corpusSortFolder').textContent = '⇅';
  document.getElementById('corpusSortFile').textContent = '⇅';
  document.getElementById('corpusSortTokens').textContent = '⇅';
  
  const arrow = corpusSummarySortAsc ? '▲' : '▼';
  if (key === 'folder') document.getElementById('corpusSortFolder').textContent = arrow;
  else if (key === 'file') document.getElementById('corpusSortFile').textContent = arrow;
  else if (key === 'tokens') document.getElementById('corpusSortTokens').textContent = arrow;
  
  // Sort data
  const sorted = [...corpusSummaryData];
  sorted.sort((a, b) => {
    let cmp = 0;
    if (key === 'folder') {
      cmp = a.folder.localeCompare(b.folder);
    } else if (key === 'file') {
      cmp = a.name.localeCompare(b.name);
    } else if (key === 'tokens') {
      cmp = a.tokenCount - b.tokenCount;
    }
    return corpusSummarySortAsc ? cmp : -cmp;
  });
  
  // Render sorted table
  const fileBody = document.getElementById('fileSummaryBody');
  let rows = '';
  sorted.forEach((f, idx) => {
    rows += `<tr>
      <td>${idx + 1}</td>
      <td>${escapeHtml(f.folder)}</td>
      <td>${escapeHtml(f.name)}</td>
      <td class="text-right">${f.tokenCount}</td>
    </tr>`;
  });
  fileBody.innerHTML = rows;
}

// ===== Summary Rendering =====
function renderSummary() {
  const fileBody = document.getElementById('fileSummaryBody');
  const fileCountSpan = document.getElementById('summaryFileCount');
  const tokenCountSpan = document.getElementById('summaryTokenCount');
  const modeBadge = document.getElementById('modeBadge');

  // Reset sort state
  corpusSummarySortKey = null;
  corpusSummarySortAsc = true;
  if (document.getElementById('corpusSortFolder')) document.getElementById('corpusSortFolder').textContent = '⇅';
  if (document.getElementById('corpusSortFile')) document.getElementById('corpusSortFile').textContent = '⇅';
  if (document.getElementById('corpusSortTokens')) document.getElementById('corpusSortTokens').textContent = '⇅';

  if (!corpus || Object.keys(corpus.files).length === 0) {
    fileBody.innerHTML = '<tr><td colspan="4" class="text-xs">No corpus loaded.</td></tr>';
    fileCountSpan.textContent = '0';
    tokenCountSpan.textContent = '0';
    modeBadge.textContent = '-';
    modeBadge.className = 'badge';
    document.getElementById('folderSelectionArea').innerHTML =
      'Folder list will appear here after loading a corpus.';
    corpusSummaryData = [];
    return;
  }

  const files = Object.values(corpus.files);
  let totalTokens = 0;
  let rows = '';
  corpusSummaryData = [];
  
  for (const f of files) {
    // CSVモードの場合はisPunctフラグを使用
    let tokenCount;
    if (corpus.mode === 'csv') {
      tokenCount = f.tokens.filter(t => !t.isPunct && !t.isSpace && t.word.trim()).length;
    } else {
      tokenCount = f.tokens.filter(t => !isPunctuationOrSpaceToken(t)).length;
    }
    totalTokens += tokenCount;
    corpusSummaryData.push({ folder: f.folder, name: f.name, tokenCount });
  }
  
  corpusSummaryData.forEach((f, idx) => {
    rows += `<tr>
      <td>${idx + 1}</td>
      <td>${escapeHtml(f.folder)}</td>
      <td>${escapeHtml(f.name)}</td>
      <td class="text-right">${f.tokenCount}</td>
    </tr>`;
  });

  fileBody.innerHTML = rows;
  fileCountSpan.textContent = String(files.length);
  tokenCountSpan.textContent = String(totalTokens);

  if (corpus.mode === 'csv') {
    modeBadge.textContent = 'CSV (Stanza/Biber)';
    modeBadge.className = 'badge tagged';
    modeBadge.style.background = '#0ea5e9';
  } else if (corpus.mode === 'tagged') {
    modeBadge.textContent = 'Tagged';
    modeBadge.className = 'badge tagged';
    modeBadge.style.background = '';
  } else {
    modeBadge.textContent = 'Plain';
    modeBadge.className = 'badge plain';
    modeBadge.style.background = '';
  }

  renderFolderSelection();
  
  // Initialize 11) Dependency Grammar UI
  try { initDepGrammarUI(); } catch(e) {}
  
  // Initialize 12) Constituent UI
  try { initConstituentUI(); } catch(e) {}
}

function renderFolderSelection() {
  const area = document.getElementById('folderSelectionArea');
  if (!corpus || !corpus.folders) {
    area.innerHTML = 'Folder list will appear here after loading a corpus.';
    return;
  }

  const folderNames = Object.keys(corpus.folders).sort();
  if (folderNames.length === 0) {
    area.innerHTML = 'No folders found.';
    return;
  }

  const isTagged = corpus.mode === 'tagged' || corpus.mode === 'csv';

  let html = `<table style="width:100%; border-collapse:collapse;">
    <thead>
      <tr>
        <th>Folder</th>
        <th class="text-center">
          Target<br>
          <button class="small" id="toggleAllTarget">All</button>
        </th>
        <th class="text-center">
          Reference<br>
          <button class="small" id="toggleAllRef">All</button>
        </th>
        <th class="text-right">Files</th>
        <th class="text-right">Sentences</th>
        <th class="text-right">Min tokens</th>
        <th class="text-right">Max tokens</th>
        <th class="text-right">Median tokens</th>
        <th class="text-right">Mean tokens</th>
        <th class="text-right">Tokens</th>
        <th class="text-right">Types</th>
        <th class="text-right">TTR</th>`;

  if (isTagged) {
    html += `
        <th class="text-right">Lemma tokens</th>
        <th class="text-right">Lemma types</th>
        <th class="text-right">Lemma TTR</th>`;
  }

  html += `
      </tr>
    </thead>
    <tbody>`;

  for (const folder of folderNames) {
    const fileIds = corpus.folders[folder];

    let sentenceCount = 0;
    const fileTokenCounts = []; // tokens per file for min/max/median

    let tokenCount = 0;
    const typeSet = new Set();

    let lemmaTokenCount = 0;
    const lemmaTypeSet = new Set();

    for (const fid of fileIds) {
      const file = corpus.files[fid];
      let fileTokens = 0; // count tokens in this file

      // Sentence-level statistics
      if (file.sentences && file.sentences.length) {
        sentenceCount += file.sentences.length;
      }

      // Token / type (surface) and lemma stats
      for (const tok of file.tokens) {
        if (isPunctuationOrSpaceToken(tok)) continue;

        // Surface tokens
        tokenCount++;
        fileTokens++;
        if (tok.word) {
          typeSet.add(tok.word.toLowerCase());
        }

        // Lemma-based stats (tagged mode only)
        if (isTagged && tok.lemma) {
          lemmaTokenCount++;
          lemmaTypeSet.add(tok.lemma.toLowerCase());
        }
      }
      
      fileTokenCounts.push(fileTokens);
    }

    // Token stats per file (min/max/median/mean)
    let minTokens = '-';
    let maxTokens = '-';
    let medianTokens = '-';
    let meanTokens = '-';

    if (fileTokenCounts.length > 0) {
      let minVal = fileTokenCounts[0];
      let maxVal = fileTokenCounts[0];
      let sumTokens = 0;
      for (const v of fileTokenCounts) {
        if (v < minVal) minVal = v;
        if (v > maxVal) maxVal = v;
        sumTokens += v;
      }
      minTokens = String(minVal);
      maxTokens = String(maxVal);
      meanTokens = (sumTokens / fileTokenCounts.length).toFixed(2);

      const sorted = [...fileTokenCounts].sort((a, b) => a - b);
      const mid = Math.floor(sorted.length / 2);
      if (sorted.length % 2 === 1) {
        medianTokens = String(sorted[mid]);
      } else {
        medianTokens = ((sorted[mid - 1] + sorted[mid]) / 2).toFixed(2);
      }
    }

    // Token / type / TTR
    const typeCount = typeSet.size;
    const ttr = tokenCount > 0 ? (typeCount / tokenCount).toFixed(4) : '-';

    // Lemma stats
    let lemmaTypeCount = lemmaTypeSet.size;
    let lemmaTtr = lemmaTokenCount > 0 ? (lemmaTypeCount / lemmaTokenCount).toFixed(4) : '-';
    if (!isTagged) {
      lemmaTokenCount = 0;
      lemmaTypeCount = 0;
      lemmaTtr = '-';
    }

    const checkedT = targetFolders.has(folder) ? 'checked' : '';
    const checkedR = referenceFolders.has(folder) ? 'checked' : '';

    html += `
      <tr>
        <td>${escapeHtml(folder)}</td>
        <td class="text-center">
          <input type="checkbox" class="targetCheck" data-folder="${escapeHtml(folder)}" ${checkedT}>
        </td>
        <td class="text-center">
          <input type="checkbox" class="refCheck" data-folder="${escapeHtml(folder)}" ${checkedR}>
        </td>
        <td class="text-right">${fileIds.length}</td>
        <td class="text-right">${sentenceCount}</td>
        <td class="text-right">${minTokens}</td>
        <td class="text-right">${maxTokens}</td>
        <td class="text-right">${medianTokens}</td>
        <td class="text-right">${meanTokens}</td>
        <td class="text-right">${tokenCount}</td>
        <td class="text-right">${typeCount}</td>
        <td class="text-right">${ttr}</td>`;

    if (isTagged) {
      html += `
        <td class="text-right">${lemmaTokenCount}</td>
        <td class="text-right">${lemmaTypeCount}</td>
        <td class="text-right">${lemmaTtr}</td>`;
    }

    html += `
      </tr>`;
  }

  html += `
    </tbody>
  </table>
  <div class="mt-1 flex">
    <button id="exportFolderSummary" class="small export">Export Folder Summary</button>
  </div>`;

  area.innerHTML = html;

  // Checkbox listeners
  area.querySelectorAll('.targetCheck').forEach(cb => {
    cb.addEventListener('change', () => {
      const folder = cb.getAttribute('data-folder');
      if (cb.checked) {
        targetFolders.add(folder);
      } else {
        targetFolders.delete(folder);
      }
    });
  });

  area.querySelectorAll('.refCheck').forEach(cb => {
    cb.addEventListener('change', () => {
      const folder = cb.getAttribute('data-folder');
      if (cb.checked) {
        referenceFolders.add(folder);
      } else {
        referenceFolders.delete(folder);
      }
    });
  });

  // Toggle all Target / Reference
  const toggleAllTargetBtn = document.getElementById('toggleAllTarget');
  if (toggleAllTargetBtn) {
    toggleAllTargetBtn.addEventListener('click', () => {
      const checks = area.querySelectorAll('.targetCheck');
      const allChecked = [...checks].every(c => c.checked);
      checks.forEach(cb => {
        cb.checked = !allChecked;
        const folder = cb.getAttribute('data-folder');
        if (cb.checked) {
          targetFolders.add(folder);
        } else {
          targetFolders.delete(folder);
        }
      });
    });
  }

  const toggleAllRefBtn = document.getElementById('toggleAllRef');
  if (toggleAllRefBtn) {
    toggleAllRefBtn.addEventListener('click', () => {
      const checks = area.querySelectorAll('.refCheck');
      const allChecked = [...checks].every(c => c.checked);
      checks.forEach(cb => {
        cb.checked = !allChecked;
        const folder = cb.getAttribute('data-folder');
        if (cb.checked) {
          referenceFolders.add(folder);
        } else {
          referenceFolders.delete(folder);
        }
      });
    });
  }

  const exportBtn = document.getElementById('exportFolderSummary');
  if (exportBtn) {
    exportBtn.addEventListener('click', exportFolderSummary);
  }
}

// ===== Feature Counting =====
function collectFeatureCounts(featureType, n, targetFolders, referenceFolders, caseInsensitive, collectFileDetails = false, clusterOptions = null) {
  const result = {
    targetCounts: {},
    referenceCounts: {},
    totalTargetUnits: 0,
    totalReferenceUnits: 0,
    targetFileFreqs: {},
    referenceFileFreqs: {},
    numTargetFiles: 0,
    numReferenceFiles: 0,
    targetFillers: {},
    referenceFillers: {},
    // Per-file detailed frequencies for dispersion calculation (only when collectFileDetails is true)
    targetFileDetails: collectFileDetails ? {} : null,
    referenceFileDetails: collectFileDetails ? {} : null,
    targetFileSizes: collectFileDetails ? {} : null,
    referenceFileSizes: collectFileDetails ? {} : null
  };

  const files = Object.values(corpus.files);

  for (const file of files) {
    const inT = targetFolders.has(file.folder);
    const inR = referenceFolders.has(file.folder);
    if (!inT && !inR) continue;

    if (inT) result.numTargetFiles++;
    if (inR) result.numReferenceFiles++;

    const dest = {
      T: inT ? { 
        counts: result.targetCounts, 
        totalUnits: 0, 
        fileFreqs: result.targetFileFreqs, 
        fillers: result.targetFillers,
        fileDetails: collectFileDetails ? result.targetFileDetails : null,
        fileName: file.name
      } : null,
      R: inR ? { 
        counts: result.referenceCounts, 
        totalUnits: 0, 
        fileFreqs: result.referenceFileFreqs, 
        fillers: result.referenceFillers,
        fileDetails: collectFileDetails ? result.referenceFileDetails : null,
        fileName: file.name
      } : null
    };

    if (featureType === 'word') {
      processWordForFile(file, 'word', inT ? dest.T : null, inR ? dest.R : null, caseInsensitive);
    } else if (featureType === 'word_lemma') {
      processWordForFile(file, 'lemma', inT ? dest.T : null, inR ? dest.R : null, caseInsensitive);
    } else if (featureType === 'ngram_word') {
      processNgramsForFile(file, 'word', n, inT ? dest.T : null, inR ? dest.R : null, caseInsensitive);
    } else if (featureType === 'ngram_lemma') {
      processNgramsForFile(file, 'lemma', n, inT ? dest.T : null, inR ? dest.R : null, caseInsensitive);
    } else if (featureType === 'pframe_word') {
      processPframesForFile(file, 'word', n, inT ? dest.T : null, inR ? dest.R : null, caseInsensitive);
    } else if (featureType === 'pframe_lemma') {
      processPframesForFile(file, 'lemma', n, inT ? dest.T : null, inR ? dest.R : null, caseInsensitive);
    } else if (featureType === 'cluster_word') {
      processClustersForFile(file, 'word', n, inT ? dest.T : null, inR ? dest.R : null, caseInsensitive, clusterOptions);
    } else if (featureType === 'cluster_lemma') {
      processClustersForFile(file, 'lemma', n, inT ? dest.T : null, inR ? dest.R : null, caseInsensitive, clusterOptions);
    } else if (featureType === 'pos_simple') {
      processPosForFile(file, 'poss', inT ? dest.T : null, inR ? dest.R : null);
    } else if (featureType === 'pos_detailed') {
      processPosForFile(file, 'posd', inT ? dest.T : null, inR ? dest.R : null);
    } else if (featureType === 'posgram_simple') {
      processPosgramsForFile(file, 'poss', n, inT ? dest.T : null, inR ? dest.R : null);
    } else if (featureType === 'posgram_detailed') {
      processPosgramsForFile(file, 'posd', n, inT ? dest.T : null, inR ? dest.R : null);
    } else if (featureType === 'wordpos_surface_simple') {
      processWordPosForFile(file, 'word', 'poss', inT ? dest.T : null, inR ? dest.R : null, caseInsensitive);
    } else if (featureType === 'wordpos_lemma_simple') {
      processWordPosForFile(file, 'lemma', 'poss', inT ? dest.T : null, inR ? dest.R : null, caseInsensitive);
    } else if (featureType === 'wordpos_surface_detailed') {
      processWordPosForFile(file, 'word', 'posd', inT ? dest.T : null, inR ? dest.R : null, caseInsensitive);
    } else if (featureType === 'wordpos_lemma_detailed') {
      processWordPosForFile(file, 'lemma', 'posd', inT ? dest.T : null, inR ? dest.R : null, caseInsensitive);
    } else if (featureType === 'ngrampos_surface_simple') {
      processNgramPosForFile(file, 'word', 'poss', n, inT ? dest.T : null, inR ? dest.R : null, caseInsensitive);
    } else if (featureType === 'ngrampos_lemma_simple') {
      processNgramPosForFile(file, 'lemma', 'poss', n, inT ? dest.T : null, inR ? dest.R : null, caseInsensitive);
    } else if (featureType === 'ngrampos_surface_detailed') {
      processNgramPosForFile(file, 'word', 'posd', n, inT ? dest.T : null, inR ? dest.R : null, caseInsensitive);
    } else if (featureType === 'ngrampos_lemma_detailed') {
      processNgramPosForFile(file, 'lemma', 'posd', n, inT ? dest.T : null, inR ? dest.R : null, caseInsensitive);
    } else if (featureType === 'biber_tag') {
      processBiberTagForFile(file, inT ? dest.T : null, inR ? dest.R : null);
    }

    if (dest.T) {
      result.totalTargetUnits += dest.T.totalUnits;
      if (collectFileDetails) result.targetFileSizes[file.name] = dest.T.totalUnits;
    }
    if (dest.R) {
      result.totalReferenceUnits += dest.R.totalUnits;
      if (collectFileDetails) result.referenceFileSizes[file.name] = dest.R.totalUnits;
    }
  }

  return result;
}

// Process clusters (n-grams containing a specific search word)
function processClustersForFile(file, field, n, destT, destR, caseInsensitive, clusterOptions) {
  if (n <= 1) return;
  if (!clusterOptions || !clusterOptions.searchWord) return;
  
  const searchWord = clusterOptions.searchWord;
  const position = clusterOptions.position || 'both';
  
  // Create matcher for search word
  let matcher;
  try {
    matcher = buildMatcherCreator(searchWord, 'wildcard', caseInsensitive);
  } catch (e) {
    return;
  }
  
  const seenThisFileT = new Set();
  const seenThisFileR = new Set();
  const thisFileCountsT = {};
  const thisFileCountsR = {};
  
  for (const sent of file.sentences) {
    const subSentences = getSentenceSegments(file.tokens, sent.tokenStart, sent.tokenEnd);
    
    for (const subSent of subSentences) {
      const arr = [];
      for (const tok of subSent.tokens) {
        let val = tok[field];
        if (!val) continue;
        arr.push(val);
      }
      if (arr.length < n) continue;
      
      for (let i = 0; i <= arr.length - n; i++) {
        const gram = arr.slice(i, i + n);
        
        // Check if search word is in the gram at allowed position
        let matchPos = -1;
        for (let j = 0; j < n; j++) {
          if (matcher(gram[j])) {
            matchPos = j;
            break;
          }
        }
        
        if (matchPos === -1) continue;
        
        // Check position constraint
        if (position === 'left' && matchPos !== 0) continue;
        if (position === 'right' && matchPos !== n - 1) continue;
        
        const key = caseInsensitive ? gram.map(w => w.toLowerCase()).join(' ') : gram.join(' ');
        
        if (destT) {
          destT.counts[key] = (destT.counts[key] || 0) + 1;
          destT.totalUnits++;
          seenThisFileT.add(key);
          if (destT.fileDetails) thisFileCountsT[key] = (thisFileCountsT[key] || 0) + 1;
        }
        if (destR) {
          destR.counts[key] = (destR.counts[key] || 0) + 1;
          destR.totalUnits++;
          seenThisFileR.add(key);
          if (destR.fileDetails) thisFileCountsR[key] = (thisFileCountsR[key] || 0) + 1;
        }
      }
    }
  }
  
  seenThisFileT.forEach(key => {
    if (destT) {
      destT.fileFreqs[key] = (destT.fileFreqs[key] || 0) + 1;
      if (destT.fileDetails) {
        if (!destT.fileDetails[key]) destT.fileDetails[key] = {};
        destT.fileDetails[key][destT.fileName] = thisFileCountsT[key];
      }
    }
  });
  seenThisFileR.forEach(key => {
    if (destR) {
      destR.fileFreqs[key] = (destR.fileFreqs[key] || 0) + 1;
      if (destR.fileDetails) {
        if (!destR.fileDetails[key]) destR.fileDetails[key] = {};
        destR.fileDetails[key][destR.fileName] = thisFileCountsR[key];
      }
    }
  });
}

function processWordForFile(file, field, destT, destR, caseInsensitive) {
  const seenThisFileT = new Set();
  const seenThisFileR = new Set();
  const thisFileCountsT = {};  // Track per-file frequency for each feature
  const thisFileCountsR = {};
  
  for (const tok of file.tokens) {
    if (isPunctuationOrSpaceToken(tok)) continue;
    let val = tok[field];
    if (!val) continue;
    if (caseInsensitive) val = val.toLowerCase();
    if (destT) {
      destT.counts[val] = (destT.counts[val] || 0) + 1;
      destT.totalUnits++;
      seenThisFileT.add(val);
      if (destT.fileDetails) thisFileCountsT[val] = (thisFileCountsT[val] || 0) + 1;
    }
    if (destR) {
      destR.counts[val] = (destR.counts[val] || 0) + 1;
      destR.totalUnits++;
      seenThisFileR.add(val);
      if (destR.fileDetails) thisFileCountsR[val] = (thisFileCountsR[val] || 0) + 1;
    }
  }
  seenThisFileT.forEach(key => {
    if (destT) {
      destT.fileFreqs[key] = (destT.fileFreqs[key] || 0) + 1;
      if (destT.fileDetails) {
        if (!destT.fileDetails[key]) destT.fileDetails[key] = {};
        destT.fileDetails[key][destT.fileName] = thisFileCountsT[key];
      }
    }
  });
  seenThisFileR.forEach(key => {
    if (destR) {
      destR.fileFreqs[key] = (destR.fileFreqs[key] || 0) + 1;
      if (destR.fileDetails) {
        if (!destR.fileDetails[key]) destR.fileDetails[key] = {};
        destR.fileDetails[key][destR.fileName] = thisFileCountsR[key];
      }
    }
  });
}

function processNgramsForFile(file, field, n, destT, destR, caseInsensitive) {
  if (n <= 1) return;
  const seenThisFileT = new Set();
  const seenThisFileR = new Set();
  const thisFileCountsT = {};
  const thisFileCountsR = {};
  
  for (const sent of file.sentences) {
    // Split by sentence-ending punctuation within the sentence
    const subSentences = getSentenceSegments(file.tokens, sent.tokenStart, sent.tokenEnd);
    
    for (const subSent of subSentences) {
      const arr = [];
      for (const tok of subSent.tokens) {
        // Double-check: skip punctuation tokens (should already be filtered by getSentenceSegments)
        if (isPunctuationOrSpaceToken(tok)) continue;
        let val = tok[field];
        if (!val) continue;
        if (caseInsensitive) val = val.toLowerCase();
        arr.push(val);
      }
      if (arr.length < n) continue;
      for (let i = 0; i <= arr.length - n; i++) {
        const gram = arr.slice(i, i + n);
        const key = gram.join(' ');
        if (destT) {
          destT.counts[key] = (destT.counts[key] || 0) + 1;
          destT.totalUnits++;
          seenThisFileT.add(key);
          if (destT.fileDetails) thisFileCountsT[key] = (thisFileCountsT[key] || 0) + 1;
        }
        if (destR) {
          destR.counts[key] = (destR.counts[key] || 0) + 1;
          destR.totalUnits++;
          seenThisFileR.add(key);
          if (destR.fileDetails) thisFileCountsR[key] = (thisFileCountsR[key] || 0) + 1;
        }
      }
    }
  }
  seenThisFileT.forEach(key => {
    if (destT) {
      destT.fileFreqs[key] = (destT.fileFreqs[key] || 0) + 1;
      if (destT.fileDetails) {
        if (!destT.fileDetails[key]) destT.fileDetails[key] = {};
        destT.fileDetails[key][destT.fileName] = thisFileCountsT[key];
      }
    }
  });
  seenThisFileR.forEach(key => {
    if (destR) {
      destR.fileFreqs[key] = (destR.fileFreqs[key] || 0) + 1;
      if (destR.fileDetails) {
        if (!destR.fileDetails[key]) destR.fileDetails[key] = {};
        destR.fileDetails[key][destR.fileName] = thisFileCountsR[key];
      }
    }
  });
}

function processPframesForFile(file, field, n, destT, destR, caseInsensitive) {
  if (n <= 1) return;
  const seenThisFileT = new Set();
  const seenThisFileR = new Set();
  const thisFileCountsT = {};
  const thisFileCountsR = {};
  
  for (const sent of file.sentences) {
    // Split by sentence-ending punctuation within the sentence
    const subSentences = getSentenceSegments(file.tokens, sent.tokenStart, sent.tokenEnd);
    
    for (const subSent of subSentences) {
      const arr = [];
      for (const tok of subSent.tokens) {
        // Double-check: skip punctuation tokens
        if (isPunctuationOrSpaceToken(tok)) continue;
        let val = tok[field];
        if (!val) continue;
        if (caseInsensitive) val = val.toLowerCase();
        arr.push(val);
      }
      if (arr.length < n) continue;
      for (let i = 0; i <= arr.length - n; i++) {
        const gram = arr.slice(i, i + n);
        for (let starPos = 1; starPos < n; starPos++) {
          const frame = gram.map((w, idx) => idx === starPos ? '*' : w);
          const key = frame.join(' ');
          const filler = gram[starPos];
          if (destT) {
            destT.counts[key] = (destT.counts[key] || 0) + 1;
            destT.totalUnits++;
            seenThisFileT.add(key);
            if (destT.fileDetails) thisFileCountsT[key] = (thisFileCountsT[key] || 0) + 1;
            if (!destT.fillers[key]) destT.fillers[key] = {};
            destT.fillers[key][filler] = (destT.fillers[key][filler] || 0) + 1;
          }
          if (destR) {
            destR.counts[key] = (destR.counts[key] || 0) + 1;
            destR.totalUnits++;
            seenThisFileR.add(key);
            if (destR.fileDetails) thisFileCountsR[key] = (thisFileCountsR[key] || 0) + 1;
            if (!destR.fillers[key]) destR.fillers[key] = {};
            destR.fillers[key][filler] = (destR.fillers[key][filler] || 0) + 1;
          }
        }
      }
    }
  }
  seenThisFileT.forEach(key => {
    if (destT) {
      destT.fileFreqs[key] = (destT.fileFreqs[key] || 0) + 1;
      if (destT.fileDetails) {
        if (!destT.fileDetails[key]) destT.fileDetails[key] = {};
        destT.fileDetails[key][destT.fileName] = thisFileCountsT[key];
      }
    }
  });
  seenThisFileR.forEach(key => {
    if (destR) {
      destR.fileFreqs[key] = (destR.fileFreqs[key] || 0) + 1;
      if (destR.fileDetails) {
        if (!destR.fileDetails[key]) destR.fileDetails[key] = {};
        destR.fileDetails[key][destR.fileName] = thisFileCountsR[key];
      }
    }
  });
}

function processPosForFile(file, field, destT, destR) {
  if (corpus.mode !== 'tagged' && corpus.mode !== 'csv') return;
  const seenThisFileT = new Set();
  const seenThisFileR = new Set();
  const thisFileCountsT = {};
  const thisFileCountsR = {};
  
  for (const tok of file.tokens) {
    if (isPunctuationOrSpaceToken(tok)) continue;
    const tag = tok[field];
    if (!tag) continue;
    if (destT) {
      destT.counts[tag] = (destT.counts[tag] || 0) + 1;
      destT.totalUnits++;
      seenThisFileT.add(tag);
      if (destT.fileDetails) thisFileCountsT[tag] = (thisFileCountsT[tag] || 0) + 1;
    }
    if (destR) {
      destR.counts[tag] = (destR.counts[tag] || 0) + 1;
      destR.totalUnits++;
      seenThisFileR.add(tag);
      if (destR.fileDetails) thisFileCountsR[tag] = (thisFileCountsR[tag] || 0) + 1;
    }
  }
  seenThisFileT.forEach(key => {
    if (destT) {
      destT.fileFreqs[key] = (destT.fileFreqs[key] || 0) + 1;
      if (destT.fileDetails) {
        if (!destT.fileDetails[key]) destT.fileDetails[key] = {};
        destT.fileDetails[key][destT.fileName] = thisFileCountsT[key];
      }
    }
  });
  seenThisFileR.forEach(key => {
    if (destR) {
      destR.fileFreqs[key] = (destR.fileFreqs[key] || 0) + 1;
      if (destR.fileDetails) {
        if (!destR.fileDetails[key]) destR.fileDetails[key] = {};
        destR.fileDetails[key][destR.fileName] = thisFileCountsR[key];
      }
    }
  });
}

function processPosgramsForFile(file, field, n, destT, destR) {
  if (corpus.mode !== 'tagged' && corpus.mode !== 'csv') return;
  if (n <= 1) return;
  const seenThisFileT = new Set();
  const seenThisFileR = new Set();
  const thisFileCountsT = {};
  const thisFileCountsR = {};
  
  for (const sent of file.sentences) {
    // Split by sentence-ending punctuation within the sentence
    const subSentences = getSentenceSegments(file.tokens, sent.tokenStart, sent.tokenEnd);
    
    for (const subSent of subSentences) {
      const arr = [];
      for (const tok of subSent.tokens) {
        // Double-check: skip punctuation tokens
        if (isPunctuationOrSpaceToken(tok)) continue;
        const tag = tok[field];
        if (!tag) continue;
        arr.push(tag);
      }
      if (arr.length < n) continue;
      for (let i = 0; i <= arr.length - n; i++) {
        const gramTags = arr.slice(i, i + n);
        const key = gramTags.join('+');
        if (destT) {
          destT.counts[key] = (destT.counts[key] || 0) + 1;
          destT.totalUnits++;
          seenThisFileT.add(key);
          if (destT.fileDetails) thisFileCountsT[key] = (thisFileCountsT[key] || 0) + 1;
        }
        if (destR) {
          destR.counts[key] = (destR.counts[key] || 0) + 1;
          destR.totalUnits++;
          seenThisFileR.add(key);
          if (destR.fileDetails) thisFileCountsR[key] = (thisFileCountsR[key] || 0) + 1;
        }
      }
    }
  }
  seenThisFileT.forEach(key => {
    if (destT) {
      destT.fileFreqs[key] = (destT.fileFreqs[key] || 0) + 1;
      if (destT.fileDetails) {
        if (!destT.fileDetails[key]) destT.fileDetails[key] = {};
        destT.fileDetails[key][destT.fileName] = thisFileCountsT[key];
      }
    }
  });
  seenThisFileR.forEach(key => {
    if (destR) {
      destR.fileFreqs[key] = (destR.fileFreqs[key] || 0) + 1;
      if (destR.fileDetails) {
        if (!destR.fileDetails[key]) destR.fileDetails[key] = {};
        destR.fileDetails[key][destR.fileName] = thisFileCountsR[key];
      }
    }
  });
}

// Process Biber tags for a file
function processBiberTagForFile(file, destT, destR) {
  if (corpus.mode !== 'csv') return;
  const seenThisFileT = new Set();
  const seenThisFileR = new Set();
  const thisFileCountsT = {};
  const thisFileCountsR = {};
  
  for (const tok of file.tokens) {
    if (isPunctuationOrSpaceToken(tok)) continue;
    if (!tok.biberTags || tok.biberTags.length === 0) continue;
    
    for (const tag of tok.biberTags) {
      if (destT) {
        destT.counts[tag] = (destT.counts[tag] || 0) + 1;
        destT.totalUnits++;
        seenThisFileT.add(tag);
        if (destT.fileDetails) thisFileCountsT[tag] = (thisFileCountsT[tag] || 0) + 1;
      }
      if (destR) {
        destR.counts[tag] = (destR.counts[tag] || 0) + 1;
        destR.totalUnits++;
        seenThisFileR.add(tag);
        if (destR.fileDetails) thisFileCountsR[tag] = (thisFileCountsR[tag] || 0) + 1;
      }
    }
  }
  seenThisFileT.forEach(key => {
    if (destT) {
      destT.fileFreqs[key] = (destT.fileFreqs[key] || 0) + 1;
      if (destT.fileDetails) {
        if (!destT.fileDetails[key]) destT.fileDetails[key] = {};
        destT.fileDetails[key][destT.fileName] = thisFileCountsT[key];
      }
    }
  });
  seenThisFileR.forEach(key => {
    if (destR) {
      destR.fileFreqs[key] = (destR.fileFreqs[key] || 0) + 1;
      if (destR.fileDetails) {
        if (!destR.fileDetails[key]) destR.fileDetails[key] = {};
        destR.fileDetails[key][destR.fileName] = thisFileCountsR[key];
      }
    }
  });
}

// Process word+POS combinations (e.g., "run_VB", "study_NN")
function processWordPosForFile(file, wordField, posField, destT, destR, caseInsensitive) {
  if (corpus.mode !== 'tagged' && corpus.mode !== 'csv') return;
  const seenThisFileT = new Set();
  const seenThisFileR = new Set();
  const thisFileCountsT = {};
  const thisFileCountsR = {};
  
  for (const tok of file.tokens) {
    if (isPunctuationOrSpaceToken(tok)) continue;
    let word = tok[wordField];
    const pos = tok[posField];
    if (!word || !pos) continue;
    if (caseInsensitive) word = word.toLowerCase();
    const key = `${word}_${pos}`;
    if (destT) {
      destT.counts[key] = (destT.counts[key] || 0) + 1;
      destT.totalUnits++;
      seenThisFileT.add(key);
      if (destT.fileDetails) thisFileCountsT[key] = (thisFileCountsT[key] || 0) + 1;
    }
    if (destR) {
      destR.counts[key] = (destR.counts[key] || 0) + 1;
      destR.totalUnits++;
      seenThisFileR.add(key);
      if (destR.fileDetails) thisFileCountsR[key] = (thisFileCountsR[key] || 0) + 1;
    }
  }
  seenThisFileT.forEach(key => {
    if (destT) {
      destT.fileFreqs[key] = (destT.fileFreqs[key] || 0) + 1;
      if (destT.fileDetails) {
        if (!destT.fileDetails[key]) destT.fileDetails[key] = {};
        destT.fileDetails[key][destT.fileName] = thisFileCountsT[key];
      }
    }
  });
  seenThisFileR.forEach(key => {
    if (destR) {
      destR.fileFreqs[key] = (destR.fileFreqs[key] || 0) + 1;
      if (destR.fileDetails) {
        if (!destR.fileDetails[key]) destR.fileDetails[key] = {};
        destR.fileDetails[key][destR.fileName] = thisFileCountsR[key];
      }
    }
  });
}

// Process n-gram word+POS combinations (e.g., "the_DT study_NN shows_VBZ")
function processNgramPosForFile(file, wordField, posField, n, destT, destR, caseInsensitive) {
  if (corpus.mode !== 'tagged' && corpus.mode !== 'csv') return;
  if (n <= 1) return;
  const seenThisFileT = new Set();
  const seenThisFileR = new Set();
  const thisFileCountsT = {};
  const thisFileCountsR = {};
  
  for (const sent of file.sentences) {
    const subSentences = getSentenceSegments(file.tokens, sent.tokenStart, sent.tokenEnd);
    
    for (const subSent of subSentences) {
      const arr = [];
      for (const tok of subSent.tokens) {
        // Double-check: skip punctuation tokens
        if (isPunctuationOrSpaceToken(tok)) continue;
        let word = tok[wordField];
        const pos = tok[posField];
        if (!word || !pos) continue;
        if (caseInsensitive) word = word.toLowerCase();
        arr.push(`${word}_${pos}`);
      }
      if (arr.length < n) continue;
      for (let i = 0; i <= arr.length - n; i++) {
        const gram = arr.slice(i, i + n);
        const key = gram.join(' ');
        if (destT) {
          destT.counts[key] = (destT.counts[key] || 0) + 1;
          destT.totalUnits++;
          seenThisFileT.add(key);
          if (destT.fileDetails) thisFileCountsT[key] = (thisFileCountsT[key] || 0) + 1;
        }
        if (destR) {
          destR.counts[key] = (destR.counts[key] || 0) + 1;
          destR.totalUnits++;
          seenThisFileR.add(key);
          if (destR.fileDetails) thisFileCountsR[key] = (thisFileCountsR[key] || 0) + 1;
        }
      }
    }
  }
  seenThisFileT.forEach(key => {
    if (destT) {
      destT.fileFreqs[key] = (destT.fileFreqs[key] || 0) + 1;
      if (destT.fileDetails) {
        if (!destT.fileDetails[key]) destT.fileDetails[key] = {};
        destT.fileDetails[key][destT.fileName] = thisFileCountsT[key];
      }
    }
  });
  seenThisFileR.forEach(key => {
    if (destR) {
      destR.fileFreqs[key] = (destR.fileFreqs[key] || 0) + 1;
      if (destR.fileDetails) {
        if (!destR.fileDetails[key]) destR.fileDetails[key] = {};
        destR.fileDetails[key][destR.fileName] = thisFileCountsR[key];
      }
    }
  });
}

// ===== Statistics =====
function computeLL(kT, kR, NT, NR) {
  const N = NT + NR;
  const k = kT + kR;
  if (k === 0 || N === 0 || NT === 0 || NR === 0) return 0;

  const ET = NT * (k / N);
  const ER = NR * (k / N);

  let ll = 0;
  if (kT > 0 && ET > 0) {
    ll += kT * Math.log(kT / ET);
  }
  if (kR > 0 && ER > 0) {
    ll += kR * Math.log(kR / ER);
  }
  const llValue = 2 * ll;
  
  // Apply sign: positive if Target-dominant, negative if Reference-dominant
  const normT = kT / NT;
  const normR = kR / NR;
  if (normT < normR) {
    return -llValue;
  }
  return llValue;
}

function computeCohenD(fT, fR, NT, NR) {
  if (NT === 0 || NR === 0) return 0;
  const pT = fT / NT;
  const pR = fR / NR;
  const varT = pT * (1 - pT);
  const varR = pR * (1 - pR);
  const pooled = Math.sqrt((varT + varR) / 2);
  if (pooled === 0 || !isFinite(pooled)) return 0;
  return (pT - pR) / pooled;
}

// Mean Text Keyness calculation based on Larsson, Kim, & Egbert (2025)
// Calculates effect size using per-text normalized frequencies
function computeMeanTextKeyness(targetFileDetails, referenceFileDetails, targetFileSizes, referenceFileSizes, numTargetFiles, numReferenceFiles, useWeighted) {
  // Helper function to calculate mean and SD of normalized frequencies
  function calcMeanAndSD(fileDetails, fileSizes, numFiles) {
    if (!fileSizes || numFiles === 0) return { mean: 0, sd: 0, n: 0 };
    
    const fileNames = Object.keys(fileSizes);
    const normedFreqs = [];
    
    // Calculate normalized frequency for each file (per 1000 words)
    for (const fileName of fileNames) {
      const freq = (fileDetails && fileDetails[fileName]) || 0;
      const fileSize = fileSizes[fileName] || 0;
      const normed = (fileSize > 0) ? (freq / fileSize) * 1000 : 0;
      normedFreqs.push(normed);
    }
    
    // Calculate mean
    const mean = normedFreqs.reduce((sum, v) => sum + v, 0) / numFiles;
    
    // Calculate population standard deviation (like keylexbundles)
    const sumSqDiff = normedFreqs.reduce((sum, v) => sum + Math.pow(v - mean, 2), 0);
    const sd = Math.sqrt(sumSqDiff / numFiles);
    
    return { mean, sd, n: numFiles };
  }
  
  const statsT = calcMeanAndSD(targetFileDetails, targetFileSizes, numTargetFiles);
  const statsR = calcMeanAndSD(referenceFileDetails, referenceFileSizes, numReferenceFiles);
  
  const meanT = statsT.mean;
  const meanR = statsR.mean;
  const sdT = statsT.sd;
  const sdR = statsR.sd;
  const nT = statsT.n;
  const nR = statsR.n;
  
  let pooledSD;
  if (useWeighted && nT > 1 && nR > 1) {
    // Weighted pooled SD: sqrt(((n1-1)*SD1² + (n2-1)*SD2²) / (n1 + n2 - 2))
    pooledSD = Math.sqrt(((nT - 1) * sdT * sdT + (nR - 1) * sdR * sdR) / (nT + nR - 2));
  } else {
    // Unweighted pooled SD: sqrt((SD1² + SD2²) / 2)
    pooledSD = Math.sqrt((sdT * sdT + sdR * sdR) / 2);
  }
  
  if (pooledSD === 0 || !isFinite(pooledSD)) return 0;
  
  return (meanT - meanR) / pooledSD;
}

// Mean Text Keyness for 11a) Dependency Pattern (using file frequency maps)
function computeMeanTextKeynessFromMaps(fileFreqT, fileFreqR, fileSizesT, fileSizesR, numFilesT, numFilesR, useWeighted) {
  // Helper function to calculate mean and SD of normalized frequencies from Map
  function calcMeanAndSDFromMap(fileFreqMap, fileSizes, numFiles) {
    if (!fileSizes || numFiles === 0) return { mean: 0, sd: 0, n: 0 };
    
    const fileNames = Object.keys(fileSizes);
    const normedFreqs = [];
    
    // Calculate normalized frequency for each file (per 1000 words)
    for (const fileName of fileNames) {
      const freq = fileFreqMap.get(fileName) || 0;
      const fileSize = fileSizes[fileName] || 0;
      const normed = (fileSize > 0) ? (freq / fileSize) * 1000 : 0;
      normedFreqs.push(normed);
    }
    
    // Calculate mean
    const mean = normedFreqs.reduce((sum, v) => sum + v, 0) / numFiles;
    
    // Calculate population standard deviation
    const sumSqDiff = normedFreqs.reduce((sum, v) => sum + Math.pow(v - mean, 2), 0);
    const sd = Math.sqrt(sumSqDiff / numFiles);
    
    return { mean, sd, n: numFiles };
  }
  
  const statsT = calcMeanAndSDFromMap(fileFreqT, fileSizesT, numFilesT);
  const statsR = calcMeanAndSDFromMap(fileFreqR, fileSizesR, numFilesR);
  
  const meanT = statsT.mean;
  const meanR = statsR.mean;
  const sdT = statsT.sd;
  const sdR = statsR.sd;
  const nT = statsT.n;
  const nR = statsR.n;
  
  let pooledSD;
  if (useWeighted && nT > 1 && nR > 1) {
    // Weighted pooled SD
    pooledSD = Math.sqrt(((nT - 1) * sdT * sdT + (nR - 1) * sdR * sdR) / (nT + nR - 2));
  } else {
    // Unweighted pooled SD
    pooledSD = Math.sqrt((sdT * sdT + sdR * sdR) / 2);
  }
  
  if (pooledSD === 0 || !isFinite(pooledSD)) return 0;
  
  return (meanT - meanR) / pooledSD;
}

// ===== Dispersion Measures =====
// Calculate dispersion metrics for a feature across files
// fileDetails: { fileName: freq, ... } - frequency in each file
// fileSizes: { fileName: totalUnits, ... } - total units in each file
// totalFreq: total frequency of the feature
// totalUnits: total units across all files
// numFiles: total number of files in the corpus

function computeDispersion(fileDetails, fileSizes, totalFreq, totalUnits, numFiles) {
  if (!fileDetails || totalFreq === 0 || numFiles === 0) {
    return { range: 0, juillandD: 0, dp: 0, kld: 0 };
  }
  
  // Range: number of files containing the feature / total files
  const filesWithFeature = Object.keys(fileDetails).length;
  const range = filesWithFeature / numFiles;
  
  // Get all file names
  const fileNames = Object.keys(fileSizes);
  const n = fileNames.length;
  if (n === 0) return { range: 0, juillandD: 0, dp: 0, kld: 0 };
  
  // Calculate proportions
  // p_i = observed proportion of feature in part i (v_i / f)
  // s_i = expected proportion based on part size (part_size / total_size)
  
  let sumSqDiff = 0;      // For Juilland's D
  let sumAbsDiff = 0;     // For Gries's DP
  let kld = 0;            // Kullback-Leibler Divergence
  
  for (const fileName of fileNames) {
    const v_i = fileDetails[fileName] || 0;  // Feature freq in this file
    const partSize = fileSizes[fileName] || 0;  // File size
    
    if (partSize === 0) continue;
    
    const p_i = v_i / totalFreq;            // Observed proportion
    const s_i = partSize / totalUnits;      // Expected proportion (file size proportion)
    
    // Gries's DP: sum of absolute differences
    sumAbsDiff += Math.abs(p_i - s_i);
    
    // Juilland's D: based on coefficient of variation
    sumSqDiff += Math.pow(p_i - (1 / n), 2);
    
    // KLD: only for files where feature appears
    if (v_i > 0 && s_i > 0) {
      kld += p_i * Math.log2(p_i / s_i);
    }
  }
  
  // Gries's DP: DP = 0.5 * sum|p_i - s_i|
  // DP ranges from 0 (perfectly even) to close to 1 (maximally uneven)
  const dp = sumAbsDiff / 2;
  
  // Juilland's D: D = 1 - (CV / sqrt(n-1))
  // CV = coefficient of variation = sd / mean
  // For uniform distribution across n parts, expected proportion = 1/n
  const meanProp = 1 / n;
  const variance = sumSqDiff / n;
  const sd = Math.sqrt(variance);
  const cv = (meanProp > 0) ? sd / meanProp : 0;
  const juillandD = 1 - (cv / Math.sqrt(n - 1 || 1));
  
  return {
    range: range,
    juillandD: Math.max(0, Math.min(1, juillandD)),  // Clamp to [0, 1]
    dp: Math.max(0, Math.min(1, dp)),                 // Clamp to [0, 1]
    kld: Math.max(0, kld)                             // KLD >= 0
  };
}

function formatNumber(num, digits) {
  if (!isFinite(num)) return '';
  return num.toFixed(digits);
}

function formatFillersWithClick(map, pframe, side) {
  if (!map) return '<span class="text-xs">-</span>';
  const entries = Object.entries(map);
  if (entries.length === 0) return '<span class="text-xs">-</span>';
  entries.sort((a, b) => b[1] - a[1] || a[0].localeCompare(b[0]));
  const top = entries.slice(0, 5);
  const items = top.map(([f, c]) => {
    const escapedF = escapeHtml(f);
    const escapedPframe = escapeHtml(pframe);
    return `<span class="filler-item" data-filler="${escapedF}" data-pframe="${escapedPframe}" data-side="${side}">${escapedF}(${c})</span>`;
  });
  return items.join(' ');
}

// ===== Keyness Rendering & Sorting =====

function applyKeynessFilter() {
  const keyStatus = document.getElementById('keyStatus');
  const keyBody = document.getElementById('keyTableBody');

  if (!allKeynessRows || allKeynessRows.length === 0) {
    if (keyBody) {
      keyBody.innerHTML = '<tr><td colspan="13" class="text-xs">No keyness results.</td></tr>';
    }
    if (keyStatus) {
      keyStatus.textContent = 'Please run Compute Keyness / Frequency first.';
    }
    return;
  }

  let topN = 200;
  const topNInput = document.getElementById('topNKeyInput');
  if (topNInput) {
    const v = parseInt(topNInput.value, 10);
    if (Number.isFinite(v) && v > 0) topN = v;
  }

  const filterBox = document.getElementById('keyFeatureFilter');
  const modeSelect = document.getElementById('keyFilterMode');
  const excludeCheck = document.getElementById('keyFilterExclude');
  const filterStr = filterBox ? filterBox.value.trim() : '';
  const mode = modeSelect ? modeSelect.value : 'exact';
  const excludeMode = excludeCheck ? excludeCheck.checked : false;

  let filtered = allKeynessRows;
  if (filterStr) {
    const fLower = filterStr.toLowerCase();
    filtered = allKeynessRows.filter(r => {
      const feat = (r.feature || '').toLowerCase();
      if (!feat) return excludeMode; // If no feature, include only in exclude mode
      let matches = false;
      if (mode === 'partial') {
        // 部分一致: feature 文字列に含まれていればヒット
        matches = feat.includes(fLower);
      } else {
        // 全体一致: feature のどれか 1 語が完全一致
        const parts = feat.split(/\s+/).filter(x => x.length > 0);
        matches = parts.some(p => p === fLower);
      }
      // Apply exclude logic
      return excludeMode ? !matches : matches;
    });
  }

  // Sort filtered data before taking top N
  const advancedStats = document.getElementById('keyAdvancedStats')?.checked ?? false;
  const factor = lastSort.dir === 'asc' ? 1 : -1;
  const colIndex = lastSort.col;
  
  filtered = [...filtered].sort((a, b) => {
    let va, vb;
    if (advancedStats) {
      switch (colIndex) {
        case 1: va = a.feature.toLowerCase(); vb = b.feature.toLowerCase(); return va.localeCompare(vb) * factor;
        case 2: va = a.fT; vb = b.fT; return (va - vb) * factor;
        case 3: va = a.normT; vb = b.normT; return (va - vb) * factor;
        case 4: va = a.rangeT || 0; vb = b.rangeT || 0; return (va - vb) * factor;
        case 5: va = a.juillandT || 0; vb = b.juillandT || 0; return (va - vb) * factor;
        case 6: va = a.dpT || 0; vb = b.dpT || 0; return (va - vb) * factor;
        case 7: va = a.fR; vb = b.fR; return (va - vb) * factor;
        case 8: va = a.normR; vb = b.normR; return (va - vb) * factor;
        case 9: va = a.rangeR || 0; vb = b.rangeR || 0; return (va - vb) * factor;
        case 10: va = a.juillandR || 0; vb = b.juillandR || 0; return (va - vb) * factor;
        case 11: va = a.dpR || 0; vb = b.dpR || 0; return (va - vb) * factor;
        case 12: va = a.freqLL || 0; vb = b.freqLL || 0; return (va - vb) * factor;
        case 13: va = a.textLL || 0; vb = b.textLL || 0; return (va - vb) * factor;
        case 14: va = a.d || 0; vb = b.d || 0; return (va - vb) * factor;
        default: return 0;
      }
    } else {
      switch (colIndex) {
        case 1: va = a.feature.toLowerCase(); vb = b.feature.toLowerCase(); return va.localeCompare(vb) * factor;
        case 2: va = a.fT; vb = b.fT; return (va - vb) * factor;
        case 3: va = a.normT; vb = b.normT; return (va - vb) * factor;
        case 4: va = a.fR; vb = b.fR; return (va - vb) * factor;
        case 5: va = a.normR; vb = b.normR; return (va - vb) * factor;
        case 6: va = a.freqLL || 0; vb = b.freqLL || 0; return (va - vb) * factor;
        case 7: va = a.textLL || 0; vb = b.textLL || 0; return (va - vb) * factor;
        case 8: va = a.d || 0; vb = b.d || 0; return (va - vb) * factor;
        default: return 0;
      }
    }
  });

  lastKeynessRows = filtered.slice(0, topN);

  if (!lastKeynessRows || lastKeynessRows.length === 0) {
    if (keyBody) {
      keyBody.innerHTML = '<tr><td colspan="13" class="text-xs">No keyness results (filter).</td></tr>';
    }
    if (keyStatus) {
      keyStatus.textContent = `Features: ${lastKeyAllCount} (after filter: 0)`;
    }
    return;
  }

  renderKeynessRows();

  if (keyStatus) {
    keyStatus.textContent = `Features: ${lastKeyAllCount} (after filter: ${filtered.length}; showing top ${lastKeynessRows.length})`;
  }
}

// Clear Keyness filter and show all results
function clearKeynessFilter() {
  const filterBox = document.getElementById('keyFeatureFilter');
  const excludeCheck = document.getElementById('keyFilterExclude');
  if (filterBox) filterBox.value = '';
  if (excludeCheck) excludeCheck.checked = false;
  
  // Reset to all rows with current sort applied
  applyKeynessFilter();
}

// Dynamically update table structure based on advanced stats mode
function updateKeynessTableStructure(advancedStats) {
  const colgroup = document.getElementById('keyTableColgroup');
  const thead = document.getElementById('keyTableHead');
  
  if (advancedStats) {
    // Advanced mode: 19 columns with file_T/file_R and dispersion
    colgroup.innerHTML = `
      <col data-col="0" style="width:40px">
      <col data-col="1" style="width:180px">
      <col data-col="2" style="width:60px">
      <col data-col="3" style="width:80px">
      <col data-col="4" style="width:50px">
      <col data-col="5" style="width:55px">
      <col data-col="6" style="width:55px">
      <col data-col="7" style="width:55px">
      <col data-col="8" style="width:60px">
      <col data-col="9" style="width:80px">
      <col data-col="10" style="width:50px">
      <col data-col="11" style="width:55px">
      <col data-col="12" style="width:55px">
      <col data-col="13" style="width:55px">
      <col data-col="14" style="width:65px">
      <col data-col="15" style="width:65px">
      <col data-col="16" style="width:65px">
      <col data-col="17" style="width:140px">
      <col data-col="18" style="width:140px">
    `;
    thead.innerHTML = `
      <tr>
        <th style="position:relative;">#<div class="key-col-resizer" data-col="0"></div></th>
        <th class="sortable" data-col="1" style="position:relative;">Feature<div class="key-col-resizer" data-col="1"></div></th>
        <th class="text-right sortable" data-col="2" style="position:relative;">freq_T<div class="key-col-resizer" data-col="2"></div></th>
        <th class="text-right sortable" data-col="3" style="position:relative;">norm_T (pm)<div class="key-col-resizer" data-col="3"></div></th>
        <th class="text-right sortable" data-col="4" style="position:relative;">file_T<div class="key-col-resizer" data-col="4"></div></th>
        <th class="text-right sortable" data-col="5" style="position:relative;">Range_T<div class="key-col-resizer" data-col="5"></div></th>
        <th class="text-right sortable" data-col="6" style="position:relative;">Juilland_T<div class="key-col-resizer" data-col="6"></div></th>
        <th class="text-right sortable" data-col="7" style="position:relative;">DP_T<div class="key-col-resizer" data-col="7"></div></th>
        <th class="text-right sortable" data-col="8" style="position:relative;">freq_R<div class="key-col-resizer" data-col="8"></div></th>
        <th class="text-right sortable" data-col="9" style="position:relative;">norm_R (pm)<div class="key-col-resizer" data-col="9"></div></th>
        <th class="text-right sortable" data-col="10" style="position:relative;">file_R<div class="key-col-resizer" data-col="10"></div></th>
        <th class="text-right sortable" data-col="11" style="position:relative;">Range_R<div class="key-col-resizer" data-col="11"></div></th>
        <th class="text-right sortable" data-col="12" style="position:relative;">Juilland_R<div class="key-col-resizer" data-col="12"></div></th>
        <th class="text-right sortable" data-col="13" style="position:relative;">DP_R<div class="key-col-resizer" data-col="13"></div></th>
        <th class="text-right sortable" data-col="14" style="position:relative;">Freq-LL (T)<div class="key-col-resizer" data-col="14"></div></th>
        <th class="text-right sortable" data-col="15" style="position:relative;">Text-LL (T)<div class="key-col-resizer" data-col="15"></div></th>
        <th class="text-right sortable" data-col="16" style="position:relative;">MTK (T)<div class="key-col-resizer" data-col="16"></div></th>
        <th style="position:relative;">Fillers_T<div class="key-col-resizer" data-col="17"></div></th>
        <th style="position:relative;">Fillers_R<div class="key-col-resizer" data-col="18"></div></th>
      </tr>
    `;
  } else {
    // Basic mode: 13 columns with file_T/file_R
    colgroup.innerHTML = `
      <col data-col="0" style="width:40px">
      <col data-col="1" style="width:180px">
      <col data-col="2" style="width:60px">
      <col data-col="3" style="width:80px">
      <col data-col="4" style="width:55px">
      <col data-col="5" style="width:60px">
      <col data-col="6" style="width:80px">
      <col data-col="7" style="width:55px">
      <col data-col="8" style="width:65px">
      <col data-col="9" style="width:65px">
      <col data-col="10" style="width:65px">
      <col data-col="11" style="width:150px">
      <col data-col="12" style="width:150px">
    `;
    thead.innerHTML = `
      <tr>
        <th style="position:relative;">#<div class="key-col-resizer" data-col="0"></div></th>
        <th class="sortable" data-col="1" style="position:relative;">Feature<div class="key-col-resizer" data-col="1"></div></th>
        <th class="text-right sortable" data-col="2" style="position:relative;">freq_T<div class="key-col-resizer" data-col="2"></div></th>
        <th class="text-right sortable" data-col="3" style="position:relative;">norm_T (pm)<div class="key-col-resizer" data-col="3"></div></th>
        <th class="text-right sortable" data-col="4" style="position:relative;">file_T<div class="key-col-resizer" data-col="4"></div></th>
        <th class="text-right sortable" data-col="5" style="position:relative;">freq_R<div class="key-col-resizer" data-col="5"></div></th>
        <th class="text-right sortable" data-col="6" style="position:relative;">norm_R (pm)<div class="key-col-resizer" data-col="6"></div></th>
        <th class="text-right sortable" data-col="7" style="position:relative;">file_R<div class="key-col-resizer" data-col="7"></div></th>
        <th class="text-right sortable" data-col="8" style="position:relative;">Freq-LL (T)<div class="key-col-resizer" data-col="8"></div></th>
        <th class="text-right sortable" data-col="9" style="position:relative;">Text-LL (T)<div class="key-col-resizer" data-col="9"></div></th>
        <th class="text-right sortable" data-col="10" style="position:relative;">MTK (T)<div class="key-col-resizer" data-col="10"></div></th>
        <th style="position:relative;">Fillers_T (for *)<div class="key-col-resizer" data-col="11"></div></th>
        <th style="position:relative;">Fillers_R (for *)<div class="key-col-resizer" data-col="12"></div></th>
      </tr>
    `;
  }

  // Re-attach click handlers
  
  // Re-attach click handlers for sortable headers
  const headers = thead.querySelectorAll('th.sortable');
  headers.forEach(th => {
    th.addEventListener('click', () => {
      const col = parseInt(th.getAttribute('data-col'), 10);
      sortKeynessBy(col);
    });
  });
  // Re-bind resizer handlers after rebuilding header/colgroup
  initKeyTableResize();
}

function renderKeynessRows() {
  const keyBody = document.getElementById('keyTableBody');
  const advancedStats = document.getElementById('keyAdvancedStats')?.checked ?? false;
  lastKeyAdvancedStats = advancedStats;
  
  // Update table structure based on advanced stats mode
  updateKeynessTableStructure(advancedStats);
  
  const numCols = advancedStats ? 19 : 13;
  
  if (!lastKeynessRows || lastKeynessRows.length === 0) {
    keyBody.innerHTML = `<tr><td colspan="${numCols}" class="text-xs">No keyness results.</td></tr>`;
    return;
  }

  const factor = lastSort.dir === 'asc' ? 1 : -1;
  const colIndex = lastSort.col;
  
  // Sorting logic depends on mode
  lastKeynessRows.sort((a, b) => {
    let va, vb;
    if (advancedStats) {
      // Advanced mode column mapping (19 cols)
      switch (colIndex) {
        case 1: va = a.feature.toLowerCase(); vb = b.feature.toLowerCase(); return va.localeCompare(vb) * factor;
        case 2: va = a.fT; vb = b.fT; return (va - vb) * factor;
        case 3: va = a.normT; vb = b.normT; return (va - vb) * factor;
        case 4: va = a.fFileT || 0; vb = b.fFileT || 0; return (va - vb) * factor;
        case 5: va = a.rangeT || 0; vb = b.rangeT || 0; return (va - vb) * factor;
        case 6: va = a.juillandT || 0; vb = b.juillandT || 0; return (va - vb) * factor;
        case 7: va = a.dpT || 0; vb = b.dpT || 0; return (va - vb) * factor;
        case 8: va = a.fR; vb = b.fR; return (va - vb) * factor;
        case 9: va = a.normR; vb = b.normR; return (va - vb) * factor;
        case 10: va = a.fFileR || 0; vb = b.fFileR || 0; return (va - vb) * factor;
        case 11: va = a.rangeR || 0; vb = b.rangeR || 0; return (va - vb) * factor;
        case 12: va = a.juillandR || 0; vb = b.juillandR || 0; return (va - vb) * factor;
        case 13: va = a.dpR || 0; vb = b.dpR || 0; return (va - vb) * factor;
        case 14: va = a.freqLL || 0; vb = b.freqLL || 0; return (va - vb) * factor;
        case 15: va = a.textLL || 0; vb = b.textLL || 0; return (va - vb) * factor;
        case 16: va = a.d || 0; vb = b.d || 0; return (va - vb) * factor;
        default: return 0;
      }
    } else {
      // Basic mode column mapping (13 cols)
      switch (colIndex) {
        case 1: va = a.feature.toLowerCase(); vb = b.feature.toLowerCase(); return va.localeCompare(vb) * factor;
        case 2: va = a.fT; vb = b.fT; return (va - vb) * factor;
        case 3: va = a.normT; vb = b.normT; return (va - vb) * factor;
        case 4: va = a.fFileT || 0; vb = b.fFileT || 0; return (va - vb) * factor;
        case 5: va = a.fR; vb = b.fR; return (va - vb) * factor;
        case 6: va = a.normR; vb = b.normR; return (va - vb) * factor;
        case 7: va = a.fFileR || 0; vb = b.fFileR || 0; return (va - vb) * factor;
        case 8: va = a.freqLL || 0; vb = b.freqLL || 0; return (va - vb) * factor;
        case 9: va = a.textLL || 0; vb = b.textLL || 0; return (va - vb) * factor;
        case 10: va = a.d || 0; vb = b.d || 0; return (va - vb) * factor;
        default: return 0;
      }
    }
  });

  let htmlRows = '';
  const isPframe = lastKeynessIsPframe;

  for (let i = 0; i < lastKeynessRows.length; i++) {
    const r = lastKeynessRows[i];
    const fillersT = isPframe ? formatFillersWithClick(lastTargetFillers[r.feature], r.feature, 'target') : '<span class="text-xs">-</span>';
    const fillersR = isPframe ? formatFillersWithClick(lastReferenceFillers[r.feature], r.feature, 'reference') : '<span class="text-xs">-</span>';
    const freqLLStr = r.freqLL != null ? formatNumber(r.freqLL, 2) : '-';
    const textLLStr = r.textLL != null ? formatNumber(r.textLL, 2) : '-';
    const dStr = r.d != null ? formatNumber(r.d, 3) : '-';
    
    if (advancedStats) {
      // Format dispersion values
      const rangeTStr = r.rangeT != null ? formatNumber(r.rangeT, 3) : '-';
      const juillandTStr = r.juillandT != null ? formatNumber(r.juillandT, 3) : '-';
      const dpTStr = r.dpT != null ? formatNumber(r.dpT, 3) : '-';
      const rangeRStr = r.rangeR != null ? formatNumber(r.rangeR, 3) : '-';
      const juillandRStr = r.juillandR != null ? formatNumber(r.juillandR, 3) : '-';
      const dpRStr = r.dpR != null ? formatNumber(r.dpR, 3) : '-';
      
      htmlRows += `<tr style="cursor:pointer;" data-row-idx="${i}">
        <td>${i + 1}</td>
        <td class="mono">${escapeHtml(r.feature)}</td>
        <td class="text-right">${r.fT}</td>
        <td class="text-right">${formatNumber(r.normT, 2)}</td>
        <td class="text-right">${r.fFileT || 0}</td>
        <td class="text-right">${rangeTStr}</td>
        <td class="text-right">${juillandTStr}</td>
        <td class="text-right">${dpTStr}</td>
        <td class="text-right">${r.fR}</td>
        <td class="text-right">${formatNumber(r.normR, 2)}</td>
        <td class="text-right">${r.fFileR || 0}</td>
        <td class="text-right">${rangeRStr}</td>
        <td class="text-right">${juillandRStr}</td>
        <td class="text-right">${dpRStr}</td>
        <td class="text-right">${freqLLStr}</td>
        <td class="text-right">${textLLStr}</td>
        <td class="text-right">${dStr}</td>
        <td class="mono fillers-cell">${fillersT}</td>
        <td class="mono fillers-cell">${fillersR}</td>
      </tr>`;
    } else {
      htmlRows += `<tr style="cursor:pointer;" data-row-idx="${i}">
        <td>${i + 1}</td>
        <td class="mono">${escapeHtml(r.feature)}</td>
        <td class="text-right">${r.fT}</td>
        <td class="text-right">${formatNumber(r.normT, 2)}</td>
        <td class="text-right">${r.fFileT || 0}</td>
        <td class="text-right">${r.fR}</td>
        <td class="text-right">${formatNumber(r.normR, 2)}</td>
        <td class="text-right">${r.fFileR || 0}</td>
        <td class="text-right">${freqLLStr}</td>
        <td class="text-right">${textLLStr}</td>
        <td class="text-right">${dStr}</td>
        <td class="mono fillers-cell">${fillersT}</td>
        <td class="mono fillers-cell">${fillersR}</td>
      </tr>`;
    }
  }
  keyBody.innerHTML = htmlRows;

  // Filler columns are at different positions based on mode
  const fillerColStart = advancedStats ? 17 : 11;
  const fillerColEnd = advancedStats ? 18 : 12;

  // Add click handlers for rows (excluding filler clicks)
  const rowsEl = keyBody.querySelectorAll('tr');
  rowsEl.forEach((tr, rowIdx) => {
    const cells = tr.querySelectorAll('td');
    cells.forEach((td, colIdx) => {
      // Skip filler columns - they have their own click handlers
      if (colIdx === fillerColStart || colIdx === fillerColEnd) return;
      
      td.addEventListener('click', () => {
        const r = lastKeynessRows[rowIdx];
        if (!r) return;
        
        // DEP type - redirect to 11b) Dependency Concordance
        if (lastKeyFeatureType === 'dep') {
          redirectToDepSectionWithFilter(r.feature);
          return;
        }
        
        // Clear previous filters
        clearKwicFilters();
        
        // Feature click searches Target only by default
        const scope = 'target';
        
        currentCollocateWord = null; // Clear collocate highlight
        
        // Set feature to all sections and get converted type
        const kwicType = setFeatureToAllSections(r.feature, lastKeyFeatureType, scope);
        currentKwicFeatureType = kwicType;
        
        // Set search mode - detect wildcard patterns
        const kwicSearchMode = document.getElementById('kwicSearchMode');
        if (kwicSearchMode) {
          if (r.feature.includes('*') || r.feature.includes('?')) {
            kwicSearchMode.value = 'wildcard';
          } else {
            kwicSearchMode.value = 'exact';
          }
        }
        
        // Get converted feature for currentKwicFeature
        let kwicFeature = r.feature;
        if (lastKeyFeatureType.startsWith('wordpos_')) {
          kwicFeature = extractWordFromWordPos(r.feature);
        } else if (lastKeyFeatureType.startsWith('ngrampos_')) {
          kwicFeature = extractWordsFromNgramPos(r.feature);
        }
        currentKwicFeature = kwicFeature;

        // Clear file/folder filters when jumping from 8) Keyness
        currentKwicFileFilter = null;
        currentKwicFolderFilter = null;

        // Check if this is wordpos/ngrampos type - need to apply filter after compute
        const needsPosFilter = lastKeyFeatureType.startsWith('wordpos_') || lastKeyFeatureType.startsWith('ngrampos_');
        
        computeKwic();
        
        // Apply POS filter automatically for wordpos/ngrampos
        if (needsPosFilter) {
          setTimeout(() => applyKwicFilter(), 50);
        }
        
        const kwicCard = document.getElementById('kwicCard');
        if (kwicCard) {
          kwicCard.scrollIntoView({ behavior: 'smooth', block: 'start' });
        }
      });
    });
  });

  // Add click handlers for filler items
  keyBody.querySelectorAll('.filler-item').forEach(item => {
    item.addEventListener('click', (e) => {
      e.stopPropagation(); // Prevent row click
      
      // Clear previous filters
      clearKwicFilters();
      
      const filler = item.getAttribute('data-filler');
      const pframe = item.getAttribute('data-pframe');
      const side = item.getAttribute('data-side');
      
      // Replace * with the filler word
      const ngramFeature = pframe.replace('*', filler);
      
      // Set scope based on side
      const scopeInput = document.querySelector(`input[name="kwicScope"][value="${side}"]`);
      if (scopeInput) {
        scopeInput.checked = true;
      }
      
      // Determine feature type (ngram_word or ngram_lemma based on current pframe type)
      let ngramType = 'ngram_word';
      if (lastKeyFeatureType === 'pframe_lemma') {
        ngramType = 'ngram_lemma';
      }
      
      currentKwicFeature = ngramFeature;
      currentCollocateWord = null; // Clear collocate highlight
      
      // Set feature to all sections
      const kwicType = setFeatureToAllSections(ngramFeature, ngramType, side);
      currentKwicFeatureType = kwicType;

      // Clear file/folder filters when jumping from 8) Keyness (n-grams / p-frames)
      currentKwicFileFilter = null;
      currentKwicFolderFilter = null;

      computeKwic();
      const kwicCard = document.getElementById('kwicCard');
      if (kwicCard) {
        kwicCard.scrollIntoView({ behavior: 'smooth', block: 'start' });
      }
    });
  });

  const keyTable = document.getElementById('keyTable');
  const headers = keyTable.querySelectorAll('thead th.sortable');
  headers.forEach(th => {
    th.classList.remove('sorted-asc', 'sorted-desc');
    const col = parseInt(th.getAttribute('data-col'), 10);
    if (col === lastSort.col) {
      th.classList.add(lastSort.dir === 'asc' ? 'sorted-asc' : 'sorted-desc');
    }
  });
}

function sortKeynessBy(colIndex) {
  if (!allKeynessRows || allKeynessRows.length === 0) return;

  if (lastSort.col === colIndex) {
    lastSort.dir = lastSort.dir === 'asc' ? 'desc' : 'asc';
  } else {
    lastSort.col = colIndex;
    lastSort.dir = 'desc';
  }
  // Sort all data and re-apply filter to get top N
  applyKeynessFilter();
}

// キャンセルフラグ
let keynessComputationCancelled = false;

// 進捗表示更新
function updateKeynessProgress(percent, detail) {
  const container = document.getElementById('keyProgressContainer');
  const bar = document.getElementById('keyProgressBar');
  const text = document.getElementById('keyProgressText');
  const detailEl = document.getElementById('keyProgressDetail');
  
  if (container) container.style.display = 'block';
  if (bar) bar.style.width = percent + '%';
  if (text) text.textContent = Math.round(percent) + '%';
  if (detailEl) detailEl.textContent = detail || '';
}

function hideKeynessProgress() {
  const container = document.getElementById('keyProgressContainer');
  const cancelBtn = document.getElementById('keyCancelBtn');
  const keynessBtn = document.getElementById('keynessBtn');
  if (container) container.style.display = 'none';
  if (cancelBtn) cancelBtn.style.display = 'none';
  if (keynessBtn) keynessBtn.disabled = false;
}

function yieldToUI() {
  return new Promise(resolve => setTimeout(resolve, 0));
}

function cancelKeynessComputation() {
  keynessComputationCancelled = true;
  const keyStatus = document.getElementById('keyStatus');
  if (keyStatus) keyStatus.textContent = 'Cancelled.';
  hideKeynessProgress();
}

async function computeKeyness() {
  const keyStatus = document.getElementById('keyStatus');
  const keyBody = document.getElementById('keyTableBody');
  const keynessBtn = document.getElementById('keynessBtn');
  const cancelBtn = document.getElementById('keyCancelBtn');
  keyStatus.textContent = '';
  keynessComputationCancelled = false;

  allKeynessRows = [];
  lastKeynessRows = [];
  lastKeynessIsPframe = false;
  lastTargetFillers = null;
  lastReferenceFillers = null;

  if (!corpus || Object.keys(corpus.files).length === 0) {
    keyStatus.textContent = 'Please load a corpus first.';
    keyBody.innerHTML = '<tr><td colspan="13" class="text-xs">No keyness results.</td></tr>';
    return;
  }

  const hasTarget = targetFolders.size > 0;
  const hasRef = referenceFolders.size > 0;

  if (!hasTarget && !hasRef) {
    keyStatus.textContent = 'Please select at least one folder for Target or Reference.';
    keyBody.innerHTML = '<tr><td colspan="13" class="text-xs">No keyness results.</td></tr>';
    return;
  }

  const featureType = document.getElementById('featureTypeSelect').value;
  let n = parseInt(document.getElementById('nInput').value, 10);
  if (!Number.isFinite(n) || n <= 0) n = 4;

  const minFreq = parseInt(document.getElementById('minFreqInput').value, 10);
  const minFreqVal = Number.isFinite(minFreq) && minFreq > 0 ? minFreq : 1;

  let topN = parseInt(document.getElementById('topNKeyInput').value, 10);
  if (!Number.isFinite(topN) || topN <= 0) topN = 200;

  if ((featureType.startsWith('pos') || featureType.startsWith('posgram') || featureType.startsWith('wordpos') || featureType.startsWith('ngrampos')) && corpus.mode !== 'tagged' && corpus.mode !== 'csv' && corpus.mode !== 'csv') {
    keyStatus.textContent = 'POS-based features are only available in Tagged or CSV mode.';
    keyBody.innerHTML = '<tr><td colspan="13" class="text-xs">No keyness results.</td></tr>';
    return;
  }

  // Biber tag validation
  if (featureType === 'biber_tag' && corpus.mode !== 'csv') {
    keyStatus.textContent = 'Biber tag features are only available in CSV mode with Biber tags.';
    keyBody.innerHTML = '<tr><td colspan="13" class="text-xs">No keyness results.</td></tr>';
    return;
  }

  // Dependency Grammar validation and redirect
  if (featureType === 'dep') {
    if (!depHasDependencyData) {
      keyStatus.textContent = 'Dependency Grammar features require CSV mode with dependency data (head, deprel columns).';
      keyBody.innerHTML = '<tr><td colspan="13" class="text-xs">No keyness results.</td></tr>';
      return;
    }
    
    // Redirect to 12) Dependency Grammar section
    computeKeynessWithDep(featureType, minFreqVal, topN);
    return;
  }

  if ((featureType.startsWith('ngram') || featureType.startsWith('pframe') || featureType.startsWith('posgram') || featureType.startsWith('cluster') || featureType.startsWith('ngrampos')) && n < 2) {
    keyStatus.textContent = 'For n-gram / p-frame / POS-gram / cluster / n-gram+POS, please set n to 2 or higher.';
    keyBody.innerHTML = '<tr><td colspan="13" class="text-xs">No keyness results.</td></tr>';
    return;
  }

  // Cluster-specific validation and options
  let clusterOptions = null;
  if (featureType.startsWith('cluster')) {
    const searchWord = document.getElementById('keyClusterWord')?.value?.trim() || '';
    const position = document.getElementById('keyClusterPosition')?.value || 'both';
    
    if (!searchWord) {
      keyStatus.textContent = 'For Cluster, please enter a Search word.';
      keyBody.innerHTML = '<tr><td colspan="13" class="text-xs">No keyness results.</td></tr>';
      return;
    }
    
    clusterOptions = { searchWord, position };
  }

  keyStatus.textContent = 'Collecting features & computing statistics...';

  const caseInsensitive = document.getElementById('keyCaseInsensitive')?.checked ?? true;
  const advancedStats = document.getElementById('keyAdvancedStats')?.checked ?? false;
  
  // BiberPlus 96 only filter
  const biberPlusOnly = document.getElementById('keyBiberPlusOnly')?.checked ?? false;
  
  // UIを更新 - 常に進捗バーとキャンセルボタンを表示
  if (keynessBtn) keynessBtn.disabled = true;
  if (cancelBtn) cancelBtn.style.display = 'inline-flex';
  
  keyStatus.textContent = 'Phase 1/3: Collecting features...';
  updateKeynessProgress(5, 'Scanning files...');
  await yieldToUI();
  
  if (keynessComputationCancelled) {
    hideKeynessProgress();
    return;
  }
  
  // Check if MTK is enabled
  const useMTK = document.getElementById('keyUseMTK')?.checked ?? false;
  
  // Only collect file details if MTK or Advanced Statistics is enabled
  const needFileDetails = useMTK || advancedStats;
  
  const stats = collectFeatureCounts(featureType, n, targetFolders, referenceFolders, caseInsensitive, needFileDetails, clusterOptions);
  
  if (keynessComputationCancelled) {
    hideKeynessProgress();
    return;
  }
  
  updateKeynessProgress(15, 'Features collected');
  await yieldToUI();
  const Tcounts = stats.targetCounts;
  const Rcounts = stats.referenceCounts;
  const NT = stats.totalTargetUnits;
  const NR = stats.totalReferenceUnits;
  const targetFileFreqs = stats.targetFileFreqs;
  const referenceFileFreqs = stats.referenceFileFreqs;
  const NFT = stats.numTargetFiles;
  const NFR = stats.numReferenceFiles;
  
  // Get file details for Mean Text Keyness and dispersion calculation (only when needed)
  const targetFileDetails = needFileDetails ? (stats.targetFileDetails || null) : null;
  const referenceFileDetails = needFileDetails ? (stats.referenceFileDetails || null) : null;
  const targetFileSizes = needFileDetails ? (stats.targetFileSizes || null) : null;
  const referenceFileSizes = needFileDetails ? (stats.referenceFileSizes || null) : null;
  
  // Get weighted pooled SD option for Mean Text Keyness
  const useWeightedPooledSD = document.getElementById('keyWeightedPooledSD')?.checked ?? false;

  if ((!hasTarget || NT === 0) && (!hasRef || NR === 0)) {
    keyStatus.textContent = 'No valid units on the selected side (check folder and mode settings).';
    keyBody.innerHTML = '<tr><td colspan="13" class="text-xs">No keyness results.</td></tr>';
    return;
  }

  const features = new Set([...Object.keys(Tcounts), ...Object.keys(Rcounts)]);
  const rows = [];
  
  // BiberPlus 96 filter for biber_tag type
  const shouldFilterBiberPlus = biberPlusOnly && featureType === 'biber_tag';

  for (const feat of features) {
    // Apply BiberPlus 96 filter if enabled
    if (shouldFilterBiberPlus) {
      // Single tag: check if it's a BiberPlus 96 tag
      if (!isBiberPlus96Tag(feat)) continue;
    }
    
    const fT = Tcounts[feat] || 0;
    const fR = Rcounts[feat] || 0;
    const totalFreq = fT + fR;
    if (totalFreq < minFreqVal) continue;

    const normT = (hasTarget && NT > 0 && fT > 0) ? (fT * 1e6) / NT : 0;
    const normR = (hasRef && NR > 0 && fR > 0) ? (fR * 1e6) / NR : 0;

    let freqLL = null;
    let textLL = null;
    let d = null;

    if (hasTarget && hasRef && NT > 0 && NR > 0) {
      freqLL = computeLL(fT, fR, NT, NR);
    }
    
    // Effect size calculation (only when Use MTK is checked)
    if (useMTK && hasTarget && hasRef && NFT > 0 && NFR > 0 && targetFileSizes && referenceFileSizes) {
      // Mean Text Keyness calculation using per-file normalized frequencies
      // Based on Larsson, Kim, & Egbert (2025)
      const featTargetFileDetails = targetFileDetails ? targetFileDetails[feat] : null;
      const featReferenceFileDetails = referenceFileDetails ? referenceFileDetails[feat] : null;
      d = computeMeanTextKeyness(
        featTargetFileDetails,
        featReferenceFileDetails,
        targetFileSizes,
        referenceFileSizes,
        NFT,
        NFR,
        useWeightedPooledSD
      );
    }

    if (hasTarget && hasRef && NFT > 0 && NFR > 0) {
      const fFileT = targetFileFreqs[feat] || 0;
      const fFileR = referenceFileFreqs[feat] || 0;
      textLL = computeLL(fFileT, fFileR, NFT, NFR);
      // Debug: log first 5 features
      if (rows.length < 5) {
        console.log(`[Keyness] ${feat}: fFileT=${fFileT}/${NFT} (${(fFileT/NFT*100).toFixed(1)}%), fFileR=${fFileR}/${NFR} (${(fFileR/NFR*100).toFixed(1)}%), textLL=${textLL}`);
      }
    }
    
    // Calculate dispersion only when Advanced Statistics is enabled
    let dispT = null;
    let dispR = null;
    if (advancedStats) {
      // Calculate dispersion for Target
      if (hasTarget && fT > 0) {
        dispT = computeDispersion(
          targetFileDetails[feat],
          targetFileSizes,
          fT,
          NT,
          NFT
        );
      }
      
      // Calculate dispersion for Reference
      if (hasRef && fR > 0) {
        dispR = computeDispersion(
          referenceFileDetails[feat],
          referenceFileSizes,
          fR,
          NR,
          NFR
        );
      }
    }

    rows.push({
      feature: feat,
      fT,
      fR,
      fFileT: targetFileFreqs[feat] || 0,
      fFileR: referenceFileFreqs[feat] || 0,
      normT,
      normR,
      rangeT: dispT ? dispT.range : null,
      juillandT: dispT ? dispT.juillandD : null,
      dpT: dispT ? dispT.dp : null,
      rangeR: dispR ? dispR.range : null,
      juillandR: dispR ? dispR.juillandD : null,
      dpR: dispR ? dispR.dp : null,
      freqLL,
      textLL,
      d
    });
  }

  if (rows.length === 0) {
    keyStatus.textContent = 'No features found above the specified Min total freq.';
    keyBody.innerHTML = '<tr><td colspan="13" class="text-xs">No keyness results.</td></tr>';
    hideKeynessProgress();
    return;
  }

  // Phase 3: Sorting and rendering
  keyStatus.textContent = 'Phase 3/3: Sorting and rendering...';
  updateKeynessProgress(85, 'Sorting results...');
  await yieldToUI();

  const isPframe = featureType.startsWith('pframe');
  const targetFillers = stats.targetFillers;
  const referenceFillers = stats.referenceFillers;

  rows.sort((a, b) => {
    const aLL = a.freqLL != null ? a.freqLL : 0;
    const bLL = b.freqLL != null ? b.freqLL : 0;
    return bLL - aLL || b.fT - a.fT || a.feature.localeCompare(b.feature);
  });

  allKeynessRows = rows;
  lastKeynessIsPframe = isPframe;
  lastTargetFillers = targetFillers;
  lastReferenceFillers = referenceFillers;
  // Freq-LL column is 8 in basic mode, 14 in advanced mode
  const advStats = document.getElementById('keyAdvancedStats')?.checked ?? false;
  lastSort = { col: advStats ? 14 : 8, dir: 'desc' };
  lastKeyFeatureType = featureType;
  lastKeyAllCount = rows.length;

  updateKeynessProgress(95, 'Rendering table...');
  await yieldToUI();
  
  applyKeynessFilter();
  
  updateKeynessProgress(100, 'Complete!');
  keyStatus.textContent = `Features: ${rows.length} (showing top ${Math.min(topN, rows.length)})`;
  
  // 少し待ってから進捗バーを非表示
  setTimeout(hideKeynessProgress, 500);
}

// Compute Keyness using Dependency Grammar (deprel tag frequency)
async function computeKeynessWithDep(featureType, minFreq, topN) {
  const keyStatus = document.getElementById('keyStatus');
  const keyBody = document.getElementById('keyTableBody');
  const keynessBtn = document.getElementById('keynessBtn');
  const cancelBtn = document.getElementById('keyCancelBtn');
  
  keyStatus.textContent = 'Computing Dependency relation frequencies...';
  if (keynessBtn) keynessBtn.disabled = true;
  if (cancelBtn) cancelBtn.style.display = 'inline-flex';
  
  depComputationCancelled = false;
  
  
  try {
    await new Promise(r => setTimeout(r, 10));
    
    // Collect deprel frequencies
    const deprelMap = new Map(); // deprel -> { freqT, freqR, instances, filesT, filesR }
    let totalTokensT = 0, totalTokensR = 0;
    
    // Check if MTK is enabled
    const useMTK = document.getElementById('keyUseMTK')?.checked ?? false;
    
    // Collect file sizes for MTK calculation (only when MTK enabled)
    const targetFileSizes = useMTK ? {} : null;
    const referenceFileSizes = useMTK ? {} : null;
    
    // Get weighted pooled SD option
    const useWeightedPooledSD = document.getElementById('keyWeightedPooledSD')?.checked ?? false;
    
    // Only include files in Target or Reference (8) is Target vs Reference comparison only)
    const files = Object.values(corpus.files).filter(f => {
      if (corpus.mode !== 'csv' || !f.tokens) return false;
      const isTarget = targetFolders.has(f.folder);
      const isReference = referenceFolders.has(f.folder);
      return isTarget || isReference;
    });
    
    const totalFiles = files.length;
    let processedFiles = 0;
    
    for (const file of files) {
      if (depComputationCancelled) break;
      
      const isTarget = targetFolders.has(file.folder);
      const isReference = referenceFolders.has(file.folder);
      
      // Count tokens for Target and Reference separately (excluding punctuation)
      let fileTokenCount = 0;
      for (const tok of file.tokens) {
        if (!isPunctuationOrSpaceToken(tok)) fileTokenCount++;
      }
      if (isTarget) {
        totalTokensT += fileTokenCount;
        if (targetFileSizes) targetFileSizes[file.name] = fileTokenCount;
      }
      if (isReference) {
        totalTokensR += fileTokenCount;
        if (referenceFileSizes) referenceFileSizes[file.name] = fileTokenCount;
      }
      
      // Determine side for instances: T, R, or B (both)
      let side = 'N';
      if (isTarget && isReference) side = 'B';
      else if (isTarget) side = 'T';
      else if (isReference) side = 'R';
      
      // Build token index by token_id (ensure consistent key type)
      const tokenById = new Map();
      file.tokens.forEach((tok, idx) => {
        const tokenId = tok.token_id != null ? String(tok.token_id) : String(idx);
        tokenById.set(tokenId, { ...tok, arrayIndex: idx });
        // Also add by index for fallback
        tokenById.set(String(idx), { ...tok, arrayIndex: idx });
      });
      
      // Build sentence map for sent_text reconstruction
      const sentenceMap = new Map(); // sent_id -> [tokens]
      file.tokens.forEach((tok, idx) => {
        const sentId = tok.sent_id;
        if (sentId != null) {
          if (!sentenceMap.has(sentId)) {
            sentenceMap.set(sentId, []);
          }
          sentenceMap.get(sentId).push(tok);
        }
      });
      
      // Count deprel for each token
      file.tokens.forEach((tok, idx) => {
        const deprel = tok.deprel || tok.dep || '';
        if (!deprel || deprel === 'ROOT' || deprel === 'root') return;
        
        // Get governor (head) word - use head_text directly if available
        let governor = tok.head_text || '';
        if (!governor) {
          // Fallback: look up by head_id
          const headId = tok.head_id ?? tok.head;
          const headIdStr = headId != null ? String(headId) : null;
          const headTok = headIdStr ? tokenById.get(headIdStr) : null;
          governor = headTok ? (headTok.word || '') : '';
        }
        const dependent = tok.word || '';
        
        // Get sentence text
        let sentText = tok.sent_text || '';
        if (!sentText && tok.sent_id != null) {
          // Reconstruct from sentence tokens
          const sentTokens = sentenceMap.get(tok.sent_id) || [];
          sentText = sentTokens.map(t => t.word || '').join(' ');
        }
        
        if (!deprelMap.has(deprel)) {
          deprelMap.set(deprel, {
            freqT: 0, freqR: 0,
            fileFreqT: new Map(), fileFreqR: new Map(),
            instances: []
          });
        }
        
        const entry = deprelMap.get(deprel);
        
        // Count for Target if in Target
        if (isTarget) {
          entry.freqT++;
          entry.fileFreqT.set(file.name, (entry.fileFreqT.get(file.name) || 0) + 1);
        }
        
        // Count for Reference if in Reference (even if also in Target)
        if (isReference) {
          entry.freqR++;
          entry.fileFreqR.set(file.name, (entry.fileFreqR.get(file.name) || 0) + 1);
        }
        
        // Get head index for fallback
        const headId = tok.head_id ?? tok.head;
        const headIdStr = headId != null ? String(headId) : null;
        const headTok = headIdStr ? tokenById.get(headIdStr) : null;
        
        // Limit instances to prevent memory issues
        if (entry.instances.length < 10000) {
          entry.instances.push({
            fileId: file.id,
            fileName: file.name,
            folder: file.folder,
            side,
            sentId: tok.sent_id,
            sentText: sentText,
            governor: governor,
            dependent: dependent,
            headIdx: headTok ? headTok.arrayIndex : -1,
            depIdx: idx
          });
        }
      });
      
      processedFiles++;
      if (processedFiles % 50 === 0 || processedFiles === totalFiles) {
        keyStatus.textContent = `Phase 1/2: Scanning files... ${processedFiles}/${totalFiles}`;
        await new Promise(r => setTimeout(r, 0));
      }
    }
    
    if (depComputationCancelled) {
      keyStatus.textContent = 'Computation cancelled.';
      if (keynessBtn) keynessBtn.disabled = false;
      if (cancelBtn) cancelBtn.style.display = 'none';
      return;
    }
    
    keyStatus.textContent = 'Phase 2/2: Computing keyness...';
    await new Promise(r => setTimeout(r, 0));
    
    // Get file counts
    const targetFileCount = getTargetFileCount();
    const refFileCount = getReferenceFileCount();
    
    // Convert to array and calculate keyness
    const results = [];
    deprelMap.forEach((data, deprel) => {
      const totalFreq = data.freqT + data.freqR;
      if (totalFreq < minFreq) return;
      
      const normT = totalTokensT > 0 ? (data.freqT / totalTokensT) * 1000000 : 0;
      const normR = totalTokensR > 0 ? (data.freqR / totalTokensR) * 1000000 : 0;
      
      // Keyness: Target vs Reference
      const ll = computeLL(data.freqT, data.freqR, totalTokensT, totalTokensR);
      const textLL = computeLL(data.fileFreqT.size, data.fileFreqR.size, targetFileCount, refFileCount);
      
      // Effect size calculation (only when Use MTK is checked)
      let cohensD = null;
      if (useMTK && targetFileSizes && referenceFileSizes) {
        // Mean Text Keyness calculation
        cohensD = computeMeanTextKeynessFromMaps(
          data.fileFreqT,
          data.fileFreqR,
          targetFileSizes,
          referenceFileSizes,
          targetFileCount,
          refFileCount,
          useWeightedPooledSD
        );
      }
      
      results.push({
        feature: deprel,
        freqT: data.freqT,
        freqR: data.freqR,
        normT,
        normR,
        rangeT: data.fileFreqT.size,
        rangeR: data.fileFreqR.size,
        ll,
        textLL,
        cohensD,
        filesT: data.fileFreqT.size,
        filesR: data.fileFreqR.size,
        instances: data.instances
      });
    });
    
    // Sort by Freq-LL desc
    results.sort((a, b) => (b.ll || 0) - (a.ll || 0));
    
    // Store for 11b) linking - use separate array for 8) Keyness
    keynessDepPatternRows = [...results];
    lastDepScope = 'target';
    
    // Display in 8) table
    displayDepKeynessResults(results, topN);
    
    keyStatus.textContent = `DEP Features: ${results.length} (showing top ${Math.min(topN, results.length)}) - Click row to view concordance in 12b)`;
  } catch (e) {
    keyStatus.textContent = 'Error: ' + e.message;
    console.error(e);
  } finally {
    if (keynessBtn) keynessBtn.disabled = false;
    if (cancelBtn) cancelBtn.style.display = 'none';
  }
}

// Display DEP results in 8) Keyness table
function displayDepKeynessResults(rows, topN) {
  const keyBody = document.getElementById('keyTableBody');
  const advanced = document.getElementById('keyAdvancedStats')?.checked ?? false;
  
  if (!keyBody) return;
  
  // テーブル構造を更新
  updateKeynessTableStructure(advanced);
  
  const displayRows = rows.slice(0, topN);
  const numCols = advanced ? 19 : 13;
  
  let html = '';
  displayRows.forEach((row, idx) => {
    html += `<tr onclick="showDepConcordanceFromKeyness(${idx})" style="cursor:pointer;" title="Click to view concordance in 12b)">`;
    html += `<td>${idx + 1}</td>`;
    html += `<td class="mono">${escapeHtml(row.feature)}</td>`;
    html += `<td class="text-right">${row.freqT.toLocaleString()}</td>`;
    html += `<td class="text-right">${row.normT.toFixed(2)}</td>`;
    html += `<td class="text-right">${row.filesT || 0}</td>`;
    if (advanced) {
      html += `<td class="text-right">${row.rangeT || 0}</td>`;
      html += `<td class="text-right">${(row.juillandT || 0).toFixed(3)}</td>`;
      html += `<td class="text-right">${(row.dpT || 0).toFixed(3)}</td>`;
    }
    html += `<td class="text-right">${row.freqR.toLocaleString()}</td>`;
    html += `<td class="text-right">${row.normR.toFixed(2)}</td>`;
    html += `<td class="text-right">${row.filesR || 0}</td>`;
    if (advanced) {
      html += `<td class="text-right">${row.rangeR || 0}</td>`;
      html += `<td class="text-right">${(row.juillandR || 0).toFixed(3)}</td>`;
      html += `<td class="text-right">${(row.dpR || 0).toFixed(3)}</td>`;
    }
    html += `<td class="text-right">${formatLL(row.ll)}</td>`;
    html += `<td class="text-right">${formatLL(row.textLL)}</td>`;
    html += `<td class="text-right">${row.cohensD != null ? row.cohensD.toFixed(3) : '-'}</td>`;
    // Fillers columns (for DEP, show "-")
    html += `<td class="mono fillers-cell text-xs">-</td>`;
    html += `<td class="mono fillers-cell text-xs">-</td>`;
    html += '</tr>';
  });
  
  keyBody.innerHTML = html || `<tr><td colspan="${numCols}" class="text-xs">No DEP features found.</td></tr>`;
  
  // Add note below table
  const keyStatus = document.getElementById('keyStatus');
  if (keyStatus) {
    keyStatus.innerHTML = `DEP Features: ${rows.length} (showing top ${Math.min(topN, rows.length)})<br><span class="text-xs" style="color:#6b7280;">※ Click a row to view concordance in 12b)</span>`;
  }
}

// Show concordance in 12b) from 8) Keyness click
function showDepConcordanceFromKeyness(rowIdx) {
  // Use keynessDepPatternRows (8) Keyness data)
  if (rowIdx < 0 || rowIdx >= keynessDepPatternRows.length) return;
  
  const row = keynessDepPatternRows[rowIdx];
  currentDepFeature = row.feature;
  currentDepInstances = row.instances;
  
  // Expand 12) section if collapsed
  const section12 = document.getElementById('section12-content');
  const arrow12 = document.getElementById('section12-arrow');
  if (section12 && section12.style.display === 'none') {
    section12.style.display = 'block';
    if (arrow12) arrow12.textContent = '▼';
  }
  
  // Expand 12b) Concordance section
  const content = document.getElementById('section12b-content');
  const arrow = document.getElementById('section12b-arrow');
  if (content && content.style.display === 'none') {
    content.style.display = 'block';
    if (arrow) arrow.textContent = '▼';
  }
  
  // Update concordance UI
  document.getElementById('depConcordanceFeature').textContent = row.feature;
  document.getElementById('depConcordanceCount').textContent = currentDepInstances.length.toLocaleString();
  
  // Set scope filter
  const concScope = document.getElementById('depConcScope');
  if (concScope) concScope.value = lastDepScope;
  
  updateDepConcordanceDisplay();
  
  // Scroll to 12b) with a slight delay to ensure the section is expanded
  setTimeout(() => {
    const section12b = document.getElementById('section12b-header');
    if (section12b) {
      section12b.scrollIntoView({ behavior: 'smooth', block: 'start' });
    }
  }, 100);
}

// Redirect to 12) Dependency Grammar section from 7)/9a) Feature Type selection
function redirectToDepSection() {
  // Expand 12) section
  const section12 = document.getElementById('section12-content');
  const arrow12 = document.getElementById('section12-arrow');
  if (section12 && section12.style.display === 'none') {
    section12.style.display = 'block';
    if (arrow12) arrow12.textContent = '▼';
  }
  
  // Expand 12a) section
  const section12a = document.getElementById('section12a-content');
  const arrow12a = document.getElementById('section12a-arrow');
  if (section12a && section12a.style.display === 'none') {
    section12a.style.display = 'block';
    if (arrow12a) arrow12a.textContent = '▼';
  }
  
  // Scroll to 12a)
  const section12aHeader = document.querySelector('#section12a-header');
  if (section12aHeader) {
    section12aHeader.scrollIntoView({ behavior: 'smooth', block: 'start' });
  }
}

// ===== Column Resize =====
function initKeyTableResize() {
  const table = document.getElementById('keyTable');
  if (!table) return;
  
  const cols = table.querySelectorAll('colgroup col');
  const resizers = table.querySelectorAll('.key-col-resizer');

  resizers.forEach((resizer) => {
    const colIndex = parseInt(resizer.dataset.col, 10);
    const col = cols[colIndex];
    if (!col) return;

    let startX = 0;
    let startWidth = 0;

    const onMouseMove = (e) => {
      const dx = e.pageX - startX;
      const newWidth = Math.max(40, startWidth + dx);
      col.style.width = newWidth + 'px';
    };

    const onMouseUp = () => {
      document.removeEventListener('mousemove', onMouseMove);
      document.removeEventListener('mouseup', onMouseUp);
    };

    resizer.addEventListener('mousedown', (e) => {
      e.preventDefault();
      e.stopPropagation();
      startX = e.pageX;
      const colStyle = window.getComputedStyle(col);
      const width = parseFloat(colStyle.width);
      startWidth = isNaN(width) ? resizer.parentElement.offsetWidth : width;
      document.addEventListener('mousemove', onMouseMove);
      document.addEventListener('mouseup', onMouseUp);
    });
  });
}

function initHfTableResize() {
  const table = document.getElementById('hfTable');
  if (!table) return;
  
  const cols = table.querySelectorAll('colgroup col');
  const resizers = table.querySelectorAll('.hf-col-resizer');

  resizers.forEach((resizer) => {
    const colIndex = parseInt(resizer.dataset.col, 10);
    const col = cols[colIndex];
    if (!col) return;

    let startX = 0;
    let startWidth = 0;

    const onMouseMove = (e) => {
      const dx = e.pageX - startX;
      const newWidth = Math.max(40, startWidth + dx);
      col.style.width = newWidth + 'px';
    };

    const onMouseUp = () => {
      document.removeEventListener('mousemove', onMouseMove);
      document.removeEventListener('mouseup', onMouseUp);
    };

    resizer.addEventListener('mousedown', (e) => {
      e.preventDefault();
      e.stopPropagation();
      startX = e.pageX;
      const colStyle = window.getComputedStyle(col);
      const width = parseFloat(colStyle.width);
      startWidth = isNaN(width) ? resizer.parentElement.offsetWidth : width;
      document.addEventListener('mousemove', onMouseMove);
      document.addEventListener('mouseup', onMouseUp);
    });
  });
}

function initKwicTableResize() {
  const table = document.getElementById('kwicTable');
  if (!table) return;
  const cols = table.querySelectorAll('colgroup col');
  const headers = table.querySelectorAll('thead th');

  headers.forEach((th, index) => {
    th.style.position = 'relative';
    const resizer = document.createElement('div');
    resizer.className = 'col-resizer';
    th.appendChild(resizer);

    let startX = 0;
    let startWidth = 0;

    const onMouseMove = (e) => {
      const dx = e.pageX - startX;
      const newWidth = Math.max(40, startWidth + dx);
      const col = cols[index];
      col.style.width = newWidth + 'px';
    };

    const onMouseUp = () => {
      document.removeEventListener('mousemove', onMouseMove);
      document.removeEventListener('mouseup', onMouseUp);
    };

    resizer.addEventListener('mousedown', (e) => {
      e.preventDefault();
      startX = e.pageX;
      const col = cols[index];
      const colStyle = window.getComputedStyle(col);
      const width = parseFloat(colStyle.width);
      startWidth = isNaN(width) ? th.offsetWidth : width;
      document.addEventListener('mousemove', onMouseMove);
      document.addEventListener('mouseup', onMouseUp);
    });
  });
}

// ===== KWIC Helpers =====
function tokenToString(tok, viewMode) {
  if (viewMode === 'tagged' && (corpus.mode === 'tagged' || corpus.mode === 'csv')) {
    const w = tok.word || '';
    const posd = tok.posd || '';
    const poss = tok.poss || '';
    const lemma = tok.lemma || tok.word || '';
    let result = `${w}_${posd}_${poss}_${lemma}`;
    
    // CSVモードでBiberタグがある場合は常に末尾に追加
    if (corpus.mode === 'csv' && tok.biberTags && tok.biberTags.length > 0) {
      result += `_[${tok.biberTags.join('|')}]`;
    }
    return result;
  }
  
  return tok.word || '';
}

// Biberタグでトークンをフィルタリング
function tokenMatchesBiberFilter(tok, selectedTags, matchMode) {
  if (!selectedTags || selectedTags.length === 0) return true;
  if (!tok.biberTags || tok.biberTags.length === 0) return false;
  
  if (matchMode === 'all') {
    // AND: 全ての選択タグがトークンに存在する必要がある
    return selectedTags.every(tag => tok.biberTags.includes(tag));
  } else {
    // OR (any): いずれかの選択タグがトークンに存在すれば良い
    return selectedTags.some(tag => tok.biberTags.includes(tag));
  }
}

// N-gramの全トークンがBiberフィルタにマッチするかチェック
function tokensMatchBiberFilter(tokens, startIdx, endIdx, selectedTags, matchMode) {
  if (!selectedTags || selectedTags.length === 0) return true;
  
  // N-gramの場合、少なくとも1つのトークンがマッチすればOK
  for (let i = startIdx; i < endIdx; i++) {
    const tok = tokens[i];
    if (isPunctuationOrSpaceToken(tok)) continue;
    if (tokenMatchesBiberFilter(tok, selectedTags, matchMode)) {
      return true;
    }
  }
  return false;
}

function getKwicViewMode() {
  const taggedRadio = document.querySelector('input[name="kwicView"][value="tagged"]');
  const surfaceRadio = document.querySelector('input[name="kwicView"][value="surface"]');
  if (taggedRadio && !taggedRadio.disabled && taggedRadio.checked) return 'tagged';
  return 'surface';
}

function getOriginalViewMode() {
  const taggedRadio = document.querySelector('input[name="originalView"][value="tagged"]');
  const surfaceRadio = document.querySelector('input[name="originalView"][value="surface"]');
  if (taggedRadio && !taggedRadio.disabled && taggedRadio.checked) return 'tagged';
  return 'surface';
}

function updateKwicViewOptions() {
  const taggedRadio = document.querySelector('input[name="kwicView"][value="tagged"]');
  const surfaceRadio = document.querySelector('input[name="kwicView"][value="surface"]');
  if (!taggedRadio || !surfaceRadio) return;
  if (corpus && (corpus.mode === 'tagged' || corpus.mode === 'csv')) {
    taggedRadio.disabled = false;
  } else {
    taggedRadio.disabled = true;
    surfaceRadio.checked = true;
  }
  
  // Biberフィルタの表示/非表示を更新
  updateKwicBiberFilterVisibility();
}

function updateOriginalViewOptions() {
  const taggedRadio = document.querySelector('input[name="originalView"][value="tagged"]');
  const surfaceRadio = document.querySelector('input[name="originalView"][value="surface"]');
  if (!taggedRadio || !surfaceRadio) return;
  if (corpus && (corpus.mode === 'tagged' || corpus.mode === 'csv')) {
    taggedRadio.disabled = false;
  } else {
    taggedRadio.disabled = true;
    surfaceRadio.checked = true;
  }
}

function getPosColorMap() {
  const bluePos = document.getElementById('bluePosSelect').value || 'L1';
  const redPos = document.getElementById('redPosSelect').value || 'Node';
  const greenPos = document.getElementById('greenPosSelect').value || 'R1';
  const rangeMode = document.getElementById('colorPosRange')?.checked || false;
  
  const map = {};
  
  // Helper to add positions to map
  const addPosition = (pos, color) => {
    if (!pos) return;
    if (!rangeMode || pos === 'Node') {
      map[pos] = color;
    } else {
      // Range mode: add all positions from 1 to N
      const match = pos.match(/^([LR])(\d)$/);
      if (match) {
        const side = match[1];
        const num = parseInt(match[2]);
        for (let i = 1; i <= num; i++) {
          const key = `${side}${i}`;
          if (!map[key]) map[key] = color;
        }
      } else {
        map[pos] = color;
      }
    }
  };
  
  // Apply colors - order matters for overlap (later colors override)
  addPosition(bluePos, '#1d4ed8');
  addPosition(redPos, '#dc2626');
  addPosition(greenPos, '#059669');
  
  return map;
}

function makeKwicRow(file, sent, startIdx, endIdx, side, viewMode) {
  const leftWidthInput = document.getElementById('kwicLeftWidth');
  const rightWidthInput = document.getElementById('kwicRightWidth');
  let L = parseInt(leftWidthInput.value, 10);
  let R = parseInt(rightWidthInput.value, 10);
  if (!Number.isFinite(L) || L <= 0) L = 15;
  if (!Number.isFinite(R) || R <= 0) R = 15;

  const tokens = file.tokens;

  // Build left context - include all tokens (punctuation too) but count only words for L limit
  const leftTokensAll = [];
  const leftLemmasAll = [];
  let leftWordCount = 0;
  for (let i = sent.tokenStart; i < startIdx; i++) {
    const tok = tokens[i];
    if (!isPunctuationOrSpaceToken(tok)) {
      leftTokensAll.push(tokenToString(tok, viewMode));
      leftLemmasAll.push(tok.lemma ? tok.lemma.toLowerCase() : tok.word.toLowerCase());
      leftWordCount++;
    } else if (tok.word) {
      // Include punctuation in display
      leftTokensAll.push(tok.word);
      leftLemmasAll.push(tok.word);
    }
  }
  // Keep last L words worth of tokens
  let leftCutIdx = 0;
  let wordsFromEnd = 0;
  for (let i = leftTokensAll.length - 1; i >= 0 && wordsFromEnd < L; i--) {
    if (!isPunctuationWord(leftLemmasAll[i])) {
      wordsFromEnd++;
    }
    leftCutIdx = i;
  }
  const leftTokens = leftTokensAll.slice(leftCutIdx);
  const leftLemmas = leftLemmasAll.slice(leftCutIdx);

  // Build node - include punctuation within the matched range
  const nodeTokens = [];
  const nodeTokensWords = []; // Words only for filtering
  for (let i = startIdx; i < endIdx; i++) {
    const tok = tokens[i];
    if (!isPunctuationOrSpaceToken(tok)) {
      nodeTokens.push(tokenToString(tok, viewMode));
      nodeTokensWords.push(tokenToString(tok, viewMode));
    } else if (tok.word) {
      nodeTokens.push(tok.word);
    }
  }

  // Build right context - include all tokens but count only words for R limit
  const rightTokensAll = [];
  const rightLemmasAll = [];
  let rightWordCount = 0;
  for (let i = endIdx; i < sent.tokenEnd; i++) {
    const tok = tokens[i];
    if (!isPunctuationOrSpaceToken(tok)) {
      rightTokensAll.push(tokenToString(tok, viewMode));
      rightLemmasAll.push(tok.lemma ? tok.lemma.toLowerCase() : tok.word.toLowerCase());
      rightWordCount++;
    } else if (tok.word) {
      rightTokensAll.push(tok.word);
      rightLemmasAll.push(tok.word);
    }
  }
  // Keep first R words worth of tokens
  let rightCutIdx = rightTokensAll.length;
  let wordsFromStart = 0;
  for (let i = 0; i < rightTokensAll.length && wordsFromStart < R; i++) {
    if (!isPunctuationWord(rightLemmasAll[i])) {
      wordsFromStart++;
    }
    rightCutIdx = i + 1;
  }
  const rightTokens = rightTokensAll.slice(0, rightCutIdx);
  const rightLemmas = rightLemmasAll.slice(0, rightCutIdx);

  return {
    side,
    folder: file.folder,
    fileName: file.name,
    fileId: file.id,
    sentStart: sent.tokenStart,
    sentEnd: sent.tokenEnd,
    matchStart: startIdx,
    matchEnd: endIdx,
    leftTokens,
    leftLemmas,
    nodeTokens,
    nodeTokensWords, // For filter matching (words only)
    rightTokens,
    rightLemmas,
    leftText: leftTokens.join(' '),
    nodeText: nodeTokens.join(' '),
    rightText: rightTokens.join(' '),
    // Store words-only versions for filtering
    leftWordsText: leftTokens.filter(t => !isPunctuationWord(t)).join(' '),
    nodeWordsText: nodeTokensWords.join(' '),
    rightWordsText: rightTokens.filter(t => !isPunctuationWord(t)).join(' ')
  };
}

function displayWildcardMatches(featureType, matchCounts, feature) {
  const wildcardArea = document.getElementById('kwicWildcardMatches');
  if (!wildcardArea) return;
  
  // Check if feature contains wildcard patterns (* or ?)
  const hasWildcard = feature && (feature.includes('*') || feature.includes('?'));
  
  // Get search mode
  const searchModeSelect = document.getElementById('kwicSearchMode');
  const searchMode = searchModeSelect ? searchModeSelect.value : 'exact';
  
  // Show for wildcard/regex search modes, or for n-gram/p-frame with wildcard patterns
  const isWildcardSearch = searchMode === 'wildcard' || searchMode === 'regex';
  const isNgramPframe = featureType.startsWith('ngram') || featureType.startsWith('pframe');
  
  if (!isWildcardSearch && !(isNgramPframe && hasWildcard) && featureType !== 'regex') {
    wildcardArea.style.display = 'none';
    return;
  }
  
  const entries = Object.entries(matchCounts);
  if (entries.length === 0) {
    wildcardArea.style.display = 'none';
    return;
  }
  
  // Sort by frequency descending
  entries.sort((a, b) => b[1] - a[1]);
  
  // Build display HTML
  let typeLabel = 'Pattern';
  if (searchMode === 'wildcard') typeLabel = 'Wildcard';
  else if (searchMode === 'regex' || featureType === 'regex') typeLabel = 'Regex';
  else if (isNgramPframe) typeLabel = 'Matched';
  
  const items = entries.map(([word, freq]) => {
    return '<span style="margin-right:0.75rem;">' + escapeHtml(word) + ' <span style="color:#6b7280;">(' + freq + ')</span></span>';
  });
  
  // Initial display limit
  const initialShow = 30;
  const totalCount = items.length;
  
  let html = '<strong>' + typeLabel + ' matches (' + totalCount + ' types):</strong> ';
  
  if (totalCount > initialShow) {
    // Create container with initial items and hidden items
    html += '<span id="wildcardInitialItems">' + items.slice(0, initialShow).join('') + '</span>';
    html += '<span id="wildcardMoreItems" style="display:none;">' + items.slice(initialShow).join('') + '</span>';
    html += '<button type="button" id="wildcardShowMoreBtn" class="btn btn-xs" style="margin-left:0.5rem; padding:0.15rem 0.5rem; font-size:0.7rem; background:#6b7280;">';
    html += 'Show more (' + (totalCount - initialShow) + ')</button>';
  } else {
    html += items.join('');
  }
  
  wildcardArea.innerHTML = html;
  wildcardArea.style.display = 'block';
  
  // Add click handler for Show more button
  const showMoreBtn = document.getElementById('wildcardShowMoreBtn');
  if (showMoreBtn) {
    showMoreBtn.addEventListener('click', () => {
      const moreItems = document.getElementById('wildcardMoreItems');
      if (moreItems) {
        if (moreItems.style.display === 'none') {
          moreItems.style.display = 'inline';
          showMoreBtn.textContent = 'Show less';
        } else {
          moreItems.style.display = 'none';
          showMoreBtn.textContent = 'Show more (' + (totalCount - initialShow) + ')';
        }
      }
    });
  }
}

// Build a matcher function based on search mode
// Returns a function that takes a string and returns true if it matches
function buildMatcherCreator(pattern, searchMode, caseInsensitive) {
  // Handle multiple patterns separated by |
  const patterns = pattern.split('|').map(p => p.trim()).filter(p => p.length > 0);
  if (patterns.length === 0) {
    throw new Error('Empty pattern');
  }
  
  // Create matchers for each pattern
  const matchers = patterns.map(pat => {
    if (searchMode === 'regex') {
      // Regex mode
      const regex = new RegExp(pat, caseInsensitive ? 'i' : '');
      return (val) => regex.test(val);
    } else if (searchMode === 'wildcard') {
      // Wildcard mode: * matches any characters, ? matches single character
      let regexStr = pat;
      // Escape regex special chars except * and ?
      regexStr = regexStr.replace(/[.+^${}()|[\]\\]/g, '\\$&');
      // Replace * with .* and ? with .
      regexStr = regexStr.replace(/\*/g, '.*');
      regexStr = regexStr.replace(/\?/g, '.');
      const regex = new RegExp('^' + regexStr + '$', caseInsensitive ? 'i' : '');
      return (val) => regex.test(val);
    } else {
      // Exact mode
      const target = caseInsensitive ? pat.toLowerCase() : pat;
      return (val) => (caseInsensitive ? val.toLowerCase() : val) === target;
    }
  });
  
  // Return a function that checks if any matcher matches
  return (val) => matchers.some(matcher => matcher(val));
}

// Build matcher for multi-word patterns (n-grams)
function buildMultiWordMatcher(patternTokens, searchMode, caseInsensitive) {
  const tokenMatchers = patternTokens.map(t => {
    if (t === '*') {
      // Standalone * in p-frame slot matches any single word
      return { type: 'any' };
    }
    
    // Handle multiple alternatives with | within a token
    const alternatives = t.split('|').map(p => p.trim()).filter(p => p.length > 0);
    if (alternatives.length === 0) {
      return { type: 'exact', match: () => false };
    }
    
    const altMatchers = alternatives.map(alt => {
      if (searchMode === 'regex') {
        const regex = new RegExp(alt, caseInsensitive ? 'i' : '');
        return (val) => regex.test(val);
      } else if (searchMode === 'wildcard' || alt.includes('*') || alt.includes('?')) {
        // Wildcard mode or pattern contains wildcards
        let regexStr = alt;
        regexStr = regexStr.replace(/[.+^${}()|[\]\\]/g, '\\$&');
        regexStr = regexStr.replace(/\*/g, '.*');
        regexStr = regexStr.replace(/\?/g, '.');
        const regex = new RegExp('^' + regexStr + '$', caseInsensitive ? 'i' : '');
        return (val) => regex.test(val);
      } else {
        // Exact match
        const target = caseInsensitive ? alt.toLowerCase() : alt;
        return (val) => (caseInsensitive ? val.toLowerCase() : val) === target;
      }
    });
    
    return {
      type: 'pattern',
      match: (val) => altMatchers.some(m => m(val))
    };
  });
  
  return tokenMatchers;
}

// Initialize Advanced KWIC with first token
function initAdvancedKwicTokens() {
  const container = document.getElementById('kwicAdvancedInputs');
  if (!container) return;
  
  container.innerHTML = '';
  addAdvancedKwicToken(0);
}

// Add a new token to Advanced KWIC search
function addAdvancedKwicToken(idx, prefill = null) {
  const container = document.getElementById('kwicAdvancedInputs');
  if (!container) return;
  
  const isTagged = corpus && (corpus.mode === 'tagged' || corpus.mode === 'csv');
  
  // Get available POS tags from corpus
  let posSimpleTags = [];
  let posDetailTags = [];
  if (isTagged && corpus.files) {
    const simpleSet = new Set();
    const detailSet = new Set();
    for (const file of Object.values(corpus.files)) {
      if (file.tokens) {
        for (const tok of file.tokens) {
          if (tok.poss) simpleSet.add(tok.poss);
          if (tok.posd) detailSet.add(tok.posd);
        }
      }
    }
    posSimpleTags = Array.from(simpleSet).sort();
    posDetailTags = Array.from(detailSet).sort();
  }
  
  const tokenDiv = document.createElement('div');
  tokenDiv.id = `kwicAdvToken_${idx}`;
  tokenDiv.className = 'kwic-adv-token';
  tokenDiv.style.cssText = 'margin-bottom:0.5rem; padding:0.5rem; background:#fff; border:1px solid #ccc; border-radius:6px; box-shadow:0 1px 3px rgba(0,0,0,0.1);';
  
  // Pre-fill values
  const pf = prefill || { surface: '', posd: [], poss: [], lemma: '', posdText: '', possText: '' };
  // Handle text input prefills
  const posdTextVal = pf.posdText || (pf.posd && pf.posd.length > 0 ? pf.posd.join('|') : '');
  const possTextVal = pf.possText || (pf.poss && pf.poss.length > 0 ? pf.poss.join('|') : '');
  
  tokenDiv.innerHTML = `
    <!-- Row 1: Token header and buttons -->
    <div style="display:flex; align-items:center; gap:0.5rem; flex-wrap:wrap; margin-bottom:0.4rem;">
      <span style="font-weight:bold; min-width:60px; font-size:0.85rem; color:#333;">Token ${idx + 1}:</span>
      <button type="button" class="small" style="padding:0.2rem 0.5rem; font-size:0.85rem; font-weight:bold; background:#4a90d9; color:white; border:none; border-radius:3px;" onclick="addAdvancedKwicToken(${idx + 1})" title="Add token">+</button>
      ${idx > 0 ? `<button type="button" class="small btn-clear" style="padding:0.2rem 0.4rem; font-size:0.8rem; background:#dc3545; color:white; border:none; border-radius:3px;" onclick="removeAdvancedKwicToken(${idx})" title="Remove token">−</button>` : ''}
      <span style="font-size:0.7rem; color:#666; margin-left:auto;">Pattern:</span>
      <input type="text" id="kwicAdvTokenPattern_${idx}" style="width:200px; font-size:0.75rem; font-family:monospace; padding:0.2rem 0.4rem; background:#f5f5f5; border:1px solid #ddd; border-radius:3px;" value="${generateTokenPattern(pf)}" oninput="parseTokenPatternToFields(${idx}); updateAdvancedPattern()">
    </div>
    <!-- Row 2: Main input fields in 2x2 grid -->
    <div style="display:grid; grid-template-columns:1fr 1fr; gap:0.5rem; margin-bottom:0.4rem; padding:0.4rem; background:#f8fafc; border:1px solid #e0e0e0; border-radius:4px;">
      <div style="display:flex; align-items:center; gap:0.3rem;">
        <label style="font-size:0.75rem; font-weight:bold; min-width:55px;">Surface:</label>
        <input type="text" id="kwicAdvSurface_${idx}" style="flex:1; min-width:80px; font-size:0.8rem; padding:0.25rem 0.4rem; border:1px solid #ccc; border-radius:3px;" placeholder="* or word" value="${escapeHtml(pf.surface)}" oninput="updateAdvancedPattern()">
      </div>
      <div style="display:flex; align-items:center; gap:0.3rem;">
        <label style="font-size:0.75rem; font-weight:bold; min-width:55px;">Lemma:</label>
        <input type="text" id="kwicAdvLemma_${idx}" style="flex:1; min-width:80px; font-size:0.8rem; padding:0.25rem 0.4rem; border:1px solid #ccc; border-radius:3px;" placeholder="*" value="${escapeHtml(pf.lemma)}" oninput="updateAdvancedPattern()">
      </div>
      <div style="display:flex; align-items:center; gap:0.3rem;">
        <label style="font-size:0.75rem; font-weight:bold; min-width:55px; color:#1a5f9e;">POS(d):</label>
        <input type="text" id="kwicAdvPosdText_${idx}" style="flex:1; min-width:80px; font-size:0.8rem; padding:0.25rem 0.4rem; border:1px solid #cce0ff; border-radius:3px; background:#f0f8ff;" placeholder="NN|VB or *" value="${escapeHtml(posdTextVal)}" oninput="syncPosdTextToChecks(${idx}); updateAdvancedPattern()">
      </div>
      <div style="display:flex; align-items:center; gap:0.3rem;">
        <label style="font-size:0.75rem; font-weight:bold; min-width:55px; color:#1a7f4e;">POS(s):</label>
        <input type="text" id="kwicAdvPossText_${idx}" style="flex:1; min-width:80px; font-size:0.8rem; padding:0.25rem 0.4rem; border:1px solid #c0e8d0; border-radius:3px; background:#f0fff4;" placeholder="NOUN|VERB or *" value="${escapeHtml(possTextVal)}" oninput="syncPossTextToChecks(${idx}); updateAdvancedPattern()">
      </div>
    </div>
    ${isTagged ? `
    <!-- Row 3: POS(d) checkbox grid (collapsible) -->
    <details style="margin-top:0.3rem;">
      <summary style="cursor:pointer; font-size:0.75rem; color:#1a5f9e; font-weight:bold; padding:0.2rem;">▶ POS (detailed) checkboxes</summary>
      <div style="padding:0.4rem; background:#f0f8ff; border:1px solid #cce0ff; border-radius:4px; margin-top:0.2rem;">
        <div style="display:flex; align-items:center; gap:0.5rem; margin-bottom:0.3rem;">
          <button type="button" class="small" style="font-size:0.7rem; padding:0.1rem 0.4rem;" onclick="selectAllPosChecks('posd', ${idx})">Select All</button>
          <button type="button" class="small" style="font-size:0.7rem; padding:0.1rem 0.4rem;" onclick="clearPosChecks('posd', ${idx})">Clear All</button>
          <span id="kwicAdvPosdLabel_${idx}" style="font-size:0.75rem; color:#666; margin-left:auto;">${pf.posd.length > 0 ? 'Selected: ' + pf.posd.join(', ') : '(any)'}</span>
        </div>
        <div style="display:grid; grid-template-columns:repeat(auto-fill, minmax(55px, 1fr)); gap:0.2rem; max-height:100px; overflow-y:auto; padding:0.2rem; background:#fff; border:1px solid #ddd; border-radius:3px;">
          ${posDetailTags.map(t => `
            <label style="font-size:0.75rem; display:flex; align-items:center; gap:0.15rem; cursor:pointer; white-space:nowrap; padding:0.1rem 0.2rem; background:#fafafa; border:1px solid #eee; border-radius:2px; user-select:none;">
              <input type="checkbox" class="kwicAdvPosdCheck_${idx}" value="${t}" ${pf.posd.includes(t) ? 'checked' : ''} onchange="syncPosdChecksToText(${idx}); updatePosLabel('posd', ${idx}); updateAdvancedPattern()" style="margin:0;">
              ${t}
            </label>
          `).join('')}
        </div>
      </div>
    </details>
    <!-- Row 4: POS(s) checkbox grid (collapsible) -->
    <details style="margin-top:0.3rem;">
      <summary style="cursor:pointer; font-size:0.75rem; color:#1a7f4e; font-weight:bold; padding:0.2rem;">▶ POS (simple) checkboxes</summary>
      <div style="padding:0.4rem; background:#f0fff4; border:1px solid #c0e8d0; border-radius:4px; margin-top:0.2rem;">
        <div style="display:flex; align-items:center; gap:0.5rem; margin-bottom:0.3rem;">
          <button type="button" class="small" style="font-size:0.7rem; padding:0.1rem 0.4rem;" onclick="selectAllPosChecks('poss', ${idx})">Select All</button>
          <button type="button" class="small" style="font-size:0.7rem; padding:0.1rem 0.4rem;" onclick="clearPosChecks('poss', ${idx})">Clear All</button>
          <span id="kwicAdvPossLabel_${idx}" style="font-size:0.75rem; color:#666; margin-left:auto;">${pf.poss.length > 0 ? 'Selected: ' + pf.poss.join(', ') : '(any)'}</span>
        </div>
        <div style="display:grid; grid-template-columns:repeat(auto-fill, minmax(70px, 1fr)); gap:0.2rem; max-height:80px; overflow-y:auto; padding:0.2rem; background:#fff; border:1px solid #ddd; border-radius:3px;">
          ${posSimpleTags.map(t => `
            <label style="font-size:0.75rem; display:flex; align-items:center; gap:0.15rem; cursor:pointer; white-space:nowrap; padding:0.1rem 0.2rem; background:#fafafa; border:1px solid #eee; border-radius:2px; user-select:none;">
              <input type="checkbox" class="kwicAdvPossCheck_${idx}" value="${t}" ${pf.poss.includes(t) ? 'checked' : ''} onchange="syncPossChecksToText(${idx}); updatePosLabel('poss', ${idx}); updateAdvancedPattern()" style="margin:0;">
              ${t}
            </label>
          `).join('')}
        </div>
      </div>
    </details>
    ` : ''}
  `;
  
  container.appendChild(tokenDiv);
  updateAdvancedPattern();
}

// Sync POS(d) text input to checkboxes
function syncPosdTextToChecks(idx) {
  const textInput = document.getElementById(`kwicAdvPosdText_${idx}`);
  if (!textInput) return;
  
  const text = textInput.value.trim();
  const tags = text ? text.split('|').map(t => t.trim()).filter(t => t && t !== '*') : [];
  
  // Update checkboxes
  const checkboxes = document.querySelectorAll(`.kwicAdvPosdCheck_${idx}`);
  checkboxes.forEach(cb => {
    cb.checked = tags.includes(cb.value);
  });
  
  updatePosLabel('posd', idx);
}

// Sync POS(s) text input to checkboxes
function syncPossTextToChecks(idx) {
  const textInput = document.getElementById(`kwicAdvPossText_${idx}`);
  if (!textInput) return;
  
  const text = textInput.value.trim();
  const tags = text ? text.split('|').map(t => t.trim()).filter(t => t && t !== '*') : [];
  
  // Update checkboxes
  const checkboxes = document.querySelectorAll(`.kwicAdvPossCheck_${idx}`);
  checkboxes.forEach(cb => {
    cb.checked = tags.includes(cb.value);
  });
  
  updatePosLabel('poss', idx);
}

// Sync POS(d) checkboxes to text input
function syncPosdChecksToText(idx) {
  const checkboxes = document.querySelectorAll(`.kwicAdvPosdCheck_${idx}:checked`);
  const selected = Array.from(checkboxes).map(cb => cb.value);
  
  const textInput = document.getElementById(`kwicAdvPosdText_${idx}`);
  if (textInput) {
    textInput.value = selected.join('|');
  }
}

// Sync POS(s) checkboxes to text input
function syncPossChecksToText(idx) {
  const checkboxes = document.querySelectorAll(`.kwicAdvPossCheck_${idx}:checked`);
  const selected = Array.from(checkboxes).map(cb => cb.value);
  
  const textInput = document.getElementById(`kwicAdvPossText_${idx}`);
  if (textInput) {
    textInput.value = selected.join('|');
  }
}

// Generate token pattern string from prefill data
function generateTokenPattern(pf) {
  const surface = pf.surface || '*';
  const posd = pf.posd && pf.posd.length > 0 ? pf.posd.join('|') : '*';
  const poss = pf.poss && pf.poss.length > 0 ? pf.poss.join('|') : '*';
  const lemma = pf.lemma || '*';
  return `${surface}_${posd}_${poss}_${lemma}`;
}

// Toggle POS dropdown visibility
function togglePosDropdown(type, idx) {
  const dropdown = document.getElementById(`kwicAdv${type.charAt(0).toUpperCase() + type.slice(1)}Dropdown_${idx}`);
  if (dropdown) {
    dropdown.style.display = dropdown.style.display === 'none' ? 'block' : 'none';
  }
}

// Select all POS checkboxes
function selectAllPosChecks(type, idx) {
  const checkboxes = document.querySelectorAll(`.kwicAdv${type.charAt(0).toUpperCase() + type.slice(1)}Check_${idx}`);
  checkboxes.forEach(cb => cb.checked = true);
  updatePosLabel(type, idx);
  
  // Sync to text input
  if (type === 'posd') {
    syncPosdChecksToText(idx);
  } else if (type === 'poss') {
    syncPossChecksToText(idx);
  }
  
  updateAdvancedPattern();
}

// Clear all POS checkboxes
function clearPosChecks(type, idx) {
  const checkboxes = document.querySelectorAll(`.kwicAdv${type.charAt(0).toUpperCase() + type.slice(1)}Check_${idx}`);
  checkboxes.forEach(cb => cb.checked = false);
  updatePosLabel(type, idx);
  
  // Sync to text input
  if (type === 'posd') {
    syncPosdChecksToText(idx);
  } else if (type === 'poss') {
    syncPossChecksToText(idx);
  }
  
  updateAdvancedPattern();
}

// Update POS label with selected values
function updatePosLabel(type, idx) {
  const checkboxes = document.querySelectorAll(`.kwicAdv${type.charAt(0).toUpperCase() + type.slice(1)}Check_${idx}:checked`);
  const selected = Array.from(checkboxes).map(cb => cb.value);
  const label = document.getElementById(`kwicAdv${type.charAt(0).toUpperCase() + type.slice(1)}Label_${idx}`);
  if (label) {
    if (selected.length > 0) {
      label.textContent = 'Selected: ' + selected.join(', ');
      label.style.color = '#333';
    } else {
      label.textContent = '(any)';
      label.style.color = '#666';
    }
  }
}

// KWIC Folder Selector Functions
function toggleKwicFolderDropdown() {
  const dropdown = document.getElementById('kwicFolderDropdown');
  if (dropdown) {
    dropdown.style.display = dropdown.style.display === 'none' ? 'block' : 'none';
  }
}

function selectAllKwicFolders() {
  const checkboxes = document.querySelectorAll('.kwicFolderCheck');
  checkboxes.forEach(cb => cb.checked = true);
  updateKwicFolderLabel();
}

function clearAllKwicFolders() {
  const checkboxes = document.querySelectorAll('.kwicFolderCheck');
  checkboxes.forEach(cb => cb.checked = false);
  updateKwicFolderLabel();
}

function updateKwicFolderLabel() {
  const checkboxes = document.querySelectorAll('.kwicFolderCheck:checked');
  const selected = Array.from(checkboxes).map(cb => cb.value);
  const label = document.getElementById('kwicFolderLabel');
  if (label) {
    if (selected.length === 0) {
      label.textContent = '(select folders)';
    } else if (selected.length <= 3) {
      label.textContent = selected.join(', ');
    } else {
      label.textContent = `${selected.length} folders selected`;
    }
  }
}

function populateKwicFolderCheckboxes() {
  const container = document.getElementById('kwicFolderCheckboxes');
  if (!container || !corpus || !corpus.files) return;
  
  // Get unique folders from corpus
  const folders = new Set();
  for (const [filename, fileData] of Object.entries(corpus.files)) {
    if (fileData.folder) {
      folders.add(fileData.folder);
    }
  }
  
  const sortedFolders = Array.from(folders).sort();
  
  container.innerHTML = sortedFolders.map(folder => `
    <label style="font-size:0.75rem; display:flex; align-items:center; gap:0.2rem; cursor:pointer; padding:0.1rem 0.2rem; background:#fafafa; border:1px solid #eee; border-radius:2px;">
      <input type="checkbox" class="kwicFolderCheck" value="${folder}" onchange="updateKwicFolderLabel()">
      ${folder}
    </label>
  `).join('');
  
  console.log('[populateKwicFolderCheckboxes] Populated with', sortedFolders.length, 'folders');
}

function getSelectedKwicFolders() {
  const checkboxes = document.querySelectorAll('.kwicFolderCheck:checked');
  return Array.from(checkboxes).map(cb => cb.value);
}

function setSelectedKwicFolders(folders) {
  // Clear all first
  const allCheckboxes = document.querySelectorAll('.kwicFolderCheck');
  allCheckboxes.forEach(cb => cb.checked = false);
  
  // Check specified folders
  const foldersArray = Array.isArray(folders) ? folders : [folders];
  foldersArray.forEach(folder => {
    const checkbox = document.querySelector(`.kwicFolderCheck[value="${folder}"]`);
    if (checkbox) checkbox.checked = true;
  });
  
  updateKwicFolderLabel();
}

// ===== Biber Tag Filter Functions =====

// BiberPlusの96タグリスト（PDFより）
const BIBER_TAGS = [
  // Tense/Aspect
  'VBD', 'VPRT', 'PEAS', 'PGAS',
  // Pronouns
  'FPP1', 'SPP2', 'TPP3', 'PIT', 'INPR', 'DEMP', 'QUPR',
  // Pro-verb
  'PROD',
  // Questions
  'WHQU',
  // Nominals
  'NOMZ', 'GER', 'NN', 'NNP',
  // Passives
  'PASS', 'BYPA',
  // Be/Existential
  'BEMA', 'EX',
  // That-clauses
  'THVC', 'THATD',
  // Participial
  'PASTP', 'WZPAST', 'WZPRES',
  // Relatives
  'TSUB', 'TOBJ', 'WHSUB', 'WHOBJ', 'PIRE', 'SERE', 'WHCL',
  // Adverbial subordinators
  'CAUS', 'CONC', 'COND', 'OSUB',
  // Prepositions
  'PREP', 'PIN',
  // Adjectives
  'JJ', 'PRED', 'CMADJ', 'SPADJ',
  // Adverbs
  'RB', 'PLACE', 'TIME',
  // Conjuncts/Coordinators
  'CONJ', 'CCONJ', 'SCONJ', 'PHC', 'ANDC',
  // Downtoners/Amplifiers/Hedges
  'DWNT', 'AMP', 'HDG', 'EMPH',
  // Modals
  'POMD', 'NEMD', 'PRMD',
  // Verb classes
  'PUBV', 'PRIV', 'SUAV', 'SMP',
  // Contractions/Negation
  'CONT', 'XX0', 'SYNE',
  // Other syntax
  'STPR', 'SPIN', 'SPAU',
  // Quantifiers
  'QUAN',
  // Articles/Determiners
  'ART', 'INDA', 'DET', 'DEMO',
  // Auxiliaries
  'AUXB', 'INF', 'TO',
  // Pronouns (additional)
  'PRP', 'SBJP', 'ACCU',
  // Other
  'CAP', 'NUM', 'WH', 'X', 'UH',
  // Social media specific
  'EMOJ', 'EMOT', 'EXCL', 'HASH', 'LAUGH', 'QUES', 'QUOT', 'AT', 'URL', 'DPAR'
];

// 96 BiberPlus tags (official Biber-style grammatical/functional tags only)
// Excludes: function words (the, of, in, for, etc.), CAP, NNP, NUM, X, UH, EMOJ, EMOT, EXCL, HASH, LAUGH, QUES, QUOT, AT, URL, DPAR
const BIBER_PLUS_96 = new Set([
  // Tense/Aspect markers
  'VBD', 'VPRT', 'PEAS', 'PGAS',
  // Pronoun types
  'FPP1', 'SPP2', 'TPP3', 'PIT', 'INPR', 'DEMP', 'QUPR', 'PRP', 'SBJP', 'ACCU',
  // Pro-verb
  'PROD',
  // Questions
  'WHQU',
  // Nominals
  'NOMZ', 'GER', 'NN',
  // Passives
  'PASS', 'BYPA',
  // Be/Existential
  'BEMA', 'EX',
  // That-clauses
  'THVC', 'THATD', 'THAC',
  // Participial clauses
  'PASTP', 'WZPAST', 'WZPRES', 'PRESP',
  // Relatives
  'TSUB', 'TOBJ', 'WHSUB', 'WHOBJ', 'PIRE', 'SERE', 'WHCL',
  // Adverbial subordinators
  'CAUS', 'CONC', 'COND', 'OSUB',
  // Prepositions
  'PREP', 'PIN',
  // Adjectives
  'JJ', 'PRED', 'CMADJ', 'SPADJ',
  // Adverbs
  'RB', 'PLACE', 'TIME',
  // Conjunctions/Coordinators
  'CONJ', 'CCONJ', 'SCONJ', 'PHC', 'ANDC',
  // Stance markers
  'DWNT', 'AMP', 'HDG', 'EMPH',
  // Modals
  'POMD', 'NEMD', 'PRMD',
  // Verb semantic classes
  'PUBV', 'PRIV', 'SUAV', 'SMP',
  // Contractions/Negation
  'CONT', 'XX0', 'SYNE',
  // Stranded prepositions / Split aux
  'STPR', 'SPIN', 'SPAU',
  // Quantifiers
  'QUAN',
  // Articles/Determiners
  'ART', 'INDA', 'DET', 'DEMO',
  // Auxiliaries/Infinitive
  'AUXB', 'INF', 'TO',
  // Wh-words
  'WH'
]);

// Check if a tag is a BiberPlus 96 tag (uppercase check)
function isBiberPlus96Tag(tag) {
  if (!tag) return false;
  return BIBER_PLUS_96.has(tag.toUpperCase());
}

// Biberタグカテゴリ（可視化用）
const BIBER_TAG_CATEGORIES = {
  'Tense/Aspect': ['VBD', 'VPRT', 'PEAS', 'PGAS'],
  'Pronouns': ['FPP1', 'SPP2', 'TPP3', 'PIT', 'INPR', 'DEMP', 'QUPR', 'PRP', 'SBJP', 'ACCU'],
  'Passives': ['PASS', 'BYPA'],
  'Modals': ['POMD', 'NEMD', 'PRMD'],
  'Verb Classes': ['PUBV', 'PRIV', 'SUAV', 'SMP', 'PROD'],
  'Nominals': ['NN', 'NNP', 'NOMZ', 'GER'],
  'Adjectives': ['JJ', 'PRED', 'CMADJ', 'SPADJ'],
  'Adverbs': ['RB', 'PLACE', 'TIME'],
  'Prepositions': ['PREP', 'PIN'],
  'Conjunctions': ['CONJ', 'CCONJ', 'SCONJ', 'PHC', 'ANDC', 'CAUS', 'CONC', 'COND', 'OSUB'],
  'Relatives': ['TSUB', 'TOBJ', 'WHSUB', 'WHOBJ', 'PIRE', 'SERE', 'WHCL'],
  'Stance': ['DWNT', 'AMP', 'HDG', 'EMPH'],
  'Negation': ['XX0', 'SYNE', 'CONT'],
  'Other': ['BEMA', 'EX', 'THVC', 'THATD', 'STPR', 'SPIN', 'SPAU', 'QUAN', 'ART', 'INDA', 'DET', 'DEMO', 'AUXB', 'INF', 'TO', 'CAP', 'NUM', 'WH', 'X', 'UH', 'WHQU', 'PASTP', 'WZPAST', 'WZPRES']
};

function toggleKwicBiberDropdown() {
  const dropdown = document.getElementById('kwicBiberTagDropdown');
  if (dropdown) {
    dropdown.style.display = dropdown.style.display === 'none' ? 'block' : 'none';
  }
}

function selectAllKwicBiberTags() {
  const checkboxes = document.querySelectorAll('.kwicBiberTagCheck');
  checkboxes.forEach(cb => cb.checked = true);
  updateKwicBiberLabel();
}

function clearAllKwicBiberTags() {
  const checkboxes = document.querySelectorAll('.kwicBiberTagCheck');
  checkboxes.forEach(cb => cb.checked = false);
  updateKwicBiberLabel();
}

function updateKwicBiberLabel() {
  const checkboxes = document.querySelectorAll('.kwicBiberTagCheck:checked');
  const selected = Array.from(checkboxes).map(cb => cb.value);
  const label = document.getElementById('kwicBiberTagLabel');
  if (label) {
    if (selected.length === 0) {
      label.textContent = '(select tags...)';
    } else if (selected.length <= 4) {
      label.textContent = selected.join(', ');
    } else {
      label.textContent = `${selected.length} tags selected`;
    }
  }
}

// ===== Biber N-gram Slot Functions =====

// Get available Biber tags from corpus
function getAvailableBiberTags() {
  const usedTags = new Set();
  if (corpus && corpus.files) {
    for (const file of Object.values(corpus.files)) {
      if (file.tokens) {
        for (const tok of file.tokens) {
          if (tok.biberTags && tok.biberTags.length > 0) {
            tok.biberTags.forEach(t => usedTags.add(t));
          }
        }
      }
    }
  }
  // Return tags in corpus, or all BIBER_TAGS if none found
  return usedTags.size > 0 ? BIBER_TAGS.filter(t => usedTags.has(t)) : BIBER_TAGS;
}

// Populate a single slot's select options
function populateBiberSlotOptions(selectEl) {
  const availableTags = getAvailableBiberTags();
  const currentValue = selectEl.value;
  
  selectEl.innerHTML = '<option value="">(select)</option>' + 
    availableTags.map(tag => `<option value="${tag}">${tag}</option>`).join('');
  
  // Restore value if it exists
  if (currentValue && availableTags.includes(currentValue)) {
    selectEl.value = currentValue;
  }
}

// Initialize all Biber N-gram slots
function initBiberNgramSlots() {
  const container = document.getElementById('kwicBiberNgramSlots');
  if (!container) return;
  
  // Populate existing slot(s)
  container.querySelectorAll('.biber-slot-select').forEach(sel => {
    populateBiberSlotOptions(sel);
  });
  
  updateBiberNgramDisplay();
}

// Add a new slot for n-gram - disabled (n-gram functionality removed)
function addBiberNgramSlot() {
  // N-gram functionality has been removed
  // This function is kept for compatibility but does nothing
}

// Remove last slot - disabled (n-gram functionality removed)
function removeBiberNgramSlot() {
  // N-gram functionality has been removed
  // This function is kept for compatibility but does nothing
}

// Clear all slots
function clearBiberNgramSlots() {
  const container = document.getElementById('kwicBiberNgramSlots');
  if (!container) return;
  
  // Reset to single empty slot
  container.innerHTML = `
    <div class="biber-ngram-slot" data-slot="0">
      <select class="biber-slot-select" style="font-size:0.75rem; padding:0.2rem; min-width:80px; background:#fffbf0; border:1px solid #d9a030; border-radius:3px;" onchange="updateBiberNgramDisplay()">
        <option value="">(select)</option>
      </select>
    </div>
  `;
  
  // Re-populate options
  initBiberNgramSlots();
}

// Update display (simplified - no n-gram indicator)
function updateBiberNgramDisplay() {
  const container = document.getElementById('kwicBiberNgramSlots');
  
  if (!container) return;
  
  const tags = getSelectedKwicBiberTags();
  // Display is simplified since n-gram functionality is removed
}

// Get selected Biber tag from slot (single tag only)
function getSelectedKwicBiberTags() {
  const container = document.getElementById('kwicBiberNgramSlots');
  if (!container) return [];
  
  const selects = container.querySelectorAll('.biber-slot-select');
  const tags = [];
  
  selects.forEach(sel => {
    if (sel.value) {
      tags.push(sel.value);
    }
  });
  
  // Only return first tag (n-gram functionality removed)
  return tags.length > 0 ? [tags[0]] : [];
}

// Get Biber tag pattern as string (single tag only)
function getBiberNgramPattern() {
  const tags = getSelectedKwicBiberTags();
  return tags.length > 0 ? tags[0] : '';
}

// Check if in n-gram mode - always false (n-gram functionality removed)
function isBiberNgramMode() {
  return false;
}

// Check if Sensitive mode is enabled
function isBiberSensitiveMode() {
  const checkbox = document.getElementById('kwicBiberSensitive');
  return checkbox ? checkbox.checked : false;
}

// Check if a token matches a single Biber tag
// - Normal mode (Sensitive OFF): token has ANY of its tags matching the target
// - Sensitive mode (Sensitive ON): token's tags EXACTLY match the target (only that tag)
function tokenMatchesBiberTag(token, targetTag, sensitiveMode) {
  if (!token || !token.biberTags || token.biberTags.length === 0) return false;
  
  if (sensitiveMode) {
    // Sensitive mode: token must have ONLY this tag (exact match)
    return token.biberTags.length === 1 && token.biberTags[0] === targetTag;
  } else {
    // Normal mode: token has this tag among its tags
    return token.biberTags.includes(targetTag);
  }
}

// Legacy function compatibility
function populateKwicBiberTagCheckboxes() {
  initBiberNgramSlots();
}

function updateKwicBiberLabel() {
  // No longer needed with slot UI, but keep for compatibility
  updateBiberNgramDisplay();
}

function clearAllKwicBiberTags() {
  clearBiberNgramSlots();
}

function selectAllKwicBiberTags() {
  // Not applicable for slot UI
}

function toggleKwicBiberDropdown() {
  // Not applicable for slot UI
}

function updateKwicBiberFilterVisibility() {
  const container = document.getElementById('kwicBiberFilterContainer');
  if (!container) return;
  
  // CSVモードでBiberタグがある場合のみ表示
  if (corpus && corpus.mode === 'csv' && corpus.csvMetadata && corpus.csvMetadata.hasTags) {
    container.style.display = 'block';
    populateKwicBiberTagCheckboxes();
    updateBiberComboPOSOptions(); // POS選択肢を初期化
  } else {
    container.style.display = 'none';
  }
}

// Biber Tag組み合わせオプションの表示/非表示を更新
function updateBiberComboOptions() {
  const wordCheck = document.getElementById('kwicBiberComboWord');
  const lemmaCheck = document.getElementById('kwicBiberComboLemma');
  const posCheck = document.getElementById('kwicBiberComboPOS');
  
  const wordInput = document.getElementById('kwicBiberComboWordInput');
  const lemmaInput = document.getElementById('kwicBiberComboLemmaInput');
  const posContainer = document.getElementById('kwicBiberComboPOSContainer');
  
  if (wordInput) wordInput.style.display = wordCheck?.checked ? 'inline-block' : 'none';
  if (lemmaInput) lemmaInput.style.display = lemmaCheck?.checked ? 'inline-block' : 'none';
  if (posContainer) posContainer.style.display = posCheck?.checked ? 'inline-block' : 'none';
}

// Biber Combo POS ドロップダウンの表示/非表示を切り替え
function toggleBiberComboPOSDropdown() {
  const dropdown = document.getElementById('kwicBiberComboPOSDropdown');
  if (dropdown) {
    dropdown.style.display = dropdown.style.display === 'none' ? 'block' : 'none';
  }
}

// Biber Combo POS選択肢を更新
function updateBiberComboPOSOptions() {
  const container = document.getElementById('kwicBiberComboPOSCheckboxes');
  const typeSelect = document.getElementById('kwicBiberComboPOSType');
  if (!container) return;
  
  const posType = typeSelect?.value || 'simple';
  
  // POSタグリスト
  const simplePOS = ['ADJ', 'ADP', 'ADV', 'AUX', 'CCONJ', 'DET', 'INTJ', 'NOUN', 'NUM', 'PART', 'PRON', 'PROPN', 'PUNCT', 'SCONJ', 'SYM', 'VERB', 'X'];
  const detailedPOS = ['CC', 'CD', 'DT', 'EX', 'FW', 'IN', 'JJ', 'JJR', 'JJS', 'LS', 'MD', 'NN', 'NNS', 'NNP', 'NNPS', 'PDT', 'POS', 'PRP', 'PRP$', 'RB', 'RBR', 'RBS', 'RP', 'SYM', 'TO', 'UH', 'VB', 'VBD', 'VBG', 'VBN', 'VBP', 'VBZ', 'WDT', 'WP', 'WP$', 'WRB'];
  
  const posList = posType === 'simple' ? simplePOS : detailedPOS;
  
  container.innerHTML = posList.map(pos => `
    <label style="display:flex; align-items:center; gap:0.1rem; cursor:pointer; padding:0.05rem 0.15rem; background:#f0f8ff; border:1px solid #d0e0f0; border-radius:2px; white-space:nowrap;">
      <input type="checkbox" class="biberComboPOSCheck" value="${pos}" onchange="updateBiberComboPOSLabel()">
      ${pos}
    </label>
  `).join('');
}

// Biber Combo POSラベルを更新
function updateBiberComboPOSLabel() {
  const checkboxes = document.querySelectorAll('.biberComboPOSCheck:checked');
  const label = document.getElementById('kwicBiberComboPOSLabel');
  const selected = Array.from(checkboxes).map(cb => cb.value);
  
  if (label) {
    if (selected.length === 0) {
      label.textContent = '(select POS...)';
    } else if (selected.length <= 3) {
      label.textContent = selected.join(', ');
    } else {
      label.textContent = `${selected.length} POS selected`;
    }
  }
}

// Biber Combo POS全選択
function selectAllBiberComboPOS() {
  document.querySelectorAll('.biberComboPOSCheck').forEach(cb => cb.checked = true);
  updateBiberComboPOSLabel();
}

// Biber Combo POSクリア
function clearAllBiberComboPOS() {
  document.querySelectorAll('.biberComboPOSCheck').forEach(cb => cb.checked = false);
  updateBiberComboPOSLabel();
}

// Biber Combo POS選択値を取得
function getSelectedBiberComboPOS() {
  const checkboxes = document.querySelectorAll('.biberComboPOSCheck:checked');
  return Array.from(checkboxes).map(cb => cb.value);
}

// Biber Comboの条件を取得
function getBiberComboConditions() {
  const result = {
    word: null,
    lemma: null,
    pos: null,
    posType: 'simple'
  };
  
  const wordCheck = document.getElementById('kwicBiberComboWord');
  const lemmaCheck = document.getElementById('kwicBiberComboLemma');
  const posCheck = document.getElementById('kwicBiberComboPOS');
  
  if (wordCheck?.checked) {
    const wordInput = document.getElementById('kwicBiberComboWordInput');
    if (wordInput?.value.trim()) {
      result.word = wordInput.value.trim();
    }
  }
  
  if (lemmaCheck?.checked) {
    const lemmaInput = document.getElementById('kwicBiberComboLemmaInput');
    if (lemmaInput?.value.trim()) {
      result.lemma = lemmaInput.value.trim();
    }
  }
  
  if (posCheck?.checked) {
    const selectedPOS = getSelectedBiberComboPOS();
    if (selectedPOS.length > 0) {
      result.pos = selectedPOS;
      result.posType = document.getElementById('kwicBiberComboPOSType')?.value || 'simple';
    }
  }
  
  return result;
}

// トークンがBiber Combo条件にマッチするか確認
function tokenMatchesBiberCombo(tok, combo, caseInsensitive = true) {
  // Word条件
  if (combo.word) {
    const word = tok.word || '';
    const pattern = combo.word;
    if (!matchPattern(word, pattern, caseInsensitive)) {
      return false;
    }
  }
  
  // Lemma条件
  if (combo.lemma) {
    const lemma = tok.lemma || '';
    const pattern = combo.lemma;
    if (!matchPattern(lemma, pattern, caseInsensitive)) {
      return false;
    }
  }
  
  // POS条件
  if (combo.pos && combo.pos.length > 0) {
    const posField = combo.posType === 'detailed' ? 'posd' : 'poss';
    const tokPOS = tok[posField] || '';
    if (!combo.pos.includes(tokPOS)) {
      return false;
    }
  }
  
  return true;
}

// パターンマッチング（ワイルドカード対応）
function matchPattern(text, pattern, caseInsensitive = true) {
  if (!pattern) return true;
  
  const t = caseInsensitive ? text.toLowerCase() : text;
  const p = caseInsensitive ? pattern.toLowerCase() : pattern;
  
  // ワイルドカードパターンの場合
  if (p.includes('*') || p.includes('?')) {
    let regexStr = p.replace(/[.+^${}()|[\]\\]/g, '\\$&');
    regexStr = regexStr.replace(/\*/g, '.*');
    regexStr = regexStr.replace(/\?/g, '.');
    const regex = new RegExp('^' + regexStr + '$', caseInsensitive ? 'i' : '');
    return regex.test(text);
  }
  
  // 完全一致
  return t === p;
}

// Handle KWIC scope radio button change
function handleKwicScopeChange() {
  const scopeRadio = document.querySelector('input[name="kwicScope"]:checked');
  const scope = scopeRadio ? scopeRadio.value : 'target';
  const folderSelector = document.getElementById('kwicFolderSelector');
  
  if (folderSelector) {
    if (scope === 'specific') {
      folderSelector.style.display = 'inline-block';
      // Populate checkboxes if not already done
      const checkboxContainer = document.getElementById('kwicFolderCheckboxes');
      if (checkboxContainer && checkboxContainer.children.length === 0) {
        populateKwicFolderCheckboxes();
      }
    } else {
      folderSelector.style.display = 'none';
    }
  }
}

// Parse token pattern input to update fields
function parseTokenPatternToFields(idx) {
  const patternInput = document.getElementById(`kwicAdvTokenPattern_${idx}`);
  if (!patternInput) return;
  
  const pattern = patternInput.value.trim();
  const parts = pattern.split('_');
  
  // Parse: surface_posd_poss_lemma
  const surface = parts[0] || '*';
  const posd = parts[1] || '*';
  const poss = parts[2] || '*';
  const lemma = parts[3] || '*';
  
  // Update surface field
  const surfaceInput = document.getElementById(`kwicAdvSurface_${idx}`);
  if (surfaceInput) surfaceInput.value = surface === '*' ? '' : surface;
  
  // Update lemma field
  const lemmaInput = document.getElementById(`kwicAdvLemma_${idx}`);
  if (lemmaInput) lemmaInput.value = lemma === '*' ? '' : lemma;
  
  // Update POS(d) checkboxes
  const posdValues = posd === '*' ? [] : posd.split('|');
  document.querySelectorAll(`.kwicAdvPosdCheck_${idx}`).forEach(cb => {
    cb.checked = posdValues.includes(cb.value);
  });
  updatePosLabel('posd', idx);
  
  // Update POS(s) checkboxes
  const possValues = poss === '*' ? [] : poss.split('|');
  document.querySelectorAll(`.kwicAdvPossCheck_${idx}`).forEach(cb => {
    cb.checked = possValues.includes(cb.value);
  });
  updatePosLabel('poss', idx);
}

// Toggle collapse/expand token details
function toggleAdvancedTokensCollapse() {
  const collapsed = document.getElementById('kwicAdvancedCollapseTokens')?.checked;
  const container = document.getElementById('kwicAdvancedInputs');
  if (!container) return;
  
  const tokens = container.querySelectorAll('.kwic-adv-token');
  tokens.forEach(tokenDiv => {
    // Find the main input grid (Row 2)
    const grid = tokenDiv.querySelector('div[style*="display:grid"]');
    if (grid) {
      grid.style.display = collapsed ? 'none' : 'grid';
    }
    // Collapse details elements
    const detailsElements = tokenDiv.querySelectorAll('details');
    detailsElements.forEach(d => {
      d.style.display = collapsed ? 'none' : 'block';
    });
  });
}

// Toggle visibility of all token inputs
function toggleAdvancedTokensVisibility() {
  const container = document.getElementById('kwicAdvancedInputs');
  const btn = document.getElementById('kwicAdvancedToggleTokensBtn');
  if (!container || !btn) return;
  
  const isHidden = container.style.display === 'none';
  
  if (isHidden) {
    container.style.display = 'block';
    btn.textContent = 'Hide Token Inputs';
    btn.style.background = '';
  } else {
    container.style.display = 'none';
    btn.textContent = 'Show Token Inputs';
    btn.style.background = '#3b82f6';
    btn.style.color = 'white';
  }
}

// Remove a token from Advanced KWIC
function removeAdvancedKwicToken(idx) {
  const tokenDiv = document.getElementById(`kwicAdvToken_${idx}`);
  if (tokenDiv) {
    tokenDiv.remove();
    renumberAdvancedTokens();
    updateAdvancedPattern();
  }
}

// Renumber tokens after removal
function renumberAdvancedTokens() {
  const container = document.getElementById('kwicAdvancedInputs');
  if (!container) return;
  
  const tokens = container.querySelectorAll('.kwic-adv-token');
  tokens.forEach((tokenDiv, newIdx) => {
    const oldId = tokenDiv.id;
    const oldIdx = parseInt(oldId.split('_')[1]) || 0;
    tokenDiv.id = `kwicAdvToken_${newIdx}`;
    
    // Update label
    const label = tokenDiv.querySelector('span');
    if (label && label.textContent.startsWith('Token')) {
      label.textContent = `Token ${newIdx + 1}:`;
    }
    
    // Update all element IDs
    const idPrefixes = ['Surface', 'Lemma', 'TokenPattern', 'PosdBtn', 'PossBtn', 'PosdDropdown', 'PossDropdown', 'PosdLabel', 'PossLabel'];
    idPrefixes.forEach(prefix => {
      const el = tokenDiv.querySelector(`[id="kwicAdv${prefix}_${oldIdx}"]`);
      if (el) el.id = `kwicAdv${prefix}_${newIdx}`;
    });
    
    // Update checkbox class names and handlers
    tokenDiv.querySelectorAll(`[class*="_${oldIdx}"]`).forEach(el => {
      el.className = el.className.replace(`_${oldIdx}`, `_${newIdx}`);
    });
    
    // Update onclick handlers for checkboxes
    tokenDiv.querySelectorAll('input[type="checkbox"]').forEach(cb => {
      const oldOnchange = cb.getAttribute('onchange');
      if (oldOnchange) {
        cb.setAttribute('onchange', oldOnchange.replace(new RegExp(oldIdx, 'g'), newIdx));
      }
    });
    
    // Update button handlers
    tokenDiv.querySelectorAll('button').forEach(btn => {
      const onclick = btn.getAttribute('onclick');
      if (onclick) {
        btn.setAttribute('onclick', onclick.replace(new RegExp(oldIdx, 'g'), newIdx));
      }
    });
    
    // Update token pattern input handler
    const patternInput = tokenDiv.querySelector(`[id^="kwicAdvTokenPattern_"]`);
    if (patternInput) {
      patternInput.setAttribute('oninput', `parseTokenPatternToFields(${newIdx}); updateAdvancedPattern()`);
    }
    
    // Update + button
    const plusBtn = tokenDiv.querySelector('button:first-of-type');
    if (plusBtn && plusBtn.textContent.trim() === '+') {
      plusBtn.onclick = () => addAdvancedKwicToken(newIdx + 1);
    }
    
    // Update - button
    const removeBtn = tokenDiv.querySelector('.btn-clear');
    if (removeBtn) {
      if (newIdx === 0) {
        removeBtn.remove();
      } else {
        removeBtn.onclick = () => removeAdvancedKwicToken(newIdx);
      }
    }
  });
}

// Update the Pattern field with combined tokens (new format: surface_posd_poss_lemma)
function updateAdvancedPattern() {
  const container = document.getElementById('kwicAdvancedInputs');
  const patternField = document.getElementById('kwicAdvancedNode');
  if (!container || !patternField) return;
  
  const tokens = container.querySelectorAll('.kwic-adv-token');
  const patterns = [];
  
  tokens.forEach((tokenDiv, idx) => {
    const surface = document.getElementById(`kwicAdvSurface_${idx}`)?.value.trim() || '*';
    const lemma = document.getElementById(`kwicAdvLemma_${idx}`)?.value.trim() || '*';
    
    // Get POS(d) selected values
    const posdCheckboxes = document.querySelectorAll(`.kwicAdvPosdCheck_${idx}:checked`);
    const posd = posdCheckboxes.length > 0 ? Array.from(posdCheckboxes).map(cb => cb.value).join('|') : '*';
    
    // Get POS(s) selected values
    const possCheckboxes = document.querySelectorAll(`.kwicAdvPossCheck_${idx}:checked`);
    const poss = possCheckboxes.length > 0 ? Array.from(possCheckboxes).map(cb => cb.value).join('|') : '*';
    
    // Format: surface_posd_poss_lemma
    const tokenPattern = `${surface || '*'}_${posd}_${poss}_${lemma || '*'}`;
    
    // Update token pattern field
    const tokenPatternInput = document.getElementById(`kwicAdvTokenPattern_${idx}`);
    if (tokenPatternInput) {
      tokenPatternInput.value = tokenPattern;
    }
    
    patterns.push(tokenPattern);
  });
  
  patternField.value = patterns.join(' ');
  
  // Sync to other Advanced modes
  syncAllAdvancedModes();
}

// Parse the main Pattern field and create/update tokens
function parseAdvancedPatternToTokens() {
  const patternField = document.getElementById('kwicAdvancedNode');
  if (!patternField) return;
  
  const pattern = patternField.value.trim();
  if (!pattern) return;
  
  const tokenPatterns = pattern.split(/\s+/);
  const container = document.getElementById('kwicAdvancedInputs');
  if (!container) return;
  
  // Clear existing tokens
  container.innerHTML = '';
  
  // Create tokens from pattern
  tokenPatterns.forEach((tokenPattern, idx) => {
    const parts = tokenPattern.split('_');
    const prefill = {
      surface: parts[0] === '*' ? '' : (parts[0] || ''),
      posd: parts[1] && parts[1] !== '*' ? parts[1].split('|') : [],
      poss: parts[2] && parts[2] !== '*' ? parts[2].split('|') : [],
      lemma: parts[3] === '*' ? '' : (parts[3] || '')
    };
    addAdvancedKwicToken(idx, prefill);
  });
  
  // Sync to other sections
  syncAllAdvancedModes();
}

// Set pattern from Collocate link (new format)
function setAdvancedPatternFromCollocate(node, featureType, calcMode) {
  // Enable advanced mode if not already
  const toggle = document.getElementById('kwicAdvancedModeToggle');
  if (toggle && !toggle.checked) {
    toggle.checked = true;
    document.getElementById('kwicSimpleMode').style.display = 'none';
    document.getElementById('kwicAdvancedMode').style.display = 'block';
  }
  
  // Convert node to new pattern format based on feature type
  let pattern = '';
  
  if (featureType === 'word' || featureType === 'ngram_word') {
    // Word surface: each word becomes surface_*_*_*
    const words = node.split(/\s+/);
    pattern = words.map(w => `${w}_*_*_*`).join(' ');
  } else if (featureType === 'lemma' || featureType === 'ngram_lemma') {
    // Lemma: each word becomes *_*_*_lemma
    const words = node.split(/\s+/);
    pattern = words.map(w => `*_*_*_${w}`).join(' ');
  } else if (featureType === 'posgram_simple') {
    // POS simple: each tag becomes *_*_POSs_*
    const tags = node.split('+');
    pattern = tags.map(t => `*_*_${t}_*`).join(' ');
  } else if (featureType === 'posgram_detailed') {
    // POS detailed: each tag becomes *_POSd_*_*
    const tags = node.split('+');
    pattern = tags.map(t => `*_${t}_*_*`).join(' ');
  } else if (featureType === 'pos_simple') {
    // Single POS simple
    pattern = `*_*_${node}_*`;
  } else if (featureType === 'pos_detailed') {
    // Single POS detailed
    pattern = `*_${node}_*_*`;
  } else if (featureType === 'pframe_word' || featureType === 'pframe_lemma') {
    // P-frame: parse and convert
    const words = node.split(/\s+/);
    const isLemma = featureType === 'pframe_lemma';
    pattern = words.map(w => {
      if (w === '*') return '*_*_*_*';
      return isLemma ? `*_*_*_${w}` : `${w}_*_*_*`;
    }).join(' ');
  } else {
    // Default: treat as surface words (including word, ngram_word, etc.)
    const words = node.split(/\s+/);
    pattern = words.map(w => `${w}_*_*_*`).join(' ');
  }
  
  // Set pattern and parse to tokens
  const patternField = document.getElementById('kwicAdvancedNode');
  if (patternField) {
    patternField.value = pattern;
    parseAdvancedPatternToTokens();
  }
}

// Set up Advanced mode from Topic Modeling (with POS filter)
function setupAdvancedKwicFromTopic(word, posTags, posMode) {
  // posTags can be a single tag (string) or array of tags
  const tagsArray = Array.isArray(posTags) ? posTags : [posTags];
  
  // Clear previous filter settings
  clearKwicFilters();
  
  // Sync Scope from Topic Modeling
  const topicScopeSelect = document.getElementById('topicScope');
  const topicScope = topicScopeSelect ? topicScopeSelect.value : 'all';
  
  // Check if per-folder mode and specific folder is selected
  const analysisModeSelect = document.getElementById('topicAnalysisMode');
  const topicFolderSelect = document.getElementById('topicFolderSelect');
  const isPerFolderMode = analysisModeSelect && analysisModeSelect.value === 'perFolder';
  const selectedTopicFolder = topicFolderSelect ? topicFolderSelect.value : 'all';
  
  // Determine KWIC scope based on Topic Modeling settings
  let kwicScopeValue = 'all';
  let specificFolder = null;
  
  if (isPerFolderMode && selectedTopicFolder !== 'all') {
    // Per-folder mode with specific folder selected -> use Specific folder scope
    kwicScopeValue = 'specific';
    specificFolder = selectedTopicFolder;
  } else if (topicScope === 'target') {
    kwicScopeValue = 'target';
  } else if (topicScope === 'reference') {
    kwicScopeValue = 'reference';
  } else {
    kwicScopeValue = 'all'; // 'all' maps to 'All folders'
  }
  
  // Set KWIC scope
  const kwicScopeInput = document.querySelector(`input[name="kwicScope"][value="${kwicScopeValue}"]`);
  if (kwicScopeInput) {
    kwicScopeInput.checked = true;
    // Trigger scope change to show/hide folder selector
    handleKwicScopeChange();
  }
  
  // If specific folder, set the folder checkbox
  if (kwicScopeValue === 'specific' && specificFolder) {
    setSelectedKwicFolders([specificFolder]);
  }
  
  // Enable advanced mode
  const toggle = document.getElementById('kwicAdvancedModeToggle');
  if (toggle && !toggle.checked) {
    toggle.checked = true;
    document.getElementById('kwicSimpleMode').style.display = 'none';
    document.getElementById('kwicAdvancedMode').style.display = 'block';
  }
  
  // Build pattern in new format: surface_posd_poss_lemma
  let pattern;
  if (posMode === 'detail') {
    // POS detailed: word_POSd_*_*
    const posPart = tagsArray.length > 0 ? tagsArray.join('|') : '*';
    pattern = `${word}_${posPart}_*_*`;
  } else {
    // POS simple: word_*_POSs_*
    const posPart = tagsArray.length > 0 ? tagsArray.join('|') : '*';
    pattern = `${word}_*_${posPart}_*`;
  }
  
  // Set pattern and parse to tokens
  const patternField = document.getElementById('kwicAdvancedNode');
  if (patternField) {
    patternField.value = pattern;
    parseAdvancedPatternToTokens();
  }
  
  console.log('[setupAdvancedKwicFromTopic] Scope synced:', topicScope, '->', kwicScopeValue);
}

// Flag to prevent infinite loop when syncing Advanced modes
let _syncingAdvancedModes = false;

// Toggle Plot Advanced mode (synced with KWIC)
function togglePlotAdvancedMode() {
  const toggle = document.getElementById('plotAdvancedModeToggle');
  const simpleMode = document.getElementById('plotSimpleMode');
  const advancedMode = document.getElementById('plotAdvancedMode');
  
  if (toggle && toggle.checked) {
    if (simpleMode) simpleMode.style.display = 'none';
    if (advancedMode) advancedMode.style.display = 'block';
    syncPlotAdvancedFromKwic();
    
    // Also turn on KWIC Advanced mode if not already on (prevent infinite loop)
    if (!_syncingAdvancedModes) {
      _syncingAdvancedModes = true;
      const kwicToggle = document.getElementById('kwicAdvancedModeToggle');
      if (kwicToggle && !kwicToggle.checked) {
        kwicToggle.checked = true;
        document.getElementById('kwicSimpleMode').style.display = 'none';
        document.getElementById('kwicAdvancedMode').style.display = 'block';
        const container = document.getElementById('kwicAdvancedInputs');
        if (container && container.querySelectorAll('.kwic-adv-token').length === 0) {
          initAdvancedKwicTokens();
        }
      }
      // Also sync Collocate
      const collocateToggle = document.getElementById('collocateAdvancedModeToggle');
      if (collocateToggle && !collocateToggle.checked) {
        collocateToggle.checked = true;
        document.getElementById('collocateSimpleMode').style.display = 'none';
        document.getElementById('collocateAdvancedMode').style.display = 'block';
        syncCollocateAdvancedFromKwic();
      }
      _syncingAdvancedModes = false;
    }
  } else {
    if (simpleMode) simpleMode.style.display = 'block';
    if (advancedMode) advancedMode.style.display = 'none';
    
    // Also turn off KWIC and Collocate Advanced mode (prevent infinite loop)
    if (!_syncingAdvancedModes) {
      _syncingAdvancedModes = true;
      const kwicToggle = document.getElementById('kwicAdvancedModeToggle');
      if (kwicToggle && kwicToggle.checked) {
        kwicToggle.checked = false;
        document.getElementById('kwicSimpleMode').style.display = 'block';
        document.getElementById('kwicAdvancedMode').style.display = 'none';
      }
      const collocateToggle = document.getElementById('collocateAdvancedModeToggle');
      if (collocateToggle && collocateToggle.checked) {
        collocateToggle.checked = false;
        document.getElementById('collocateSimpleMode').style.display = 'block';
        document.getElementById('collocateAdvancedMode').style.display = 'none';
      }
      _syncingAdvancedModes = false;
    }
  }
}

// Sync Plot Advanced mode from KWIC Advanced pattern
function syncPlotAdvancedFromKwic() {
  const kwicPattern = document.getElementById('kwicAdvancedNode')?.value || '';
  const plotPattern = document.getElementById('plotAdvancedPattern');
  if (plotPattern) {
    plotPattern.textContent = kwicPattern || '(set pattern in KWIC Advanced mode)';
  }
  
  // Biberタグ設定も同期
  syncBiberTagsToSection('plot');
}

// 5b) PlotにBiberタグ設定を同期
function syncBiberTagsToSection(section) {
  // 現在のKWIC Biberタグ設定を取得
  const selectedBiberTags = getSelectedKwicBiberTags();
  const biberMatchMode = document.getElementById('kwicBiberMatchMode')?.value || 'any';
  
  // Biber Combo条件も取得
  const biberCombo = getBiberComboConditions();
  
  // セクション別に設定を適用（将来的に拡張可能）
  // 現時点では、Plotと Collocateは同じBiberタグフィルタを使用
  // （4) KWICのBiberタグフィルタがマスターとして機能）
}

// Toggle Collocate Advanced mode (synced with KWIC)
function toggleCollocateAdvancedMode() {
  const toggle = document.getElementById('collocateAdvancedModeToggle');
  const simpleMode = document.getElementById('collocateSimpleMode');
  const advancedMode = document.getElementById('collocateAdvancedMode');
  
  if (toggle && toggle.checked) {
    if (simpleMode) simpleMode.style.display = 'none';
    if (advancedMode) advancedMode.style.display = 'block';
    syncCollocateAdvancedFromKwic();
    
    // Show POS options if tagged corpus
    if (corpus && (corpus.mode === 'tagged' || corpus.mode === 'csv')) {
      document.querySelectorAll('.collocate-pos-option-adv').forEach(el => el.style.display = 'inline');
    }
    
    // Also turn on KWIC Advanced mode if not already on (prevent infinite loop)
    if (!_syncingAdvancedModes) {
      _syncingAdvancedModes = true;
      const kwicToggle = document.getElementById('kwicAdvancedModeToggle');
      if (kwicToggle && !kwicToggle.checked) {
        kwicToggle.checked = true;
        document.getElementById('kwicSimpleMode').style.display = 'none';
        document.getElementById('kwicAdvancedMode').style.display = 'block';
        const container = document.getElementById('kwicAdvancedInputs');
        if (container && container.querySelectorAll('.kwic-adv-token').length === 0) {
          initAdvancedKwicTokens();
        }
      }
      // Also sync Plot
      const plotToggle = document.getElementById('plotAdvancedModeToggle');
      if (plotToggle && !plotToggle.checked) {
        plotToggle.checked = true;
        document.getElementById('plotSimpleMode').style.display = 'none';
        document.getElementById('plotAdvancedMode').style.display = 'block';
        syncPlotAdvancedFromKwic();
      }
      _syncingAdvancedModes = false;
    }
  } else {
    if (simpleMode) simpleMode.style.display = 'block';
    if (advancedMode) advancedMode.style.display = 'none';
    
    // Also turn off KWIC and Plot Advanced mode (prevent infinite loop)
    if (!_syncingAdvancedModes) {
      _syncingAdvancedModes = true;
      const kwicToggle = document.getElementById('kwicAdvancedModeToggle');
      if (kwicToggle && kwicToggle.checked) {
        kwicToggle.checked = false;
        document.getElementById('kwicSimpleMode').style.display = 'block';
        document.getElementById('kwicAdvancedMode').style.display = 'none';
      }
      const plotToggle = document.getElementById('plotAdvancedModeToggle');
      if (plotToggle && plotToggle.checked) {
        plotToggle.checked = false;
        document.getElementById('plotSimpleMode').style.display = 'block';
        document.getElementById('plotAdvancedMode').style.display = 'none';
      }
      _syncingAdvancedModes = false;
    }
  }
}

// Sync Collocate Advanced mode from KWIC Advanced pattern
function syncCollocateAdvancedFromKwic() {
  const kwicPattern = document.getElementById('kwicAdvancedNode')?.value || '';
  const collocatePattern = document.getElementById('collocateAdvancedPattern');
  if (collocatePattern) {
    collocatePattern.textContent = kwicPattern || '(set pattern in KWIC Advanced mode)';
  }
  
  // Biberタグ設定も同期
  syncBiberTagsToSection('collocate');
}

// Sync all Advanced modes when KWIC pattern changes
function syncAllAdvancedModes() {
  const kwicPattern = document.getElementById('kwicAdvancedNode')?.value || '';
  
  // Sync to Plot if in Advanced mode
  const plotToggle = document.getElementById('plotAdvancedModeToggle');
  if (plotToggle && plotToggle.checked) {
    const plotPattern = document.getElementById('plotAdvancedPattern');
    if (plotPattern) plotPattern.textContent = kwicPattern || '(no pattern)';
  }
  
  // Sync to Collocate if in Advanced mode
  const collocateToggle = document.getElementById('collocateAdvancedModeToggle');
  if (collocateToggle && collocateToggle.checked) {
    const collocatePattern = document.getElementById('collocateAdvancedPattern');
    if (collocatePattern) collocatePattern.textContent = kwicPattern || '(no pattern)';
  }
}

// Helper: Get token filters from KWIC Advanced mode UI
// Get token filters from new Advanced mode UI (format: surface_posd_poss_lemma)
function getKwicAdvancedTokenFilters() {
  const container = document.getElementById('kwicAdvancedInputs');
  if (!container) return null;
  
  const tokenDivs = container.querySelectorAll('.kwic-adv-token');
  if (tokenDivs.length === 0) return null;
  
  const caseInsensitive = document.getElementById('kwicAdvancedCaseInsensitive')?.checked !== false;
  
  const tokenFilters = [];
  
  tokenDivs.forEach((tokenDiv, idx) => {
    // Get values from new UI fields
    const surface = document.getElementById(`kwicAdvSurface_${idx}`)?.value.trim() || '';
    const lemma = document.getElementById(`kwicAdvLemma_${idx}`)?.value.trim() || '';
    
    // Get POS(d) selected values
    const posdCheckboxes = document.querySelectorAll(`.kwicAdvPosdCheck_${idx}:checked`);
    const posdTags = Array.from(posdCheckboxes).map(cb => cb.value);
    
    // Get POS(s) selected values
    const possCheckboxes = document.querySelectorAll(`.kwicAdvPossCheck_${idx}:checked`);
    const possTags = Array.from(possCheckboxes).map(cb => cb.value);
    
    // Build filter object
    const filter = {
      surface: surface || null,
      lemma: lemma || null,
      posd: posdTags.length > 0 ? new Set(posdTags) : null,
      poss: possTags.length > 0 ? new Set(possTags) : null
    };
    
    tokenFilters.push(filter);
  });
  
  if (tokenFilters.length === 0) return null;
  
  return { tokenFilters, caseInsensitive };
}

// Build matcher function for new Advanced KWIC format (surface_posd_poss_lemma)
function buildAdvancedTokenMatcherNew(filter, caseInsensitive) {
  return (token) => {
    if (!token) return false;
    
    // Skip punctuation and space tokens
    if (isPunctuationOrSpaceToken(token)) return false;
    
    // Check surface (supports wildcards)
    if (filter.surface) {
      const tokenSurface = token.surface || token.word || '';
      const testSurface = caseInsensitive ? tokenSurface.toLowerCase() : tokenSurface;
      const pattern = caseInsensitive ? filter.surface.toLowerCase() : filter.surface;
      
      // Check for wildcard pattern
      if (pattern.includes('*') || pattern.includes('?')) {
        const wildcardRegex = new RegExp(
          '^' + pattern.replace(/[.+^${}()|[\]\\]/g, '\\$&')
                       .replace(/\*/g, '.*')
                       .replace(/\?/g, '.') + '$',
          caseInsensitive ? 'i' : ''
        );
        if (!wildcardRegex.test(tokenSurface)) return false;
      } else {
        // Exact match (support pipe-separated alternatives)
        const alternatives = pattern.split('|');
        if (!alternatives.some(alt => testSurface === alt)) return false;
      }
    }
    
    // Check lemma
    if (filter.lemma) {
      const tokenLemma = token.lemma || token.surface || token.word || '';
      const testLemma = caseInsensitive ? tokenLemma.toLowerCase() : tokenLemma;
      const pattern = caseInsensitive ? filter.lemma.toLowerCase() : filter.lemma;
      
      // Check for wildcard pattern
      if (pattern.includes('*') || pattern.includes('?')) {
        const wildcardRegex = new RegExp(
          '^' + pattern.replace(/[.+^${}()|[\]\\]/g, '\\$&')
                       .replace(/\*/g, '.*')
                       .replace(/\?/g, '.') + '$',
          caseInsensitive ? 'i' : ''
        );
        if (!wildcardRegex.test(tokenLemma)) return false;
      } else {
        // Exact match (support pipe-separated alternatives)
        const alternatives = pattern.split('|');
        if (!alternatives.some(alt => testLemma === alt)) return false;
      }
    }
    
    // Check POS detailed
    if (filter.posd && filter.posd.size > 0) {
      const tokenPosd = token.posd || token.pos || '';
      if (!filter.posd.has(tokenPosd)) return false;
    }
    
    // Check POS simple
    if (filter.poss && filter.poss.size > 0) {
      const tokenPoss = token.poss || '';
      if (!filter.poss.has(tokenPoss)) return false;
    }
    
    return true;
  };
}

// Compute Plot using Advanced mode pattern
function computePlotAdvanced() {
  const status = document.getElementById('plotStatus');
  const container = document.getElementById('plotContainer');
  
  if (!corpus) {
    status.textContent = 'No corpus loaded.';
    return;
  }
  
  // Check for Tagged corpus
  if (corpus.mode !== 'tagged' && corpus.mode !== 'csv') {
    status.textContent = 'Advanced mode requires a Tagged corpus.';
    return;
  }
  
  const advancedData = getKwicAdvancedTokenFilters();
  if (!advancedData) {
    status.textContent = 'Please set a pattern in KWIC Advanced mode first.';
    return;
  }
  
  const { tokenFilters, caseInsensitive } = advancedData;
  const n = tokenFilters.length;
  
  // Build matchers for each token using new format
  const matchers = tokenFilters.map(filter => buildAdvancedTokenMatcherNew(filter, caseInsensitive));
  
  // Get scope from Advanced mode radio buttons
  const scopeRadio = document.querySelector('input[name="plotScope"]:checked');
  const plotScope = scopeRadio ? scopeRadio.value : 'target';
  
  // Get group by
  const groupBy = document.getElementById('plotGroupByAdv')?.value || 'file';
  
  // Determine folders to search
  let foldersToSearch = [];
  if (plotScope === 'target') foldersToSearch = Array.from(targetFolders);
  else if (plotScope === 'reference') foldersToSearch = Array.from(referenceFolders);
  else foldersToSearch = [...new Set([...targetFolders, ...referenceFolders])];
  
  if (foldersToSearch.length === 0) {
    status.textContent = 'Please select Target or Reference folders first.';
    return;
  }
  
  // Search and build plot data
  plotData = [];
  
  for (const [fileId, file] of Object.entries(corpus.files)) {
    if (!foldersToSearch.includes(file.folder)) continue;
    
    const fileTokens = file.tokens || [];
    const totalTokens = fileTokens.filter(t => !isPunctuationOrSpaceToken(t)).length;
    const positions = [];
    
    // Find matches
    for (let i = 0; i <= fileTokens.length - n; i++) {
      let match = true;
      for (let j = 0; j < n; j++) {
        if (!matchers[j](fileTokens[i + j])) {
          match = false;
          break;
        }
      }
      if (match) {
        // Calculate relative position (0-1)
        const relPos = totalTokens > 0 ? (i / fileTokens.length) : 0;
        positions.push(relPos);
      }
    }
    
    plotData.push({
      fileId,
      folder: file.folder,
      name: file.name,
      totalTokens,
      positions,
      hits: positions.length
    });
  }
  
  const totalHits = plotData.reduce((sum, d) => sum + d.hits, 0);
  status.textContent = `Found ${totalHits} matches (Advanced pattern: ${document.getElementById('kwicAdvancedNode')?.value || ''})`;
  
  renderPlot(groupBy);
}

// Compute Collocates using Advanced mode pattern
function computeCollocatesAdvanced() {
  const status = document.getElementById('collocateStatus');
  status.textContent = '';
  collocateData = null;
  
  if (!corpus) {
    status.textContent = 'No corpus loaded.';
    clearCollocateTables();
    return;
  }
  
  // Check for Tagged corpus
  if (corpus.mode !== 'tagged' && corpus.mode !== 'csv') {
    status.textContent = 'Advanced mode requires a Tagged corpus.';
    clearCollocateTables();
    return;
  }
  
  const advancedData = getKwicAdvancedTokenFilters();
  if (!advancedData) {
    status.textContent = 'Please set a pattern in KWIC Advanced mode first.';
    clearCollocateTables();
    return;
  }
  
  const { tokenFilters, caseInsensitive } = advancedData;
  const n = tokenFilters.length;
  const node = document.getElementById('kwicAdvancedNode')?.value || '';
  
  // Build matchers for each token using new format
  const matchers = tokenFilters.map(filter => buildAdvancedTokenMatcherNew(filter, caseInsensitive));
  
  // Get settings from Advanced mode controls
  const spanL = parseInt(document.getElementById('collocateSpanLAdv')?.value) || 5;
  const spanR = parseInt(document.getElementById('collocateSpanRAdv')?.value) || 5;
  const topN = parseInt(document.getElementById('collocateTopNAdv')?.value) || 20;
  const statType = document.getElementById('collocateStatSelectAdv')?.value || 'frequency';
  
  // Get collocate calculation mode from Advanced radio buttons
  const calcModeRadio = document.querySelector('input[name="collocateCalcModeAdv"]:checked');
  const calcMode = calcModeRadio ? calcModeRadio.value : 'surface';
  
  // Data structure for collocates
  const data = {
    target: { left: {}, right: {} },
    reference: { left: {}, right: {} }
  };
  
  for (let p = 1; p <= 5; p++) {
    data.target.left[p] = {};
    data.target.right[p] = {};
    data.reference.left[p] = {};
    data.reference.right[p] = {};
  }
  
  let totalTargetHits = 0;
  let totalRefHits = 0;
  
  // Corpus-wide statistics
  let targetTotalTokens = 0;
  let refTotalTokens = 0;
  const targetWordFreq = {};
  const refWordFreq = {};
  
  // Helper to get collocate value from token
  const getCollocateValue = (tok) => {
    let val;
    if (calcMode === 'lemma') {
      val = tok.lemma || tok.word;
    } else if (calcMode === 'pos_simple') {
      val = tok.poss || tok.pos || tok.word;
    } else if (calcMode === 'pos_detailed') {
      val = tok.posd || tok.pos || tok.word;
    } else {
      val = tok.word;
    }
    return caseInsensitive && val ? val.toLowerCase() : val;
  };
  
  // First pass: count corpus-wide token frequencies
  for (const [fileId, file] of Object.entries(corpus.files)) {
    const folder = file.folder;
    const isTarget = targetFolders.has(folder);
    const isRef = referenceFolders.has(folder);
    if (!isTarget && !isRef) continue;
    
    const tokens = file.tokens;
    for (let i = 0; i < tokens.length; i++) {
      const tok = tokens[i];
      if (isPunctuationOrSpaceToken(tok)) continue;
      const word = getCollocateValue(tok);
      if (isTarget) {
        targetTotalTokens++;
        targetWordFreq[word] = (targetWordFreq[word] || 0) + 1;
      }
      if (isRef) {
        refTotalTokens++;
        refWordFreq[word] = (refWordFreq[word] || 0) + 1;
      }
    }
  }
  
  // Second pass: find matches and count collocates
  for (const [fileId, file] of Object.entries(corpus.files)) {
    const folder = file.folder;
    const isTarget = targetFolders.has(folder);
    const isRef = referenceFolders.has(folder);
    if (!isTarget && !isRef) continue;
    
    const fileTokens = file.tokens || [];
    
    for (let i = 0; i <= fileTokens.length - n; i++) {
      let match = true;
      for (let j = 0; j < n; j++) {
        if (!matchers[j](fileTokens[i + j])) {
          match = false;
          break;
        }
      }
      
      if (match) {
        if (isTarget) totalTargetHits++;
        if (isRef) totalRefHits++;
        
        // Collect left collocates
        for (let pos = 1; pos <= spanL; pos++) {
          const idx = i - pos;
          if (idx >= 0) {
            const tok = fileTokens[idx];
            if (!isPunctuationOrSpaceToken(tok)) {
              const word = getCollocateValue(tok);
              if (isTarget) {
                data.target.left[pos][word] = (data.target.left[pos][word] || 0) + 1;
              }
              if (isRef) {
                data.reference.left[pos][word] = (data.reference.left[pos][word] || 0) + 1;
              }
            }
          }
        }
        
        // Collect right collocates
        for (let pos = 1; pos <= spanR; pos++) {
          const idx = i + n - 1 + pos;
          if (idx < fileTokens.length) {
            const tok = fileTokens[idx];
            if (!isPunctuationOrSpaceToken(tok)) {
              const word = getCollocateValue(tok);
              if (isTarget) {
                data.target.right[pos][word] = (data.target.right[pos][word] || 0) + 1;
              }
              if (isRef) {
                data.reference.right[pos][word] = (data.reference.right[pos][word] || 0) + 1;
              }
            }
          }
        }
      }
    }
  }
  
  collocateData = {
    node,
    data,
    spanL,
    spanR,
    topN,
    statType,
    featureType: 'advanced',
    calcMode,
    totalTargetHits,
    totalRefHits,
    targetTotalTokens,
    refTotalTokens,
    targetWordFreq,
    refWordFreq
  };
  
  renderAllCollocateTables();
  
  const modeLabelMap = { surface: 'surface', lemma: 'lemma', pos_simple: 'POS simple', pos_detailed: 'POS detailed' };
  const modeLabel = ` (collocates: ${modeLabelMap[calcMode] || 'surface'})`;
  status.textContent = `Node: "${node}" — Target hits: ${totalTargetHits}, Reference hits: ${totalRefHits}${modeLabel}`;
}

// Compute KWIC using advanced mode with Word+POS filters
function computeAdvancedKwic() {
  const status = document.getElementById('kwicStatus');
  const body = document.getElementById('kwicTableBody');
  status.textContent = '';
  lastKwicRows = [];
  window.lastKwicFilterState = null;
  currentCollocateWord = null;
  currentCollocateInfo = null;

  if (!corpus || Object.keys(corpus.files).length === 0) {
    status.textContent = 'Please load a corpus first.';
    body.innerHTML = '<tr><td colspan="6" class="text-xs">No KWIC.</td></tr>';
    return;
  }
  
  // Check for Tagged corpus
  if (corpus.mode !== 'tagged' && corpus.mode !== 'csv') {
    status.textContent = 'Advanced mode requires a Tagged corpus (surface_POSd_POSs_lemma format).';
    body.innerHTML = '<tr><td colspan="6" class="text-xs">Please load a Tagged corpus.</td></tr>';
    return;
  }

  const advancedData = getKwicAdvancedTokenFilters();
  if (!advancedData || advancedData.tokenFilters.length === 0) {
    status.textContent = 'Please add at least one token.';
    return;
  }
  
  const { tokenFilters, caseInsensitive } = advancedData;
  const n = tokenFilters.length;
  
  // Build matchers for each token using new format
  const matchers = tokenFilters.map(filter => buildAdvancedTokenMatcherNew(filter, caseInsensitive));
  
  // Get scope
  const scopeRadio = document.querySelector('input[name="kwicScope"]:checked');
  const kwicScope = scopeRadio ? scopeRadio.value : 'all';
  
  // Use global targetFolders and referenceFolders Sets
  let foldersToSearch = [];
  if (kwicScope === 'target') foldersToSearch = Array.from(targetFolders);
  else if (kwicScope === 'reference') foldersToSearch = Array.from(referenceFolders);
  else if (kwicScope === 'all') {
    // All folders: get all unique folders from corpus
    const allFolders = new Set();
    for (const file of Object.values(corpus.files)) {
      if (file.folder) allFolders.add(file.folder);
    }
    foldersToSearch = Array.from(allFolders);
  }
  else if (kwicScope === 'specific') {
    // Specific folders: get selected folders from checkboxes
    foldersToSearch = getSelectedKwicFolders();
    if (foldersToSearch.length === 0) {
      status.textContent = 'Please select at least one folder.';
      return;
    }
  }
  else foldersToSearch = [...new Set([...targetFolders, ...referenceFolders])];
  
  if (foldersToSearch.length === 0) {
    status.textContent = 'Please select Target or Reference.';
    return;
  }
  
  // Search corpus
  const leftWidth = parseInt(document.getElementById('kwicLeftWidth')?.value) || 15;
  const rightWidth = parseInt(document.getElementById('kwicRightWidth')?.value) || 15;
  const maxHits = parseInt(document.getElementById('kwicMaxHits')?.value) || 300;
  
  const results = [];
  
  for (const [fileId, file] of Object.entries(corpus.files)) {
    if (!foldersToSearch.includes(file.folder)) continue;
    
    const fileTokens = file.tokens || [];
    
    // Slide window through tokens
    for (let i = 0; i <= fileTokens.length - n; i++) {
      let match = true;
      for (let j = 0; j < n; j++) {
        if (!matchers[j](fileTokens[i + j])) {
          match = false;
          break;
        }
      }
      
      if (match) {
        // Build KWIC row - find sentence boundaries for context
        let sentStart = i;
        let sentEnd = i + n;
        
        // Expand to sentence boundaries (look for sentence-ending punctuation)
        while (sentStart > 0) {
          const tok = fileTokens[sentStart - 1];
          const word = tok?.surface || tok?.word || '';
          if (/[.!?]$/.test(word)) break;
          sentStart--;
        }
        while (sentEnd < fileTokens.length) {
          const tok = fileTokens[sentEnd];
          const word = tok?.surface || tok?.word || '';
          if (/[.!?]$/.test(word)) {
            sentEnd++;
            break;
          }
          sentEnd++;
        }
        
        // Apply width limits
        const leftStart = Math.max(sentStart, i - leftWidth);
        const rightEnd = Math.min(sentEnd, i + n + rightWidth);
        
        const leftTokens = fileTokens.slice(leftStart, i);
        const nodeTokens = fileTokens.slice(i, i + n);
        const rightTokens = fileTokens.slice(i + n, rightEnd);
        
        const getDisplay = (tok) => tok.surface || tok.word || tok;
        
        // Determine side (Target/Reference)
        const isTarget = targetFolders.has(file.folder);
        const isRef = referenceFolders.has(file.folder);
        let side = '';
        if (isTarget && isRef) side = 'T/R';
        else if (isTarget) side = 'T';
        else if (isRef) side = 'R';
        
        results.push({
          fileId,
          folder: file.folder,
          fileName: file.name,
          leftText: leftTokens.map(getDisplay).join(' '),
          nodeText: nodeTokens.map(getDisplay).join(' '),
          rightText: rightTokens.map(getDisplay).join(' '),
          position: i,
          sentStart: leftStart,
          sentEnd: rightEnd,
          matchStart: i,
          matchEnd: i + n,
          leftTokens,
          nodeTokens,
          rightTokens,
          side
        });
        
        if (results.length >= maxHits * 10) break; // Limit for performance
      }
    }
    if (results.length >= maxHits * 10) break;
  }
  
  // Store for other sections
  lastKwicRows = results.slice(0, maxHits);
  allKwicRows = results;
  lastKwicAllCount = results.length;
  
  // Build feature string from tokens
  const featureStr = tokenFilters.map(f => f.word || '*').join(' ');
  currentKwicFeature = featureStr;
  currentKwicFeatureType = n > 1 ? 'ngram_word' : 'word';
  
  renderKwicRows();
  status.textContent = `Found ${results.length} matches (showing ${Math.min(results.length, maxHits)}).`;
  
  // Update simple mode inputs to keep in sync
  const kwicFeatureInput = document.getElementById('kwicFeatureInput');
  if (kwicFeatureInput) kwicFeatureInput.value = featureStr;
}

// Build matcher function for advanced KWIC with Word+POS filter
function buildAdvancedTokenMatcher(wordFilter, posFilter, caseInsensitive) {
  return (token) => {
    if (!token) return false;
    
    // Skip punctuation and space tokens
    if (isPunctuationOrSpaceToken(token)) return false;
    
    // Check word filter
    if (wordFilter && wordFilter.type !== 'any') {
      const { type, pattern } = wordFilter;
      
      // Skip if pattern is empty (unless type is 'any')
      if (!pattern && type !== 'any') {
        // No pattern specified, skip word filter check
      } else if (pattern) {
        let value;
        
        switch (type) {
          case 'surface':
            value = token.surface || token.word || '';
            break;
          case 'lemma':
            value = token.lemma || token.surface || token.word || '';
            break;
          case 'wildcard':
          case 'regex':
            value = token.surface || token.word || '';
            break;
          default:
            value = token.surface || token.word || '';
        }
        
        let wordMatch = false;
        const testValue = caseInsensitive ? value.toLowerCase() : value;
        const testPattern = caseInsensitive ? pattern.toLowerCase() : pattern;
        
        if (type === 'wildcard') {
          const wildcardRegex = new RegExp(
            '^' + testPattern.replace(/[.+^${}()|[\]\\]/g, '\\$&')
                             .replace(/\*/g, '.*')
                             .replace(/\?/g, '.') + '$',
            caseInsensitive ? 'i' : ''
          );
          wordMatch = wildcardRegex.test(value);
        } else if (type === 'regex') {
          try {
            const regex = new RegExp(pattern, caseInsensitive ? 'i' : '');
            wordMatch = regex.test(value);
          } catch (e) {
            wordMatch = false;
          }
        } else {
          // Exact match (surface or lemma)
          // Support pipe-separated alternatives
          const alternatives = testPattern.split('|');
          wordMatch = alternatives.some(alt => testValue === alt);
        }
        
        if (!wordMatch) return false;
      }
    }
    // If wordFilter.type === 'any', skip word check (matches any non-punctuation token)
    
    // Check POS filter if specified
    if (posFilter && posFilter.tags.size > 0) {
      const tokenPos = posFilter.mode === 'simple' ? (token.poss || '') : (token.posd || token.pos || '');
      if (!posFilter.tags.has(tokenPos)) return false;
    }
    
    return true;
  };
}

// Legacy function for compatibility - now uses token-based UI
function updateAdvancedKwicInputs(prefillData = null) {
  initAdvancedKwicTokens();
}

function computeKwic() {
  const status = document.getElementById('kwicStatus');
  const body = document.getElementById('kwicTableBody');
  status.textContent = '';
  // Reset KWIC / filter / collocate state for new search
  lastKwicRows = [];
  window.lastKwicFilterState = null;
  currentCollocateWord = null;
  currentCollocateInfo = null;

  // Biberタグフィルタ設定を取得
  const selectedBiberTags = getSelectedKwicBiberTags();
  const hasBiberFilter = selectedBiberTags.length > 0;
  const biberSensitive = isBiberSensitiveMode();

  if (!corpus || Object.keys(corpus.files).length === 0) {
    status.textContent = 'Please load a corpus first.';
    body.innerHTML = '<tr><td colspan="6" class="text-xs">No KWIC.</td></tr>';
    return;
  }

  const kwicFeatureInput = document.getElementById('kwicFeatureInput');
  const kwicTypeSelect = document.getElementById('kwicFeatureTypeSelect');
  let featureInput = kwicFeatureInput ? kwicFeatureInput.value.trim() : '';

  // Biberタグスロットに値がある場合、スロットの値を優先使用
  let forceBiberMode = false;
  if (hasBiberFilter) {
    // 単一タグ → biber_tag タイプ（n-gram機能は削除済み）
    currentKwicFeature = selectedBiberTags[0];
    currentKwicFeatureType = 'biber_tag';
    forceBiberMode = true;
    
    // Biberスロットから検索時は Node filter をクリア（自動フィルタリング防止）
    const nodeFilter = document.getElementById('kwicNodeFilter');
    if (nodeFilter) nodeFilter.value = '';
  } else if (featureInput) {
    currentKwicFeature = featureInput;
    if (kwicTypeSelect && kwicTypeSelect.value) {
      currentKwicFeatureType = kwicTypeSelect.value;
    }
  }
  
  // Biberタグフィルタで選択がある場合、検索語なしでも実行可能
  if (!currentKwicFeature && !hasBiberFilter) {
    status.textContent = 'Please specify a feature or select Biber tag(s).';
    body.innerHTML = '<tr><td colspan="6" class="text-xs">No KWIC.</td></tr>';
    return;
  }

  // featureTypeを決定
  const featureType = currentKwicFeatureType || lastKeyFeatureType || 'word';
  if (!featureType) {
    status.textContent = 'Feature type is unknown. Please compute 8) Keyness first.';
    body.innerHTML = '<tr><td colspan="6" class="text-xs">No KWIC.</td></tr>';
    return;
  }

  const maxHitsInput = document.getElementById('kwicMaxHits');
  let maxHits = parseInt(maxHitsInput.value, 10);
  if (!Number.isFinite(maxHits) || maxHits <= 0) maxHits = 300;

  const feature = currentKwicFeature || '';
  const viewMode = getKwicViewMode();

  let scope = 'target';
  const scopeEl = document.querySelector('input[name="kwicScope"]:checked');
  if (scopeEl && scopeEl.value) {
    scope = scopeEl.value;
  }

  // Get search mode
  const searchModeSelect = document.getElementById('kwicSearchMode');
  let searchMode = searchModeSelect ? searchModeSelect.value : 'exact';
  if (featureType === 'regex') {
    searchMode = 'regex';
  }
  const caseInsensitive = document.getElementById('kwicCaseInsensitive')?.checked ?? true;
  
  // Create matcher function based on search mode
  // Skip matcher creation for Biber tag types (they use different matching logic)
  let createMatcher = null;
  const isBiberTagType = featureType === 'biber_tag';
  if (!isBiberTagType && feature) {
    try {
      createMatcher = buildMatcherCreator(feature, searchMode, caseInsensitive);
    } catch (e) {
      status.textContent = `Invalid pattern: ${e.message}`;
      body.innerHTML = '<tr><td colspan="6" class="text-xs">Invalid pattern.</td></tr>';
      return;
    }
  }

  const allRows = [];
  const wildcardMatchCounts = {}; // Track matched words/phrases for wildcard/character search
  const files = Object.values(corpus.files);

  const isPframe = featureType.startsWith('pframe');
  const isNgramWord = featureType === 'ngram_word' || featureType === 'ngram_lemma';
  const isPosgram = featureType === 'posgram_simple' || featureType === 'posgram_detailed';
  const isBiberTag = featureType === 'biber_tag';
  
  // Check if feature contains space (multi-word pattern) for word/word_lemma types
  // Also treat patterns with punctuation as multi-word (e.g., "here," becomes ["here", ","])
  const patternHasPunct = /[.,!?;:]/.test(feature);
  const isMultiWordPattern = (featureType === 'word' || featureType === 'word_lemma') && (feature.includes(' ') || patternHasPunct);

  // Helper function to split feature tokens, separating punctuation
  const splitFeatureWithPunct = (feat) => {
    const rawTokens = feat.split(featureType === 'posgram_simple' || featureType === 'posgram_detailed' ? '+' : ' ').filter(t => t.length > 0);
    const result = [];
    for (const tok of rawTokens) {
      // Check for leading punctuation
      const leadingMatch = tok.match(/^([.,!?;:]+)/);
      if (leadingMatch) {
        result.push(leadingMatch[1]);
      }
      // Extract word part
      const wordPart = tok.replace(/^[.,!?;:]+|[.,!?;:]+$/g, '');
      if (wordPart) {
        result.push(wordPart);
      }
      // Check for trailing punctuation
      const trailingMatch = tok.match(/([.,!?;:]+)$/);
      if (trailingMatch && wordPart) {
        result.push(trailingMatch[1]);
      } else if (trailingMatch && !wordPart && !leadingMatch) {
        result.push(trailingMatch[1]);
      }
    }
    return result;
  };
  
  const featureTokens = (isNgramWord || isPframe || isPosgram || isMultiWordPattern) 
    ? (patternHasPunct ? splitFeatureWithPunct(feature) : feature.split(featureType === 'posgram_simple' || featureType === 'posgram_detailed' ? '+' : ' ').filter(t => t.length > 0))
    : null;
  const n = featureTokens ? featureTokens.length : 1;
  let starPos = -1;
  if (isPframe && featureTokens) {
    starPos = featureTokens.indexOf('*');
  }
  
  // Biberタグ検索用: フィーチャーをタグリストに変換
  const biberSearchTags = isBiberTag ? feature.split('|').map(t => t.trim()).filter(t => t.length > 0) : null;


  // Handle specific folder scope - get selected folders once
  const specificFolders = (scope === 'specific') ? getSelectedKwicFolders() : null;
  if (scope === 'specific' && (!specificFolders || specificFolders.length === 0)) {
    status.textContent = 'Please select at least one folder.';
    body.innerHTML = '<tr><td colspan="6" class="text-xs">No folders selected.</td></tr>';
    return;
  }
  for (const file of files) {
    const inT = targetFolders.has(file.folder);
    const inR = referenceFolders.has(file.folder);

    let useFile = false;
    if (scope === 'target') {
      useFile = inT;
    } else if (scope === 'reference') {
      useFile = inR;
    } else if (scope === 'all') {
      useFile = true;
    } else if (scope === 'specific') {
      useFile = specificFolders.includes(file.folder);
    } else {
      useFile = inT || inR;
    }
    if (!useFile) continue;

    // Apply optional file / folder filters (from 5b Concordance Plot)
    if (currentKwicFileFilter && file.name !== currentKwicFileFilter) {
      continue;
    }
    if (currentKwicFolderFilter && file.folder !== currentKwicFolderFilter) {
      continue;
    }

    const side = inT && inR ? 'T/R' : (inT ? 'T' : 'R');

    for (const sent of file.sentences) {
      const tokens = file.tokens;

      if (featureType === 'regex') {
        // Legacy regex feature type - still support for backward compatibility
        const caseInsensitive = document.getElementById('kwicCaseInsensitive')?.checked ?? true;
        let regex;
        try {
          regex = new RegExp(feature, caseInsensitive ? 'i' : '');
        } catch (e) {
          status.textContent = `Invalid regex: ${e.message}`;
          body.innerHTML = '<tr><td colspan="6" class="text-xs">Invalid regex.</td></tr>';
          return;
        }
        for (let idx = sent.tokenStart; idx < sent.tokenEnd; idx++) {
          const tok = tokens[idx];
          if (isPunctuationOrSpaceToken(tok)) continue;
          const val = tok.word || '';
          if (!val) continue;
          if (regex.test(val)) {
            allRows.push(makeKwicRow(file, sent, idx, idx + 1, side, viewMode));
            // Track matched word for display
            wildcardMatchCounts[val] = (wildcardMatchCounts[val] || 0) + 1;
          }
        }
      } else if (featureType === 'word' || featureType === 'word_lemma') {
        // Use the new matcher that supports exact/wildcard/regex and multiple patterns
        const useLemma = (featureType === 'word_lemma');
        for (let idx = sent.tokenStart; idx < sent.tokenEnd; idx++) {
          const tok = tokens[idx];
          if (isPunctuationOrSpaceToken(tok)) continue;
          const rawVal = (useLemma ? tok.lemma : tok.word) || '';
          if (!rawVal) continue;
          if (createMatcher(rawVal)) {
            // Biberタグフィルタを適用
            if (hasBiberFilter && !tokenMatchesBiberFilter(tok, selectedBiberTags, biberMatchMode)) {
              continue;
            }
            allRows.push(makeKwicRow(file, sent, idx, idx + 1, side, viewMode));
            // Track matched word for display
            const matchKey = caseInsensitive ? rawVal.toLowerCase() : rawVal;
            wildcardMatchCounts[matchKey] = (wildcardMatchCounts[matchKey] || 0) + 1;
          }
        }
      } else if (featureType === 'pos_simple' || featureType === 'pos_detailed') {
        const field = featureType === 'pos_simple' ? 'poss' : 'posd';
        for (let idx = sent.tokenStart; idx < sent.tokenEnd; idx++) {
          const tok = tokens[idx];
          if (isPunctuationOrSpaceToken(tok)) continue;
          const val = tok[field] || '';
          if (!val) continue;
          if (val === feature) {
            // Biberタグフィルタを適用
            if (hasBiberFilter && !tokenMatchesBiberFilter(tok, selectedBiberTags, biberMatchMode)) {
              continue;
            }
            allRows.push(makeKwicRow(file, sent, idx, idx + 1, side, viewMode));
          }
        }
      } else if (isBiberTag) {
        // Biber tag search: find tokens that have the specified Biber tags
        // biberSearchTags is derived from feature (e.g., "NOMZ" or "PASS|VPRT")
        const sensitive = isBiberSensitiveMode();
        for (let idx = sent.tokenStart; idx < sent.tokenEnd; idx++) {
          const tok = tokens[idx];
          if (isPunctuationOrSpaceToken(tok)) continue;
          if (!tok.biberTags || tok.biberTags.length === 0) continue;
          
          // Check if token matches the tag(s)
          let hasMatch = false;
          if (sensitive) {
            // Sensitive mode: token must have ONLY one of the search tags (exact match)
            hasMatch = biberSearchTags.some(tag => 
              tok.biberTags.length === 1 && tok.biberTags[0] === tag
            );
          } else {
            // Normal mode: token has any of the search tags
            hasMatch = biberSearchTags.some(tag => tok.biberTags.includes(tag));
          }
          
          if (hasMatch) {
            allRows.push(makeKwicRow(file, sent, idx, idx + 1, side, viewMode));
            // Track matched tag for display
            tok.biberTags.forEach(tag => {
              if (biberSearchTags.includes(tag)) {
                wildcardMatchCounts[tag] = (wildcardMatchCounts[tag] || 0) + 1;
              }
            });
          }
        }
      } else if (isNgramWord || isPframe || isPosgram || isMultiWordPattern) {
        // Check if pattern contains punctuation
        const patternHasPunct = /[.,!?;:]/.test(feature);
        
        // Split by sentence-ending punctuation within the sentence (unless pattern has punct)
        let subSentences;
        if (patternHasPunct) {
          // Include punctuation tokens when pattern contains punctuation
          const allTokens = [];
          const allIndices = [];
          for (let i = sent.tokenStart; i < sent.tokenEnd; i++) {
            const tok = tokens[i];
            if (tok.word) {
              allTokens.push(tok);
              allIndices.push(i);
            }
          }
          subSentences = allTokens.length > 0 ? [{ tokens: allTokens, indices: allIndices }] : [];
        } else {
          subSentences = getSentenceSegments(tokens, sent.tokenStart, sent.tokenEnd);
        }
        
        // Use the new multi-word matcher that supports |, *, ? and regex
        const tokenMatchers = buildMultiWordMatcher(featureTokens, searchMode, caseInsensitive);
        
        // Determine if using lemma for word-type multi-word patterns
        const useLemmaForMultiWord = featureType === 'word_lemma' || featureType === 'ngram_lemma';
        
        // Check if pattern contains wildcards for frequency tracking
        const hasWildcardPattern = searchMode === 'wildcard' || searchMode === 'regex' || 
                                    feature.includes('*') || feature.includes('?') || feature.includes('|');
        
        for (const subSent of subSentences) {
          const arr = [];
          const indices = [];  // Build indices array in sync with arr
          
          for (let ti = 0; ti < subSent.tokens.length; ti++) {
            const tok = subSent.tokens[ti];
            let val = '';
            if (isPosgram) {
              val = featureType === 'posgram_simple' ? tok.poss : tok.posd;
            } else if (useLemmaForMultiWord) {
              val = tok.lemma || tok.word;
            } else {
              val = tok.word;
            }
            if (!val) continue;
            arr.push(val);
            indices.push(subSent.indices[ti]);  // Keep indices in sync
          }
          if (arr.length < n) continue;
        
          for (let i = 0; i <= arr.length - n; i++) {
            const gram = arr.slice(i, i + n);
            let matches = true;
            for (let j = 0; j < n; j++) {
              const matcher = tokenMatchers[j];
              
              if (matcher.type === 'any') {
                // Standalone * matches anything
                continue;
              } else if (!matcher.match(gram[j])) {
                matches = false;
                break;
              }
            }
            if (matches) {
              const startIdx = indices[i];
              const endIdx = indices[i + n - 1] + 1;
              allRows.push(makeKwicRow(file, sent, startIdx, endIdx, side, viewMode));
              
              // Track matched phrase for wildcard frequency display
              if (hasWildcardPattern) {
                const matchedPhrase = gram.join(' ');
                const matchKey = caseInsensitive ? matchedPhrase.toLowerCase() : matchedPhrase;
                wildcardMatchCounts[matchKey] = (wildcardMatchCounts[matchKey] || 0) + 1;
              }
            }
          }
        }
      }
    }
  }

  allKwicRows = allRows;
  lastKwicAllCount = allRows.length;
  lastKwicSort = { col: 0, dir: 'asc' };
  lastOriginalIndex = null;
  
  // Store wildcard match counts for display
  lastWildcardMatchCounts = wildcardMatchCounts;

  if (allRows.length === 0) {
    status.textContent = 'No matching KWIC found.';
    body.innerHTML = '<tr><td colspan="6" class="text-xs">No KWIC.</td></tr>';
    document.getElementById('originalText').textContent = 'No text selected.';
    // Hide wildcard matches area
    const wildcardArea = document.getElementById('kwicWildcardMatches');
    if (wildcardArea) wildcardArea.style.display = 'none';
    return;
  }
  
  // Display wildcard/character match frequencies if applicable
  displayWildcardMatches(featureType, wildcardMatchCounts, feature);

  applyKwicFilter();
}



// Helper function to find the Nth word position (excluding punctuation/space)
function findNthWordPosition(tokens, row, context, n) {
  let count = 0;
  
  if (context === 'left') {
    // Search backwards from matchStart
    for (let i = row.matchStart - 1; i >= 0; i--) {
      const tok = tokens[i];
      if (isPunctuationOrSpaceToken(tok)) continue;
      count++;
      if (count === n) return i;
    }
  } else if (context === 'right') {
    // Search forwards from matchEnd
    for (let i = row.matchEnd; i < tokens.length; i++) {
      const tok = tokens[i];
      if (isPunctuationOrSpaceToken(tok)) continue;
      count++;
      if (count === n) return i;
    }
  } else {
    // Node - return matchStart
    return row.matchStart;
  }
  
  return -1; // Not found
}

function kwicMatchesFilter(text, pattern, mode, row = null, context = 'node', position = 'any', isRange = false) {
  if (!pattern) return true;
  const p = pattern.toLowerCase();
  
  // Handle wildcard mode
  if (mode === 'wildcard') {
    // Build wildcard regex
    let regexStr = pattern;
    regexStr = regexStr.replace(/[.+^${}()|[\]\\]/g, '\\$&');
    regexStr = regexStr.replace(/\*/g, '.*');
    regexStr = regexStr.replace(/\?/g, '.');
    const wildcardRegex = new RegExp('^' + regexStr + '$', 'i');
    
    // Get text to match based on context
    let textToMatch = text || '';
    if (position !== 'any' && row && context !== 'node') {
      const posNum = parseInt(position) || 1;
      let tokens;
      if (context === 'left') {
        tokens = row.leftTokens || [];
        if (isRange) {
          for (let pos = 1; pos <= posNum; pos++) {
            const targetIdx = tokens.length - pos;
            if (targetIdx >= 0 && targetIdx < tokens.length) {
              const tok = tokens[targetIdx];
              const word = tok.surface || tok.word || tok || '';
              if (wildcardRegex.test(word)) return true;
            }
          }
          return false;
        } else {
          const targetIdx = tokens.length - posNum;
          if (targetIdx >= 0 && targetIdx < tokens.length) {
            const tok = tokens[targetIdx];
            const word = tok.surface || tok.word || tok || '';
            return wildcardRegex.test(word);
          }
          return false;
        }
      } else if (context === 'right') {
        tokens = row.rightTokens || [];
        if (isRange) {
          for (let pos = 1; pos <= posNum; pos++) {
            const targetIdx = pos - 1;
            if (targetIdx >= 0 && targetIdx < tokens.length) {
              const tok = tokens[targetIdx];
              const word = tok.surface || tok.word || tok || '';
              if (wildcardRegex.test(word)) return true;
            }
          }
          return false;
        } else {
          const targetIdx = posNum - 1;
          if (targetIdx >= 0 && targetIdx < tokens.length) {
            const tok = tokens[targetIdx];
            const word = tok.surface || tok.word || tok || '';
            return wildcardRegex.test(word);
          }
          return false;
        }
      }
    }
    
    // Match any word in the text
    const words = textToMatch.split(/\s+/).filter(w => w.length > 0);
    return words.some(w => wildcardRegex.test(w));
  }
  
  if (mode === 'pos_simple' || mode === 'pos_detailed') {
    // POS filtering: need to access original token data
    if (!row || !corpus || !corpus.files[row.fileId]) {
      return true; // Can't filter without token data
    }
    
    const file = corpus.files[row.fileId];
    const tokens = file.tokens;
    const posField = mode === 'pos_detailed' ? 'posd' : 'poss';
    
    // Determine token range based on context
    let startIdx, endIdx;
    if (context === 'left') {
      startIdx = row.sentStart;
      endIdx = row.matchStart;
    } else if (context === 'right') {
      startIdx = row.matchEnd;
      endIdx = row.sentEnd;
    } else { // node
      startIdx = row.matchStart;
      endIdx = row.matchEnd;
    }
    
    // If specific position is requested
    if (position !== 'any') {
      const posNum = parseInt(position) || 1;
      
      if (isRange) {
        // Range mode: check L1 through Ln or R1 through Rn
        for (let pos = 1; pos <= posNum; pos++) {
          let targetIdx = findNthWordPosition(tokens, row, context, pos);
          
          if (targetIdx >= 0 && targetIdx < tokens.length) {
            const tok = tokens[targetIdx];
            const posVal = (tok[posField] || '').toLowerCase();
            if (posVal === p) return true;
          }
        }
        return false;
      } else {
        // Single position mode
        let targetIdx = findNthWordPosition(tokens, row, context, posNum);
        
        if (targetIdx >= 0 && targetIdx < tokens.length) {
          const tok = tokens[targetIdx];
          const posVal = (tok[posField] || '').toLowerCase();
          return posVal === p;
        }
        return false;
      }
    }
    
    // Check if any token in range has matching POS
    for (let i = startIdx; i < endIdx; i++) {
      const tok = tokens[i];
      if (isPunctuationOrSpaceToken(tok)) continue;
      const posVal = (tok[posField] || '').toLowerCase();
      if (posVal === p) return true;
    }
    return false;
  }
  
  // POSgram filtering: match sequence of POS tags (e.g., "DT+NN" for node)
  if (mode === 'posgram_simple' || mode === 'posgram_detailed') {
    if (!row || !corpus || !corpus.files[row.fileId]) {
      return true; // Can't filter without token data
    }
    
    const file = corpus.files[row.fileId];
    const tokens = file.tokens;
    const posField = mode === 'posgram_detailed' ? 'posd' : 'poss';
    
    // Parse expected POS sequence from pattern (e.g., "DT+NN" -> ["DT", "NN"])
    const expectedPOS = pattern.split('+').map(p => p.trim().toLowerCase());
    
    // For node context, get POS of matched tokens
    if (context === 'node') {
      // Collect POS tags from match tokens (skip punctuation and space)
      const matchPOS = [];
      for (let i = row.matchStart; i < row.matchEnd; i++) {
        const tok = tokens[i];
        if (!tok) continue;
        // Skip punctuation and space tokens
        if (isPunctuationOrSpaceToken(tok)) continue;
        const posVal = (tok[posField] || '').toLowerCase();
        if (posVal) matchPOS.push(posVal);
      }
      
      // Check if match POS sequence equals expected
      if (matchPOS.length === 0) return false;
      
      // Exact match: lengths and all elements must match
      if (matchPOS.length === expectedPOS.length) {
        for (let i = 0; i < expectedPOS.length; i++) {
          if (matchPOS[i] !== expectedPOS[i]) return false;
        }
        return true;
      }
      
      // Length mismatch - this can happen when:
      // 1. n-gram contains punctuation (matchPOS.length < expectedPOS.length)
      // 2. Filter doesn't match this n-gram pattern
      // In both cases, we should return false for strict matching
      return false;
    }
    
    // For left/right context: check POS sequence starting from specified position
    let startIdx, direction;
    if (context === 'left') {
      // For left context, start from the end (closest to node)
      startIdx = row.matchStart - 1;
      direction = -1; // Go backwards
    } else if (context === 'right') {
      // For right context, start from the beginning (closest to node)
      startIdx = row.matchEnd;
      direction = 1; // Go forwards
    } else {
      return true; // Unknown context
    }
    
    // Collect POS tags from context tokens
    const contextPOS = [];
    let posCount = 0;
    const targetCount = position !== 'any' ? parseInt(position) || expectedPOS.length : expectedPOS.length;
    
    for (let i = startIdx; posCount < targetCount && i >= 0 && i < tokens.length; i += direction) {
      const tok = tokens[i];
      if (!tok) continue;
      if (isPunctuationOrSpaceToken(tok)) continue;
      const posVal = (tok[posField] || '').toLowerCase();
      if (posVal) {
        if (direction === -1) {
          contextPOS.unshift(posVal); // Left context: prepend
        } else {
          contextPOS.push(posVal); // Right context: append
        }
        posCount++;
      }
    }
    
    // Check if context POS sequence matches expected
    if (contextPOS.length !== expectedPOS.length) return false;
    for (let i = 0; i < expectedPOS.length; i++) {
      if (contextPOS[i] !== expectedPOS[i]) return false;
    }
    return true;
  }
  
  // Biber tag filtering: match tokens with specified Biber tags
  if (mode === 'biber_tag') {
    if (!row || !corpus || !corpus.files[row.fileId]) {
      return true; // Can't filter without token data
    }
    
    const file = corpus.files[row.fileId];
    const tokens = file.tokens;
    
    // Parse expected Biber tags from pattern (e.g., "PASS|NOMZ" -> ["PASS", "NOMZ"])
    const expectedTags = pattern.split('|').map(t => t.trim().toUpperCase()).filter(t => t.length > 0);
    if (expectedTags.length === 0) return true;
    
    // If specific position is requested for left/right context
    if (position !== 'any' && context !== 'node') {
      const posNum = parseInt(position) || 1;
      
      if (isRange) {
        // Range mode: check L1 through Ln or R1 through Rn
        for (let pos = 1; pos <= posNum; pos++) {
          let targetIdx = findNthWordPosition(tokens, row, context, pos);
          
          if (targetIdx >= 0 && targetIdx < tokens.length) {
            const tok = tokens[targetIdx];
            if (tok.biberTags && tok.biberTags.length > 0) {
              if (expectedTags.some(tag => tok.biberTags.includes(tag))) {
                return true;
              }
            }
          }
        }
        return false;
      } else {
        // Single position mode
        let targetIdx = findNthWordPosition(tokens, row, context, posNum);
        
        if (targetIdx >= 0 && targetIdx < tokens.length) {
          const tok = tokens[targetIdx];
          if (tok.biberTags && tok.biberTags.length > 0) {
            return expectedTags.some(tag => tok.biberTags.includes(tag));
          }
        }
        return false;
      }
    }
    
    // Determine token range based on context
    let startIdx, endIdx;
    if (context === 'left') {
      startIdx = row.sentStart;
      endIdx = row.matchStart;
    } else if (context === 'right') {
      startIdx = row.matchEnd;
      endIdx = row.sentEnd;
    } else { // node
      startIdx = row.matchStart;
      endIdx = row.matchEnd;
    }
    
    // Check if any token in range has matching Biber tag (OR logic)
    for (let i = startIdx; i < endIdx; i++) {
      const tok = tokens[i];
      if (isPunctuationOrSpaceToken(tok)) continue;
      if (!tok.biberTags || tok.biberTags.length === 0) continue;
      
      // Check if token has any of the expected tags
      if (expectedTags.some(tag => tok.biberTags.includes(tag))) {
        return true;
      }
    }
    return false;
  }
  
  // Standard text-based filtering
  const t = (text || '').toLowerCase();
  
  // If specific position is requested for exact/partial match
  if (position !== 'any' && row && context !== 'node') {
    const posNum = parseInt(position) || 1;
    let tokens;
    
    if (context === 'left') {
      tokens = row.leftTokens || [];
      
      if (isRange) {
        // Range mode: check L1 through Ln
        for (let pos = 1; pos <= posNum; pos++) {
          const targetIdx = tokens.length - pos;
          if (targetIdx >= 0 && targetIdx < tokens.length) {
            const tok = tokens[targetIdx];
            const word = (tok.surface || tok.word || tok || '').toLowerCase();
            if (mode === 'partial') {
              if (word.includes(p)) return true;
            } else {
              if (word === p) return true;
            }
          }
        }
        return false;
      } else {
        // Single position mode
        const targetIdx = tokens.length - posNum;
        if (targetIdx >= 0 && targetIdx < tokens.length) {
          const tok = tokens[targetIdx];
          const word = (tok.surface || tok.word || tok || '').toLowerCase();
          if (mode === 'partial') {
            return word.includes(p);
          }
          return word === p;
        }
        return false;
      }
    } else if (context === 'right') {
      tokens = row.rightTokens || [];
      
      if (isRange) {
        // Range mode: check R1 through Rn
        for (let pos = 1; pos <= posNum; pos++) {
          const targetIdx = pos - 1;
          if (targetIdx >= 0 && targetIdx < tokens.length) {
            const tok = tokens[targetIdx];
            const word = (tok.surface || tok.word || tok || '').toLowerCase();
            if (mode === 'partial') {
              if (word.includes(p)) return true;
            } else {
              if (word === p) return true;
            }
          }
        }
        return false;
      } else {
        // Single position mode
        const targetIdx = posNum - 1;
        if (targetIdx >= 0 && targetIdx < tokens.length) {
          const tok = tokens[targetIdx];
          const word = (tok.surface || tok.word || tok || '').toLowerCase();
          if (mode === 'partial') {
            return word.includes(p);
          }
          return word === p;
        }
        return false;
      }
    }
  }
  
  if (!t) return false;
  
  if (mode === 'partial') {
    return t.includes(p);
  }
  
  // Exact match mode
  const parts = t.split(/\s+/).filter(x => x.length > 0);
  return parts.some(w => w === p);
}

// Check if current view mode is tagged
function isTaggedViewMode() {
  const viewMode = getKwicViewMode();
  return viewMode === 'tagged';
}

// Update the filter status bar above KWIC table
function updateFilterStatusBar() {
  const statusBar = document.getElementById('kwicFilterStatusBar');
  if (!statusBar) return;
  
  // Only show status bar if there's an active KWIC feature
  if (!currentKwicFeature) {
    statusBar.innerHTML = '';
    statusBar.classList.remove('active');
    return;
  }
  
  const fs = window.lastKwicFilterState || {};
  const leftStr = fs.leftStr || '';
  const nodeStr = fs.nodeStr || '';
  const rightStr = fs.rightStr || '';
  const leftMode = fs.leftMode || 'exact';
  const nodeMode = fs.nodeMode || 'exact';
  const rightMode = fs.rightMode || 'exact';
  
  // Get current scope
  const scopeRadio = document.querySelector('input[name="kwicScope"]:checked');
  const scope = scopeRadio ? scopeRadio.value : 'target';
  const scopeLabel = scope === 'target' ? 'Target' : (scope === 'reference' ? 'Reference' : 'Both');
  
  // Get collocate filter info
  const collocateInfo = currentCollocateInfo;
  const collocateWord = currentCollocateWord;
  
  // Build status parts
  const parts = [];
  
  // Helper to format filter with mode
  const formatFilter = (label, str, mode) => {
    if (!str) return null;
    let modeLabel = '';
    if (mode === 'pos_simple') modeLabel = '[POS-s]';
    else if (mode === 'pos_detailed') modeLabel = '[POS-d]';
    else if (mode === 'partial') modeLabel = '[partial]';
    return `${label}=<span class="value">${escapeHtml(str)}</span>${modeLabel}`;
  };
  
  // Helper to format filter with mode, position, and range
  const formatFilterWithPos = (label, str, mode, pos, isRange) => {
    if (!str) return null;
    let modeLabel = '';
    if (mode === 'pos_simple') modeLabel = '[POS-s]';
    else if (mode === 'pos_detailed') modeLabel = '[POS-d]';
    else if (mode === 'partial') modeLabel = '[partial]';
    let posLabel = '';
    if (pos && pos !== 'any') {
      if (isRange) {
        posLabel = `@${label[0]}1-${label[0]}${pos}`;
      } else {
        posLabel = `@${label[0]}${pos}`;
      }
    }
    return `${label}=<span class="value">${escapeHtml(str)}</span>${modeLabel}${posLabel}`;
  };
  
  // Get position and range from filter state
  const leftPos = fs.leftPos || 'any';
  const rightPos = fs.rightPos || 'any';
  const leftRange = fs.leftRange || false;
  const rightRange = fs.rightRange || false;
  
  // KWIC Filter info
  const kwicFilterParts = [];
  const leftPart = formatFilterWithPos('Left', leftStr, leftMode, leftPos, leftRange);
  const nodePart = formatFilter('Node', nodeStr, nodeMode);
  const rightPart = formatFilterWithPos('Right', rightStr, rightMode, rightPos, rightRange);
  if (leftPart) kwicFilterParts.push(leftPart);
  if (nodePart) kwicFilterParts.push(nodePart);
  if (rightPart) kwicFilterParts.push(rightPart);
  
  if (kwicFilterParts.length > 0) {
    parts.push(`<span class="label">KWIC Filter:</span> ${kwicFilterParts.join(', ')}`);
  }
  
  // Collocate filter info
  if (collocateInfo && collocateWord) {
    const posLabel = collocateInfo.position === 'all' 
      ? `${collocateInfo.direction.toUpperCase()}-1~${collocateInfo.span}`
      : `${collocateInfo.direction.toUpperCase()}-${collocateInfo.position}`;
    parts.push(`<span class="label">Collocate:</span> ${posLabel} <span class="value">${escapeHtml(collocateWord)}</span>`);
  }
  
  // Always show scope and feature
  parts.push(`<span class="label">Scope:</span> <span class="value">${scopeLabel}</span>`);
  parts.push(`<span class="label">Feature:</span> <span class="value">${escapeHtml(currentKwicFeature)}</span>`);
  
  // Update the status bar with Reset button on the right
  const statusContent = parts.join('<span class="separator">|</span>');
  statusBar.innerHTML = `
    <div style="display:flex; justify-content:space-between; align-items:center;">
      <div>${statusContent}</div>
      <button type="button" class="btn-reset-filter" onclick="resetKwicToFeature()">Reset</button>
    </div>
  `;
  statusBar.classList.add('active');
}

// Reset KWIC to original Feature search results (clear filters and collocate narrowing)
// Clear ALL KWIC state and reset to initial state
function clearAllKwicState() {
  // Clear Simple mode inputs
  const kwicFeatureInput = document.getElementById('kwicFeatureInput');
  const kwicTypeSelect = document.getElementById('kwicFeatureTypeSelect');
  const kwicSearchMode = document.getElementById('kwicSearchMode');
  if (kwicFeatureInput) kwicFeatureInput.value = '';
  if (kwicTypeSelect) kwicTypeSelect.value = 'word';
  if (kwicSearchMode) kwicSearchMode.value = 'exact';
  
  // Clear Advanced mode inputs
  const patternField = document.getElementById('kwicAdvancedNode');
  if (patternField) patternField.value = '';
  initAdvancedKwicTokens();
  
  // Clear filter inputs
  const leftFilter = document.getElementById('kwicLeftFilter');
  const nodeFilter = document.getElementById('kwicNodeFilter');
  const rightFilter = document.getElementById('kwicRightFilter');
  if (leftFilter) leftFilter.value = '';
  if (nodeFilter) nodeFilter.value = '';
  if (rightFilter) rightFilter.value = '';
  
  // Reset position dropdowns
  const leftPos = document.getElementById('kwicLeftFilterPos');
  const rightPos = document.getElementById('kwicRightFilterPos');
  if (leftPos) leftPos.value = 'any';
  if (rightPos) rightPos.value = 'any';
  
  // Reset range checkboxes
  const leftRange = document.getElementById('kwicLeftFilterRange');
  const rightRange = document.getElementById('kwicRightFilterRange');
  if (leftRange) leftRange.checked = false;
  if (rightRange) rightRange.checked = false;
  
  // Reset filter modes
  const leftMode = document.getElementById('kwicLeftFilterMode');
  const nodeMode = document.getElementById('kwicNodeFilterMode');
  const rightMode = document.getElementById('kwicRightFilterMode');
  if (leftMode) leftMode.value = 'exact';
  if (nodeMode) nodeMode.value = 'exact';
  if (rightMode) rightMode.value = 'exact';
  
  // Clear all state variables
  currentKwicFeature = null;
  currentKwicFeatureType = null;
  lastKwicRows = [];
  allKwicRows = [];
  lastKwicAllCount = 0;
  lastKwicSort = { col: 0, dir: 'asc' };
  window.lastKwicFilterState = {};
  currentCollocateWord = null;
  currentCollocateInfo = null;
  
  // Clear KWIC table
  const body = document.getElementById('kwicTableBody');
  if (body) body.innerHTML = '<tr><td colspan="6" class="text-xs">No KWIC.</td></tr>';
  
  // Clear status
  const status = document.getElementById('kwicStatus');
  if (status) status.textContent = '';
  
  // Clear filter status bar
  const statusBar = document.getElementById('kwicFilterStatusBar');
  if (statusBar) {
    statusBar.innerHTML = '';
    statusBar.classList.remove('active');
  }
  
  // Clear original text
  const origText = document.getElementById('originalText');
  if (origText) origText.textContent = 'No text selected.';
  
  console.log('[clearAllKwicState] KWIC state cleared');
}

// Clear KWIC filters only (used when jumping from other sections)
function clearKwicFilters() {
  // Clear filter inputs
  const leftFilter = document.getElementById('kwicLeftFilter');
  const nodeFilter = document.getElementById('kwicNodeFilter');
  const rightFilter = document.getElementById('kwicRightFilter');
  if (leftFilter) leftFilter.value = '';
  if (nodeFilter) nodeFilter.value = '';
  if (rightFilter) rightFilter.value = '';
  
  // Reset position dropdowns
  const leftPos = document.getElementById('kwicLeftFilterPos');
  const rightPos = document.getElementById('kwicRightFilterPos');
  if (leftPos) leftPos.value = 'any';
  if (rightPos) rightPos.value = 'any';
  
  // Reset range checkboxes
  const leftRange = document.getElementById('kwicLeftFilterRange');
  const rightRange = document.getElementById('kwicRightFilterRange');
  if (leftRange) leftRange.checked = false;
  if (rightRange) rightRange.checked = false;
  
  // Reset filter modes
  const leftMode = document.getElementById('kwicLeftFilterMode');
  const nodeMode = document.getElementById('kwicNodeFilterMode');
  const rightMode = document.getElementById('kwicRightFilterMode');
  if (leftMode) leftMode.value = 'exact';
  if (nodeMode) nodeMode.value = 'exact';
  if (rightMode) rightMode.value = 'exact';
  
  // Clear Biber Tag Filter
  const biberTagCheckboxes = document.querySelectorAll('.kwicBiberTagCheck');
  biberTagCheckboxes.forEach(cb => cb.checked = false);
  const biberTagLabel = document.getElementById('kwicBiberTagLabel');
  if (biberTagLabel) biberTagLabel.textContent = 'Select tags...';
  // Close dropdown if open
  const biberDropdown = document.getElementById('kwicBiberTagDropdown');
  if (biberDropdown) biberDropdown.style.display = 'none';
  
  // Clear Biber N-gram slots (the slot selector UI)
  if (typeof clearBiberNgramSlots === 'function') {
    clearBiberNgramSlots();
  }
  
  // Note: Biber container UI is kept visible, only selection values are cleared
  
  // Clear filter state
  window.lastKwicFilterState = {};
  currentCollocateWord = null;
  currentCollocateInfo = null;
  
  console.log('[clearKwicFilters] KWIC filters cleared (including Biber Tag Filter)');
}

// Clear KWIC filters and refresh display (for UI button)
function clearKwicFiltersUI() {
  clearKwicFilters();
  
  // Reset to all KWIC rows from original feature search
  if (allKwicRows && allKwicRows.length > 0) {
    let maxHits = 300;
    const maxHitsInput = document.getElementById('kwicMaxHits');
    if (maxHitsInput) {
      const v = parseInt(maxHitsInput.value, 10);
      if (Number.isFinite(v) && v > 0) {
        maxHits = v;
      }
    }
    
    lastKwicRows = allKwicRows.slice(0, maxHits);
    lastKwicSort = { col: 0, dir: 'asc' };
    
    renderKwicRows();
    
    const status = document.getElementById('kwicStatus');
    if (status) {
      status.textContent = `KWIC hits: ${allKwicRows.length} (showing up to ${lastKwicRows.length})`;
    }
    
    updateFilterStatusBar();
  }
  
  console.log('[clearKwicFiltersUI] KWIC filters cleared and display refreshed');
}

// Clear KWIC sort settings
function clearKwicSort() {
  // Reset sort controls
  const sortPos = document.getElementById('kwicSortPos');
  const sortColumn = document.getElementById('kwicSortColumn');
  const sortDir = document.getElementById('kwicSortDir');
  
  if (sortPos) sortPos.value = '1';
  if (sortColumn) sortColumn.value = '2'; // Node
  if (sortDir) sortDir.value = 'asc';
  
  // Reset sort state
  lastKwicSort = { col: 0, dir: 'asc' };
  
  // Hide sort frequency area
  const sortFreqArea = document.getElementById('kwicSortFreqArea');
  if (sortFreqArea) sortFreqArea.style.display = 'none';
  
  // Re-render with default order (by row index)
  if (lastKwicRows && lastKwicRows.length > 0) {
    renderKwicRows();
  }
  
  console.log('[clearKwicSort] Sort settings cleared');
}

function resetKwicToFeature() {
  // Clear filter inputs
  const leftFilter = document.getElementById('kwicLeftFilter');
  const nodeFilter = document.getElementById('kwicNodeFilter');
  const rightFilter = document.getElementById('kwicRightFilter');
  if (leftFilter) leftFilter.value = '';
  if (nodeFilter) nodeFilter.value = '';
  if (rightFilter) rightFilter.value = '';
  
  // Reset position dropdowns
  const leftPos = document.getElementById('kwicLeftFilterPos');
  const rightPos = document.getElementById('kwicRightFilterPos');
  if (leftPos) leftPos.value = 'any';
  if (rightPos) rightPos.value = 'any';
  
  // Reset range checkboxes
  const leftRange = document.getElementById('kwicLeftFilterRange');
  const rightRange = document.getElementById('kwicRightFilterRange');
  if (leftRange) leftRange.checked = false;
  if (rightRange) rightRange.checked = false;
  
  // Reset filter modes
  const leftMode = document.getElementById('kwicLeftFilterMode');
  const nodeMode = document.getElementById('kwicNodeFilterMode');
  const rightMode = document.getElementById('kwicRightFilterMode');
  if (leftMode) leftMode.value = 'exact';
  if (nodeMode) nodeMode.value = 'exact';
  if (rightMode) rightMode.value = 'exact';
  
  // Clear filter state
  window.lastKwicFilterState = {};
  
  // Clear collocate filter
  currentCollocateWord = null;
  currentCollocateInfo = null;
  
  // Reset to all KWIC rows from original feature search
  if (allKwicRows && allKwicRows.length > 0) {
    let maxHits = 300;
    const maxHitsInput = document.getElementById('kwicMaxHits');
    if (maxHitsInput) {
      const v = parseInt(maxHitsInput.value, 10);
      if (Number.isFinite(v) && v > 0) {
        maxHits = v;
      }
    }
    
    lastKwicRows = allKwicRows.slice(0, maxHits);
    lastKwicSort = { col: 0, dir: 'asc' };
    lastOriginalIndex = null;
    
    renderKwicRows();
    
    const status = document.getElementById('kwicStatus');
    if (status) {
      status.textContent = `KWIC hits: ${allKwicRows.length} (showing up to ${lastKwicRows.length})`;
    }
    
    // Update status bar
    updateFilterStatusBar();
    
    // Clear original text
    const origText = document.getElementById('originalText');
    if (origText) origText.textContent = 'No text selected.';
    
    // Re-compute collocates based on reset KWIC
    computeCollocatesFromKwic();
  }
}

function applyKwicFilter() {
  const status = document.getElementById('kwicStatus');
  const body = document.getElementById('kwicTableBody');

  if (!allKwicRows || allKwicRows.length === 0) {
    if (body) {
      body.innerHTML = '<tr><td colspan="6" class="text-xs">No KWIC.</td></tr>';
    }
    if (status) {
      status.textContent = 'KWIC has not been computed yet (please select a feature from 4)).';
    }
    return;
  }

  let maxHits = 300;
  const maxHitsInput = document.getElementById('kwicMaxHits');
  if (maxHitsInput) {
    const v = parseInt(maxHitsInput.value, 10);
    if (Number.isFinite(v) && v > 0) {
      maxHits = v;
    }
  }

  const leftBox  = document.getElementById('kwicLeftFilter');
  const nodeBox  = document.getElementById('kwicNodeFilter');
  const rightBox = document.getElementById('kwicRightFilter');

  const leftModeSel  = document.getElementById('kwicLeftFilterMode');
  const nodeModeSel  = document.getElementById('kwicNodeFilterMode');
  const rightModeSel = document.getElementById('kwicRightFilterMode');
  
  const leftPosSel  = document.getElementById('kwicLeftFilterPos');
  const rightPosSel = document.getElementById('kwicRightFilterPos');
  
  const leftRangeCheck  = document.getElementById('kwicLeftFilterRange');
  const rightRangeCheck = document.getElementById('kwicRightFilterRange');
  
  const leftExcludeCheck  = document.getElementById('kwicLeftFilterExclude');
  const nodeExcludeCheck  = document.getElementById('kwicNodeFilterExclude');
  const rightExcludeCheck = document.getElementById('kwicRightFilterExclude');

  const leftStr  = leftBox  ? leftBox.value.trim()  : '';
  const nodeStr  = nodeBox  ? nodeBox.value.trim()  : '';
  const rightStr = rightBox ? rightBox.value.trim() : '';

  const leftMode  = leftModeSel  ? leftModeSel.value  : 'exact';
  const nodeMode  = nodeModeSel  ? nodeModeSel.value  : 'exact';
  const rightMode = rightModeSel ? rightModeSel.value : 'exact';
  
  const leftPos  = leftPosSel  ? leftPosSel.value  : 'any';
  const rightPos = rightPosSel ? rightPosSel.value : 'any';
  
  const leftRange  = leftRangeCheck  ? leftRangeCheck.checked  : false;
  const rightRange = rightRangeCheck ? rightRangeCheck.checked : false;
  
  const leftExclude  = leftExcludeCheck  ? leftExcludeCheck.checked  : false;
  const nodeExclude  = nodeExcludeCheck  ? nodeExcludeCheck.checked  : false;
  const rightExclude = rightExcludeCheck ? rightExcludeCheck.checked : false;

  // Check if POS filter is being used - requires Tagged corpus mode
  const usingPosFilter = leftMode.startsWith('pos_') || nodeMode.startsWith('pos_') || rightMode.startsWith('pos_');
  if (usingPosFilter && corpus && corpus.mode !== 'tagged' && corpus.mode !== 'csv') {
    if (status) {
      status.textContent = 'POS filter requires Tagged corpus format (word_POSd_POSs_lemma).';
    }
    return;
  }

  // Base rows: if KWIC is already narrowed (e.g., by collocate), use that as input.
  const baseRows = (lastKwicRows && lastKwicRows.length > 0) ? lastKwicRows : allKwicRows;

  let filtered = baseRows.filter(r => {
    // Pass row data for POS filtering with position and range
    let okLeft  = kwicMatchesFilter(r.leftText,  leftStr,  leftMode, r, 'left', leftPos, leftRange);
    let okNode  = kwicMatchesFilter(r.nodeText,  nodeStr,  nodeMode, r, 'node', 'any', false);
    let okRight = kwicMatchesFilter(r.rightText, rightStr, rightMode, r, 'right', rightPos, rightRange);
    
    // Apply Exclude logic (invert match result if Exclude is checked and filter has content)
    if (leftStr && leftExclude) okLeft = !okLeft;
    if (nodeStr && nodeExclude) okNode = !okNode;
    if (rightStr && rightExclude) okRight = !okRight;
    
    return okLeft && okNode && okRight;
  });

  lastKwicRows = filtered.slice(0, maxHits);
  lastOriginalIndex = null;

  // 保存してハイライトに使う
  window.lastKwicFilterState = {
    leftStr, nodeStr, rightStr, leftMode, nodeMode, rightMode, leftPos, rightPos, leftRange, rightRange,
    leftExclude, nodeExclude, rightExclude
  };
  
  // Update the filter status bar
  updateFilterStatusBar();

  if (!lastKwicRows || lastKwicRows.length === 0) {
    if (body) {
      body.innerHTML = '<tr><td colspan="6" class="text-xs">No KWIC (filter).</td></tr>';
    }
    if (status) {
      status.textContent = `KWIC hits: ${lastKwicAllCount} (after filter: 0)`;
    }
    const orig = document.getElementById('originalText');
    if (orig) orig.textContent = 'No text selected.';
    updateFilterStatusBar(); // Also update when no results
    return;
  }

  renderKwicRows();
  if (status) {
    status.textContent = `KWIC hits: ${lastKwicAllCount} (after filter: ${filtered.length}; showing up to ${lastKwicRows.length})`;
  }

  // Auto-compute collocates when KWIC is updated
  computeCollocatesFromKwic();
}
function renderKwicRows() {
  const body = document.getElementById('kwicTableBody');
  if (!lastKwicRows || lastKwicRows.length === 0) {
    body.innerHTML = '<tr><td colspan="6" class="text-xs">No KWIC.</td></tr>';
    return;
  }

  const posColorMap = getPosColorMap();
  const viewMode = getKwicViewMode();

  const factor = lastKwicSort.dir === 'asc' ? 1 : -1;
  const col = lastKwicSort.col;
  
  // Get unified sort position
  const sortPos = parseInt(document.getElementById('kwicSortPos')?.value, 10) || 1;
  const sortPosLeft = sortPos;
  const sortPosNode = sortPos;
  const sortPosRight = sortPos;

  // Helper function to get Nth word from text (ignoring punctuation)
  const getNthWord = (text, n, fromEnd = false) => {
    const words = (text || '').split(/\s+/).filter(w => w.length > 0 && !isPunctuationWord(w));
    if (words.length === 0) return '';
    if (fromEnd) {
      const idx = words.length - n;
      return idx >= 0 ? words[idx].toLowerCase() : '';
    } else {
      const idx = n - 1;
      return idx < words.length ? words[idx].toLowerCase() : '';
    }
  };

  lastKwicRows.sort((a, b) => {
    let va, vb;
    switch (col) {
      case 1: 
        va = getNthWord(a.leftText, sortPosLeft, true); 
        vb = getNthWord(b.leftText, sortPosLeft, true); 
        return va.localeCompare(vb) * factor;
      case 2: 
        va = getNthWord(a.nodeText, sortPosNode, false); 
        vb = getNthWord(b.nodeText, sortPosNode, false); 
        return va.localeCompare(vb) * factor;
      case 3: 
        va = getNthWord(a.rightText, sortPosRight, false); 
        vb = getNthWord(b.rightText, sortPosRight, false); 
        return va.localeCompare(vb) * factor;
      case 4: va = a.folder.toLowerCase(); vb = b.folder.toLowerCase(); return va.localeCompare(vb) * factor;
      case 5: va = a.fileName.toLowerCase(); vb = b.fileName.toLowerCase(); return va.localeCompare(vb) * factor;
      default: return 0;
    }
  });

  let html = '';
  for (let i = 0; i < lastKwicRows.length; i++) {
    const r = lastKwicRows[i];
    
    const file = corpus.files[r.fileId];
    const tokens = file ? file.tokens : [];
    
    const leftWidthInput = document.getElementById('kwicLeftWidth');
    const rightWidthInput = document.getElementById('kwicRightWidth');
    let L = parseInt(leftWidthInput.value, 10);
    let R = parseInt(rightWidthInput.value, 10);
    if (!Number.isFinite(L) || L <= 0) L = 15;
    if (!Number.isFinite(R) || R <= 0) R = 15;
    
    // Build left tokens - include punctuation in display but count only words for L limit
    const leftTokensAll = [];
    for (let j = r.sentStart; j < r.matchStart; j++) {
      const tok = tokens[j];
      if (!tok || !tok.word) continue;
      const isPunct = isPunctuationOrSpaceToken(tok);
      leftTokensAll.push({
        text: tokenToString(tok, viewMode),
        lemma: tok.lemma ? tok.lemma.toLowerCase() : tok.word.toLowerCase(),
        isPunct,
        tok  // Keep original token for POS filtering
      });
    }
    // Keep last L words worth of tokens (punctuation attaches to adjacent words)
    let leftCutIdx = 0;
    let wordsFromEnd = 0;
    for (let j = leftTokensAll.length - 1; j >= 0 && wordsFromEnd < L; j--) {
      if (!leftTokensAll[j].isPunct) {
        wordsFromEnd++;
      }
      leftCutIdx = j;
    }
    const leftTokens = leftTokensAll.slice(leftCutIdx);

    // Build node tokens - include punctuation
    const nodeTokens = [];
    for (let j = r.matchStart; j < r.matchEnd; j++) {
      const tok = tokens[j];
      if (!tok || !tok.word) continue;
      const isPunct = isPunctuationOrSpaceToken(tok);
      nodeTokens.push({
        text: tokenToString(tok, viewMode),
        lemma: tok.lemma ? tok.lemma.toLowerCase() : tok.word.toLowerCase(),
        isPunct,
        tok
      });
    }

    // Build right tokens - include punctuation but count only words for R limit
    const rightTokensAll = [];
    for (let j = r.matchEnd; j < r.sentEnd; j++) {
      const tok = tokens[j];
      if (!tok || !tok.word) continue;
      const isPunct = isPunctuationOrSpaceToken(tok);
      rightTokensAll.push({
        text: tokenToString(tok, viewMode),
        lemma: tok.lemma ? tok.lemma.toLowerCase() : tok.word.toLowerCase(),
        isPunct,
        tok
      });
    }
    // Keep first R words worth of tokens
    let rightCutIdx = rightTokensAll.length;
    let wordsFromStart = 0;
    for (let j = 0; j < rightTokensAll.length && wordsFromStart < R; j++) {
      if (!rightTokensAll[j].isPunct) {
        wordsFromStart++;
      }
      rightCutIdx = j + 1;
    }
    const rightTokens = rightTokensAll.slice(0, rightCutIdx);

    // Filter state for orange highlight
    const fs = window.lastKwicFilterState || {};
    const fLeft  = (fs.leftStr  || '').toLowerCase();
    const fNode  = (fs.nodeStr  || '').toLowerCase();
    const fRight = (fs.rightStr || '').toLowerCase();
    const mLeft  = fs.leftMode  || 'exact';
    const mNode  = fs.nodeMode  || 'exact';
    const mRight = fs.rightMode || 'exact';

    // Check if token matches filter (including POS modes)
    const matchTokenForFilter = (tokItem, pattern, mode) => {
      if (!pattern) return false;
      const p = pattern.toLowerCase();
      
      if (mode === 'pos_simple' || mode === 'pos_detailed') {
        if (tokItem.isPunct) return false;
        const posField = mode === 'pos_detailed' ? 'posd' : 'poss';
        const posVal = (tokItem.tok[posField] || '').toLowerCase();
        return posVal === p;
      }
      
      // Text-based matching
      const t = (tokItem.text || '').toLowerCase();
      if (mode === 'partial') {
        return t.includes(p);
      }
      // Exact match - for tagged mode, match the word part only
      if (viewMode === 'tagged' && t.includes('_')) {
        const wordPart = t.split('_')[0];
        return wordPart === p;
      }
      return t === p;
    };

    // Calculate word positions (excluding punctuation) for coloring
    const calcWordPositions = (tokenArr, fromEnd = false) => {
      const positions = [];
      let wordCount = 0;
      if (fromEnd) {
        for (let j = tokenArr.length - 1; j >= 0; j--) {
          if (!tokenArr[j].isPunct) {
            wordCount++;
            positions[j] = wordCount;
          } else {
            positions[j] = -1; // punctuation
          }
        }
      } else {
        for (let j = 0; j < tokenArr.length; j++) {
          if (!tokenArr[j].isPunct) {
            wordCount++;
            positions[j] = wordCount;
          } else {
            positions[j] = -1;
          }
        }
      }
      return positions;
    };

    const leftPositions = calcWordPositions(leftTokens, true); // L1 = closest to node
    const rightPositions = calcWordPositions(rightTokens, false); // R1 = closest to node

    // Build left HTML
    const fLeftPos = fs.leftPos || 'any';
    const fLeftRange = fs.leftRange || false;
    const fRightPos = fs.rightPos || 'any';
    const fRightRange = fs.rightRange || false;
    
    const leftParts = leftTokens.map((tokItem, idx) => {
      if (tokItem.isPunct) {
        return escapeHtml(tokItem.text);
      }
      
      let h = escapeHtml(tokItem.text);

      // Orange highlight for filter match - consider position
      const posFromNode = leftPositions[idx];
      let shouldHighlight = false;
      if (fLeft && matchTokenForFilter(tokItem, fLeft, mLeft)) {
        if (fLeftPos === 'any') {
          shouldHighlight = true;
        } else {
          const targetPos = parseInt(fLeftPos);
          if (fLeftRange) {
            // Range: L1 through Ln
            shouldHighlight = posFromNode >= 1 && posFromNode <= targetPos;
          } else {
            // Single position
            shouldHighlight = posFromNode === targetPos;
          }
        }
      }
      if (shouldHighlight) {
        h = `<span style="background-color:#fed7aa;">${h}</span>`;
      }

      // Collocate highlight (purple)
      if (currentCollocateInfo && currentCollocateInfo.direction === 'left' && tokItem.lemma === currentCollocateWord) {
        const posMatch = currentCollocateInfo.position === 'all' 
          ? posFromNode <= currentCollocateInfo.span
          : posFromNode === parseInt(currentCollocateInfo.position, 10);
        if (posMatch) {
          h = `<span class="kwic-collocate">${h}</span>`;
        } else if (posFromNode >= 1 && posFromNode <= 5) {
          const posLabel = 'L' + posFromNode;
          const color = posColorMap[posLabel];
          if (color) h = `<span style="color:${color};">${h}</span>`;
        }
      } else if (posFromNode >= 1 && posFromNode <= 5) {
        const posLabel = 'L' + posFromNode;
        const color = posColorMap[posLabel];
        if (color) h = `<span style="color:${color};">${h}</span>`;
      }
      return h;
    });
    const leftHtml = leftParts.join(' ');

    // Build node HTML
    const nodeParts = nodeTokens.map((tokItem) => {
      if (tokItem.isPunct) {
        return escapeHtml(tokItem.text);
      }
      
      let h = escapeHtml(tokItem.text);

      // Orange highlight for filter match
      if (matchTokenForFilter(tokItem, fNode, mNode)) {
        h = `<span style="background-color:#fed7aa;">${h}</span>`;
      }

      const color = posColorMap['Node'];
      if (color) h = `<span style="color:${color};">${h}</span>`;
      return h;
    });
    const nodeHtml = nodeParts.join(' ');

    // Build right HTML
    const rightParts = rightTokens.map((tokItem, idx) => {
      if (tokItem.isPunct) {
        return escapeHtml(tokItem.text);
      }
      
      let h = escapeHtml(tokItem.text);

      // Orange highlight for filter match - consider position
      const posFromNode = rightPositions[idx];
      let shouldHighlight = false;
      if (fRight && matchTokenForFilter(tokItem, fRight, mRight)) {
        if (fRightPos === 'any') {
          shouldHighlight = true;
        } else {
          const targetPos = parseInt(fRightPos);
          if (fRightRange) {
            // Range: R1 through Rn
            shouldHighlight = posFromNode >= 1 && posFromNode <= targetPos;
          } else {
            // Single position
            shouldHighlight = posFromNode === targetPos;
          }
        }
      }
      if (shouldHighlight) {
        h = `<span style="background-color:#fed7aa;">${h}</span>`;
      }

      // Collocate highlight (purple)
      if (currentCollocateInfo && currentCollocateInfo.direction === 'right' && tokItem.lemma === currentCollocateWord) {
        const posMatch = currentCollocateInfo.position === 'all' 
          ? posFromNode <= currentCollocateInfo.span
          : posFromNode === parseInt(currentCollocateInfo.position, 10);
        if (posMatch) {
          h = `<span class="kwic-collocate">${h}</span>`;
        } else if (posFromNode >= 1 && posFromNode <= 5) {
          const posLabel = 'R' + posFromNode;
          const color = posColorMap[posLabel];
          if (color) h = `<span style="color:${color};">${h}</span>`;
        }
      } else if (posFromNode >= 1 && posFromNode <= 5) {
        const posLabel = 'R' + posFromNode;
        const color = posColorMap[posLabel];
        if (color) h = `<span style="color:${color};">${h}</span>`;
      }
      return h;
    });
    const rightHtml = rightParts.join(' ');

    html += `<tr data-kwic-idx="${i}">
      <td>${i + 1}</td>
      <td class="mono text-right">${leftHtml}</td>
      <td class="mono text-center">${nodeHtml}</td>
      <td class="mono">${rightHtml}</td>
      <td>${escapeHtml(r.folder)}</td>
      <td>${escapeHtml(r.fileName)}</td>
    </tr>`;
  }
  body.innerHTML = html;

  const kwicTable = document.getElementById('kwicTable');
  const headers = kwicTable.querySelectorAll('thead th.sortable');
  headers.forEach(th => {
    th.classList.remove('sorted-asc', 'sorted-desc');
    const c = parseInt(th.getAttribute('data-col'), 10);
    if (c === lastKwicSort.col) {
      th.classList.add(lastKwicSort.dir === 'asc' ? 'sorted-asc' : 'sorted-desc');
    }
  });

  body.querySelectorAll('tr').forEach((tr, idx) => {
    tr.addEventListener('click', () => {
      lastOriginalIndex = idx;
      showOriginalFromKwic(idx);
      const origCard = document.getElementById('originalCard');
      if (origCard) {
        origCard.scrollIntoView({ behavior: 'smooth', block: 'start' });
      }
    });
  });
  
  // Calculate and display sort key frequencies
  displaySortKeyFrequencies(col, sortPos);
}

// Display sort key frequencies
function displaySortKeyFrequencies(col, sortPos) {
  const freqArea = document.getElementById('kwicSortFreqArea');
  const freqList = document.getElementById('kwicSortFreqList');
  const freqMore = document.getElementById('kwicSortFreqMore');
  const freqColSpan = document.getElementById('kwicSortFreqColumn');
  const freqPosSpan = document.getElementById('kwicSortFreqPos');
  
  if (!freqArea || !lastKwicRows || lastKwicRows.length === 0) {
    if (freqArea) freqArea.style.display = 'none';
    return;
  }
  
  // Only show for Left/Node/Right columns
  if (col < 1 || col > 3) {
    freqArea.style.display = 'none';
    return;
  }
  
  const colNames = { 1: 'Left', 2: 'Node', 3: 'Right' };
  freqColSpan.textContent = colNames[col];
  freqPosSpan.textContent = sortPos;
  
  // Helper to get Nth word
  const getNthWord = (text, n, fromEnd = false) => {
    const words = (text || '').split(/\s+/).filter(w => w.length > 0);
    if (words.length === 0) return '';
    if (fromEnd) {
      const idx = words.length - n;
      return idx >= 0 ? words[idx].toLowerCase() : '';
    } else {
      const idx = n - 1;
      return idx < words.length ? words[idx].toLowerCase() : '';
    }
  };
  
  // Count frequencies
  const freqMap = {};
  for (const row of lastKwicRows) {
    let word = '';
    switch (col) {
      case 1: word = getNthWord(row.leftText, sortPos, true); break;
      case 2: word = getNthWord(row.nodeText, sortPos, false); break;
      case 3: word = getNthWord(row.rightText, sortPos, false); break;
    }
    if (word) {
      freqMap[word] = (freqMap[word] || 0) + 1;
    }
  }
  
  // Sort by frequency descending
  const sorted = Object.entries(freqMap).sort((a, b) => b[1] - a[1]);
  
  if (sorted.length === 0) {
    freqArea.style.display = 'none';
    return;
  }
  
  // Store for show more
  window._sortKeyFreqData = sorted;
  window._sortKeyFreqShowAll = false;
  
  // Display top 10 initially
  const displayCount = Math.min(10, sorted.length);
  const displayItems = sorted.slice(0, displayCount);
  
  freqList.innerHTML = displayItems.map(([word, count]) => 
    `<span style="display:inline-block; margin-right:0.75rem; margin-bottom:0.25rem;">${escapeHtml(word)} <span style="color:#6b7280;">(${count})</span></span>`
  ).join('');
  
  // Show "show more" link if there are more items
  if (sorted.length > 10) {
    freqMore.style.display = 'block';
    const showMoreLink = document.getElementById('kwicSortFreqShowMore');
    showMoreLink.textContent = `Show more... (${sorted.length - 10} more)`;
    showMoreLink.onclick = (e) => {
      e.preventDefault();
      if (window._sortKeyFreqShowAll) {
        // Collapse
        freqList.innerHTML = window._sortKeyFreqData.slice(0, 10).map(([word, count]) => 
          `<span style="display:inline-block; margin-right:0.75rem; margin-bottom:0.25rem;">${escapeHtml(word)} <span style="color:#6b7280;">(${count})</span></span>`
        ).join('');
        showMoreLink.textContent = `Show more... (${window._sortKeyFreqData.length - 10} more)`;
        window._sortKeyFreqShowAll = false;
      } else {
        // Expand
        freqList.innerHTML = window._sortKeyFreqData.map(([word, count]) => 
          `<span style="display:inline-block; margin-right:0.75rem; margin-bottom:0.25rem;">${escapeHtml(word)} <span style="color:#6b7280;">(${count})</span></span>`
        ).join('');
        showMoreLink.textContent = 'Show less';
        window._sortKeyFreqShowAll = true;
      }
    };
  } else {
    freqMore.style.display = 'none';
  }
  
  freqArea.style.display = 'block';
}

function sortKwicBy(colIndex) {
  if (!lastKwicRows || lastKwicRows.length === 0) return;
  if (lastKwicSort.col === colIndex) {
    lastKwicSort.dir = lastKwicSort.dir === 'asc' ? 'desc' : 'asc';
  } else {
    lastKwicSort.col = colIndex;
    lastKwicSort.dir = 'asc';
  }
  renderKwicRows();
}

function buildLabelMapForRow(row, file) {
  const labelMap = {};
  const seqIndices = [];

  for (let idx = row.sentStart; idx < row.sentEnd; idx++) {
    const tok = file.tokens[idx];
    if (isPunctuationOrSpaceToken(tok)) continue;
    seqIndices.push(idx);
  }

  if (seqIndices.length === 0) return labelMap;

  let nodeStartPos = null;
  let nodeEndPos = null;

  for (let i = 0; i < seqIndices.length; i++) {
    const idx = seqIndices[i];
    if (idx >= row.matchStart && idx < row.matchEnd) {
      if (nodeStartPos === null) nodeStartPos = i;
      nodeEndPos = i + 1;
    }
  }

  if (nodeStartPos == null || nodeEndPos == null) return labelMap;

  for (let i = 0; i < seqIndices.length; i++) {
    const idx = seqIndices[i];
    let label = null;
    if (i < nodeStartPos) {
      const d = nodeStartPos - 1 - i;
      if (d >= 0 && d < 5) label = 'L' + (d + 1);
    } else if (i >= nodeStartPos && i < nodeEndPos) {
      label = 'Node';
    } else {
      const d = i - nodeEndPos;
      if (d >= 0 && d < 5) label = 'R' + (d + 1);
    }
    if (label) labelMap[idx] = label;
  }

  return labelMap;
}

function showOriginalFromKwic(index) {
  const origText = document.getElementById('originalText');
  const origMeta = document.getElementById('originalMeta');
  if (!lastKwicRows || index < 0 || index >= lastKwicRows.length) {
    origText.textContent = 'No text selected.';
    return;
  }
  const row = lastKwicRows[index];
  const file = corpus.files[row.fileId];
  if (!file) {
    origText.textContent = 'No text selected.';
    return;
  }

  const viewMode = getOriginalViewMode();
  const posColorMap = getPosColorMap();
  const labelMap = buildLabelMapForRow(row, file);
  
  // フィルタ状態（オレンジ用）
  const fs = window.lastKwicFilterState || {};
  const fLeft  = (fs.leftStr  || '').toLowerCase();
  const fNode  = (fs.nodeStr  || '').toLowerCase();
  const fRight = (fs.rightStr || '').toLowerCase();
  const mLeft  = fs.leftMode  || 'exact';
  const mNode  = fs.nodeMode  || 'exact';
  const mRight = fs.rightMode || 'exact';

  const matchTokenForFilter = (tok, pattern, mode) => {
    if (!pattern) return false;
    const t = (tok || '').toLowerCase();
    if (mode === 'partial') {
      return t.includes(pattern);
    }
    return t === pattern;
  };

  const lines = [];
  let firstHighlightSentenceIdx = -1; // Track first highlighted sentence
  for (let sentIdx = 0; sentIdx < file.sentences.length; sentIdx++) {
    const sent = file.sentences[sentIdx];
    const parts = [];
    let hasHighlight = false;
    for (let idx = sent.tokenStart; idx < sent.tokenEnd; idx++) {
      const tok = file.tokens[idx];
      const tokenStr = tokenToString(tok, viewMode);
      const label = labelMap[idx] || null;
      let h = escapeHtml(tokenStr);
      
      if (label) hasHighlight = true;
      
      // Apply orange filter highlight based on position
      let hasFilterHighlight = false;
      if (label) {
        if (label.startsWith('L') && fLeft) {
          if (matchTokenForFilter(tokenStr, fLeft, mLeft)) {
            h = `<span style="background-color:#fed7aa;">${h}</span>`;
            hasFilterHighlight = true;
          }
        } else if (label === 'Node' && fNode) {
          if (matchTokenForFilter(tokenStr, fNode, mNode)) {
            h = `<span style="background-color:#fed7aa;">${h}</span>`;
            hasFilterHighlight = true;
          }
        } else if (label.startsWith('R') && fRight) {
          if (matchTokenForFilter(tokenStr, fRight, mRight)) {
            h = `<span style="background-color:#fed7aa;">${h}</span>`;
            hasFilterHighlight = true;
          }
        }
      }
      
      // Apply position color
      const color = label ? posColorMap[label] : null;
      if (color) {
        h = `<span style="color:${color};">${h}</span>`;
      }
      parts.push(h);
    }
    
    // Track first sentence with highlight
    if (hasHighlight && firstHighlightSentenceIdx === -1) {
      firstHighlightSentenceIdx = sentIdx;
    }
    
    // Add ID to first highlighted sentence for scrolling
    if (sentIdx === firstHighlightSentenceIdx) {
      lines.push(`<span id="kwic-highlight-target">${parts.join(' ')}</span>`);
    } else {
      lines.push(parts.join(' '));
    }
  }

  origText.innerHTML = lines.join('<br>');

  // Scroll to highlighted portion
  setTimeout(() => {
    const target = document.getElementById('kwic-highlight-target');
    if (target) {
      target.scrollIntoView({ behavior: 'smooth', block: 'center' });
    }
  }, 100);

  origMeta.innerHTML = `
    <span class="text-xs help-text">
      Folder: <strong>${escapeHtml(row.folder)}</strong>,
      File: <strong>${escapeHtml(row.fileName)}</strong>,
      Side: <strong>${escapeHtml(row.side)}</strong>,
      Feature: <strong>${escapeHtml(currentKwicFeature || '')}</strong>
    </span>
  `;
}

// ===== Feature Type options by mode =====

// Convert feature type for KWIC (cluster -> ngram)
function convertFeatureTypeForKwic(featureType) {
  if (featureType === 'cluster_word') return 'ngram_word';
  if (featureType === 'cluster_lemma') return 'ngram_lemma';
  // Convert wordpos to word type
  if (featureType === 'wordpos_surface_simple' || featureType === 'wordpos_surface_detailed') return 'word';
  if (featureType === 'wordpos_lemma_simple' || featureType === 'wordpos_lemma_detailed') return 'word_lemma';
  // Convert ngrampos to ngram type
  if (featureType === 'ngrampos_surface_simple' || featureType === 'ngrampos_surface_detailed') return 'ngram_word';
  if (featureType === 'ngrampos_lemma_simple' || featureType === 'ngrampos_lemma_detailed') return 'ngram_lemma';
  return featureType;
}

// Extract word from word_POS format (e.g., "study_NN" -> "study")
function extractWordFromWordPos(feature) {
  // Split by last underscore to handle cases like "New_York_NNP"
  const lastUnderscoreIdx = feature.lastIndexOf('_');
  if (lastUnderscoreIdx > 0) {
    return feature.substring(0, lastUnderscoreIdx);
  }
  return feature;
}

// Extract POS from word_POS format (e.g., "study_NN" -> "NN")
function extractPosFromWordPos(feature) {
  const lastUnderscoreIdx = feature.lastIndexOf('_');
  if (lastUnderscoreIdx > 0 && lastUnderscoreIdx < feature.length - 1) {
    return feature.substring(lastUnderscoreIdx + 1);
  }
  return '';
}

// Extract words from n-gram word_POS format (e.g., "the_DT study_NN" -> "the study")
function extractWordsFromNgramPos(feature) {
  const parts = feature.split(' ');
  const words = parts.map(part => extractWordFromWordPos(part));
  return words.join(' ');
}

// Extract all POS tags from n-gram word_POS format (e.g., "the_DT study_NN" -> ["DT", "NN"])
function extractPosFromNgramPos(feature) {
  const parts = feature.split(' ');
  return parts.map(part => extractPosFromWordPos(part));
}

// Set feature to all related sections (KWIC, Collocate, Plot)
// Returns { kwicType, posTag, posMode } for wordpos/ngrampos types
function setFeatureToAllSections(feature, featureType, scope) {
  const kwicType = convertFeatureTypeForKwic(featureType);
  
  // Convert feature for wordpos/ngrampos types
  let kwicFeature = feature;
  let posTag = null;
  let posMode = null;
  
  // Biberタグの場合の特別処理
  const isBiberTag = featureType === 'biber_tag';
  
  if (isBiberTag) {
    // Biberタグの場合、Biber Tag Filter（スロットUI）に設定
    // featureはタグ名（例: "NOMZ"）
    
    // まずスロットをクリア
    clearBiberNgramSlots();
    
    // 最初のスロットを設定
    const container = document.getElementById('kwicBiberNgramSlots');
    if (container) {
      const firstSelect = container.querySelector('.biber-slot-select');
      if (firstSelect) {
        populateBiberSlotOptions(firstSelect);
        firstSelect.value = feature.trim();
      }
    }
    
    updateBiberNgramDisplay();
    
    // KWICのfeatureは空にする（Biberタグフィルタのみで検索）
    kwicFeature = '';
    
    // Biberタグフィルタコンテナを表示
    const biberContainer = document.getElementById('kwicBiberFilterContainer');
    if (biberContainer) biberContainer.style.display = 'block';
  } else if (featureType.startsWith('wordpos_')) {
    kwicFeature = extractWordFromWordPos(feature);
    posTag = extractPosFromWordPos(feature);
    // Use pos_simple or pos_detailed based on featureType
    // Check for both old format (wordpos_simple) and new format (wordpos_surface_simple)
    const isSimple = featureType.includes('_simple');
    posMode = isSimple ? 'pos_simple' : 'pos_detailed';
  } else if (featureType.startsWith('ngrampos_')) {
    kwicFeature = extractWordsFromNgramPos(feature);
    // For n-gram, get all POS tags and join with +
    const posTags = extractPosFromNgramPos(feature);
    if (posTags.length > 0) {
      posTag = posTags.join('+'); // Join with + for POSgram format (e.g., "DT+NN")
    }
    // Use posgram_simple or posgram_detailed for n-gram POS
    // Check for both old format (ngrampos_simple) and new format (ngrampos_surface_simple)
    const isSimple = featureType.includes('_simple');
    posMode = isSimple ? 'posgram_simple' : 'posgram_detailed';
  }
  
  // Set KWIC
  const kwicFeatureInput = document.getElementById('kwicFeatureInput');
  const kwicTypeSelect = document.getElementById('kwicFeatureTypeSelect');
  const kwicSearchMode = document.getElementById('kwicSearchMode');
  if (kwicFeatureInput) kwicFeatureInput.value = kwicFeature;
  if (kwicTypeSelect) kwicTypeSelect.value = kwicType;
  if (kwicSearchMode) kwicSearchMode.value = 'exact';  // Always use exact for linked searches
  
  // Set Node filter for wordpos/ngrampos types
  if (posTag && posMode) {
    const nodeFilter = document.getElementById('kwicNodeFilter');
    const nodeFilterMode = document.getElementById('kwicNodeFilterMode');
    if (nodeFilter) nodeFilter.value = posTag;
    if (nodeFilterMode) nodeFilterMode.value = posMode;
  }
  
  // For biber_tag types, do NOT set Node filter
  // The Biber slot selection is used directly for searching, not for filtering
  // Clear Node filter if it was set from previous search
  if (isBiberTag) {
    const nodeFilter = document.getElementById('kwicNodeFilter');
    if (nodeFilter) nodeFilter.value = '';
  }
  
  // Set Collocate (include Biber tag pattern for biber_tag types)
  const collocateInput = document.getElementById('collocateNodeInput');
  const collocateType = document.getElementById('collocateFeatureTypeSelect');
  if (isBiberTag) {
    // For Biber tags, set the feature directly to collocate
    if (collocateInput) collocateInput.value = feature;
    if (collocateType) collocateType.value = 'biber_tag';
  } else {
    if (collocateInput) collocateInput.value = kwicFeature;
    if (collocateType) collocateType.value = kwicType;
  }
  
  // Set Plot (include Biber tag pattern for biber_tag types)
  const plotInput = document.getElementById('plotFeatureInput');
  const plotType = document.getElementById('plotFeatureTypeSelect');
  const plotSearchMode = document.getElementById('plotSearchMode');
  if (isBiberTag) {
    if (plotInput) plotInput.value = feature;
    if (plotType) plotType.value = 'biber_tag';
  } else {
    if (plotInput) plotInput.value = kwicFeature;
    if (plotType) plotType.value = kwicType;
  }
  if (plotSearchMode) plotSearchMode.value = 'exact';
  
  // Set scope for KWIC and Plot
  if (scope) {
    const kwicScopeInput = document.querySelector(`input[name="kwicScope"][value="${scope}"]`);
    if (kwicScopeInput) kwicScopeInput.checked = true;
    
    const plotScopeInput = document.querySelector(`input[name="plotScope"][value="${scope}"]`);
    if (plotScopeInput) plotScopeInput.checked = true;
  }
  
  // Note: 12) Dependency Grammar Query is NOT synchronized with other sections
  // to avoid interference with pattern search
  
  return kwicType;
}

function refreshFeatureTypeOptions() {
  const sel = document.getElementById('featureTypeSelect');
  if (!sel) return;
  if (!corpus || corpus.mode === 'plain') {
    sel.innerHTML = `
      <option value="word">Word (surface)</option>
      <option value="ngram_word">n-gram (word)</option>
      <option value="pframe_word">p-frame (word)</option>
      <option value="cluster_word">Cluster (word)</option>
    `;
  } else if (corpus.mode === 'csv' && corpus.csvMetadata && corpus.csvMetadata.hasTags) {
    // CSV mode with Biber tags
    sel.innerHTML = `
      <option value="word">Word (surface)</option>
      <option value="word_lemma">Word (lemma)</option>
      <option value="ngram_word">n-gram (word)</option>
      <option value="ngram_lemma">n-gram (lemma)</option>
      <option value="pframe_word">p-frame (word)</option>
      <option value="pframe_lemma">p-frame (lemma)</option>
      <option value="cluster_word">Cluster (word)</option>
      <option value="cluster_lemma">Cluster (lemma)</option>
      <option value="pos_simple">POS (simple)</option>
      <option value="posgram_simple">POS-gram (simple)</option>
      <option value="pos_detailed">POS (detailed)</option>
      <option value="posgram_detailed">POS-gram (detailed)</option>
      <optgroup label="Biber Tags">
        <option value="biber_tag">Biber tag</option>
        
      </optgroup>
      <optgroup label="Dependency Grammar">
        <option value="dep">DEP (deprel tag frequency)</option>
        
        
        
        
      </optgroup>
      <optgroup label="Word + POS">
        <option value="wordpos_surface_simple">Word(surface)_POS(simple)</option>
        <option value="wordpos_lemma_simple">Word(lemma)_POS(simple)</option>
        <option value="wordpos_surface_detailed">Word(surface)_POS(detailed)</option>
        <option value="wordpos_lemma_detailed">Word(lemma)_POS(detailed)</option>
      </optgroup>
      <optgroup label="n-gram Word + POS">
        <option value="ngrampos_surface_simple">n-gram(surface)_POS(simple)</option>
        <option value="ngrampos_lemma_simple">n-gram(lemma)_POS(simple)</option>
        <option value="ngrampos_surface_detailed">n-gram(surface)_POS(detailed)</option>
        <option value="ngrampos_lemma_detailed">n-gram(lemma)_POS(detailed)</option>
      </optgroup>
    `;
  } else {
    // Tagged mode or CSV mode - both have POS/lemma info
    sel.innerHTML = `
      <option value="word">Word (surface)</option>
      <option value="word_lemma">Word (lemma)</option>
      <option value="ngram_word">n-gram (word)</option>
      <option value="ngram_lemma">n-gram (lemma)</option>
      <option value="pframe_word">p-frame (word)</option>
      <option value="pframe_lemma">p-frame (lemma)</option>
      <option value="cluster_word">Cluster (word)</option>
      <option value="cluster_lemma">Cluster (lemma)</option>
      <option value="pos_simple">POS (simple)</option>
      <option value="posgram_simple">POS-gram (simple)</option>
      <option value="pos_detailed">POS (detailed)</option>
      <option value="posgram_detailed">POS-gram (detailed)</option>
      <optgroup label="Word + POS">
        <option value="wordpos_surface_simple">Word(surface)_POS(simple)</option>
        <option value="wordpos_lemma_simple">Word(lemma)_POS(simple)</option>
        <option value="wordpos_surface_detailed">Word(surface)_POS(detailed)</option>
        <option value="wordpos_lemma_detailed">Word(lemma)_POS(detailed)</option>
      </optgroup>
      <optgroup label="n-gram Word + POS">
        <option value="ngrampos_surface_simple">n-gram(surface)_POS(simple)</option>
        <option value="ngrampos_lemma_simple">n-gram(lemma)_POS(simple)</option>
        <option value="ngrampos_surface_detailed">n-gram(surface)_POS(detailed)</option>
        <option value="ngrampos_lemma_detailed">n-gram(lemma)_POS(detailed)</option>
      </optgroup>
    `;
  }
  updateClusterUI('key');
}

function refreshKwicFeatureTypeOptions() {
  const kwicSel = document.getElementById('kwicFeatureTypeSelect');
  const collocateSel = document.getElementById('collocateFeatureTypeSelect');
  
  // Full options list for both KWIC and Collocate
  let plainOptionsHtml = `
    <option value="word">Word (surface)</option>
    <option value="ngram_word">n-gram (word)</option>
    <option value="pframe_word">p-frame (word)</option>
    <option value="regex">Regex</option>
  `;
  
  let taggedOptionsHtml = `
    <option value="word">Word (surface)</option>
    <option value="word_lemma">Word (lemma)</option>
    <option value="ngram_word">n-gram (word)</option>
    <option value="ngram_lemma">n-gram (lemma)</option>
    <option value="pframe_word">p-frame (word)</option>
    <option value="pframe_lemma">p-frame (lemma)</option>
    <option value="pos_simple">POS (simple)</option>
    <option value="posgram_simple">POS-gram (simple)</option>
    <option value="pos_detailed">POS (detailed)</option>
    <option value="posgram_detailed">POS-gram (detailed)</option>
    <option value="regex">Regex</option>
  `;
  
  // CSV mode with Biber tags - add Biber tag options (no DEP for KWIC/Collocate)
  let csvBiberOptionsHtml = `
    <option value="word">Word (surface)</option>
    <option value="word_lemma">Word (lemma)</option>
    <option value="ngram_word">n-gram (word)</option>
    <option value="ngram_lemma">n-gram (lemma)</option>
    <option value="pframe_word">p-frame (word)</option>
    <option value="pframe_lemma">p-frame (lemma)</option>
    <option value="pos_simple">POS (simple)</option>
    <option value="posgram_simple">POS-gram (simple)</option>
    <option value="pos_detailed">POS (detailed)</option>
    <option value="posgram_detailed">POS-gram (detailed)</option>
    <optgroup label="Biber Tags">
      <option value="biber_tag">Biber tag</option>
    </optgroup>
    <option value="regex">Regex</option>
  `;
  
  // Determine which options to use
  let optionsHtml;
  if (!corpus || corpus.mode === 'plain') {
    optionsHtml = plainOptionsHtml;
  } else if (corpus.mode === 'csv' && corpus.csvMetadata && corpus.csvMetadata.hasTags) {
    optionsHtml = csvBiberOptionsHtml;
  } else {
    optionsHtml = taggedOptionsHtml;
  }
  
  // Set options for KWIC
  if (kwicSel) {
    kwicSel.innerHTML = optionsHtml;
  }
  
  // Set options for Collocate (same as KWIC)
  if (collocateSel) {
    collocateSel.innerHTML = optionsHtml;
  }
  
  // Set options for Plot (same as KWIC)
  const plotSel = document.getElementById('plotFeatureTypeSelect');
  if (plotSel) {
    plotSel.innerHTML = optionsHtml;
  }
}


function refreshHfFeatureTypeOptions() {
  const sel = document.getElementById('hfFeatureTypeSelect');
  if (!sel) return;
  if (!corpus || corpus.mode === 'plain') {
    sel.innerHTML = `
      <option value="word">Word (surface)</option>
      <option value="ngram_word">n-gram (word)</option>
      <option value="pframe_word">p-frame (word)</option>
      <option value="cluster_word">Cluster (word)</option>
    `;
  } else if (corpus.mode === 'csv' && corpus.csvMetadata && corpus.csvMetadata.hasTags) {
    // CSV mode with Biber tags
    sel.innerHTML = `
      <option value="word">Word (surface)</option>
      <option value="word_lemma">Word (lemma)</option>
      <option value="ngram_word">n-gram (word)</option>
      <option value="ngram_lemma">n-gram (lemma)</option>
      <option value="pframe_word">p-frame (word)</option>
      <option value="pframe_lemma">p-frame (lemma)</option>
      <option value="cluster_word">Cluster (word)</option>
      <option value="cluster_lemma">Cluster (lemma)</option>
      <option value="pos_simple">POS (simple)</option>
      <option value="posgram_simple">POS-gram (simple)</option>
      <option value="pos_detailed">POS (detailed)</option>
      <option value="posgram_detailed">POS-gram (detailed)</option>
      <optgroup label="Biber Tags">
        <option value="biber_tag">Biber tag</option>
        
      </optgroup>
      <optgroup label="Dependency Grammar">
        <option value="dep">DEP (deprel tag frequency)</option>
        
        
        
        
      </optgroup>
      <optgroup label="Word + POS">
        <option value="wordpos_surface_simple">Word(surface)_POS(simple)</option>
        <option value="wordpos_lemma_simple">Word(lemma)_POS(simple)</option>
        <option value="wordpos_surface_detailed">Word(surface)_POS(detailed)</option>
        <option value="wordpos_lemma_detailed">Word(lemma)_POS(detailed)</option>
      </optgroup>
      <optgroup label="n-gram Word + POS">
        <option value="ngrampos_surface_simple">n-gram(surface)_POS(simple)</option>
        <option value="ngrampos_lemma_simple">n-gram(lemma)_POS(simple)</option>
        <option value="ngrampos_surface_detailed">n-gram(surface)_POS(detailed)</option>
        <option value="ngrampos_lemma_detailed">n-gram(lemma)_POS(detailed)</option>
      </optgroup>
    `;
  } else {
    // Tagged mode or CSV mode
    sel.innerHTML = `
      <option value="word">Word (surface)</option>
      <option value="word_lemma">Word (lemma)</option>
      <option value="ngram_word">n-gram (word)</option>
      <option value="ngram_lemma">n-gram (lemma)</option>
      <option value="pframe_word">p-frame (word)</option>
      <option value="pframe_lemma">p-frame (lemma)</option>
      <option value="cluster_word">Cluster (word)</option>
      <option value="cluster_lemma">Cluster (lemma)</option>
      <option value="pos_simple">POS (simple)</option>
      <option value="posgram_simple">POS-gram (simple)</option>
      <option value="pos_detailed">POS (detailed)</option>
      <option value="posgram_detailed">POS-gram (detailed)</option>
      <optgroup label="Word + POS">
        <option value="wordpos_surface_simple">Word(surface)_POS(simple)</option>
        <option value="wordpos_lemma_simple">Word(lemma)_POS(simple)</option>
        <option value="wordpos_surface_detailed">Word(surface)_POS(detailed)</option>
        <option value="wordpos_lemma_detailed">Word(lemma)_POS(detailed)</option>
      </optgroup>
      <optgroup label="n-gram Word + POS">
        <option value="ngrampos_surface_simple">n-gram(surface)_POS(simple)</option>
        <option value="ngrampos_lemma_simple">n-gram(lemma)_POS(simple)</option>
        <option value="ngrampos_surface_detailed">n-gram(surface)_POS(detailed)</option>
        <option value="ngrampos_lemma_detailed">n-gram(lemma)_POS(detailed)</option>
      </optgroup>
    `;
  }
  updateClusterUI('hf');
}

// Update Cluster UI visibility
function updateClusterUI(section) {
  const isKey = section === 'key';
  const featureType = isKey 
    ? document.getElementById('featureTypeSelect')?.value 
    : document.getElementById('hfFeatureTypeSelect')?.value;
  
  const isCluster = featureType && featureType.startsWith('cluster');
  // BiberPlus only is shown for biber_tag (single)
  const isBiberTagSingle = featureType === 'biber_tag';
  
  if (isKey) {
    const clusterUI = document.getElementById('keyClusterUI');
    if (clusterUI) clusterUI.style.display = isCluster ? 'flex' : 'none';
    
    // BiberPlus only checkbox visibility (only for single biber_tag)
    const biberPlusContainer = document.getElementById('keyBiberPlusContainer');
    if (biberPlusContainer) biberPlusContainer.style.display = isBiberTagSingle ? 'inline-flex' : 'none';
  } else {
    const clusterUI = document.getElementById('hfClusterUI');
    if (clusterUI) clusterUI.style.display = isCluster ? 'flex' : 'none';
    
    // BiberPlus only checkbox visibility for 7) HF (only for single biber_tag)
    const biberPlusContainer = document.getElementById('hfBiberPlusContainer');
    if (biberPlusContainer) biberPlusContainer.style.display = isBiberTagSingle ? 'inline-flex' : 'none';
  }
  
  // Also update Frequency Table BiberPlus container
  updateFreqTableBiberPlusVisibility();
}

// Update BiberPlus checkbox visibility for Frequency Table
function updateFreqTableBiberPlusVisibility() {
  const featureType = document.getElementById('freqTableFeatureType')?.value;
  // BiberPlus only is shown for biber_tag (single)
  const isBiberTagSingle = featureType === 'biber_tag';
  const container = document.getElementById('freqTableBiberPlusContainer');
  if (container) container.style.display = isBiberTagSingle ? 'inline-flex' : 'none';
}

// Sync feature type between 7) HF and 8) Keyness
function syncFeatureTypeSelects(source) {
  const keySel = document.getElementById('featureTypeSelect');
  const hfSel = document.getElementById('hfFeatureTypeSelect');
  const keyN = document.getElementById('nInput');
  const hfN = document.getElementById('hfNInput');
  
  if (source === 'key' && keySel && hfSel) {
    hfSel.value = keySel.value;
    if (keyN && hfN) hfN.value = keyN.value;
    updateClusterUI('hf');
  } else if (source === 'hf' && keySel && hfSel) {
    keySel.value = hfSel.value;
    if (keyN && hfN) keyN.value = hfN.value;
    updateClusterUI('key');
  }
  
  // Also sync cluster search word and position
  syncClusterInputs(source);
}

function syncClusterInputs(source) {
  const keyWord = document.getElementById('keyClusterWord');
  const hfWord = document.getElementById('hfClusterWord');
  const keyPos = document.getElementById('keyClusterPosition');
  const hfPos = document.getElementById('hfClusterPosition');
  
  if (source === 'key') {
    if (keyWord && hfWord) hfWord.value = keyWord.value;
    if (keyPos && hfPos) hfPos.value = keyPos.value;
  } else {
    if (keyWord && hfWord) keyWord.value = hfWord.value;
    if (keyPos && hfPos) keyPos.value = hfPos.value;
  }
}


// ===== High-Frequency Features (HF List) =====
function computeHF() {
  const status = document.getElementById('hfStatus');
  const body = document.getElementById('hfTableBody');
  status.textContent = '';

  allHfRows = [];
  lastHfRows = [];

  if (!corpus || !corpus.files || Object.keys(corpus.files).length === 0) {
    status.textContent = 'Please load a corpus first.';
    if (body) {
      body.innerHTML = '<tr><td colspan="10" class="text-xs">No high-frequency features.</td></tr>';
    }
    return;
  }

  const hasTarget = targetFolders.size > 0;
  const hasRef = referenceFolders.size > 0;

  if (!hasTarget && !hasRef) {
    status.textContent = 'Please select at least one folder for Target or Reference.';
    if (body) {
      body.innerHTML = '<tr><td colspan="10" class="text-xs">No high-frequency features.</td></tr>';
    }
    return;
  }

  const featureTypeSel = document.getElementById('hfFeatureTypeSelect');
  const nInput = document.getElementById('hfNInput');
  const minFreqInput = document.getElementById('hfMinFreqInput');
  const topNInput = document.getElementById('hfTopNInput');

  const featureType = featureTypeSel ? featureTypeSel.value : 'word';
  let n = parseInt(nInput.value, 10);
  if (!Number.isFinite(n) || n <= 0) n = 1;

  let minFreq = parseInt(minFreqInput.value, 10);
  if (!Number.isFinite(minFreq) || minFreq <= 0) minFreq = 1;

  let topN = parseInt(topNInput.value, 10);
  if (!Number.isFinite(topN) || topN <= 0) topN = 200;

  // DEP type handling - compute directly
  if (featureType === 'dep') {
    if (!depHasDependencyData) {
      status.textContent = 'DEP features require CSV mode with dependency data (head, deprel columns).';
      return;
    }
    computeHfDep(minFreq, topN);
    return;
  }

  if ((featureType.startsWith('pos') || featureType.startsWith('posgram') || featureType.startsWith('wordpos') || featureType.startsWith('ngrampos')) && corpus.mode !== 'tagged' && corpus.mode !== 'csv') {
    status.textContent = 'POS-based features are only available in Tagged mode.';
    if (body) {
      body.innerHTML = '<tr><td colspan="10" class="text-xs">No high-frequency features.</td></tr>';
    }
    return;
  }

  if ((featureType.startsWith('ngram') || featureType.startsWith('pframe') || featureType.startsWith('posgram') || featureType.startsWith('cluster') || featureType.startsWith('ngrampos')) && n < 2) {
    status.textContent = 'For n-gram / p-frame / POS-gram / cluster / n-gram+POS, please set n to 2 or higher.';
    if (body) {
      body.innerHTML = '<tr><td colspan="10" class="text-xs">No high-frequency features.</td></tr>';
    }
    return;
  }

  // Cluster-specific validation and options
  let clusterOptions = null;
  if (featureType.startsWith('cluster')) {
    const searchWord = document.getElementById('hfClusterWord')?.value?.trim() || '';
    const position = document.getElementById('hfClusterPosition')?.value || 'both';
    
    if (!searchWord) {
      status.textContent = 'For Cluster, please enter a Search word.';
      if (body) {
        body.innerHTML = '<tr><td colspan="10" class="text-xs">No high-frequency features.</td></tr>';
      }
      return;
    }
    
    clusterOptions = { searchWord, position };
  }

  status.textContent = 'Collecting features...';

  const caseInsensitive = document.getElementById('hfCaseInsensitive')?.checked ?? true;
  const excludeStopwords = document.getElementById('hfExcludeStopwords')?.checked ?? false;
  const stats = collectFeatureCounts(featureType, n, targetFolders, referenceFolders, caseInsensitive, false, clusterOptions);
  const Tcounts = stats.targetCounts;
  const Rcounts = stats.referenceCounts;
  const NT = stats.totalTargetUnits;
  const NR = stats.totalReferenceUnits;
  const NFT = stats.numTargetFiles;
  const NFR = stats.numReferenceFiles;
  const targetFileFreqs = stats.targetFileFreqs;
  const referenceFileFreqs = stats.referenceFileFreqs;

  // Check if stopword filter should be applied (only for word surface)
  const applyStopwordFilter = excludeStopwords && featureType === 'word';
  
  // Check if BiberPlus 96 filter should be applied
  const biberPlusOnly = document.getElementById('hfBiberPlusOnly')?.checked ?? false;
  const applyBiberPlusFilter = biberPlusOnly && featureType === 'biber_tag';

  const targetList = [];
  for (const [feat, freq] of Object.entries(Tcounts)) {
    if (freq >= minFreq) {
      // Skip stopwords if filter is enabled
      if (applyStopwordFilter && STOPWORDS.has(feat.toLowerCase())) continue;
      // Skip non-BiberPlus 96 tags if filter is enabled
      if (applyBiberPlusFilter && !isBiberPlus96Tag(feat)) continue;
      targetList.push({
        feature: feat,
        freq: freq,
        norm: NT > 0 ? (freq * 1e6) / NT : 0,
        files: targetFileFreqs[feat] || 0
      });
    }
  }
  targetList.sort((a, b) => b.freq - a.freq || a.feature.localeCompare(b.feature));

  const refList = [];
  for (const [feat, freq] of Object.entries(Rcounts)) {
    if (freq >= minFreq) {
      // Skip stopwords if filter is enabled
      if (applyStopwordFilter && STOPWORDS.has(feat.toLowerCase())) continue;
      // Skip non-BiberPlus 96 tags if filter is enabled
      if (applyBiberPlusFilter && !isBiberPlus96Tag(feat)) continue;
      refList.push({
        feature: feat,
        freq: freq,
        norm: NR > 0 ? (freq * 1e6) / NR : 0,
        files: referenceFileFreqs[feat] || 0
      });
    }
  }
  refList.sort((a, b) => b.freq - a.freq || a.feature.localeCompare(b.feature));

  const maxRows = Math.max(targetList.length, refList.length, 1);
  const displayRows = Math.min(maxRows, topN);

  let html = '';
  for (let i = 0; i < displayRows; i++) {
    const t = targetList[i] || {};
    const r = refList[i] || {};
    html += `<tr>
      <td class="text-right">${t.feature ? i + 1 : ''}</td>
      <td class="mono hf-feature-link" data-feature="${t.feature ? escapeHtml(t.feature) : ''}" data-scope="target" data-feature-type="${featureType}">${t.feature ? escapeHtml(t.feature) : ''}</td>
      <td class="text-right">${t.freq != null ? t.freq : ''}</td>
      <td class="text-right">${t.norm != null ? formatNumber(t.norm, 2) : ''}</td>
      <td class="text-right hf-divider">${t.files != null ? t.files : ''}</td>
      <td class="text-right">${r.feature ? i + 1 : ''}</td>
      <td class="mono hf-feature-link" data-feature="${r.feature ? escapeHtml(r.feature) : ''}" data-scope="reference" data-feature-type="${featureType}">${r.feature ? escapeHtml(r.feature) : ''}</td>
      <td class="text-right">${r.freq != null ? r.freq : ''}</td>
      <td class="text-right">${r.norm != null ? formatNumber(r.norm, 2) : ''}</td>
      <td class="text-right">${r.files != null ? r.files : ''}</td>
    </tr>`;
  }

  if (displayRows === 0) {
    html = '<tr><td colspan="10" class="text-xs">No high-frequency features.</td></tr>';
  }

  body.innerHTML = html;
  allHfRows = { targetList, refList, featureType };
  lastHfRows = { targetList: targetList.slice(0, topN), refList: refList.slice(0, topN) };
  lastHfFeatureType = featureType;

  // Add click handlers for HF feature links
  body.querySelectorAll('.hf-feature-link').forEach(el => {
    if (!el.dataset.feature) return;
    el.addEventListener('click', () => {
      const feature = el.dataset.feature;
      const scope = el.dataset.scope;
      const ftype = el.dataset.featureType;
      jumpToKwicFromHf(feature, scope, ftype);
    });
  });

  status.textContent = `Target features: ${targetList.length}, Reference features: ${refList.length} (showing top ${displayRows} each)${applyStopwordFilter ? ' [stopwords excluded]' : ''}${applyBiberPlusFilter ? ' [BiberPlus 96 only]' : ''}`;
}

// Compute HF for DEP (deprel tag frequency)
function computeHfDep(minFreq, topN) {
  const status = document.getElementById('hfStatus');
  const body = document.getElementById('hfTableBody');
  
  status.textContent = 'Computing DEP features...';
  
  const hasTarget = targetFolders.size > 0;
  const hasRef = referenceFolders.size > 0;
  
  
  // Collect DEP frequencies
  const targetCounts = {};
  const refCounts = {};
  const targetFileFreqs = {};
  const refFileFreqs = {};
  let totalTargetTokens = 0;
  let totalRefTokens = 0;
  
  Object.values(corpus.files).forEach(file => {
    if (corpus.mode !== 'csv' || !file.tokens) return;
    
    const isTarget = targetFolders.has(file.folder);
    const isRef = referenceFolders.has(file.folder);
    
    // Skip files not in Target or Reference (7) is Target vs Reference comparison only)
    if (!isTarget && !isRef) return;
    
    const fileCounts = {};
    
    file.tokens.forEach(tok => {
      const deprel = tok.deprel || tok.dep || '';
      if (!deprel || deprel === 'ROOT' || deprel === 'root') return;
      
      fileCounts[deprel] = (fileCounts[deprel] || 0) + 1;
    });
    
    // Count for Target if in Target
    if (isTarget) {
      for (const [deprel, count] of Object.entries(fileCounts)) {
        targetCounts[deprel] = (targetCounts[deprel] || 0) + count;
        targetFileFreqs[deprel] = (targetFileFreqs[deprel] || 0) + 1;
        totalTargetTokens += count;
      }
    }
    
    // Count for Reference if in Reference (even if also in Target)
    if (isRef) {
      for (const [deprel, count] of Object.entries(fileCounts)) {
        refCounts[deprel] = (refCounts[deprel] || 0) + count;
        refFileFreqs[deprel] = (refFileFreqs[deprel] || 0) + 1;
        totalRefTokens += count;
      }
    }
  });
  
  // Build target list
  const targetList = [];
  for (const [feat, freq] of Object.entries(targetCounts)) {
    if (freq >= minFreq) {
      targetList.push({
        feature: feat,
        freq: freq,
        norm: totalTargetTokens > 0 ? (freq * 1e6) / totalTargetTokens : 0,
        files: targetFileFreqs[feat] || 0
      });
    }
  }
  targetList.sort((a, b) => b.freq - a.freq || a.feature.localeCompare(b.feature));
  
  // Build reference list
  const refList = [];
  for (const [feat, freq] of Object.entries(refCounts)) {
    if (freq >= minFreq) {
      refList.push({
        feature: feat,
        freq: freq,
        norm: totalRefTokens > 0 ? (freq * 1e6) / totalRefTokens : 0,
        files: refFileFreqs[feat] || 0
      });
    }
  }
  refList.sort((a, b) => b.freq - a.freq || a.feature.localeCompare(b.feature));
  
  // Render
  const maxRows = Math.max(targetList.length, refList.length, 1);
  const displayRows = Math.min(maxRows, topN);
  
  let html = '';
  for (let i = 0; i < displayRows; i++) {
    const t = targetList[i] || {};
    const r = refList[i] || {};
    html += `<tr>
      <td class="text-right">${t.feature ? i + 1 : ''}</td>
      <td class="mono hf-feature-link" data-feature="${t.feature ? escapeHtml(t.feature) : ''}" data-scope="target" data-feature-type="dep">${t.feature ? escapeHtml(t.feature) : ''}</td>
      <td class="text-right">${t.freq != null ? t.freq : ''}</td>
      <td class="text-right">${t.norm != null ? formatNumber(t.norm, 2) : ''}</td>
      <td class="text-right hf-divider">${t.files != null ? t.files : ''}</td>
      <td class="text-right">${r.feature ? i + 1 : ''}</td>
      <td class="mono hf-feature-link" data-feature="${r.feature ? escapeHtml(r.feature) : ''}" data-scope="reference" data-feature-type="dep">${r.feature ? escapeHtml(r.feature) : ''}</td>
      <td class="text-right">${r.freq != null ? r.freq : ''}</td>
      <td class="text-right">${r.norm != null ? formatNumber(r.norm, 2) : ''}</td>
      <td class="text-right">${r.files != null ? r.files : ''}</td>
    </tr>`;
  }
  
  if (displayRows === 0) {
    html = '<tr><td colspan="10" class="text-xs">No DEP features found.</td></tr>';
  }
  
  body.innerHTML = html;
  allHfRows = { targetList, refList, featureType: 'dep' };
  lastHfRows = { targetList: targetList.slice(0, topN), refList: refList.slice(0, topN) };
  lastHfFeatureType = 'dep';
  
  // Add click handlers
  body.querySelectorAll('.hf-feature-link').forEach(el => {
    if (!el.dataset.feature) return;
    el.addEventListener('click', () => {
      const feature = el.dataset.feature;
      const scope = el.dataset.scope;
      // For DEP, redirect to 12) section
      redirectToDepSectionWithFilter(feature);
    });
  });
  
  status.textContent = `Target DEP features: ${targetList.length}, Reference DEP features: ${refList.length} (showing top ${displayRows} each)`;
}

// Redirect to 12b) Concordance with specific deprel filter
function redirectToDepSectionWithFilter(deprel) {
  // Expand section 12
  const section12 = document.getElementById('section12-content');
  const arrow12 = document.getElementById('section12-arrow');
  if (section12 && section12.style.display === 'none') {
    section12.style.display = 'block';
    if (arrow12) arrow12.textContent = '▼';
  }
  
  // Expand 12b) Concordance section
  const content12b = document.getElementById('section12b-content');
  const arrow12b = document.getElementById('section12b-arrow');
  if (content12b && content12b.style.display === 'none') {
    content12b.style.display = 'block';
    if (arrow12b) arrow12b.textContent = '▼';
  }
  
  // Build concordance data for the deprel
  const instances = [];
  const files = Object.values(corpus.files);
  
  files.forEach(file => {
    if (corpus.mode !== 'csv' || !file.tokens) return;
    
    const isTarget = targetFolders.has(file.folder);
    const isRef = referenceFolders.has(file.folder);
    
    // Determine side: T, R, B (both), or N (neither)
    let side = 'N';
    if (isTarget && isRef) side = 'B';
    else if (isTarget) side = 'T';
    else if (isRef) side = 'R';
    
    // Build sentence map
    const sentenceMap = new Map();
    file.tokens.forEach(tok => {
      const sentId = tok.sent_id;
      if (sentId != null) {
        if (!sentenceMap.has(sentId)) sentenceMap.set(sentId, []);
        sentenceMap.get(sentId).push(tok);
      }
    });
    
    file.tokens.forEach(tok => {
      const tokDeprel = tok.deprel || tok.dep || '';
      if (tokDeprel !== deprel) return;
      
      // Get governor
      const governor = tok.head_text || '';
      const dependent = tok.word || '';
      
      // Get sentence text
      let sentText = tok.sent_text || '';
      if (!sentText && tok.sent_id != null) {
        const sentTokens = sentenceMap.get(tok.sent_id) || [];
        sentText = sentTokens.map(t => t.word || '').join(' ');
      }
      
      instances.push({
        fileId: file.id,
        fileName: file.name,
        folder: file.folder,
        side,
        sentId: tok.sent_id,
        sentText,
        governor,
        dependent
      });
    });
  });
  
  // Update 12b) with the data
  currentDepFeature = deprel;
  currentDepInstances = instances;
  
  document.getElementById('depConcordanceFeature').textContent = deprel;
  document.getElementById('depConcordanceCount').textContent = instances.length.toLocaleString();
  
  updateDepConcordanceDisplay();
  
  // Scroll to 12b) Concordance card
  const depConcCard = document.getElementById('depConcordanceCard');
  if (depConcCard) {
    setTimeout(() => {
      depConcCard.scrollIntoView({ behavior: 'smooth', block: 'start' });
    }, 100);
  }
}

// Jump to KWIC from HF Features (with scope selection)
function jumpToKwicFromHf(feature, scope, featureType) {
  // Clear previous filters
  clearKwicFilters();
  
  // Clear collocate highlight
  currentCollocateWord = null;
  currentCollocateInfo = null;
  
  // Set feature to all sections and get converted type
  const kwicType = setFeatureToAllSections(feature, featureType, scope);
  currentKwicFeatureType = kwicType;
  
  // Set search mode - detect wildcard patterns
  const kwicSearchMode = document.getElementById('kwicSearchMode');
  if (kwicSearchMode) {
    if (feature.includes('*') || feature.includes('?')) {
      kwicSearchMode.value = 'wildcard';
    } else {
      kwicSearchMode.value = 'exact';
    }
  }
  
  // Get converted feature for currentKwicFeature
  let kwicFeature = feature;
  if (featureType.startsWith('wordpos_')) {
    kwicFeature = extractWordFromWordPos(feature);
  } else if (featureType.startsWith('ngrampos_')) {
    kwicFeature = extractWordsFromNgramPos(feature);
  }
  currentKwicFeature = kwicFeature;
  
  // Check if this is wordpos/ngrampos type - need to apply filter after compute
  const needsPosFilter = featureType.startsWith('wordpos_') || featureType.startsWith('ngrampos_');
  
  // Compute KWIC
  computeKwic();
  
  // Apply POS filter automatically for wordpos/ngrampos
  if (needsPosFilter) {
    setTimeout(() => applyKwicFilter(), 50);
  }
  
  // Scroll to KWIC section
  const kwicCard = document.getElementById('kwicCard');
  if (kwicCard) {
    kwicCard.scrollIntoView({ behavior: 'smooth', block: 'start' });
  }
}

function exportHfToExcel() {
  if (!allHfRows || (!allHfRows.targetList?.length && !allHfRows.refList?.length)) {
    alert('No high-frequency features to export.');
    return;
  }

  const targetList = allHfRows.targetList || [];
  const refList = allHfRows.refList || [];
  const maxRows = Math.max(targetList.length, refList.length);

  let xml = '<?xml version="1.0" encoding="UTF-8"?>\n';
  xml += '<?mso-application progid="Excel.Sheet"?>\n';
  xml += '<Workbook xmlns="urn:schemas-microsoft-com:office:spreadsheet"\n';
  xml += '  xmlns:ss="urn:schemas-microsoft-com:office:spreadsheet">\n';
  xml += '<Worksheet ss:Name="High-Frequency Features">\n<Table>\n';

  const headers = ['# (T)', 'Feature (T)', 'freq_T', 'norm_T (pm)', 'files_T', '# (R)', 'Feature (R)', 'freq_R', 'norm_R (pm)', 'files_R'];
  xml += '<Row>';
  headers.forEach(h => {
    xml += '<Cell><Data ss:Type="String">' + escapeHtml(h) + '</Data></Cell>';
  });
  xml += '</Row>\n';

  for (let i = 0; i < maxRows; i++) {
    const t = targetList[i] || {};
    const r = refList[i] || {};
    const rowVals = [
      t.feature ? String(i + 1) : '',
      t.feature || '',
      t.freq != null ? String(t.freq) : '',
      t.norm != null ? formatNumber(t.norm, 2) : '',
      t.files != null ? String(t.files) : '',
      r.feature ? String(i + 1) : '',
      r.feature || '',
      r.freq != null ? String(r.freq) : '',
      r.norm != null ? formatNumber(r.norm, 2) : '',
      r.files != null ? String(r.files) : ''
    ];
    xml += '<Row>';
    rowVals.forEach(v => {
      const safe = (v || '').replace(/&/g,'&amp;').replace(/</g,'&lt;');
      xml += '<Cell><Data ss:Type="String">' + safe + '</Data></Cell>';
    });
    xml += '</Row>\n';
  }

  xml += '</Table>\n</Worksheet>\n</Workbook>';

  const blob = new Blob([xml], { type: 'application/vnd.ms-excel;charset=utf-8;' });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = 'high_frequency_features.xls';
  document.body.appendChild(a);
  a.click();
  document.body.removeChild(a);
  URL.revokeObjectURL(url);
}

// ===== HF Feature Filter =====
let hfFilteredRows = null; // Store filtered results

function applyHfFilter() {
  if (!allHfRows || (!allHfRows.targetList?.length && !allHfRows.refList?.length)) {
    return;
  }
  
  const filterInput = document.getElementById('hfFilterInput');
  const filterMode = document.getElementById('hfFilterMode');
  const filterScope = document.getElementById('hfFilterScope');
  const filterExclude = document.getElementById('hfFilterExclude');
  const status = document.getElementById('hfStatus');
  
  const pattern = (filterInput?.value || '').trim();
  const mode = filterMode?.value || 'partial';
  const scope = filterScope?.value || 'all';
  const isExclude = filterExclude?.checked || false;
  
  if (!pattern) {
    // No filter - reset to original (not filtered)
    hfFilteredRows = null;
    renderHfFilteredRows();
    // Update status to show original counts
    if (allHfRows) {
      const targetList = allHfRows.targetList || [];
      const refList = allHfRows.refList || [];
      const topN = parseInt(document.getElementById('hfTopN')?.value) || 50;
      const displayRows = Math.max(targetList.length, refList.length);
      status.textContent = `Target features: ${targetList.length}, Reference features: ${refList.length} (showing top ${Math.min(displayRows, topN)} each)`;
    }
    return;
  }
  
  // Build base matcher based on mode
  let baseMatcher;
  if (mode === 'exact') {
    // Exact match with wildcard support (* and ?)
    if (pattern.includes('*') || pattern.includes('?')) {
      const escaped = pattern.replace(/[.+^${}()|[\]\\]/g, '\\$&');
      const regexStr = '^' + escaped.replace(/\*/g, '.*').replace(/\?/g, '.') + '$';
      const regex = new RegExp(regexStr, 'i');
      baseMatcher = (feature) => regex.test(feature);
    } else {
      baseMatcher = (feature) => feature.toLowerCase() === pattern.toLowerCase();
    }
  } else {
    // Partial match (substring) with wildcard support
    if (pattern.includes('*') || pattern.includes('?')) {
      const escaped = pattern.replace(/[.+^${}()|[\]\\]/g, '\\$&');
      const regexStr = escaped.replace(/\*/g, '.*').replace(/\?/g, '.');
      const regex = new RegExp(regexStr, 'i');
      baseMatcher = (feature) => regex.test(feature);
    } else {
      const lowerPattern = pattern.toLowerCase();
      baseMatcher = (feature) => feature.toLowerCase().includes(lowerPattern);
    }
  }
  
  // Apply exclude if checked
  const matcher = isExclude ? (feature) => !baseMatcher(feature) : baseMatcher;
  
  // CUMULATIVE: Apply filter to currently displayed data (hfFilteredRows or allHfRows)
  const sourceData = hfFilteredRows || allHfRows;
  const targetList = sourceData.targetList || [];
  const refList = sourceData.refList || [];
  
  let filteredTarget, filteredRef;
  
  if (scope === 'all') {
    filteredTarget = targetList.filter(item => matcher(item.feature));
    filteredRef = refList.filter(item => matcher(item.feature));
  } else if (scope === 'target') {
    filteredTarget = targetList.filter(item => matcher(item.feature));
    filteredRef = refList; // Keep current reference
  } else if (scope === 'reference') {
    filteredTarget = targetList; // Keep current target
    filteredRef = refList.filter(item => matcher(item.feature));
  }
  
  hfFilteredRows = {
    targetList: filteredTarget,
    refList: filteredRef,
    featureType: allHfRows.featureType
  };
  
  renderHfFilteredRows();
  
  // Update status
  const filterInfo = isExclude ? `excluding "${pattern}"` : `matching "${pattern}"`;
  const scopeInfo = scope === 'all' ? 'both sides' : (scope === 'target' ? 'Target only' : 'Reference only');
  status.textContent = `Filtered (${filterInfo}, ${scopeInfo}): Target: ${filteredTarget.length}, Reference: ${filteredRef.length}`;
}

function clearHfFilter() {
  const filterInput = document.getElementById('hfFilterInput');
  const filterExclude = document.getElementById('hfFilterExclude');
  if (filterInput) filterInput.value = '';
  if (filterExclude) filterExclude.checked = false;
  
  hfFilteredRows = null;
  renderHfFilteredRows();
  
  // Restore original status
  if (allHfRows && (allHfRows.targetList?.length || allHfRows.refList?.length)) {
    const targetList = allHfRows.targetList || [];
    const refList = allHfRows.refList || [];
    const topN = parseInt(document.getElementById('hfTopN')?.value) || 50;
    const displayRows = Math.max(targetList.length, refList.length);
    const status = document.getElementById('hfStatus');
    const applyStopwordFilter = document.getElementById('hfStopwordFilter')?.checked ?? false;
    status.textContent = `Target features: ${targetList.length}, Reference features: ${refList.length} (showing top ${Math.min(displayRows, topN)} each)${applyStopwordFilter ? ' [stopwords excluded]' : ''}`;
  }
}

function renderHfFilteredRows() {
  const body = document.getElementById('hfTableBody');
  if (!body) return;
  
  const dataSource = hfFilteredRows || allHfRows;
  if (!dataSource || (!dataSource.targetList?.length && !dataSource.refList?.length)) {
    body.innerHTML = '<tr><td colspan="10" class="text-xs">No high-frequency features.</td></tr>';
    return;
  }
  
  const targetList = dataSource.targetList || [];
  const refList = dataSource.refList || [];
  const featureType = dataSource.featureType || 'word';
  const topN = parseInt(document.getElementById('hfTopN')?.value) || 50;
  
  const displayRows = Math.min(Math.max(targetList.length, refList.length), topN);
  
  let html = '';
  for (let i = 0; i < displayRows; i++) {
    const t = targetList[i] || {};
    const r = refList[i] || {};
    html += `<tr>
      <td class="text-right">${t.feature ? (i + 1) : ''}</td>
      <td>${t.feature ? `<span class="hf-feature-link" data-feature="${escapeHtml(t.feature)}" data-scope="target" data-feature-type="${featureType}">${escapeHtml(t.feature)}</span>` : ''}</td>
      <td class="text-right">${t.freq != null ? t.freq : ''}</td>
      <td class="text-right">${t.norm != null ? formatNumber(t.norm, 2) : ''}</td>
      <td class="text-right hf-divider">${t.files != null ? t.files : ''}</td>
      <td class="text-right">${r.feature ? (i + 1) : ''}</td>
      <td>${r.feature ? `<span class="hf-feature-link" data-feature="${escapeHtml(r.feature)}" data-scope="reference" data-feature-type="${featureType}">${escapeHtml(r.feature)}</span>` : ''}</td>
      <td class="text-right">${r.freq != null ? r.freq : ''}</td>
      <td class="text-right">${r.norm != null ? formatNumber(r.norm, 2) : ''}</td>
      <td class="text-right">${r.files != null ? r.files : ''}</td>
    </tr>`;
  }
  
  if (displayRows === 0) {
    html = '<tr><td colspan="10" class="text-xs">No matching features.</td></tr>';
  }
  
  body.innerHTML = html;
  
  // Re-add click handlers for HF feature links
  body.querySelectorAll('.hf-feature-link').forEach(el => {
    if (!el.dataset.feature) return;
    el.addEventListener('click', () => {
      const feature = el.dataset.feature;
      const scope = el.dataset.scope;
      const ftype = el.dataset.featureType;
      jumpToKwicFromHf(feature, scope, ftype);
    });
  });
}


// ===== Excel Export =====
function exportKeynessToExcel() {
  if (!allKeynessRows || allKeynessRows.length === 0) {
    alert('No keyness results to export.');
    return;
  }

  const advancedStats = document.getElementById('keyAdvancedStats')?.checked ?? false;

  let xml = '<?xml version="1.0" encoding="UTF-8"?>\n';
  xml += '<?mso-application progid="Excel.Sheet"?>\n';
  xml += '<Workbook xmlns="urn:schemas-microsoft-com:office:spreadsheet"\n';
  xml += '  xmlns:ss="urn:schemas-microsoft-com:office:spreadsheet">\n';
  xml += '<Worksheet ss:Name="Keyness">\n<Table>\n';

  const isPframe = lastKeynessIsPframe;
  let headers;
  if (advancedStats) {
    headers = ['#', 'Feature', 'freq_T', 'norm_T (pm)', 'file_T', 'Range_T', 'Juilland_T', 'DP_T', 
               'freq_R', 'norm_R (pm)', 'file_R', 'Range_R', 'Juilland_R', 'DP_R',
               'Freq-LL', 'Text-LL', "MTK"];
  } else {
    headers = ['#', 'Feature', 'freq_T', 'norm_T (pm)', 'file_T', 'freq_R', 'norm_R (pm)', 'file_R',
               'Freq-LL', 'Text-LL', "MTK"];
  }
  if (isPframe) {
    headers.push('Fillers_T (for *)');
    headers.push('Fillers_R (for *)');
  }
  xml += '<Row>';
  headers.forEach(h => {
    xml += '<Cell><Data ss:Type="String">' + escapeHtml(h) + '</Data></Cell>';
  });
  xml += '</Row>\n';

  const sortedRows = [...allKeynessRows].sort((a, b) => {
    const aLL = a.freqLL != null ? a.freqLL : 0;
    const bLL = b.freqLL != null ? b.freqLL : 0;
    return bLL - aLL || b.fT - a.fT || a.feature.localeCompare(b.feature);
  });

  for (let i = 0; i < sortedRows.length; i++) {
    const r = sortedRows[i];
    const freqLLStr = r.freqLL != null ? formatNumber(r.freqLL, 2) : '';
    const textLLStr = r.textLL != null ? formatNumber(r.textLL, 2) : '';
    const dStr = r.d != null ? formatNumber(r.d, 3) : '';
    
    let rowVals;
    if (advancedStats) {
      const rangeTStr = r.rangeT != null ? formatNumber(r.rangeT, 3) : '';
      const juillandTStr = r.juillandT != null ? formatNumber(r.juillandT, 3) : '';
      const dpTStr = r.dpT != null ? formatNumber(r.dpT, 3) : '';
      const rangeRStr = r.rangeR != null ? formatNumber(r.rangeR, 3) : '';
      const juillandRStr = r.juillandR != null ? formatNumber(r.juillandR, 3) : '';
      const dpRStr = r.dpR != null ? formatNumber(r.dpR, 3) : '';
      
      rowVals = [
        String(i + 1),
        r.feature,
        String(r.fT),
        formatNumber(r.normT, 2),
        String(r.fFileT || 0),
        rangeTStr,
        juillandTStr,
        dpTStr,
        String(r.fR),
        formatNumber(r.normR, 2),
        String(r.fFileR || 0),
        rangeRStr,
        juillandRStr,
        dpRStr,
        freqLLStr,
        textLLStr,
        dStr
      ];
    } else {
      rowVals = [
        String(i + 1),
        r.feature,
        String(r.fT),
        formatNumber(r.normT, 2),
        String(r.fFileT || 0),
        String(r.fR),
        formatNumber(r.normR, 2),
        String(r.fFileR || 0),
        freqLLStr,
        textLLStr,
        dStr
      ];
    }
    if (isPframe) {
      const fillersT = lastTargetFillers[r.feature] || {};
      const fillersR = lastReferenceFillers[r.feature] || {};
      const entriesT = Object.entries(fillersT).sort((a, b) => b[1] - a[1]).slice(0, 5).map(([f, c]) => `${f}(${c})`).join('; ');
      const entriesR = Object.entries(fillersR).sort((a, b) => b[1] - a[1]).slice(0, 5).map(([f, c]) => `${f}(${c})`).join('; ');
      rowVals.push(entriesT || '-');
      rowVals.push(entriesR || '-');
    }
    xml += '<Row>';
    rowVals.forEach(v => {
      const safe = (v || '').replace(/&/g,'&amp;').replace(/</g,'&lt;');
      xml += '<Cell><Data ss:Type="String">' + safe + '</Data></Cell>';
    });
    xml += '</Row>\n';
  }

  xml += '</Table>\n</Worksheet>\n</Workbook>';

  const blob = new Blob([xml], { type: 'application/vnd.ms-excel;charset=utf-8;' });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = 'keyness_results.xls';
  document.body.appendChild(a);
  a.click();
  document.body.removeChild(a);
  URL.revokeObjectURL(url);
}

function exportKwicToExcel() {
  if (!allKwicRows || allKwicRows.length === 0) {
    alert('No KWIC results to export.');
    return;
  }

  let xml = '<?xml version="1.0" encoding="UTF-8"?>\n';
  xml += '<?mso-application progid="Excel.Sheet"?>\n';
  xml += '<Workbook xmlns="urn:schemas-microsoft-com:office:spreadsheet"\n';
  xml += '  xmlns:ss="urn:schemas-microsoft-com:office:spreadsheet">\n';
  xml += '<Worksheet ss:Name="KWIC">\n<Table>\n';

  const headers = ['#', 'Left', 'Node', 'Right', 'Folder', 'File', 'Side'];
  xml += '<Row>';
  headers.forEach(h => {
    xml += '<Cell><Data ss:Type="String">' + escapeHtml(h) + '</Data></Cell>';
  });
  xml += '</Row>\n';

  for (let i = 0; i < allKwicRows.length; i++) {
    const r = allKwicRows[i];
    const rowVals = [
      String(i + 1),
      r.leftText,
      r.nodeText,
      r.rightText,
      r.folder,
      r.fileName,
      r.side
    ];
    xml += '<Row>';
    rowVals.forEach(v => {
      const safe = (v || '').replace(/&/g,'&amp;').replace(/</g,'&lt;');
      xml += '<Cell><Data ss:Type="String">' + safe + '</Data></Cell>';
    });
    xml += '</Row>\n';
  }

  xml += '</Table>\n</Worksheet>\n</Workbook>';

  const blob = new Blob([xml], { type: 'application/vnd.ms-excel;charset=utf-8;' });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = 'kwic_results.xls';
  document.body.appendChild(a);
  a.click();
  document.body.removeChild(a);
  URL.revokeObjectURL(url);
}


function exportFolderSummary() {
  if (!corpus || !corpus.folders) {
    alert('No corpus loaded.');
    return;
  }

  const folderNames = Object.keys(corpus.folders).sort();
  const isTagged = corpus.mode === 'tagged' || corpus.mode === 'csv';

  let xml = '<?xml version="1.0" encoding="UTF-8"?>\n';
  xml += '<?mso-application progid="Excel.Sheet"?>\n';
  xml += '<Workbook xmlns="urn:schemas-microsoft-com:office:spreadsheet"\n';
  xml += '  xmlns:ss="urn:schemas-microsoft-com:office:spreadsheet">\n';
  xml += '<Worksheet ss:Name="Folder Summary">\n<Table>\n';

  const headers = isTagged
    ? ['#', 'Folder', 'Files', 'Sentences', 'MinSentLen', 'MaxSentLen', 'MedianSentLen', 'MeanSentLen', 'Tokens', 'Types', 'TTR', 'LemmaTokens', 'LemmaTypes', 'LemmaTTR']
    : ['#', 'Folder', 'Files', 'Sentences', 'MinSentLen', 'MaxSentLen', 'MedianSentLen', 'MeanSentLen', 'Tokens', 'Types', 'TTR'];

  xml += '<Row>';
  headers.forEach(h => {
    xml += '<Cell><Data ss:Type="String">' + escapeHtml(h) + '</Data></Cell>';
  });
  xml += '</Row>\n';

  let idx = 1;
  for (const folder of folderNames) {
    const fileIds = corpus.folders[folder];

    let sentenceCount = 0;
    const sentLengths = [];

    let tokenCount = 0;
    const typeSet = new Set();

    let lemmaTokenCount = 0;
    const lemmaTypeSet = new Set();

    for (const fid of fileIds) {
      const file = corpus.files[fid];

      // Sentence stats
      if (file.sentences && file.sentences.length) {
        for (const sent of file.sentences) {
          let len = 0;
          for (let i = sent.tokenStart; i < sent.tokenEnd; i++) {
            const tok = file.tokens[i];
            if (isPunctuationOrSpaceToken(tok)) continue;
            len++;
          }
          sentenceCount++;
          sentLengths.push(len);
        }
      }

      // Token / type (surface) and lemma stats
      for (const tok of file.tokens) {
        if (isPunctuationOrSpaceToken(tok)) continue;

        tokenCount++;
        if (tok.word) {
          typeSet.add(tok.word.toLowerCase());
        }

        if (isTagged && tok.lemma) {
          lemmaTokenCount++;
          lemmaTypeSet.add(tok.lemma.toLowerCase());
        }
      }
    }

    // Sentence summary
    let minSent = '';
    let maxSent = '';
    let medianSent = '';
    let meanSent = '';

    if (sentenceCount > 0 && sentLengths.length > 0) {
      let minVal = sentLengths[0];
      let maxVal = sentLengths[0];
      let sumLen = 0;
      for (const v of sentLengths) {
        if (v < minVal) minVal = v;
        if (v > maxVal) maxVal = v;
        sumLen += v;
      }
      minSent = String(minVal);
      maxSent = String(maxVal);
      meanSent = (sumLen / sentenceCount).toFixed(6);

      const sorted = [...sentLengths].sort((a, b) => a - b);
      const mid = Math.floor(sorted.length / 2);
      if (sorted.length % 2 === 1) {
        medianSent = String(sorted[mid]);
      } else {
        medianSent = ((sorted[mid - 1] + sorted[mid]) / 2).toFixed(6);
      }
    }

    const typeCount = typeSet.size;
    const ttr = tokenCount > 0 ? (typeCount / tokenCount) : 0;
    const ttrStr = tokenCount > 0 ? ttr.toFixed(6) : '';

    let lemmaTypeCount = lemmaTypeSet.size;
    let lemmaTtr = lemmaTokenCount > 0 ? (lemmaTypeCount / lemmaTokenCount) : 0;
    const lemmaTtrStr = lemmaTokenCount > 0 ? lemmaTtr.toFixed(6) : '';

    const rowVals = isTagged
      ? [
          String(idx++),
          folder,
          String(fileIds.length),
          String(sentenceCount),
          minSent,
          maxSent,
          medianSent,
          meanSent,
          String(tokenCount),
          String(typeCount),
          ttrStr,
          String(lemmaTokenCount),
          String(lemmaTypeCount),
          lemmaTtrStr
        ]
      : [
          String(idx++),
          folder,
          String(fileIds.length),
          String(sentenceCount),
          minSent,
          maxSent,
          medianSent,
          meanSent,
          String(tokenCount),
          String(typeCount),
          ttrStr
        ];

    xml += '<Row>';
    rowVals.forEach(v => {
      const safe = (v || '').replace(/&/g, '&amp;').replace(/</g, '&lt;');
      xml += '<Cell><Data ss:Type="String">' + safe + '</Data></Cell>';
    });
    xml += '</Row>\n';
  }

  xml += '</Table>\n</Worksheet>\n</Workbook>';

  const blob = new Blob([xml], { type: 'application/vnd.ms-excel;charset=utf-8;' });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = 'folder_summary.xls';
  document.body.appendChild(a);
  a.click();
  document.body.removeChild(a);
  URL.revokeObjectURL(url);
}


// ===== Collocate Functions =====
// Global collocate data storage
let collocateData = null;
let collocateTableData = {}; // Store data for each table for sorting
let collocateTableIdCounter = 0;

// Compute collocates from KWIC results (called automatically after KWIC computation)
function computeCollocatesFromKwic() {
  const status = document.getElementById('collocateStatus');
  const nodeInput = document.getElementById('collocateNodeInput');
  const kwicFeatureInput = document.getElementById('kwicFeatureInput');
  const kwicTypeSelect = document.getElementById('kwicFeatureTypeSelect');
  const collocateTypeSelect = document.getElementById('collocateFeatureTypeSelect');
  
  // Get node from KWIC (prefer currentKwicFeature, fallback to input field)
  const node = currentKwicFeature || (kwicFeatureInput ? kwicFeatureInput.value.trim() : '');
  
  // Sync node to Collocate input
  if (nodeInput && node) {
    nodeInput.value = node;
  }
  
  // Sync feature type from KWIC to Collocate (including POS-gram types)
  if (kwicTypeSelect && collocateTypeSelect) {
    const kwicType = kwicTypeSelect.value;
    // Check if option exists in collocate select
    const optionExists = Array.from(collocateTypeSelect.options).some(opt => opt.value === kwicType);
    if (optionExists) {
      collocateTypeSelect.value = kwicType;
    }
  }
  
  // Check if we have KWIC rows to compute from
  if (!allKwicRows || allKwicRows.length === 0) {
    if (status) status.textContent = 'No KWIC data. Please search in 4) KWIC first.';
    clearCollocateTables();
    return;
  }
  
  // Check if node is valid
  if (!node) {
    if (status) status.textContent = 'Node is not set.';
    clearCollocateTables();
    return;
  }
  
  const spanL = parseInt(document.getElementById('collocateSpanL').value, 10) || 5;
  const spanR = parseInt(document.getElementById('collocateSpanR').value, 10) || 5;
  const topN = parseInt(document.getElementById('collocateTopN').value, 10) || 20;
  const statType = document.getElementById('collocateStatSelect').value || 'frequency';
  const caseInsensitive = document.getElementById('collocateCaseInsensitive')?.checked ?? true;
  
  // Get collocate calculation mode (surface or lemma)
  const calcModeRadio = document.querySelector('input[name="collocateCalcMode"]:checked');
  const calcMode = calcModeRadio ? calcModeRadio.value : 'surface';
  
  // Get feature type from collocate select (already synced from KWIC)
  const featureType = collocateTypeSelect ? collocateTypeSelect.value : 'word';
  
  // Data structure for collocates
  const data = {
    target: { left: {}, right: {} },
    reference: { left: {}, right: {} }
  };
  
  for (let p = 1; p <= 5; p++) {
    data.target.left[p] = {};
    data.target.right[p] = {};
    data.reference.left[p] = {};
    data.reference.right[p] = {};
  }
  
  let totalTargetHits = 0;
  let totalRefHits = 0;
  
  // Corpus-wide statistics for t-score/MI/LL
  let targetTotalTokens = 0;
  let refTotalTokens = 0;
  const targetWordFreq = {};
  const refWordFreq = {};
  
  // Helper to get collocate value from token
  const getCollocateValue = (tok) => {
    let val;
    if (calcMode === 'lemma') {
      val = tok.lemma || tok.word;
    } else if (calcMode === 'pos_simple') {
      val = tok.poss || tok.pos || tok.word;
    } else if (calcMode === 'pos_detailed') {
      val = tok.posd || tok.pos || tok.word;
    } else {
      val = tok.word;
    }
    return caseInsensitive && val ? val.toLowerCase() : val;
  };
  
  // First pass: count corpus-wide token frequencies (for statistics)
  for (const [fileId, file] of Object.entries(corpus.files)) {
    const folder = file.folder;
    const isTarget = targetFolders.has(folder);
    const isRef = referenceFolders.has(folder);
    if (!isTarget && !isRef) continue;
    
    const tokens = file.tokens;
    for (let i = 0; i < tokens.length; i++) {
      const tok = tokens[i];
      if (isPunctuationOrSpaceToken(tok)) continue;
      const word = getCollocateValue(tok);
      if (isTarget) {
        targetTotalTokens++;
        targetWordFreq[word] = (targetWordFreq[word] || 0) + 1;
      }
      if (isRef) {
        refTotalTokens++;
        refWordFreq[word] = (refWordFreq[word] || 0) + 1;
      }
    }
  }
  
  // Second pass: compute collocates from KWIC rows
  for (const row of allKwicRows) {
    const file = corpus.files[row.fileId];
    if (!file) continue;
    
    const tokens = file.tokens;
    const isTarget = row.side === 'target';
    const isRef = row.side === 'reference';
    
    if (isTarget) totalTargetHits++;
    if (isRef) totalRefHits++;
    
    // Build word array from sentence (excluding punctuation)
    const wordArr = [];
    const wordIndices = [];
    for (let i = row.sentStart; i < row.sentEnd; i++) {
      const tok = tokens[i];
      if (isPunctuationOrSpaceToken(tok)) continue;
      wordArr.push(getCollocateValue(tok));
      wordIndices.push(i);
    }
    
    // Find node position in word array
    let nodeStartInArr = -1;
    let nodeEndInArr = -1;
    for (let i = 0; i < wordIndices.length; i++) {
      if (wordIndices[i] === row.matchStart) nodeStartInArr = i;
      if (wordIndices[i] === row.matchEnd - 1) nodeEndInArr = i;
    }
    
    if (nodeStartInArr === -1) continue;
    if (nodeEndInArr === -1) nodeEndInArr = nodeStartInArr;
    
    // Left collocates (L1 = closest to node)
    for (let pos = 1; pos <= 5; pos++) {
      const leftIdx = nodeStartInArr - pos;
      if (leftIdx >= 0) {
        const word = wordArr[leftIdx];
        if (isTarget) {
          data.target.left[pos][word] = (data.target.left[pos][word] || 0) + 1;
        }
        if (isRef) {
          data.reference.left[pos][word] = (data.reference.left[pos][word] || 0) + 1;
        }
      }
    }
    
    // Right collocates (R1 = closest to node)
    for (let pos = 1; pos <= 5; pos++) {
      const rightIdx = nodeEndInArr + pos;
      if (rightIdx < wordArr.length) {
        const word = wordArr[rightIdx];
        if (isTarget) {
          data.target.right[pos][word] = (data.target.right[pos][word] || 0) + 1;
        }
        if (isRef) {
          data.reference.right[pos][word] = (data.reference.right[pos][word] || 0) + 1;
        }
      }
    }
  }
  
  collocateData = {
    node,
    data,
    spanL,
    spanR,
    topN,
    statType,
    featureType,
    calcMode,
    totalTargetHits,
    totalRefHits,
    targetTotalTokens,
    refTotalTokens,
    targetWordFreq,
    refWordFreq
  };
  
  renderAllCollocateTables();
  
  const modeLabelMap = { surface: 'surface', lemma: 'lemma', pos_simple: 'POS simple', pos_detailed: 'POS detailed' };
  const modeLabel = ` (collocates: ${modeLabelMap[calcMode] || 'surface'})`;
  if (status) status.textContent = `Node: "${node}" — Target hits: ${totalTargetHits}, Reference hits: ${totalRefHits}${modeLabel}`;
}

// Compute collocates from manual node input (searches corpus directly)
function computeCollocatesManual() {
  // Sync collocate input to KWIC and Plot before computing
  const collocateInput = document.getElementById('collocateNodeInput');
  const collocateType = document.getElementById('collocateFeatureTypeSelect');
  const node = collocateInput ? collocateInput.value.trim() : '';
  const featureType = collocateType ? collocateType.value : 'word';
  
  if (node) {
    // Sync to KWIC
    const kwicInput = document.getElementById('kwicFeatureInput');
    const kwicType = document.getElementById('kwicFeatureTypeSelect');
    if (kwicInput) kwicInput.value = node;
    if (kwicType) kwicType.value = featureType;
    
    // Sync to Plot
    const plotInput = document.getElementById('plotFeatureInput');
    const plotType = document.getElementById('plotFeatureTypeSelect');
    if (plotInput) plotInput.value = node;
    if (plotType) plotType.value = featureType;
  }
  
  computeCollocatesInternal(false);
}

function computeCollocatesInternal(fromKwic) {
  const status = document.getElementById('collocateStatus');
  const nodeInput = document.getElementById('collocateNodeInput');
  const node = nodeInput ? nodeInput.value.trim() : '';
  
  status.textContent = '';
  collocateData = null;
  
  if (!corpus) {
    status.textContent = 'No corpus loaded.';
    clearCollocateTables();
    return;
  }
  
  if (!node) {
    status.textContent = 'Please enter a Node.';
    clearCollocateTables();
    return;
  }
  
  const spanL = parseInt(document.getElementById('collocateSpanL').value, 10) || 5;
  const spanR = parseInt(document.getElementById('collocateSpanR').value, 10) || 5;
  const topN = parseInt(document.getElementById('collocateTopN').value, 10) || 20;
  const statType = document.getElementById('collocateStatSelect').value || 'frequency';
  
  // Get feature type from collocate dropdown
  const featureTypeSelect = document.getElementById('collocateFeatureTypeSelect');
  const featureType = featureTypeSelect ? featureTypeSelect.value : 'word';
  
  // Get collocate calculation mode (surface or lemma)
  const calcModeRadio = document.querySelector('input[name="collocateCalcMode"]:checked');
  const calcMode = calcModeRadio ? calcModeRadio.value : 'surface';
  
  // Data structure for collocates
  const data = {
    target: { left: {}, right: {} },
    reference: { left: {}, right: {} }
  };
  
  for (let p = 1; p <= 5; p++) {
    data.target.left[p] = {};
    data.target.right[p] = {};
    data.reference.left[p] = {};
    data.reference.right[p] = {};
  }
  
  let totalTargetHits = 0;
  let totalRefHits = 0;
  
  // Corpus-wide statistics for t-score/MI/LL
  let targetTotalTokens = 0;
  let refTotalTokens = 0;
  const targetWordFreq = {};
  const refWordFreq = {};
  
  // Get case-insensitive setting
  const caseInsensitive = document.getElementById('collocateCaseInsensitive')?.checked ?? true;
  
  // Helper to get token value based on feature type and calc mode
  const getTokenValue = (tok, forNode = false) => {
    let val;
    if (forNode) {
      // For node matching, use the feature type
      if (featureType.includes('lemma')) {
        val = tok.lemma || tok.word;
      } else if (featureType.startsWith('pos')) {
        val = featureType.includes('simple') ? tok.poss : tok.posd;
      } else {
        val = tok.word;
      }
    } else {
      // For collocates, use calcMode (surface, lemma, pos_simple, or pos_detailed)
      if (calcMode === 'lemma') {
        val = tok.lemma || tok.word;
      } else if (calcMode === 'pos_simple') {
        val = tok.poss || tok.pos || tok.word;
      } else if (calcMode === 'pos_detailed') {
        val = tok.posd || tok.pos || tok.word;
      } else {
        val = tok.word;
      }
    }
    return caseInsensitive && val ? val.toLowerCase() : val;
  };
  
  // Determine node pattern type
  let nodeTokens;
  const isPosgram = featureType.startsWith('posgram');
  if (isPosgram) {
    // POS-gram: tags are joined with '+', e.g. NOUN+ADP+DET+NOUN
    nodeTokens = node.split('+').filter(t => t.length > 0);
  } else {
    nodeTokens = node.split(/\s+/).filter(t => t.length > 0);
  }
  const isPframe = featureType.startsWith('pframe') || nodeTokens.includes('*');
  const isPosSearch = featureType.startsWith('pos') && !isPosgram;
  const isRegex = featureType === 'regex';
  const isBiberTag = featureType === 'biber_tag';
  
  // Get search mode for wildcard detection
  const searchModeSelect = document.getElementById('collocateSearchMode') || document.getElementById('kwicSearchMode');
  const searchMode = searchModeSelect ? searchModeSelect.value : 'exact';
  const isWildcardSearch = searchMode === 'wildcard';
  
  // For Biber tags, handle special splitting
  if (isBiberTag) {
    // For single Biber tag, treat the whole input as one pattern (allows | for OR)
    nodeTokens = [node];
  }
  
  const nodeLen = nodeTokens.length;
  
  // Create matchers for wildcard/character/regex patterns
  const createMatcher = (pattern) => {
    if (pattern === '*') {
      return { type: 'any' };
    } else if (isBiberTag) {
      // For Biber tags, split by | for OR matching
      const tags = pattern.split('|').map(t => t.trim().toUpperCase()).filter(t => t.length > 0);
      return { type: 'biber', tags };
    } else if (isWildcardSearch || (pattern.includes('*') && pattern !== '*') || pattern.includes('?')) {
      let regexStr = pattern;
      regexStr = regexStr.replace(/[.+^${}()|[\]\\]/g, '\\$&');
      regexStr = regexStr.replace(/\*/g, '.*');
      regexStr = regexStr.replace(/\?/g, '.');
      return { type: 'pattern', regex: new RegExp('^' + regexStr + '$', caseInsensitive ? 'i' : '') };
    } else if (isRegex) {
      try {
        return { type: 'regex', regex: new RegExp(pattern, caseInsensitive ? 'i' : '') };
      } catch (e) {
        return { type: 'exact', value: caseInsensitive ? pattern.toLowerCase() : pattern };
      }
    } else {
      return { type: 'exact', value: caseInsensitive ? pattern.toLowerCase() : pattern };
    }
  };
  
  const nodeMatchers = nodeTokens.map(t => createMatcher(t));
  
  // First pass: count total tokens and word frequencies for corpus (collocate mode)
  for (const [fileId, file] of Object.entries(corpus.files)) {
    const folder = file.folder;
    const isTarget = targetFolders.has(folder);
    const isRef = referenceFolders.has(folder);
    if (!isTarget && !isRef) continue;
    
    const tokens = file.tokens;
    for (let i = 0; i < tokens.length; i++) {
      const tok = tokens[i];
      if (isPunctuationOrSpaceToken(tok)) continue;
      const word = getTokenValue(tok, false); // collocate mode
      if (isTarget) {
        targetTotalTokens++;
        targetWordFreq[word] = (targetWordFreq[word] || 0) + 1;
      }
      if (isRef) {
        refTotalTokens++;
        refWordFreq[word] = (refWordFreq[word] || 0) + 1;
      }
    }
  }
  
  // Second pass: find node matches and collect collocates
  // Respect sentence boundaries - collocates should not cross sentence ends
  for (const [fileId, file] of Object.entries(corpus.files)) {
    const folder = file.folder;
    const isTarget = targetFolders.has(folder);
    const isRef = referenceFolders.has(folder);
    if (!isTarget && !isRef) continue;
    
    const tokens = file.tokens;
    
    // Process each sentence separately to respect boundaries
    for (const sent of file.sentences) {
      const subSentences = getSentenceSegments(tokens, sent.tokenStart, sent.tokenEnd);
      
      for (const subSent of subSentences) {
        // Build arrays for this sub-sentence
        const nodeArr = [];
        const collocateArr = [];
        const tokensArr = []; // Keep reference to original tokens for Biber tag matching
        
        for (const tok of subSent.tokens) {
          nodeArr.push(getTokenValue(tok, true));
          collocateArr.push(getTokenValue(tok, false));
          tokensArr.push(tok);
        }
        
        // For Biber tags, we need nodeLen to be recalculated based on split tokens
        const effectiveNodeLen = isBiberTag ? nodeMatchers.length : nodeLen;
        
        if (nodeArr.length < effectiveNodeLen) continue;
        
        // Find matches within this sub-sentence
        for (let i = 0; i <= nodeArr.length - effectiveNodeLen; i++) {
          let matches = true;
          for (let j = 0; j < effectiveNodeLen; j++) {
            const matcher = nodeMatchers[j];
            const val = nodeArr[i + j];
            const tok = tokensArr[i + j];
            
            if (matcher.type === 'any') {
              continue;
            } else if (matcher.type === 'biber') {
              // Biber tag matching: check if token has any of the expected tags
              if (!tok.biberTags || tok.biberTags.length === 0) {
                matches = false;
                break;
              }
              if (!matcher.tags.some(tag => tok.biberTags.includes(tag))) {
                matches = false;
                break;
              }
            } else if (matcher.type === 'pattern' || matcher.type === 'regex') {
              if (!matcher.regex.test(val)) {
                matches = false;
                break;
              }
            } else {
              if (val !== matcher.value) {
                matches = false;
                break;
              }
            }
          }
          
          if (matches) {
            if (isTarget) totalTargetHits++;
            if (isRef) totalRefHits++;
            
            // Left collocates (L1 = closest to node) - within sub-sentence only
            for (let pos = 1; pos <= 5; pos++) {
              const leftIdx = i - pos;
              if (leftIdx >= 0) {
                const word = collocateArr[leftIdx];
                if (isTarget) {
                  data.target.left[pos][word] = (data.target.left[pos][word] || 0) + 1;
                }
                if (isRef) {
                  data.reference.left[pos][word] = (data.reference.left[pos][word] || 0) + 1;
                }
              }
            }
            
            // Right collocates (R1 = closest to node) - within sub-sentence only
            for (let pos = 1; pos <= 5; pos++) {
              const rightIdx = i + effectiveNodeLen - 1 + pos;
              if (rightIdx < collocateArr.length) {
                const word = collocateArr[rightIdx];
                if (isTarget) {
                  data.target.right[pos][word] = (data.target.right[pos][word] || 0) + 1;
                }
                if (isRef) {
                  data.reference.right[pos][word] = (data.reference.right[pos][word] || 0) + 1;
                }
              }
            }
          }
        }
      }
    }
  }
  
  collocateData = {
    node,
    data,
    spanL,
    spanR,
    topN,
    statType,
    featureType,
    calcMode,
    totalTargetHits,
    totalRefHits,
    // Corpus-wide statistics
    targetTotalTokens,
    refTotalTokens,
    targetWordFreq,
    refWordFreq
  };
  
  renderAllCollocateTables();
  
  const modeLabelMap = { surface: 'surface', lemma: 'lemma', pos_simple: 'POS simple', pos_detailed: 'POS detailed' };
  const modeLabel = ` (collocates: ${modeLabelMap[calcMode] || 'surface'})`;
  status.textContent = `Node: "${node}" — Target hits: ${totalTargetHits}, Reference hits: ${totalRefHits}${modeLabel}`;
}

function clearCollocateTables() {
  ['targetLeftContainer', 'targetRightContainer', 'refLeftContainer', 'refRightContainer'].forEach(id => {
    const el = document.getElementById(id);
    if (el) el.innerHTML = '<div class="text-xs" style="color:#666; padding:0.5rem;">No collocates yet.</div>';
  });
}

function renderAllCollocateTables() {
  if (!collocateData) return;
  
  // Reset table data and counter
  collocateTableData = {};
  collocateTableIdCounter = 0;
  
  const { spanL, spanR } = collocateData;
  
  // Target Left (all + L-1, L-2, ... L-n)
  renderCollocateContainer('target', 'left', 'targetLeftContainer', spanL);
  // Target Right (all + R1, R2, ... Rn)
  renderCollocateContainer('target', 'right', 'targetRightContainer', spanR);
  // Reference Left
  renderCollocateContainer('reference', 'left', 'refLeftContainer', spanL);
  // Reference Right
  renderCollocateContainer('reference', 'right', 'refRightContainer', spanR);
}

function renderCollocateContainer(side, direction, containerId, span) {
  const container = document.getElementById(containerId);
  if (!container || !collocateData) return;
  
  const { data, topN, statType, totalTargetHits, totalRefHits, 
          targetTotalTokens, refTotalTokens, targetWordFreq, refWordFreq } = collocateData;
  const posData = data[side][direction];
  const totalHits = side === 'target' ? totalTargetHits : totalRefHits;
  const corpusTotalTokens = side === 'target' ? targetTotalTokens : refTotalTokens;
  const corpusWordFreq = side === 'target' ? targetWordFreq : refWordFreq;
  const scope = side;
  
  // Calculate total tokens for each position
  const totalTokensPerPos = {};
  for (let p = 1; p <= 5; p++) {
    totalTokensPerPos[p] = Object.values(posData[p]).reduce((a, b) => a + b, 0);
  }
  
  // Aggregate "All" frequencies (sum of positions 1 to span)
  const allFreqs = {};
  for (let p = 1; p <= span; p++) {
    for (const [word, count] of Object.entries(posData[p])) {
      allFreqs[word] = (allFreqs[word] || 0) + count;
    }
  }
  const totalAllTokens = Object.values(allFreqs).reduce((a, b) => a + b, 0);
  
  // Build HTML
  let html = '';
  
  // All table
  const allTitle = direction === 'left' ? 'Left Collocates (all)' : 'Right Collocates (all)';
  html += buildCollocateBox(allTitle, allFreqs, totalAllTokens, totalHits, statType, topN, scope, direction, 'all', corpusTotalTokens, corpusWordFreq);
  
  // Position tables (L-1, L-2... or R1, R2...)
  for (let p = 1; p <= span; p++) {
    const posTitle = direction === 'left' ? ('L-' + p) : ('R' + p);
    const posFreqs = posData[p];
    const totalPosTokens = totalTokensPerPos[p];
    html += buildCollocateBox(posTitle, posFreqs, totalPosTokens, totalHits, statType, topN, scope, direction, String(p), corpusTotalTokens, corpusWordFreq);
  }
  
  container.innerHTML = html;
  
  // Add click handlers for word links (KWIC filter)
  container.querySelectorAll('.collocate-word-link').forEach(function(link) {
    link.addEventListener('click', function(e) {
      e.preventDefault();
      e.stopPropagation();
      var word = e.target.getAttribute('data-word');
      var sc = e.target.getAttribute('data-scope');
      var dir = e.target.getAttribute('data-direction');
      var pos = e.target.getAttribute('data-position');
      filterKwicByCollocate(word, sc, dir, pos);
    });
  });
  
  // Add click handlers for column headers (sorting)
  container.querySelectorAll('.collocate-sort-header').forEach(function(th) {
    th.addEventListener('click', function(e) {
      var tableId = th.getAttribute('data-table-id');
      var col = th.getAttribute('data-col');
      sortCollocateBoxTable(tableId, col);
    });
  });
}

function buildCollocateBox(title, freqMap, totalTokens, totalHits, statType, topN, scope, direction, position, corpusTotalTokens, corpusWordFreq) {
  // Generate unique table ID
  var tableId = 'collocate-table-' + (collocateTableIdCounter++);
  
  // Build word list with stats
  var wordList = [];
  for (var word in freqMap) {
    if (freqMap.hasOwnProperty(word)) {
      var freq = freqMap[word];
      if (freq === 0) continue;
      var wordCorpusFreq = corpusWordFreq[word] || 0;
      var stat = calcCollocateStat(freq, totalHits, wordCorpusFreq, corpusTotalTokens, statType);
      wordList.push({ word: word, freq: freq, stat: stat, wordCorpusFreq: wordCorpusFreq });
    }
  }
  
  // Sort by stat descending (default)
  wordList.sort(function(a, b) { return b.stat - a.stat; });
  
  // Store table data for sorting
  collocateTableData[tableId] = {
    wordList: wordList,
    topN: topN,
    scope: scope,
    direction: direction,
    position: position,
    statType: statType,
    corpusTotalTokens: corpusTotalTokens,
    corpusWordFreq: corpusWordFreq,
    totalHits: totalHits,
    sortCol: 'stat',
    sortDir: 'desc'
  };
  
  var topWords = wordList.slice(0, topN);
  
  if (topWords.length === 0) {
    return '<div class="collocate-box">' +
      '<div class="collocate-box-title">' + escapeHtml(title) + '</div>' +
      '<div style="padding:0.5rem; text-align:center; color:#999;">No data</div>' +
      '</div>';
  }
  
  var html = '<div class="collocate-box" data-table-id="' + tableId + '">' +
    '<div class="collocate-box-title">' + escapeHtml(title) + '</div>' +
    '<table><thead><tr>' +
    '<th class="collocate-sort-header col-rank" data-table-id="' + tableId + '" data-col="rank">#<span class="sort-icon">↕</span></th>' +
    '<th class="collocate-sort-header col-word" data-table-id="' + tableId + '" data-col="word">Word<span class="sort-icon">↕</span></th>' +
    '<th class="collocate-sort-header col-freq" data-table-id="' + tableId + '" data-col="freq">Freq<span class="sort-icon">↕</span></th>' +
    '<th class="collocate-sort-header col-score sorted-desc" data-table-id="' + tableId + '" data-col="stat">' + getStatLabel(statType) + '<span class="sort-icon">▼</span></th>' +
    '</tr></thead><tbody id="' + tableId + '-body">';
  
  for (var i = 0; i < topWords.length; i++) {
    var w = topWords[i];
    var statStr = formatCollocateStat(w.stat, statType);
    html += '<tr>' +
      '<td>' + (i + 1) + '</td>' +
      '<td><span class="collocate-word-link" data-word="' + escapeHtml(w.word) + '" data-scope="' + scope + '" data-direction="' + direction + '" data-position="' + position + '">' + escapeHtml(w.word) + '</span></td>' +
      '<td>' + w.freq + '</td>' +
      '<td>' + statStr + '</td>' +
      '</tr>';
  }
  
  html += '</tbody></table></div>';
  return html;
}

function sortCollocateBoxTable(tableId, col) {
  var tableData = collocateTableData[tableId];
  if (!tableData) return;
  
  var wordList = tableData.wordList.slice(); // copy
  var currentSortCol = tableData.sortCol;
  var currentSortDir = tableData.sortDir;
  
  // Determine new sort direction
  var newSortDir;
  if (currentSortCol === col) {
    newSortDir = currentSortDir === 'desc' ? 'asc' : 'desc';
  } else {
    newSortDir = 'desc'; // default to descending for new column
  }
  
  // Sort
  wordList.sort(function(a, b) {
    var valA, valB;
    if (col === 'word') {
      valA = a.word.toLowerCase();
      valB = b.word.toLowerCase();
      if (newSortDir === 'asc') {
        return valA < valB ? -1 : (valA > valB ? 1 : 0);
      } else {
        return valA > valB ? -1 : (valA < valB ? 1 : 0);
      }
    } else if (col === 'freq') {
      valA = a.freq;
      valB = b.freq;
    } else if (col === 'stat') {
      valA = a.stat;
      valB = b.stat;
    } else if (col === 'rank') {
      // rank is just based on current order, use stat for sorting
      valA = a.stat;
      valB = b.stat;
    }
    if (newSortDir === 'asc') {
      return valA - valB;
    } else {
      return valB - valA;
    }
  });
  
  // Update stored sort state
  tableData.sortCol = col;
  tableData.sortDir = newSortDir;
  
  // Re-render table body
  var tbody = document.getElementById(tableId + '-body');
  if (!tbody) return;
  
  var topWords = wordList.slice(0, tableData.topN);
  var scope = tableData.scope;
  var direction = tableData.direction;
  var position = tableData.position;
  var statType = tableData.statType;
  
  var html = '';
  for (var i = 0; i < topWords.length; i++) {
    var w = topWords[i];
    var statStr = formatCollocateStat(w.stat, statType);
    html += '<tr>' +
      '<td>' + (i + 1) + '</td>' +
      '<td><span class="collocate-word-link" data-word="' + escapeHtml(w.word) + '" data-scope="' + scope + '" data-direction="' + direction + '" data-position="' + position + '">' + escapeHtml(w.word) + '</span></td>' +
      '<td>' + w.freq + '</td>' +
      '<td>' + statStr + '</td>' +
      '</tr>';
  }
  tbody.innerHTML = html;
  
  // Re-add click handlers for word links
  tbody.querySelectorAll('.collocate-word-link').forEach(function(link) {
    link.addEventListener('click', function(e) {
      e.preventDefault();
      e.stopPropagation();
      var word = e.target.getAttribute('data-word');
      var sc = e.target.getAttribute('data-scope');
      var dir = e.target.getAttribute('data-direction');
      var pos = e.target.getAttribute('data-position');
      filterKwicByCollocate(word, sc, dir, pos);
    });
  });
  
  // Update header icons
  var box = document.querySelector('.collocate-box[data-table-id="' + tableId + '"]');
  if (box) {
    box.querySelectorAll('.collocate-sort-header').forEach(function(th) {
      th.classList.remove('sorted-asc', 'sorted-desc');
      var icon = th.querySelector('.sort-icon');
      if (icon) icon.textContent = '↕';
    });
    var sortedTh = box.querySelector('.collocate-sort-header[data-col="' + col + '"]');
    if (sortedTh) {
      sortedTh.classList.add(newSortDir === 'asc' ? 'sorted-asc' : 'sorted-desc');
      var icon = sortedTh.querySelector('.sort-icon');
      if (icon) icon.textContent = newSortDir === 'asc' ? '▲' : '▼';
    }
  }
}

// Filter KWIC results by collocate word and position
function filterKwicByCollocate(word, scope, direction, position) {
  console.log('[filterKwicByCollocate] Called with:', { word, scope, direction, position });
  
  if (!collocateData || !collocateData.node) {
    alert('Please compute Collocate first.');
    return;
  }
  
  const collocateNode = collocateData.node;
  const collocateCalcMode = collocateData.calcMode || 'surface';
  const collocateFeatureType = collocateData.featureType || 'word';
  
  console.log('[filterKwicByCollocate] collocateData:', {
    node: collocateNode,
    calcMode: collocateCalcMode,
    featureType: collocateFeatureType
  });
  
  // Check if collocate was computed in POS mode (for collocate display)
  const isPosCalcMode = collocateCalcMode === 'pos_simple' || collocateCalcMode === 'pos_detailed';
  console.log('[filterKwicByCollocate] isPosCalcMode:', isPosCalcMode);
  
  // Clear previous filter settings first (except for collocate filter which will be set)
  clearKwicFilters();
  
  // Check if collocate was computed from Advanced mode
  const isAdvancedMode = collocateFeatureType === 'advanced';
  
  if (isAdvancedMode) {
    // Only for Advanced mode collocates, use KWIC Advanced mode
    const kwicToggle = document.getElementById('kwicAdvancedModeToggle');
    if (kwicToggle && !kwicToggle.checked) {
      kwicToggle.checked = true;
      document.getElementById('kwicSimpleMode').style.display = 'none';
      document.getElementById('kwicAdvancedMode').style.display = 'block';
    }
    
    // Set KWIC scope
    const scopeInput = document.querySelector(`input[name="kwicScope"][value="${scope}"]`);
    if (scopeInput) scopeInput.checked = true;
    
    // Compute KWIC using advanced mode if not already computed
    if (!allKwicRows || allKwicRows.length === 0) {
      computeAdvancedKwic();
    }
    
    // Apply collocate filter to existing KWIC
    setTimeout(() => applyCollocateFilter(word, scope, direction, position), 100);
    return;
  }
  
  if (isPosCalcMode) {
    // For POS-mode collocates, use the filter with position
    // First compute KWIC for the node, then apply filter
    setupKwicWithPosFilter(word, collocateNode, direction, position, collocateCalcMode, scope);
    return;
  }
  
  // Ensure simple mode is active (for non-advanced mode)
  const kwicToggle = document.getElementById('kwicAdvancedModeToggle');
  if (kwicToggle && kwicToggle.checked) {
    kwicToggle.checked = false;
    document.getElementById('kwicSimpleMode').style.display = 'block';
    document.getElementById('kwicAdvancedMode').style.display = 'none';
  }
  
  // Scroll to KWIC card
  const kwicCard = document.getElementById('kwicCard');
  if (kwicCard) {
    kwicCard.scrollIntoView({ behavior: 'smooth', block: 'start' });
  }
  
  // Original behavior for word/lemma mode
  // Get current KWIC scope
  const currentScopeEl = document.querySelector('input[name="kwicScope"]:checked');
  const currentScope = currentScopeEl ? currentScopeEl.value : 'target';
  
  // Check if we need to recompute KWIC (node changed, no KWIC data, or scope changed)
  const needsRecompute = !allKwicRows || allKwicRows.length === 0 || 
                         currentKwicFeature !== collocateNode ||
                         currentScope !== scope;
  
  if (needsRecompute) {
    // Set KWIC scope radio button
    const scopeInput = document.querySelector(`input[name="kwicScope"][value="${scope}"]`);
    if (scopeInput) scopeInput.checked = true;
    
    // Set KWIC feature to collocate node
    currentKwicFeature = collocateNode;
    
    // Determine the appropriate feature type for KWIC
    let kwicFeatureType = collocateFeatureType;
    
    // Map collocate feature type to KWIC feature type
    if (collocateFeatureType.startsWith('posgram')) {
      // For POS-gram feature type, use the same
      kwicFeatureType = collocateFeatureType;
    } else if (collocateFeatureType.startsWith('pos_')) {
      // For single POS, use word type
      kwicFeatureType = 'word';
    }
    
    currentKwicFeatureType = kwicFeatureType;
    
    // Update all related inputs
    const kwicFeatureInput = document.getElementById('kwicFeatureInput');
    const kwicTypeSelect = document.getElementById('kwicFeatureTypeSelect');
    if (kwicFeatureInput) kwicFeatureInput.value = collocateNode;
    if (kwicTypeSelect) {
      // Check if option exists
      const optionExists = Array.from(kwicTypeSelect.options).some(opt => opt.value === kwicFeatureType);
      if (optionExists) {
        kwicTypeSelect.value = kwicFeatureType;
      } else {
        // Fallback: try to find a similar type or default to word (surface)
        const lemmaOption = Array.from(kwicTypeSelect.options).find(opt => opt.value.includes('lemma'));
        const wordOption = Array.from(kwicTypeSelect.options).find(opt => opt.value === 'word' || opt.value.includes('surface'));
        if (kwicFeatureType.includes('lemma') && lemmaOption) {
          kwicTypeSelect.value = lemmaOption.value;
          currentKwicFeatureType = lemmaOption.value;
        } else if (wordOption) {
          kwicTypeSelect.value = wordOption.value;
          currentKwicFeatureType = wordOption.value;
        }
      }
    }
    
    // Also sync Search mode based on Feature type
    const kwicSearchMode = document.getElementById('kwicSearchMode');
    if (kwicSearchMode) {
      if (kwicFeatureType === 'regex') {
        kwicSearchMode.value = 'regex';
      }
      // Keep current search mode for other types
    }
    
    // Also sync to Plot
    const plotInput = document.getElementById('plotFeatureInput');
    const plotType = document.getElementById('plotFeatureTypeSelect');
    if (plotInput) plotInput.value = collocateNode;
    if (plotType) plotType.value = currentKwicFeatureType;
    
    // Set KWIC View to Surface (always display in surface form)
    const surfaceViewRadio = document.querySelector('input[name="kwicView"][value="surface"]');
    if (surfaceViewRadio) surfaceViewRadio.checked = true;
    
    // Compute KWIC first, then filter
    computeKwicThenFilter(word, scope, direction, position);
    return;
  }
  
  // KWIC already computed for this node and scope, just filter
  applyCollocateFilter(word, scope, direction, position);
}

// Set up KWIC with POS filter from Collocate POS mode
function setupKwicWithPosFilter(posTag, node, direction, position, calcMode, scope) {
  console.log('[setupKwicWithPosFilter] Called with:', { posTag, node, direction, position, calcMode, scope });
  console.log('[setupKwicWithPosFilter] collocateData:', collocateData);
  
  // Clear previous filter settings first
  clearKwicFilters();
  
  // Ensure simple mode is active
  const toggle = document.getElementById('kwicAdvancedModeToggle');
  if (toggle && toggle.checked) {
    toggle.checked = false;
    document.getElementById('kwicSimpleMode').style.display = 'block';
    document.getElementById('kwicAdvancedMode').style.display = 'none';
  }
  
  // Set KWIC scope
  const scopeInput = document.querySelector(`input[name="kwicScope"][value="${scope}"]`);
  if (scopeInput) scopeInput.checked = true;
  
  // Set KWIC feature to collocate node (the word being searched, e.g., "is")
  const kwicFeatureInput = document.getElementById('kwicFeatureInput');
  if (kwicFeatureInput) kwicFeatureInput.value = node;
  
  // Set feature type from collocateData (the type used in Collocate search)
  const featureType = collocateData ? collocateData.featureType : 'word';
  console.log('[setupKwicWithPosFilter] featureType from collocateData:', featureType);
  
  const kwicTypeSelect = document.getElementById('kwicFeatureTypeSelect');
  if (kwicTypeSelect) {
    // Check if option exists
    const availableOptions = Array.from(kwicTypeSelect.options).map(opt => opt.value);
    console.log('[setupKwicWithPosFilter] Available options:', availableOptions);
    
    const optionExists = availableOptions.includes(featureType);
    console.log('[setupKwicWithPosFilter] Option exists:', optionExists);
    
    if (optionExists) {
      kwicTypeSelect.value = featureType;
      console.log('[setupKwicWithPosFilter] Set kwicTypeSelect.value to:', featureType);
    } else {
      kwicTypeSelect.value = 'word';
      console.log('[setupKwicWithPosFilter] Fallback to word');
    }
  }
  
  // Set current feature and type BEFORE computing KWIC
  currentKwicFeature = node;
  currentKwicFeatureType = featureType;
  
  // Scroll to KWIC card
  const kwicCard = document.getElementById('kwicCard');
  if (kwicCard) {
    kwicCard.scrollIntoView({ behavior: 'smooth', block: 'start' });
  }
  
  // Store filter settings to apply after KWIC computation
  const filterMode = calcMode === 'pos_detailed' ? 'pos_detailed' : 'pos_simple';
  const pendingFilter = {
    posTag,
    direction,
    position,
    filterMode
  };
  
  // Set up the filter inputs BEFORE computing (they will be applied automatically)
  if (pendingFilter.direction === 'left') {
    const leftFilter = document.getElementById('kwicLeftFilter');
    const leftMode = document.getElementById('kwicLeftFilterMode');
    const leftPos = document.getElementById('kwicLeftFilterPos');
    
    if (leftFilter) leftFilter.value = pendingFilter.posTag;
    if (leftMode) leftMode.value = pendingFilter.filterMode;
    if (leftPos) leftPos.value = pendingFilter.position;
    
    // Clear right filter
    const rightFilter = document.getElementById('kwicRightFilter');
    const rightPos = document.getElementById('kwicRightFilterPos');
    if (rightFilter) rightFilter.value = '';
    if (rightPos) rightPos.value = 'any';
  } else {
    const rightFilter = document.getElementById('kwicRightFilter');
    const rightMode = document.getElementById('kwicRightFilterMode');
    const rightPos = document.getElementById('kwicRightFilterPos');
    
    if (rightFilter) rightFilter.value = pendingFilter.posTag;
    if (rightMode) rightMode.value = pendingFilter.filterMode;
    if (rightPos) rightPos.value = pendingFilter.position;
    
    // Clear left filter
    const leftFilter = document.getElementById('kwicLeftFilter');
    const leftPos = document.getElementById('kwicLeftFilterPos');
    if (leftFilter) leftFilter.value = '';
    if (leftPos) leftPos.value = 'any';
  }
  
  // Clear node filter
  const nodeFilter = document.getElementById('kwicNodeFilter');
  if (nodeFilter) nodeFilter.value = '';
  
  // Use the standard computeKwic function which handles all feature types correctly
  computeKwic();
  
  // Apply filter after a short delay to ensure KWIC is computed
  setTimeout(() => {
    applyKwicFilter();
    updateFilterStatusBar();
  }, 100);
}

// Compute KWIC specifically for collocate link (with explicit parameters)
function computeKwicForCollocate(feature, featureType, scope, callback) {
  const status = document.getElementById('kwicStatus');
  const body = document.getElementById('kwicTableBody');
  status.textContent = 'Computing KWIC...';
  
  // Reset KWIC state
  lastKwicRows = [];
  allKwicRows = [];
  window.lastKwicFilterState = null;
  
  if (!corpus || Object.keys(corpus.files).length === 0) {
    status.textContent = 'Please load a corpus first.';
    body.innerHTML = '<tr><td colspan="6" class="text-xs">No KWIC.</td></tr>';
    return;
  }
  
  if (!feature) {
    status.textContent = 'Please specify a feature.';
    body.innerHTML = '<tr><td colspan="6" class="text-xs">No KWIC.</td></tr>';
    return;
  }
  
  const viewMode = getKwicViewMode();
  const allRows = [];
  const files = Object.values(corpus.files);
  
  // Get search mode from KWIC settings
  const searchModeSelect = document.getElementById('kwicSearchMode');
  let searchMode = searchModeSelect ? searchModeSelect.value : 'exact';
  
  // Override search mode based on featureType
  if (featureType === 'regex') {
    searchMode = 'regex';
  }
  
  // Check for wildcard characters in the feature itself
  if (feature.includes('*') || feature.includes('?')) {
    searchMode = 'wildcard';
  }
  
  const caseInsensitive = document.getElementById('kwicCaseInsensitive')?.checked ?? true;
  
  console.log('[computeKwicForCollocate] feature:', feature, 'featureType:', featureType, 'scope:', scope, 'searchMode:', searchMode);
  
  // Build matcher using the standard function
  let createMatcher;
  try {
    createMatcher = buildMatcherCreator(feature, searchMode, caseInsensitive);
  } catch (e) {
    console.error('[computeKwicForCollocate] Error building matcher:', e);
    status.textContent = 'Invalid pattern: ' + e.message;
    body.innerHTML = '<tr><td colspan="6" class="text-xs">No KWIC.</td></tr>';
    return;
  }
  
  for (const file of files) {
    const inT = targetFolders.has(file.folder);
    const inR = referenceFolders.has(file.folder);
    
    let useFile = false;
    if (scope === 'target') {
      useFile = inT;
    } else if (scope === 'reference') {
      useFile = inR;
    } else {
      useFile = inT || inR;
    }
    if (!useFile) continue;
    
    const side = inT && inR ? 'T/R' : (inT ? 'T' : 'R');
    
    for (const sent of file.sentences) {
      const tokens = file.tokens;
      
      // Determine which field to match based on featureType
      let useLemma = (featureType === 'word_lemma' || featureType === 'lemma' || featureType === 'ngram_lemma');
      let usePosSimple = (featureType === 'pos_simple');
      let usePosDetailed = (featureType === 'pos_detailed');
      let isNgram = (featureType === 'ngram_word' || featureType === 'ngram_lemma');
      
      if (isNgram) {
        // Handle n-gram matching
        const featureTokens = feature.split(' ').filter(t => t.length > 0);
        const n = featureTokens.length;
        
        // Build matchers for each token in the n-gram
        const tokenMatchers = featureTokens.map(t => {
          const tLower = caseInsensitive ? t.toLowerCase() : t;
          return (val) => {
            const vLower = caseInsensitive ? val.toLowerCase() : val;
            return vLower === tLower;
          };
        });
        
        // Build array of content tokens (skip punctuation)
        const contentTokens = [];
        const contentIndices = [];
        for (let i = sent.tokenStart; i < sent.tokenEnd; i++) {
          const tok = tokens[i];
          if (isPunctuationOrSpaceToken(tok)) continue;
          const val = useLemma ? (tok.lemma || tok.word) : tok.word;
          if (val) {
            contentTokens.push(val);
            contentIndices.push(i);
          }
        }
        
        // Slide through tokens looking for n-gram matches
        for (let i = 0; i <= contentTokens.length - n; i++) {
          let match = true;
          for (let j = 0; j < n; j++) {
            if (!tokenMatchers[j](contentTokens[i + j])) {
              match = false;
              break;
            }
          }
          if (match) {
            const startIdx = contentIndices[i];
            const endIdx = contentIndices[i + n - 1] + 1;
            allRows.push(makeKwicRow(file, sent, startIdx, endIdx, side, viewMode));
          }
        }
      } else {
        // Single token matching
        for (let idx = sent.tokenStart; idx < sent.tokenEnd; idx++) {
          const tok = tokens[idx];
          if (isPunctuationOrSpaceToken(tok)) continue;
          
          let val;
          if (usePosSimple) {
            val = tok.poss || '';
          } else if (usePosDetailed) {
            val = tok.posd || '';
          } else if (useLemma) {
            val = tok.lemma || '';
          } else {
            val = tok.word || '';
          }
          
          if (!val) continue;
          
          if (createMatcher(val)) {
            allRows.push(makeKwicRow(file, sent, idx, idx + 1, side, viewMode));
          }
        }
      }
    }
  }
  
  allKwicRows = allRows;
  lastKwicAllCount = allRows.length;
  lastKwicSort = { col: 0, dir: 'asc' };
  lastOriginalIndex = null;
  
  console.log('[computeKwicForCollocate] Found', allRows.length, 'KWIC rows');
  
  if (allRows.length === 0) {
    status.textContent = 'No matching KWIC found.';
    body.innerHTML = '<tr><td colspan="6" class="text-xs">No KWIC.</td></tr>';
    document.getElementById('originalText').textContent = 'No text selected.';
    return;
  }
  
  // Render KWIC without filter first
  lastKwicRows = allRows.slice(0, 300);
  renderKwicRows();
  status.textContent = `KWIC hits: ${allRows.length}`;
  
  // Call the callback to apply filter
  if (callback) {
    setTimeout(callback, 50);
  }
}

// Compute KWIC and then apply collocate filter
function computeKwicThenFilter(word, scope, direction, position) {
  // Store filter params for after KWIC computation
  window._pendingCollocateFilter = { word, scope, direction, position };
  
  // Compute KWIC (this will call applyKwicFilter which normally calls computeCollocatesFromKwic)
  // We need to intercept and apply our filter instead
  computeKwicWithCallback(() => {
    const params = window._pendingCollocateFilter;
    if (params) {
      window._pendingCollocateFilter = null;
      applyCollocateFilter(params.word, params.scope, params.direction, params.position);
    }
  });
}

// Modified computeKwic that accepts a callback
function computeKwicWithCallback(callback) {
  const status = document.getElementById('kwicStatus');
  const body = document.getElementById('kwicTableBody');
  status.textContent = '';
  // Reset KWIC / filter / collocate state for new search (callback mode)
  lastKwicRows = [];
  window.lastKwicFilterState = null;
  currentCollocateWord = null;
  currentCollocateInfo = null;


  if (!corpus || Object.keys(corpus.files).length === 0) {
    status.textContent = 'Please load a corpus first.';
    body.innerHTML = '<tr><td colspan="6" class="text-xs">No KWIC.</td></tr>';
    return;
  }

  const kwicFeatureInput = document.getElementById('kwicFeatureInput');
  const kwicTypeSelect = document.getElementById('kwicFeatureTypeSelect');
  const featureInput = kwicFeatureInput ? kwicFeatureInput.value.trim() : '';

  if (featureInput) {
    currentKwicFeature = featureInput;
  }
  if (!currentKwicFeature) {
    status.textContent = 'Please specify a feature.';
    body.innerHTML = '<tr><td colspan="6" class="text-xs">No KWIC.</td></tr>';
    return;
  }

  if (kwicTypeSelect && kwicTypeSelect.value) {
    currentKwicFeatureType = kwicTypeSelect.value;
  }
  const featureType = currentKwicFeatureType || lastKeyFeatureType;
  if (!featureType) {
    status.textContent = 'Feature type is unknown.';
    body.innerHTML = '<tr><td colspan="6" class="text-xs">No KWIC.</td></tr>';
    return;
  }

  const maxHitsInput = document.getElementById('kwicMaxHits');
  let maxHits = parseInt(maxHitsInput.value, 10);
  if (!Number.isFinite(maxHits) || maxHits <= 0) maxHits = 300;

  const feature = currentKwicFeature;
  const viewMode = getKwicViewMode();

  let scope = 'target';
  const scopeEl = document.querySelector('input[name="kwicScope"]:checked');
  if (scopeEl && scopeEl.value) {
    scope = scopeEl.value;
  }

  const allRows = [];
  const files = Object.values(corpus.files);

  const isPframe = featureType.startsWith('pframe');
  const isNgramWord = featureType === 'ngram_word' || featureType === 'ngram_lemma';
  const isPosgram = featureType === 'posgram_simple' || featureType === 'posgram_detailed';

  const featureTokens = (isNgramWord || isPframe || isPosgram) ? feature.split(featureType.startsWith('posgram') ? '+' : ' ') : null;
  const n = featureTokens ? featureTokens.length : 1;
  let starPos = -1;
  if (isPframe && featureTokens) {
    starPos = featureTokens.indexOf('*');
  }

  for (const file of files) {
    const inT = targetFolders.has(file.folder);
    const inR = referenceFolders.has(file.folder);

    let useFile = false;
    if (scope === 'target') {
      useFile = inT;
    } else if (scope === 'reference') {
      useFile = inR;
    } else {
      useFile = inT || inR;
    }
    if (!useFile) continue;

    // Apply optional file / folder filters (from 5b Concordance Plot)
    if (currentKwicFileFilter && file.name !== currentKwicFileFilter) {
      continue;
    }
    if (currentKwicFolderFilter && file.folder !== currentKwicFolderFilter) {
      continue;
    }

    const side = inT && inR ? 'T/R' : (inT ? 'T' : 'R');

    for (const sent of file.sentences) {
      const tokens = file.tokens;

      if (featureType === 'word' || featureType === 'word_lemma') {
        const targetVal = feature.toLowerCase();
        const useLemma = (featureType === 'word_lemma');
        for (let idx = sent.tokenStart; idx < sent.tokenEnd; idx++) {
          const tok = tokens[idx];
          if (isPunctuationOrSpaceToken(tok)) continue;
          const val = (useLemma ? tok.lemma : tok.word) || '';
          if (!val) continue;
          if (val.toLowerCase() === targetVal) {
            allRows.push(makeKwicRow(file, sent, idx, idx + 1, side, viewMode));
          }
        }
      } else if (featureType === 'pos_simple' || featureType === 'pos_detailed') {
        const field = featureType === 'pos_simple' ? 'poss' : 'posd';
        for (let idx = sent.tokenStart; idx < sent.tokenEnd; idx++) {
          const tok = tokens[idx];
          if (isPunctuationOrSpaceToken(tok)) continue;
          const val = tok[field] || '';
          if (!val) continue;
          if (val === feature) {
            allRows.push(makeKwicRow(file, sent, idx, idx + 1, side, viewMode));
          }
        }
      } else if (isNgramWord || isPframe || isPosgram) {
        const arr = [];
        const indices = [];
        for (let i = sent.tokenStart; i < sent.tokenEnd; i++) {
          const tok = tokens[i];
          if (isPunctuationOrSpaceToken(tok)) continue;
          let val = '';
          if (isPosgram) {
            val = featureType === 'posgram_simple' ? tok.poss : tok.posd;
          } else {
            val = featureType.includes('lemma') ? tok.lemma : tok.word;
          }
          if (!val) continue;
          arr.push(val);
          indices.push(i);
        }
        if (arr.length < n) continue;

        for (let start = 0; start <= arr.length - n; start++) {
          let match = true;
          for (let k = 0; k < n; k++) {
            if (isPframe && k === starPos) continue;
            if (arr[start + k].toLowerCase() !== featureTokens[k].toLowerCase()) {
              match = false;
              break;
            }
          }
          if (match) {
            const startIdx = indices[start];
            const endIdx = indices[start + n - 1] + 1;
            allRows.push(makeKwicRow(file, sent, startIdx, endIdx, side, viewMode));
          }
        }
      }
    }
  }

  allKwicRows = allRows;
  lastKwicAllCount = allRows.length;
  lastKwicSort = { col: 0, dir: 'asc' };
  lastOriginalIndex = null;

  if (allRows.length === 0) {
    status.textContent = 'No matching KWIC found.';
    body.innerHTML = '<tr><td colspan="6" class="text-xs">No KWIC.</td></tr>';
    document.getElementById('originalText').textContent = 'No text selected.';
    return;
  }

  // Apply filter without calling computeCollocates (we'll call our callback instead)
  applyKwicFilterWithCallback(callback);
}

function applyKwicFilterWithCallback(callback) {
  const status = document.getElementById('kwicStatus');
  const body = document.getElementById('kwicTableBody');

  if (!allKwicRows || allKwicRows.length === 0) {
    if (body) {
      body.innerHTML = '<tr><td colspan="6" class="text-xs">No KWIC.</td></tr>';
    }
    if (status) {
      status.textContent = 'KWIC has not been computed yet.';
    }
    return;
  }

  let maxHits = 300;
  const maxHitsInput = document.getElementById('kwicMaxHits');
  if (maxHitsInput) {
    const v = parseInt(maxHitsInput.value, 10);
    if (Number.isFinite(v) && v > 0) {
      maxHits = v;
    }
  }

  const leftBox  = document.getElementById('kwicLeftFilter');
  const nodeBox  = document.getElementById('kwicNodeFilter');
  const rightBox = document.getElementById('kwicRightFilter');

  const leftModeSel  = document.getElementById('kwicLeftFilterMode');
  const nodeModeSel  = document.getElementById('kwicNodeFilterMode');
  const rightModeSel = document.getElementById('kwicRightFilterMode');

  const leftStr  = leftBox  ? leftBox.value.trim()  : '';
  const nodeStr  = nodeBox  ? nodeBox.value.trim()  : '';
  const rightStr = rightBox ? rightBox.value.trim() : '';

  const leftMode  = leftModeSel  ? leftModeSel.value  : 'exact';
  const nodeMode  = nodeModeSel  ? nodeModeSel.value  : 'exact';
  const rightMode = rightModeSel ? rightModeSel.value : 'exact';

  // Base rows: if KWIC is already narrowed (e.g., by collocate), use that as input.
  const baseRows = (lastKwicRows && lastKwicRows.length > 0) ? lastKwicRows : allKwicRows;

  let filtered = baseRows.filter(row => {
    const okLeft  = kwicMatchesFilter(row.leftText,  leftStr,  leftMode);
    const okNode  = kwicMatchesFilter(row.nodeText,  nodeStr,  nodeMode);
    const okRight = kwicMatchesFilter(row.rightText, rightStr, rightMode);
    return okLeft && okNode && okRight;
  });

  lastKwicRows = filtered.slice(0, maxHits);
  lastKwicSort = { col: 0, dir: 'asc' };
  lastOriginalIndex = null;

  // 保存してハイライトに使う
  window.lastKwicFilterState = {
    leftStr, nodeStr, rightStr, leftMode, nodeMode, rightMode
  };

  if (!lastKwicRows || lastKwicRows.length === 0) {
    if (body) {
      body.innerHTML = '<tr><td colspan="6" class="text-xs">No KWIC (filter).</td></tr>';
    }
    if (status) {
      status.textContent = `KWIC hits: ${lastKwicAllCount} (after filter: 0)`;
    }
    const orig = document.getElementById('originalText');
    if (orig) orig.textContent = 'No text selected.';
    return;
  }

  renderKwicRows();
  if (status) {
    status.textContent = `KWIC hits: ${lastKwicAllCount} (after filter: ${filtered.length}; showing up to ${lastKwicRows.length})`;
  }

  // Call the callback instead of computeCollocatesFromKwic
  if (callback) {
    callback();
  } else {
    computeCollocatesFromKwic();
  }
}
// Apply collocate filter to existing KWIC results
function applyCollocateFilter(word, scope, direction, position) {
  // Update KWIC scope radio button
  const scopeInput = document.querySelector(`input[name="kwicScope"][value="${scope}"]`);
  if (scopeInput) scopeInput.checked = true;

  // Get span from appropriate mode (Simple or Advanced)
  const isAdvancedMode = document.getElementById('kwicAdvancedModeToggle')?.checked;
  const spanLEl = isAdvancedMode ? document.getElementById('collocateSpanLAdv') : document.getElementById('collocateSpanL');
  const spanREl = isAdvancedMode ? document.getElementById('collocateSpanRAdv') : document.getElementById('collocateSpanR');
  const spanL = parseInt(spanLEl?.value, 10) || 5;
  const spanR = parseInt(spanREl?.value, 10) || 5;
  const span = direction === 'left' ? spanL : spanR;

  const wordLower = word.toLowerCase();
  const calcMode = collocateData ? collocateData.calcMode : 'surface';
  const isPosMode = calcMode === 'pos_simple' || calcMode === 'pos_detailed';
  const useLemma = calcMode === 'lemma';

  // Helper to check if a string is punctuation
  const isPunct = (s) => /^[^\w]+$/.test(s);
  
  // Helper to get token value based on calc mode
  const getTokenValue = (tok, mode) => {
    if (!tok) return '';
    if (typeof tok === 'string') return tok;
    
    if (mode === 'pos_detailed') return tok.posd || tok.pos || '';
    if (mode === 'pos_simple') return tok.poss || '';
    if (mode === 'lemma') return tok.lemma || tok.surface || tok.word || '';
    return tok.surface || tok.word || '';
  };

  // Filter allKwicRows by scope and collocate position
  const filtered = allKwicRows.filter(row => {
    // Check scope (target/reference)
    if (scope === 'target' && row.side !== 'T' && row.side !== 'T/R') return false;
    if (scope === 'reference' && row.side !== 'R' && row.side !== 'T/R') return false;

    // Get left/right arrays - Advanced mode uses leftTokens/rightTokens as objects
    let leftArr, rightArr;
    
    if (row.leftTokens && Array.isArray(row.leftTokens) && row.leftTokens[0] && typeof row.leftTokens[0] === 'object') {
      // Advanced mode - tokens are objects
      leftArr = row.leftTokens;
      rightArr = row.rightTokens || [];
    } else if (useLemma && row.leftLemmas) {
      // Simple mode with lemma
      leftArr = row.leftLemmas || [];
      rightArr = row.rightLemmas || [];
    } else {
      // Simple mode with surface
      leftArr = row.leftTokens || [];
      rightArr = row.rightTokens || [];
    }
    
    // Filter out punctuation to get word-only arrays
    const leftWords = leftArr.filter(t => {
      const val = typeof t === 'object' ? (t.surface || t.word || '') : String(t);
      return !isPunct(val);
    });
    const rightWords = rightArr.filter(t => {
      const val = typeof t === 'object' ? (t.surface || t.word || '') : String(t);
      return !isPunct(val);
    });

    // Check if collocate word/POS exists at the specified position
    if (direction === 'left') {
      if (position === 'all') {
        for (let p = 1; p <= Math.min(span, leftWords.length); p++) {
          const idx = leftWords.length - p;
          if (idx >= 0) {
            const val = getTokenValue(leftWords[idx], calcMode);
            if (val.toLowerCase() === wordLower) return true;
          }
        }
        return false;
      } else {
        const pos = parseInt(position, 10);
        const idx = leftWords.length - pos;
        if (idx >= 0 && idx < leftWords.length) {
          const val = getTokenValue(leftWords[idx], calcMode);
          return val.toLowerCase() === wordLower;
        }
        return false;
      }
    } else {
      if (position === 'all') {
        for (let p = 1; p <= Math.min(span, rightWords.length); p++) {
          const idx = p - 1;
          if (idx < rightWords.length) {
            const val = getTokenValue(rightWords[idx], calcMode);
            if (val.toLowerCase() === wordLower) return true;
          }
        }
        return false;
      } else {
        const pos = parseInt(position, 10);
        const idx = pos - 1;
        if (idx >= 0 && idx < rightWords.length) {
          const val = getTokenValue(rightWords[idx], calcMode);
          return val.toLowerCase() === wordLower;
        }
        return false;
      }
    }
  });

  // Set collocate info for precise purple highlight
  currentCollocateWord = wordLower;
  currentCollocateInfo = { word: wordLower, direction, position, scope, span, calcMode };

  // Set filter input fields for user visibility
  if (direction === 'left') {
    const leftFilter = document.getElementById('kwicLeftFilter');
    const leftMode = document.getElementById('kwicLeftFilterMode');
    const leftPos = document.getElementById('kwicLeftFilterPos');
    
    if (leftFilter) leftFilter.value = word;
    if (leftMode) leftMode.value = isPosMode ? calcMode : (useLemma ? 'exact' : 'exact');
    if (leftPos) leftPos.value = position === 'all' ? 'any' : position;
    
    // Clear right filter
    const rightFilter = document.getElementById('kwicRightFilter');
    const rightPos = document.getElementById('kwicRightFilterPos');
    if (rightFilter) rightFilter.value = '';
    if (rightPos) rightPos.value = 'any';
  } else {
    const rightFilter = document.getElementById('kwicRightFilter');
    const rightMode = document.getElementById('kwicRightFilterMode');
    const rightPos = document.getElementById('kwicRightFilterPos');
    
    if (rightFilter) rightFilter.value = word;
    if (rightMode) rightMode.value = isPosMode ? calcMode : (useLemma ? 'exact' : 'exact');
    if (rightPos) rightPos.value = position === 'all' ? 'any' : position;
    
    // Clear left filter
    const leftFilter = document.getElementById('kwicLeftFilter');
    const leftPos = document.getElementById('kwicLeftFilterPos');
    if (leftFilter) leftFilter.value = '';
    if (leftPos) leftPos.value = 'any';
  }
  
  // Clear node filter
  const nodeFilter = document.getElementById('kwicNodeFilter');
  if (nodeFilter) nodeFilter.value = '';

  // Update KWIC display with filtered results
  lastKwicRows = filtered.slice(0, 300);
  lastKwicSort = { col: 0, dir: 'asc' };

  renderKwicRows();
  
  // Update filter status bar
  updateFilterStatusBar();

  const status = document.getElementById('kwicStatus');
  const scopeLabel = scope === 'target' ? 'Target' : 'Reference';
  const posLabel = position === 'all'
    ? `${direction === 'left' ? 'L' : 'R'}1–${direction === 'left' ? 'L' : 'R'}${span}`
    : `${direction === 'left' ? 'L' : 'R'}${position}`;
  if (status) {
    status.textContent = `KWIC hits: ${allKwicRows.length} → ${scopeLabel} ${posLabel}: ${filtered.length} (showing ${lastKwicRows.length})`;
  }

  // Scroll to KWIC
  const kwicCard = document.getElementById('kwicCard');
  if (kwicCard) {
    kwicCard.scrollIntoView({ behavior: 'smooth', block: 'start' });
  }
}


// Calculate collocate statistic (standard corpus linguistics formulas)
// O = observed frequency (freq of collocate in position)
// N = total node hits
// C = corpus frequency of collocate word
// T = total tokens in corpus
function calcCollocateStat(O, N, C, T, statType) {
  if (O === 0 || T === 0) return 0;
  
  if (statType === 'frequency') {
    return O;
  }
  
  // Expected frequency: E = N * C / T
  const E = (N * C) / T;
  if (E === 0) return 0;
  
  if (statType === 'tscore') {
    // t-score: (O - E) / sqrt(O)
    return (O - E) / Math.sqrt(O);
  } else if (statType === 'zscore') {
    // z-score: (O - E) / sqrt(E)
    return (O - E) / Math.sqrt(E);
  } else if (statType === 'mi') {
    // MI (Mutual Information): log2(O / E) = log2(O * T / (N * C))
    return Math.log2(O / E);
  } else if (statType === 'mi2') {
    // MI² (MI-squared): MI * O - gives more weight to frequent collocates
    const mi = Math.log2(O / E);
    return mi * O;
  } else if (statType === 'mi3') {
    // MI³ (MI-cubed): MI * O² - even more weight to frequent collocates
    const mi = Math.log2(O / E);
    return mi * O * O;
  } else if (statType === 'll') {
    // Log-Likelihood (G²)
    // LL = 2 * (O * ln(O/E) + (N-O) * ln((N-O)/(N-E)))
    if (O >= N) return 0;
    const term1 = O * Math.log(O / E);
    const notO = N - O;
    const notE = N - E;
    const term2 = notE > 0 && notO > 0 ? notO * Math.log(notO / notE) : 0;
    return 2 * (term1 + term2);
  } else if (statType === 'logdice') {
    // LogDice (Sketch Engine default): 14 + log2(2 * O / (N + C))
    // Range roughly 0-14, with 14 being maximum association
    const denom = N + C;
    if (denom === 0) return 0;
    return 14 + Math.log2((2 * O) / denom);
  } else if (statType === 'dice') {
    // Dice coefficient: 2 * O / (N + C)
    // Range 0-1
    const denom = N + C;
    if (denom === 0) return 0;
    return (2 * O) / denom;
  } else if (statType === 'deltap') {
    // Delta P: P(collocate|node) - P(collocate)
    // = O/N - C/T
    // Measures how much more likely the collocate is given the node
    const pCollocateGivenNode = O / N;
    const pCollocate = C / T;
    return pCollocateGivenNode - pCollocate;
  }
  return O;
}

// Format collocate statistic for display
function formatCollocateStat(val, statType) {
  if (statType === 'frequency') {
    return String(Math.round(val));
  } else if (statType === 'mi3') {
    // MI³ can have very large values
    if (Math.abs(val) >= 1000) {
      return val.toExponential(2);
    }
    return val.toFixed(1);
  } else if (statType === 'dice') {
    // Dice is 0-1, show more decimal places
    return val.toFixed(4);
  } else if (statType === 'deltap') {
    // Delta P is typically small
    return val.toFixed(4);
  }
  return val.toFixed(2);
}

// Get label for statistic type
function getStatLabel(statType) {
  const labels = {
    'frequency': 'Freq',
    'tscore': 't-score',
    'zscore': 'z-score',
    'mi': 'MI',
    'mi2': 'MI²',
    'mi3': 'MI³',
    'll': 'LL',
    'logdice': 'LogDice',
    'dice': 'Dice',
    'deltap': 'ΔP'
  };
  return labels[statType] || statType;
}

function exportCollocatesToExcel() {
  if (!collocateData) {
    alert('No collocates to export.');
    return;
  }
  
  const { data, spanL, spanR, statType, totalTargetHits, totalRefHits } = collocateData;
  const statLabel = getStatLabel(statType);
  
  let xml = '<?xml version="1.0" encoding="UTF-8"?>\n';
  xml += '<?mso-application progid="Excel.Sheet"?>\n';
  xml += '<Workbook xmlns="urn:schemas-microsoft-com:office:spreadsheet"\n';
  xml += '  xmlns:ss="urn:schemas-microsoft-com:office:spreadsheet">\n';
  
  // Export each of the 4 tables
  const tables = [
    { name: 'Target Left', side: 'target', direction: 'left', span: spanL },
    { name: 'Target Right', side: 'target', direction: 'right', span: spanR },
    { name: 'Reference Left', side: 'reference', direction: 'left', span: spanL },
    { name: 'Reference Right', side: 'reference', direction: 'right', span: spanR }
  ];
  
  for (const table of tables) {
    const totalHits = table.side === 'target' ? totalTargetHits : totalRefHits;
    xml += `<Worksheet ss:Name="${table.name}">\n<Table>\n`;
    
    // Headers: Word, #, Freq, Score, then each position
    const headers = ['Word', '#', 'Freq', statLabel];
    if (table.direction === 'left') {
      for (let p = 1; p <= table.span; p++) headers.push(`L-${p}`);
    } else {
      for (let p = 1; p <= table.span; p++) headers.push(`R${p}`);
    }
    
    xml += '<Row>';
    headers.forEach(h => {
      xml += '<Cell><Data ss:Type="String">' + escapeHtml(h) + '</Data></Cell>';
    });
    xml += '</Row>\n';
    
    // Data
    const posData = data[table.side][table.direction];
    const allFreqs = {};
    for (let p = 1; p <= table.span; p++) {
      for (const [word, count] of Object.entries(posData[p])) {
        allFreqs[word] = (allFreqs[word] || 0) + count;
      }
    }
    
    const totalTokens = Object.values(allFreqs).reduce((a, b) => a + b, 0);
    
    const wordList = Object.entries(allFreqs)
      .filter(([w, f]) => f > 0)
      .map(([word, freq]) => ({
        word,
        freq,
        stat: calcCollocateStat(freq, totalTokens, totalHits, statType)
      }))
      .sort((a, b) => b.stat - a.stat);
    
    for (let i = 0; i < wordList.length; i++) {
      const w = wordList[i];
      const rowVals = [w.word, String(i + 1), String(w.freq), formatCollocateStat(w.stat, statType)];
      
      if (table.direction === 'left') {
        for (let p = 1; p <= table.span; p++) {
          rowVals.push(String(posData[p][w.word] || 0));
        }
      } else {
        for (let p = 1; p <= table.span; p++) {
          rowVals.push(String(posData[p][w.word] || 0));
        }
      }
      
      xml += '<Row>';
      rowVals.forEach(v => {
        const safe = (v || '').replace(/&/g,'&amp;').replace(/</g,'&lt;');
        xml += '<Cell><Data ss:Type="String">' + safe + '</Data></Cell>';
      });
      xml += '</Row>\n';
    }
    
    xml += '</Table>\n</Worksheet>\n';
  }
  
  xml += '</Workbook>';
  
  const blob = new Blob([xml], { type: 'application/vnd.ms-excel;charset=utf-8' });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = 'collocates.xls';
  document.body.appendChild(a);
  a.click();
  document.body.removeChild(a);
  URL.revokeObjectURL(url);
}

// ===== Event Handlers =====
async function handleAnalyzeClick() {
  const status = document.getElementById('statusMessage');
  const keyStatus = document.getElementById('keyStatus');
  keyStatus.textContent = '';

  const dataTypeRadios = document.querySelectorAll('input[name="dataType"]');
  let selectedType = null;
  dataTypeRadios.forEach(r => { if (r.checked) selectedType = r.value; });

  // CSVモードの場合
  if (selectedType === 'csv') {
    const csvInput = document.getElementById('csvInput');
    if (!csvInput || !csvInput.files || csvInput.files.length === 0) {
      status.textContent = 'Please select CSV file(s) (or ZIP containing CSV).';
      return;
    }
    
    const csvFiles = Array.from(csvInput.files);
    status.textContent = `Loading ${csvFiles.length} CSV file(s)...`;
    updateCsvProgress(0, 'Starting...');
    
    try {
      const csvOptions = {
        useSearchToken: document.getElementById('csvUseSearchToken')?.checked !== false,
        preserveSentence: document.getElementById('csvPreserveSentence')?.checked !== false,
        respectSentenceBoundary: document.getElementById('respectSentenceBoundary')?.checked !== false
      };
      
      // 複数ファイルを順番に処理してマージ
      let mergedCorpus = null;
      
      for (let fileIdx = 0; fileIdx < csvFiles.length; fileIdx++) {
        const csvFile = csvFiles[fileIdx];
        const fileProgress = Math.round((fileIdx / csvFiles.length) * 100);
        updateCsvProgress(fileProgress, `Processing file ${fileIdx + 1}/${csvFiles.length}: ${csvFile.name}`);
        
        let csvText;
        
        // ZIPかCSVかを判定
        if (csvFile.name.toLowerCase().endsWith('.zip')) {
          const extracted = await extractCSVFromZip(csvFile);
          csvText = extracted.content;
        } else {
          csvText = await readFileAsText(csvFile);
        }
        
        const partialCorpus = await parseCorpusFromCSV(csvText, csvOptions);
        
        if (!partialCorpus || Object.keys(partialCorpus.files).length === 0) {
          console.warn(`No valid data in ${csvFile.name}, skipping.`);
          continue;
        }
        
        // マージ
        if (!mergedCorpus) {
          mergedCorpus = partialCorpus;
        } else {
          // ファイルIDを調整してマージ
          const existingMaxId = Math.max(...Object.keys(mergedCorpus.files).map(Number));
          let newId = existingMaxId + 1;
          
          for (const [oldId, fileData] of Object.entries(partialCorpus.files)) {
            const newFileId = String(newId++);
            fileData.id = newFileId;
            mergedCorpus.files[newFileId] = fileData;
            
            // フォルダにも追加
            const folder = fileData.folder;
            if (!mergedCorpus.folders[folder]) {
              mergedCorpus.folders[folder] = [];
            }
            mergedCorpus.folders[folder].push(newFileId);
          }
        }
      }
      
      corpus = mergedCorpus;
      
      if (!corpus || Object.keys(corpus.files).length === 0) {
        status.textContent = 'No valid data found in CSV file(s).';
        hideCsvProgress();
        renderSummary();
        return;
      }
      
      updateCsvProgress(100, 'Complete!');
      const totalTokens = Object.values(corpus.files).reduce((sum, f) => sum + f.tokens.length, 0);
      status.textContent = `CSV corpus loaded: ${Object.keys(corpus.files).length} file(s), ${totalTokens.toLocaleString()} tokens from ${csvFiles.length} CSV file(s).`;
      
      // CSV固有メタデータを表示
      if (corpus.csvMetadata) {
        const meta = corpus.csvMetadata;
        let features = [];
        if (meta.hasLemma) features.push('lemma');
        if (meta.hasPos) features.push('POS');
        if (meta.hasDep) features.push('dependency');
        if (meta.hasChunk) features.push('chunk');
        if (meta.hasTags) features.push('Biber tags');
        if (features.length > 0) {
          status.textContent += ` Features: ${features.join(', ')}.`;
        }
      }
      
      setTimeout(hideCsvProgress, 500);
      
      // Initialize 11) Dependency Grammar UI
      setTimeout(() => { try { initDepGrammarUI(); } catch(e) {} }, 100);
      
      // Initialize 12) Constituent UI
      setTimeout(() => { try { initConstituentUI(); } catch(e) {} }, 150);
      
    } catch (err) {
      console.error('CSV loading error:', err);
      status.textContent = `Error loading CSV: ${err.message}`;
      hideCsvProgress();
      return;
    }
    
  } else {
    // 従来のテキストファイル処理
    const folderInput = document.getElementById('folderInput');
    const fileInput = document.getElementById('fileInput');

    const files = [];
    for (const f of folderInput.files) files.push(f);
    for (const f of fileInput.files) files.push(f);

    const visibleFiles = files.filter(f => !isHiddenFile(f));
    const selectedInfo = document.getElementById('selectedFilesInfo');
    selectedInfo.textContent = `Selected: ${files.length} file(s), using ${visibleFiles.length} (hidden excluded).`;

    if (visibleFiles.length === 0) {
      status.textContent = 'No files found. Please select a Folder or Files.';
      corpus = null;
      renderSummary();
      document.getElementById('keyTableBody').innerHTML =
        '<tr><td colspan="13" class="text-xs">No keyness results.</td></tr>';
      document.getElementById('kwicTableBody').innerHTML =
        '<tr><td colspan="6" class="text-xs">No KWIC.</td></tr>';
      document.getElementById('kwicStatus').textContent = '';
      document.getElementById('originalText').textContent = 'No text selected.';
      return;
    }

    status.textContent = 'Reading files...';
    const fileContents = [];
    try {
      for (const f of visibleFiles) {
        const text = await readFileAsText(f);
        fileContents.push({ file: f, text });
      }
    } catch (err) {
      console.error(err);
      status.textContent = 'Error occurred while reading files.';
      return;
    }

    let mode = 'plain';
    if (selectedType === 'tagged') {
      mode = 'tagged';
    } else if (selectedType === 'plain') {
      mode = 'plain';
    } else if (selectedType === 'auto') {
      let firstText = '';
      for (const fc of fileContents) {
        if (fc.text && fc.text.trim()) {
          firstText = fc.text;
          break;
        }
      }
      mode = detectModeFromText(firstText || '');
      status.textContent = `Auto-detect result: Parsing as ${mode.toUpperCase()} mode.`;
    }

    const tokenizeOptions = {
      includeHyphen: document.getElementById('includeHyphen').checked,
      includeAposS: document.getElementById('includeAposS').checked,
      mergeShortLines: document.getElementById('mergeShortLines').checked
    };

    status.textContent += ' Parsing corpus...';
    corpus = parseCorpus(mode, fileContents, tokenizeOptions);
    if (!corpus || Object.keys(corpus.files).length === 0) {
      status.textContent = 'No valid text found.';
      renderSummary();
      return;
    }
    status.textContent = `Corpus loaded: ${Object.keys(corpus.files).length} file(s).`;
  }

  
  // Sync feature type between 7) High-Frequency and 8) Keyness (and KWIC)
  const keyFeatureTypeSel = document.getElementById('featureTypeSelect');
  const hfFeatureTypeSel = document.getElementById('hfFeatureTypeSelect');
  const kwicFeatureTypeSel = document.getElementById('kwicFeatureTypeSelect');

  if (keyFeatureTypeSel && hfFeatureTypeSel) {
    keyFeatureTypeSel.addEventListener('change', () => {
      if (hfFeatureTypeSel.value !== keyFeatureTypeSel.value) {
        hfFeatureTypeSel.value = keyFeatureTypeSel.value;
      }
      if (kwicFeatureTypeSel && kwicFeatureTypeSel.value !== keyFeatureTypeSel.value) {
        kwicFeatureTypeSel.value = keyFeatureTypeSel.value;
      }
    });
    hfFeatureTypeSel.addEventListener('change', () => {
      if (keyFeatureTypeSel.value !== hfFeatureTypeSel.value) {
        keyFeatureTypeSel.value = hfFeatureTypeSel.value;
      }
      if (kwicFeatureTypeSel && kwicFeatureTypeSel.value !== hfFeatureTypeSel.value) {
        kwicFeatureTypeSel.value = hfFeatureTypeSel.value;
      }
    });
  }

refreshFeatureTypeOptions();
  refreshKwicFeatureTypeOptions();
  refreshHfFeatureTypeOptions();
  refreshFreqTableFeatureTypeOptions();
  updateKwicViewOptions();
  updateOriginalViewOptions();
  updateTopicPosFilter();
  updateCollocatePosOptions();
  populateKwicFolderCheckboxes(); // Populate folder checkboxes for KWIC Specific folder scope
  renderSummary();

  document.getElementById('keyTableBody').innerHTML =
    '<tr><td colspan="13" class="text-xs">No keyness results.</td></tr>';
  document.getElementById('kwicTableBody').innerHTML =
    '<tr><td colspan="6" class="text-xs">No KWIC.</td></tr>';
  document.getElementById('kwicStatus').textContent = '';
  document.getElementById('originalText').textContent = 'No text selected.';
  currentKwicFeature = null;
  currentKwicFeatureType = null;
  allKeynessRows = [];
  lastKeynessRows = [];
  allKwicRows = [];
  lastKwicRows = [];
  clearFrequencyTable();
}

function updateSelectedFilesInfo() {
  const folderInput = document.getElementById('folderInput');
  const fileInput = document.getElementById('fileInput');
  const files = [];
  for (const f of folderInput.files) files.push(f);
  for (const f of fileInput.files) files.push(f);
  const visibleFiles = files.filter(f => !isHiddenFile(f));
  const selectedInfo = document.getElementById('selectedFilesInfo');
  selectedInfo.textContent = `Selected: ${files.length} file(s), using ${visibleFiles.length} (hidden excluded).`;
}

// ===== Concordance Plot =====
let plotData = [];


function computePlot() {
  const status = document.getElementById('plotStatus');
  const container = document.getElementById('plotContainer');
  status.textContent = '';
  plotData = [];

  if (!corpus || Object.keys(corpus.files).length === 0) {
    status.textContent = 'Please load a corpus first.';
    container.innerHTML = '<div class="text-xs text-gray-500">No plot yet.</div>';
    return;
  }

  const feature = document.getElementById('plotFeatureInput').value.trim();
  if (!feature) {
    status.textContent = 'Please enter a Selected feature.';
    container.innerHTML = '<div class="text-xs text-gray-500">No plot yet.</div>';
    return;
  }

  const featureType = document.getElementById('plotFeatureTypeSelect')?.value || 'word';
  let searchMode = document.getElementById('plotSearchMode').value;
  const caseInsensitive = document.getElementById('plotCaseInsensitive')?.checked ?? true;
  const groupBy = document.getElementById('plotGroupBy').value;

  // Align search mode with feature type to avoid overlapping settings
  if (featureType === 'regex') {
    searchMode = 'regex';
  }
  // Auto-detect wildcard patterns if feature contains * or ? (except for p-frame which uses * differently)
  if (searchMode === 'exact' && !featureType.startsWith('pframe') && (feature.includes('*') || feature.includes('?'))) {
    searchMode = 'wildcard';
  }

  let scope = 'target';
  const scopeEl = document.querySelector('input[name="plotScope"]:checked');
  if (scopeEl) scope = scopeEl.value;

  status.textContent = 'Computing plot...';

  // Flags for feature types
  const isNgram = featureType.startsWith('ngram');
  const isPframe = featureType.startsWith('pframe');
  const isPosSingle = (featureType === 'pos_simple' || featureType === 'pos_detailed');
  const isPosGram = (featureType === 'posgram_simple' || featureType === 'posgram_detailed');
  
  // Check if feature contains space (multi-word pattern) for word/word_lemma types
  const isMultiWordPattern = (featureType === 'word' || featureType === 'word_lemma') && feature.includes(' ');
  const isMultiWord = isNgram || isPframe || isMultiWordPattern;

  const featureTokens = isMultiWord ? feature.split(' ').filter(t => t.length > 0) : null;
  const n = featureTokens ? featureTokens.length : 1;

  // Matcher for lexical (word / lemma / wildcard / regex) features
  let matcher = null;
  try {
    matcher = buildMatcherCreator(feature, searchMode, caseInsensitive);
  } catch (e) {
    console.error(e);
    status.textContent = 'Invalid pattern for plot.';
    container.innerHTML = '<div class="text-xs text-gray-500">Invalid pattern.</div>';
    return;
  }

  const files = Object.values(corpus.files);
  const results = [];

  for (const file of files) {
    const inT = targetFolders.has(file.folder);
    const inR = referenceFolders.has(file.folder);

    let useFile = false;
    if (scope === 'target') useFile = inT;
    else if (scope === 'reference') useFile = inR;
    else useFile = inT || inR;
    if (!useFile) continue;

    const contentTokens = file.tokens.filter(t => !isPunctuationOrSpaceToken(t));
    const totalTokens = contentTokens.length;
    if (totalTokens === 0) continue;

    const positions = [];

    if (isMultiWord) {
      // n-gram / p-frame (word / lemma) matching
      const tokenMatchers = buildMultiWordMatcher(featureTokens, searchMode, caseInsensitive);

      for (const sent of file.sentences) {
        const subSentences = getSentenceSegments(file.tokens, sent.tokenStart, sent.tokenEnd);

        for (const subSent of subSentences) {
          const words = [];
          const indices = [];
          for (let i = 0; i < subSent.tokens.length; i++) {
            const tok = subSent.tokens[i];
            const w = featureType.includes('lemma') ? tok.lemma : tok.word;
            if (w) {
              words.push(w);
              indices.push(subSent.indices[i]);
            }
          }

          if (words.length < n) continue;

          for (let i = 0; i <= words.length - n; i++) {
            let matches = true;
            for (let j = 0; j < n; j++) {
              const tm = tokenMatchers[j];
              if (tm.type === 'any') continue;
              if (!tm.match(words[i + j])) {
                matches = false;
                break;
              }
            }
            if (matches) {
              const tokIdx = indices[i];
              const relPos = tokIdx / file.tokens.length;
              positions.push(relPos);
            }
          }
        }
      }
    } else if (isPosSingle) {
      // Single POS tag (simple / detailed)
      const field = featureType === 'pos_simple' ? 'poss' : 'posd';
      let tokenIdx = 0;
      for (const tok of contentTokens) {
        const tag = tok[field] || '';
        if (tag && tag === feature) {
          positions.push(tokenIdx / totalTokens);
        }
        tokenIdx++;
      }
    } else if (isPosGram) {
      // POS-gram (simple / detailed): pattern like "NN+IN+DT"
      // Respect sentence boundaries
      const field = featureType === 'posgram_simple' ? 'poss' : 'posd';
      const gramTokens = feature.split('+').map(s => s.trim()).filter(s => s.length > 0);
      const gramLen = gramTokens.length;
      
      if (gramLen > 0) {
        for (const sent of file.sentences) {
          const subSentences = getSentenceSegments(file.tokens, sent.tokenStart, sent.tokenEnd);
          
          for (const subSent of subSentences) {
            const tags = [];
            const indices = [];
            for (let i = 0; i < subSent.tokens.length; i++) {
              const tok = subSent.tokens[i];
              const tag = tok[field] || '';
              if (tag) {
                tags.push(tag);
                indices.push(subSent.indices[i]);
              }
            }
            
            if (tags.length < gramLen) continue;
            
            for (let i = 0; i <= tags.length - gramLen; i++) {
              let ok = true;
              for (let j = 0; j < gramLen; j++) {
                if (tags[i + j] !== gramTokens[j]) {
                  ok = false;
                  break;
                }
              }
              if (ok) {
                const tokIdx = indices[i];
                const relPos = tokIdx / file.tokens.length;
                positions.push(relPos);
              }
            }
          }
        }
      }
    } else if (featureType === 'biber_tag') {
      // Single Biber tag: match tokens with the specified tag(s)
      // Support multiple tags with | (OR logic): "PASS|NOMZ"
      const searchTags = feature.split('|').map(t => t.trim().toUpperCase()).filter(t => t.length > 0);
      if (searchTags.length > 0) {
        let tokenIdx = 0;
        for (const tok of contentTokens) {
          if (tok.biberTags && tok.biberTags.length > 0) {
            if (searchTags.some(tag => tok.biberTags.includes(tag))) {
              positions.push(tokenIdx / totalTokens);
            }
          }
          tokenIdx++;
        }
      }
    } else {
      // Single word / lemma / wildcard / regex
      let tokenIdx = 0;
      const useLemma = featureType.includes('lemma');
      for (const tok of contentTokens) {
        const word = useLemma ? (tok.lemma || '') : (tok.word || '');
        if (!word) {
          tokenIdx++;
          continue;
        }
        if (matcher(word)) {
          positions.push(tokenIdx / totalTokens);
        }
        tokenIdx++;
      }
    }

    results.push({
      name: file.name,
      folder: file.folder,
      positions,
      hits: positions.length,
      totalTokens,
      side: inT ? 'T' : 'R'
    });
  }

  if (results.length === 0) {
    status.textContent = 'No files match the scope.';
    container.innerHTML = '<div class="text-xs text-gray-500">No matching files.</div>';
    return;
  }

  // Sort by hits descending, then by name
  results.sort((a, b) => b.hits - a.hits || a.name.localeCompare(b.name));

  plotData = results;

  renderPlot(groupBy);

  const totalHits = results.reduce((sum, r) => sum + r.hits, 0);
  status.textContent = `Found ${totalHits} hits across ${results.length} files.`;
}



function renderPlot(groupBy) {
  const container = document.getElementById('plotContainer');

  if (plotData.length === 0) {
    container.innerHTML = '<div class="text-xs text-gray-500">No plot data.</div>';
    return;
  }

  // Check both simple and advanced hideZero checkboxes
  const hideZeroSimple = document.getElementById('plotHideZeroGroups')?.checked ?? false;
  const hideZeroAdv = document.getElementById('plotHideZeroGroupsAdv')?.checked ?? false;
  const hideZero = hideZeroSimple || hideZeroAdv;
  let html = '';

  if (groupBy === 'folder') {
    const folderGroups = {};
    for (const item of plotData) {
      if (!folderGroups[item.folder]) {
        folderGroups[item.folder] = { items: [], totalHits: 0, totalTokens: 0 };
      }
      folderGroups[item.folder].items.push(item);
      folderGroups[item.folder].totalHits += item.hits;
      folderGroups[item.folder].totalTokens += item.totalTokens;
    }

    const sortedFolders = Object.entries(folderGroups).sort((a, b) => {
      const [nameA, dataA] = a;
      const [nameB, dataB] = b;
      return dataB.totalHits - dataA.totalHits || nameA.localeCompare(nameB);
    });

    for (const [folder, data] of sortedFolders) {
      if (hideZero && data.totalHits === 0) continue;
      const combinedPositions = [];
      let cumTokens = 0;
      for (const item of data.items) {
        for (const pos of item.positions) {
          combinedPositions.push((cumTokens + pos * item.totalTokens) / data.totalTokens);
        }
        cumTokens += item.totalTokens;
      }

      html += renderPlotRow(folder, combinedPositions, data.totalHits, data.items.length, folder);
    }
  } else {
    // File level
    for (const item of plotData) {
      if (hideZero && item.hits === 0) continue;
      html += renderPlotRow(item.name, item.positions, item.hits, null, item.folder);
    }
  }

  if (!html) {
    container.innerHTML = '<div class="text-xs text-gray-500">No matching files.</div>';
    return;
  }

  container.innerHTML = html;

  // Add click handlers to jump to KWIC
  container.querySelectorAll('.plot-row').forEach(row => {
    row.addEventListener('click', () => {
      // Clear previous filters
      clearKwicFilters();
      
      const fileName = row.dataset.file;
      const folderName = row.dataset.folder;

      const feature = document.getElementById('plotFeatureInput').value.trim();
      const featureType = document.getElementById('plotFeatureTypeSelect')?.value || 'word';
      let searchMode = document.getElementById('plotSearchMode').value;

      // Keep search behaviour consistent with feature type
      if (featureType === 'regex') {
        searchMode = 'regex';
      }

      // Determine scope from 5b plot (Target / Reference / Both)
      const plotScopeEl = document.querySelector('input[name="plotScope"]:checked');
      const scope = plotScopeEl ? plotScopeEl.value : 'target';

      // Apply file / folder filter depending on groupBy setting
      const groupBySelect = document.getElementById('plotGroupBy');
      const groupBy = groupBySelect ? groupBySelect.value : 'file';

      if (groupBy === 'folder') {
        currentKwicFolderFilter = folderName || null;
        currentKwicFileFilter = null;
      } else {
        currentKwicFileFilter = fileName || null;
        currentKwicFolderFilter = null;
      }

      // Sync KWIC scope radio button to the selected plot scope
      const kwicScopeInput = document.querySelector(`input[name="kwicScope"][value="${scope}"]`);
      if (kwicScopeInput) {
        kwicScopeInput.checked = true;
      }

      // Set to all sections using helper (respecting scope)
      const kwicType = setFeatureToAllSections(feature, featureType, scope);

      // Also set search mode in KWIC
      const kwicSearchMode = document.getElementById('kwicSearchMode');
      if (kwicSearchMode) kwicSearchMode.value = searchMode;

      currentKwicFeature = feature;
      currentKwicFeatureType = kwicType;
      computeKwic();

      document.getElementById('kwicCard')?.scrollIntoView({ behavior: 'smooth' });
    });
  });
}


function renderPlotRow(label, positions, hits, fileCount, folderName) {
  const barWidth = 600;
  const barHeight = 16;
  
  // Create SVG bar
  let lines = '';
  for (const pos of positions) {
    const x = Math.round(pos * barWidth);
    lines += `<line x1="${x}" y1="0" x2="${x}" y2="${barHeight}" stroke="#2563eb" stroke-width="1.5"/>`;
  }
  
  const labelText = fileCount !== null ? `${label} (${fileCount} files)` : label;
  const hitText = `${hits} hit${hits !== 1 ? 's' : ''}`;
  
  return `
    <div class="plot-row" style="display:flex; align-items:center; margin-bottom:4px; cursor:pointer; padding:2px 4px; border-radius:4px;" 
         data-file="${escapeHtml(label)}" data-folder="${escapeHtml(folderName)}"
         onmouseover="this.style.background='#f0f0f0'" onmouseout="this.style.background='transparent'">
      <div style="width:200px; font-size:11px; overflow:hidden; text-overflow:ellipsis; white-space:nowrap; margin-right:8px;" title="${escapeHtml(labelText)}">
        ${escapeHtml(labelText)}
      </div>
      <svg width="${barWidth}" height="${barHeight}" style="background:#f3f4f6; border:1px solid #e5e7eb; border-radius:2px;">
        ${lines}
      </svg>
      <div style="width:60px; font-size:10px; margin-left:8px; color:#666;">
        ${hitText}
      </div>
    </div>
  `;
}

function clearPlot() {
  plotData = [];
  document.getElementById('plotContainer').innerHTML = '<div class="text-xs text-gray-500">No plot yet.</div>';
  document.getElementById('plotStatus').textContent = '';
}

// Download plot as JPEG
function downloadPlotAsJpeg() {
  const container = document.getElementById('plotContainer');
  if (!container || plotData.length === 0) {
    alert('No plot to download.');
    return;
  }
  
  // Create a canvas to draw the plot
  const rows = container.querySelectorAll('.plot-row');
  if (rows.length === 0) return;
  
  const rowHeight = 24;
  const labelWidth = 220;
  const barWidth = 600;
  const hitWidth = 80;
  const padding = 20;
  const totalWidth = labelWidth + barWidth + hitWidth + padding * 2;
  const totalHeight = rows.length * rowHeight + padding * 2 + 30; // +30 for title
  
  const canvas = document.createElement('canvas');
  canvas.width = totalWidth;
  canvas.height = totalHeight;
  const ctx = canvas.getContext('2d');
  
  // White background
  ctx.fillStyle = '#ffffff';
  ctx.fillRect(0, 0, totalWidth, totalHeight);
  
  // Title
  const feature = document.getElementById('plotFeatureInput')?.value || '';
  ctx.fillStyle = '#333333';
  ctx.font = 'bold 14px Arial';
  ctx.fillText(`Concordance Plot: "${feature}"`, padding, padding + 12);
  
  // Draw rows
  ctx.font = '11px Arial';
  let y = padding + 35;
  
  rows.forEach(row => {
    const label = row.querySelector('div:first-child')?.textContent || '';
    const hitText = row.querySelector('div:last-child')?.textContent || '';
    const svg = row.querySelector('svg');
    
    // Label
    ctx.fillStyle = '#333333';
    ctx.fillText(label.substring(0, 30), padding, y + 12);
    
    // Bar background
    ctx.fillStyle = '#f3f4f6';
    ctx.fillRect(padding + labelWidth, y, barWidth, 16);
    ctx.strokeStyle = '#e5e7eb';
    ctx.strokeRect(padding + labelWidth, y, barWidth, 16);
    
    // Hit lines
    if (svg) {
      const lines = svg.querySelectorAll('line');
      ctx.strokeStyle = '#2563eb';
      ctx.lineWidth = 1.5;
      lines.forEach(line => {
        const x = parseInt(line.getAttribute('x1'), 10);
        ctx.beginPath();
        ctx.moveTo(padding + labelWidth + x, y);
        ctx.lineTo(padding + labelWidth + x, y + 16);
        ctx.stroke();
      });
    }
    
    // Hit count
    ctx.fillStyle = '#666666';
    ctx.font = '10px Arial';
    ctx.fillText(hitText, padding + labelWidth + barWidth + 10, y + 12);
    ctx.font = '11px Arial';
    
    y += rowHeight;
  });
  
  // Convert to JPEG and download
  canvas.toBlob(blob => {
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = `concordance_plot_${feature.replace(/[^a-zA-Z0-9]/g, '_')}.jpg`;
    a.click();
    URL.revokeObjectURL(url);
  }, 'image/jpeg', 0.95);
}

// Sync plot feature input to other sections
function syncPlotFeatureToOthers() {
  const plotFeature = document.getElementById('plotFeatureInput')?.value || '';
  const plotType = document.getElementById('plotFeatureTypeSelect')?.value || 'word';
  
  // Sync to KWIC
  const kwicInput = document.getElementById('kwicFeatureInput');
  const kwicType = document.getElementById('kwicFeatureTypeSelect');
  if (kwicInput) kwicInput.value = plotFeature;
  if (kwicType) kwicType.value = plotType;
  
  // Sync to Collocate
  const collocateInput = document.getElementById('collocateNodeInput');
  const collocateType = document.getElementById('collocateFeatureTypeSelect');
  if (collocateInput) collocateInput.value = plotFeature;
  if (collocateType) collocateType.value = plotType;
}

// Sync feature input from other sections to Plot
function syncFeatureToPlot(feature, featureType) {
  const plotInput = document.getElementById('plotFeatureInput');
  const plotType = document.getElementById('plotFeatureTypeSelect');
  if (plotInput) plotInput.value = feature;
  if (plotType && featureType) plotType.value = featureType;
}

// ===== Frequency Table Functions =====
let freqTableData = null;
let freqTableGroups = [];
let freqTableFeatures = [];
let freqTableDeletedRows = new Set(); // Deleted row indices
let freqTableDeletedCols = new Set(); // Deleted column indices (feature indices)
let freqTableFilteredFeatures = null; // Filtered feature indices (null = show all)

function refreshFreqTableFeatureTypeOptions() {
  const sel = document.getElementById('freqTableFeatureType');
  if (!sel) return;
  if (!corpus || corpus.mode === 'plain') {
    sel.innerHTML = `
      <option value="word">Word (surface)</option>
      <option value="ngram_word">n-gram (word)</option>
      <option value="pframe_word">p-frame (word)</option>
      <option value="cluster_word">Cluster (word)</option>
    `;
  } else {
    // Tagged mode or CSV mode
    const hasBiberTags = corpus.mode === 'csv' && corpus.csvMetadata && corpus.csvMetadata.hasTags;
    const biberOptions = hasBiberTags ? `
      <optgroup label="Biber Tags">
        <option value="biber_tag">Biber tag</option>
        
      </optgroup>
    ` : '';
    
    const depOptions = hasBiberTags ? `
      <optgroup label="Dependency Grammar">
        <option value="dep">DEP (deprel tag frequency)</option>
        
        
        
        
      </optgroup>
    ` : '';
    
    sel.innerHTML = `
      <option value="word">Word (surface)</option>
      <option value="word_lemma">Word (lemma)</option>
      <option value="ngram_word">n-gram (word)</option>
      <option value="ngram_lemma">n-gram (lemma)</option>
      <option value="pframe_word">p-frame (word)</option>
      <option value="pframe_lemma">p-frame (lemma)</option>
      <option value="cluster_word">Cluster (word)</option>
      <option value="cluster_lemma">Cluster (lemma)</option>
      <option value="pos_simple">POS (simple)</option>
      <option value="posgram_simple">POS-gram (simple)</option>
      <option value="pos_detailed">POS (detailed)</option>
      <option value="posgram_detailed">POS-gram (detailed)</option>
      <optgroup label="Word + POS">
        <option value="wordpos_surface_simple">Word(surface)_POS(simple)</option>
        <option value="wordpos_lemma_simple">Word(lemma)_POS(simple)</option>
        <option value="wordpos_surface_detailed">Word(surface)_POS(detailed)</option>
        <option value="wordpos_lemma_detailed">Word(lemma)_POS(detailed)</option>
      </optgroup>
      <optgroup label="n-gram Word + POS">
        <option value="ngrampos_surface_simple">n-gram(surface)_POS(simple)</option>
        <option value="ngrampos_lemma_simple">n-gram(lemma)_POS(simple)</option>
        <option value="ngrampos_surface_detailed">n-gram(surface)_POS(detailed)</option>
        <option value="ngrampos_lemma_detailed">n-gram(lemma)_POS(detailed)</option>
      </optgroup>
      ${biberOptions}
      ${depOptions}
    `;
  }
  updateFreqTableClusterUI();
}

function updateFreqTableClusterUI() {
  const featureType = document.getElementById('freqTableFeatureType')?.value || 'word';
  const clusterUI = document.getElementById('freqTableClusterUI');
  if (clusterUI) {
    clusterUI.style.display = featureType.startsWith('cluster') ? 'flex' : 'none';
  }
}

function computeFrequencyTable() {
  const status = document.getElementById('freqTableStatus');
  const body = document.getElementById('freqTableBody');
  const head = document.getElementById('freqTableHead');
  status.textContent = '';

  if (!corpus || Object.keys(corpus.files).length === 0) {
    status.textContent = 'Please load a corpus first.';
    body.innerHTML = '<tr><td colspan="2" class="text-xs">No frequency table.</td></tr>';
    return;
  }

  if (targetFolders.size === 0 && referenceFolders.size === 0) {
    status.textContent = 'Please select Target or Reference.';
    body.innerHTML = '<tr><td colspan="2" class="text-xs">No frequency table.</td></tr>';
    return;
  }

  const featureType = document.getElementById('freqTableFeatureType')?.value || 'word';
  
  // DEP feature type - compute DEP frequency
  if (featureType === 'dep') {
    if (!depHasDependencyData) {
      status.textContent = 'DEP features require CSV mode with dependency data (head, deprel columns).';
      return;
    }
    computeFrequencyTableDep();
    return;
  }
  
  const n = parseInt(document.getElementById('freqTableN')?.value, 10) || 4;
  const minFreq = parseInt(document.getElementById('freqTableMinFreq')?.value, 10) || 2;
  const numColumns = parseInt(document.getElementById('freqTableColumns')?.value, 10) || 15;
  const caseInsensitive = document.getElementById('freqTableCaseInsensitive')?.checked ?? true;
  const groupBy = document.getElementById('freqTableGroupBy')?.value || 'corpus';
  const valueType = document.getElementById('freqTableValueType')?.value || 'raw';
  
  // Validate POS-based feature types require tagged corpus
  if ((featureType.startsWith('pos') || featureType.startsWith('posgram') || featureType.startsWith('wordpos') || featureType.startsWith('ngrampos')) && corpus.mode !== 'tagged' && corpus.mode !== 'csv') {
    status.textContent = 'POS-based features are only available in Tagged mode.';
    body.innerHTML = '<tr><td colspan="2" class="text-xs">No frequency table.</td></tr>';
    return;
  }
  
  // Validate n >= 2 for n-gram based features
  if ((featureType.startsWith('ngram') || featureType.startsWith('pframe') || featureType.startsWith('posgram') || featureType.startsWith('cluster') || featureType.startsWith('ngrampos')) && n < 2) {
    status.textContent = 'For n-gram / p-frame / POS-gram / cluster / n-gram+POS, please set n to 2 or higher.';
    body.innerHTML = '<tr><td colspan="2" class="text-xs">No frequency table.</td></tr>';
    return;
  }
  
  // Get scope
  const scopeEl = document.querySelector('input[name="freqTableScope"]:checked');
  const scope = scopeEl ? scopeEl.value : 'target';

  // Cluster-specific options
  const clusterWord = document.getElementById('freqTableClusterWord')?.value?.trim() || '';
  const clusterPosition = document.getElementById('freqTableClusterPosition')?.value || 'both';
  const isCluster = featureType.startsWith('cluster');

  // Normalization options
  const normBase = parseInt(document.getElementById('freqTableNormBase')?.value, 10) || 10000;
  
  // TF-IDF options
  const tfType = document.getElementById('freqTableTfType')?.value || 'norm';
  const tfNormBase = parseInt(document.getElementById('freqTableTfNormBase')?.value, 10) || 10000;
  const idfPlusOne = document.getElementById('freqTableIdfPlusOne')?.checked ?? false;

  status.textContent = 'Computing frequency table...';

  // Determine field based on feature type
  let field = 'word';
  if (featureType.includes('lemma')) {
    field = 'lemma';
  } else if (featureType === 'pos_simple' || featureType === 'posgram_simple') {
    field = 'poss';
  } else if (featureType === 'pos_detailed' || featureType === 'posgram_detailed') {
    field = 'posd';
  }

  // Count features by group
  // groupData[groupName] = { counts: { feature: freq }, totalTokens: N }
  const groupData = {};
  const globalCounts = {};  // Global counts for all features
  const featureDocFreq = {}; // For IDF: how many groups contain this feature
  
  // For Document Frequency (DF) - track per-file occurrences
  const groupFileDf = {};     // groupFileDf[groupName][feature] = number of files in group with this feature
  const globalFileDf = {};    // globalFileDf[feature] = total files with this feature
  const groupFileCount = {};  // groupFileCount[groupName] = total files in group
  
  const files = Object.values(corpus.files);
  
  for (const file of files) {
    const inT = targetFolders.has(file.folder);
    const inR = referenceFolders.has(file.folder);
    
    // Determine if file should be included based on scope
    // Files in both Target and Reference are included in both scopes
    let useFile = false;
    if (scope === 'all') {
      useFile = true;
    } else if (scope === 'target') {
      useFile = inT;
    } else if (scope === 'reference') {
      useFile = inR;
    } else {
      useFile = inT || inR;
    }
    if (!useFile) continue;
    
    const groupName = groupBy === 'file' ? file.name : file.folder;
    
    if (!groupData[groupName]) {
      groupData[groupName] = { counts: {}, totalTokens: 0, inTarget: false, inReference: false };
      groupFileDf[groupName] = {};
      groupFileCount[groupName] = 0;
    }
    const dest = groupData[groupName];
    groupFileCount[groupName]++;
    
    // Track features found in this file (for DF calculation)
    const fileFeaturesFound = new Set();
    
    // Track which scope this group belongs to
    if (inT) dest.inTarget = true;
    if (inR) dest.inReference = true;
    
    // Process based on feature type
    if (featureType === 'word' || featureType === 'word_lemma') {
      for (const tok of file.tokens) {
        if (isPunctuationOrSpaceToken(tok)) continue;
        let val = tok[field];
        if (!val) continue;
        if (caseInsensitive) val = val.toLowerCase();
        dest.counts[val] = (dest.counts[val] || 0) + 1;
        globalCounts[val] = (globalCounts[val] || 0) + 1;
        dest.totalTokens++;
        fileFeaturesFound.add(val); // Track for DF
      }
    } else if ((featureType.startsWith('ngram') && !featureType.startsWith('ngrampos')) || featureType.startsWith('cluster')) {
      for (const sent of file.sentences) {
        const subSentences = getSentenceSegments(file.tokens, sent.tokenStart, sent.tokenEnd);
        for (const subSent of subSentences) {
          const arr = [];
          for (const tok of subSent.tokens) {
            // Double-check: skip punctuation tokens
            if (isPunctuationOrSpaceToken(tok)) continue;
            let val = tok[field];
            if (!val) continue;
            if (caseInsensitive) val = val.toLowerCase();
            arr.push(val);
          }
          if (arr.length < n) continue;
          for (let i = 0; i <= arr.length - n; i++) {
            const gram = arr.slice(i, i + n);
            const key = gram.join(' ');
            
            // Cluster filtering
            if (isCluster && clusterWord) {
              const pattern = clusterWord.toLowerCase();
              const parts = pattern.split('|').map(p => p.trim()).filter(p => p.length > 0);
              
              const matchesPattern = (word, patterns) => {
                for (const pat of patterns) {
                  let regexStr = pat.replace(/[.+^${}()|[\]\\]/g, '\\$&');
                  regexStr = regexStr.replace(/\*/g, '.*');
                  regexStr = regexStr.replace(/\?/g, '.');
                  const regex = new RegExp('^' + regexStr + '$', 'i');
                  if (regex.test(word)) return true;
                }
                return false;
              };
              
              let matches = false;
              if (clusterPosition === 'left' && matchesPattern(gram[0], parts)) {
                matches = true;
              } else if (clusterPosition === 'right' && matchesPattern(gram[n - 1], parts)) {
                matches = true;
              } else if (clusterPosition === 'both') {
                for (const w of gram) {
                  if (matchesPattern(w, parts)) {
                    matches = true;
                    break;
                  }
                }
              }
              if (!matches) continue;
            }
            
            dest.counts[key] = (dest.counts[key] || 0) + 1;
            globalCounts[key] = (globalCounts[key] || 0) + 1;
            dest.totalTokens++;
            fileFeaturesFound.add(key); // Track for DF
          }
        }
      }
    } else if (featureType.startsWith('pframe')) {
      for (const sent of file.sentences) {
        const subSentences = getSentenceSegments(file.tokens, sent.tokenStart, sent.tokenEnd);
        for (const subSent of subSentences) {
          const arr = [];
          for (const tok of subSent.tokens) {
            // Double-check: skip punctuation tokens
            if (isPunctuationOrSpaceToken(tok)) continue;
            let val = tok[field];
            if (!val) continue;
            if (caseInsensitive) val = val.toLowerCase();
            arr.push(val);
          }
          if (arr.length < n) continue;
          for (let i = 0; i <= arr.length - n; i++) {
            const gram = arr.slice(i, i + n);
            for (let starPos = 1; starPos < n; starPos++) {
              const frame = gram.map((w, idx) => idx === starPos ? '*' : w);
              const key = frame.join(' ');
              dest.counts[key] = (dest.counts[key] || 0) + 1;
              globalCounts[key] = (globalCounts[key] || 0) + 1;
              dest.totalTokens++;
              fileFeaturesFound.add(key); // Track for DF
            }
          }
        }
      }
    } else if (featureType === 'pos_simple' || featureType === 'pos_detailed') {
      for (const tok of file.tokens) {
        if (isPunctuationOrSpaceToken(tok)) continue;
        const tag = tok[field];
        if (!tag) continue;
        dest.counts[tag] = (dest.counts[tag] || 0) + 1;
        globalCounts[tag] = (globalCounts[tag] || 0) + 1;
        dest.totalTokens++;
        fileFeaturesFound.add(tag); // Track for DF
      }
    } else if (featureType === 'posgram_simple' || featureType === 'posgram_detailed') {
      for (const sent of file.sentences) {
        const subSentences = getSentenceSegments(file.tokens, sent.tokenStart, sent.tokenEnd);
        for (const subSent of subSentences) {
          const arr = [];
          for (const tok of subSent.tokens) {
            // Double-check: skip punctuation tokens
            if (isPunctuationOrSpaceToken(tok)) continue;
            const tag = tok[field];
            if (!tag) continue;
            arr.push(tag);
          }
          if (arr.length < n) continue;
          for (let i = 0; i <= arr.length - n; i++) {
            const gramTags = arr.slice(i, i + n);
            const key = gramTags.join('+');
            dest.counts[key] = (dest.counts[key] || 0) + 1;
            globalCounts[key] = (globalCounts[key] || 0) + 1;
            dest.totalTokens++;
            fileFeaturesFound.add(key); // Track for DF
          }
        }
      }
    } else if (featureType === 'biber_tag') {
      // Biber tag frequency
      const biberPlusOnly = document.getElementById('freqTableBiberPlusOnly')?.checked ?? false;
      for (const tok of file.tokens) {
        if (isPunctuationOrSpaceToken(tok)) continue;
        if (!tok.biberTags || tok.biberTags.length === 0) continue;
        for (const tag of tok.biberTags) {
          // If BiberPlus only is checked, filter to 96 BiberPlus tags
          if (biberPlusOnly && !isBiberPlus96Tag(tag)) continue;
          dest.counts[tag] = (dest.counts[tag] || 0) + 1;
          globalCounts[tag] = (globalCounts[tag] || 0) + 1;
          dest.totalTokens++;
          fileFeaturesFound.add(tag); // Track for DF
        }
      }
    } else if (featureType.startsWith('wordpos_')) {
      // Word + POS (1-gram): study_NN
      const wordField = featureType.includes('lemma') ? 'lemma' : 'word';
      const posField = featureType.includes('detailed') ? 'posd' : 'poss';
      for (const tok of file.tokens) {
        if (isPunctuationOrSpaceToken(tok)) continue;
        let word = tok[wordField];
        const pos = tok[posField];
        if (!word || !pos) continue;
        if (caseInsensitive) word = word.toLowerCase();
        const key = `${word}_${pos}`;
        dest.counts[key] = (dest.counts[key] || 0) + 1;
        globalCounts[key] = (globalCounts[key] || 0) + 1;
        dest.totalTokens++;
        fileFeaturesFound.add(key); // Track for DF
      }
    } else if (featureType.startsWith('ngrampos_')) {
      // n-gram Word + POS: the_DT study_NN shows_VB
      const wordField = featureType.includes('lemma') ? 'lemma' : 'word';
      const posField = featureType.includes('detailed') ? 'posd' : 'poss';
      for (const sent of file.sentences) {
        const subSentences = getSentenceSegments(file.tokens, sent.tokenStart, sent.tokenEnd);
        for (const subSent of subSentences) {
          const arr = [];
          for (const tok of subSent.tokens) {
            // Double-check: skip punctuation tokens
            if (isPunctuationOrSpaceToken(tok)) continue;
            let word = tok[wordField];
            const pos = tok[posField];
            if (!word || !pos) continue;
            if (caseInsensitive) word = word.toLowerCase();
            arr.push(`${word}_${pos}`);
          }
          if (arr.length < n) continue;
          for (let i = 0; i <= arr.length - n; i++) {
            const gram = arr.slice(i, i + n);
            const key = gram.join(' ');
            dest.counts[key] = (dest.counts[key] || 0) + 1;
            globalCounts[key] = (globalCounts[key] || 0) + 1;
            dest.totalTokens++;
            fileFeaturesFound.add(key); // Track for DF
          }
        }
      }
    }
    
    // Update DF counts for this file
    for (const feature of fileFeaturesFound) {
      groupFileDf[groupName][feature] = (groupFileDf[groupName][feature] || 0) + 1;
      globalFileDf[feature] = (globalFileDf[feature] || 0) + 1;
    }
  }
  
  const groupNames = Object.keys(groupData).sort();
  const numGroups = groupNames.length;
  
  if (numGroups === 0) {
    status.textContent = 'No data found for the selected scope.';
    body.innerHTML = '<tr><td colspan="2" class="text-xs">No frequency table.</td></tr>';
    return;
  }
  
  // Calculate document frequency for IDF
  for (const feature of Object.keys(globalCounts)) {
    let docCount = 0;
    for (const gName of groupNames) {
      if (groupData[gName].counts[feature] > 0) docCount++;
    }
    featureDocFreq[feature] = docCount;
  }
  
  // Filter features by min frequency and sort by global frequency
  let features = Object.entries(globalCounts)
    .filter(([f, c]) => c >= minFreq)
    .sort((a, b) => b[1] - a[1])
    .slice(0, numColumns)
    .map(([f, c]) => f);
  
  if (features.length === 0) {
    status.textContent = 'No features found with the specified minimum frequency.';
    body.innerHTML = '<tr><td colspan="2" class="text-xs">No frequency table.</td></tr>';
    return;
  }
  
  // Calculate values for table
  // tableData[groupName] = { feature: value, ... }
  const tableData = {};
  
  // Store raw frequencies for TOTAL calculation
  const rawFreqByGroup = {};
  
  // TF-IDF calculation function
  const calculateTfIdf = (rawFreq, totalTokens, docFreq, numDocs, tfMode, addOne, normBaseVal) => {
    if (rawFreq === 0) return 0;
    
    // TF calculation per document
    let tf;
    if (tfMode === 'raw') {
      tf = rawFreq;
    } else { // norm - normalized with per N words
      tf = totalTokens > 0 ? (rawFreq / totalTokens) * normBaseVal : 0;
    }
    
    // IDF calculation
    // N = total number of documents (groups)
    // df = number of documents containing this term
    let idf;
    if (docFreq === 0 || !docFreq || numDocs === 0) {
      idf = 0;
    } else if (addOne) {
      // IDF + 1: log(N/df) + 1
      idf = Math.log(numDocs / docFreq) + 1;
    } else {
      // Standard IDF: log(N/df)
      idf = Math.log(numDocs / docFreq);
    }
    
    return tf * idf;
  };
  
  const calculateValue = (rawFreq, totalTokens, docFreq, numDocs, fileDf) => {
    if (valueType === 'raw') {
      return rawFreq;
    } else if (valueType === 'df') {
      return fileDf || 0;  // Document frequency (number of files)
    } else if (valueType === 'normalized') {
      if (totalTokens === 0) return 0;
      return (rawFreq / totalTokens) * normBase;
    } else if (valueType === 'tfidf') {
      return calculateTfIdf(rawFreq, totalTokens, docFreq, numDocs, tfType, idfPlusOne, tfNormBase);
    }
    return rawFreq;
  };
  
  // Calculate total for each group (sum of all tokens or files)
  const groupTotals = {};
  for (const gName of groupNames) {
    // For DF, show file count; otherwise show token count
    groupTotals[gName] = valueType === 'df' ? (groupFileCount[gName] || 0) : groupData[gName].totalTokens;
    rawFreqByGroup[gName] = {};
  }
  
  for (const gName of groupNames) {
    tableData[gName] = {};
    for (const feature of features) {
      const rawFreq = groupData[gName].counts[feature] || 0;
      const totalTokens = groupData[gName].totalTokens;
      const docFreq = featureDocFreq[feature] || 0;
      const fileDf = groupFileDf[gName]?.[feature] || 0;
      rawFreqByGroup[gName][feature] = rawFreq;
      tableData[gName][feature] = calculateValue(rawFreq, totalTokens, docFreq, numGroups, fileDf);
    }
  }
  
  // Calculate global totals for each feature
  const globalTotals = {};
  const globalRawTotals = {}; // For TF-IDF, store raw totals
  let grandTotalTokens = 0;
  let grandTotalFiles = 0;
  for (const gName of groupNames) {
    grandTotalTokens += groupData[gName].totalTokens;
    grandTotalFiles += groupFileCount[gName] || 0;
  }
  
  for (const feature of features) {
    const rawFreq = globalCounts[feature] || 0;
    globalRawTotals[feature] = rawFreq;
    
    if (valueType === 'tfidf') {
      // For TF-IDF, sum the individual TF-IDF values
      let sum = 0;
      for (const gName of groupNames) {
        sum += tableData[gName][feature] || 0;
      }
      globalTotals[feature] = sum;
    } else if (valueType === 'df') {
      // For DF, use global file document frequency
      globalTotals[feature] = globalFileDf[feature] || 0;
    } else {
      const docFreq = featureDocFreq[feature] || 0;
      globalTotals[feature] = calculateValue(rawFreq, grandTotalTokens, docFreq, numGroups);
    }
  }
  
  // Build groupScopes mapping
  const groupScopes = {};
  for (const gName of groupNames) {
    groupScopes[gName] = {
      inTarget: groupData[gName].inTarget,
      inReference: groupData[gName].inReference
    };
  }
  
  // Store data for export
  freqTableData = {
    tableData,
    rawData: rawFreqByGroup,  // Store raw frequencies for Chi-square test
    groupNames,
    features,
    globalTotals,
    groupTotals,
    grandTotalTokens,
    grandTotalFiles,  // For DF value type
    valueType,
    featureType,  // Store for KWIC linking
    groupBy,      // Store for filtering (folder or file)
    groupScopes   // Store for scope determination
  };
  freqTableGroups = groupNames;
  freqTableFeatures = features;
  
  // Clear warning
  const warningEl = document.getElementById('freqTableWarning');
  if (warningEl) warningEl.style.display = 'none';
  
  // Render table
  renderFrequencyTable();
  
  // Check if all values are zero (TF-IDF without IDF+1)
  if (valueType === 'tfidf' && !idfPlusOne) {
    let allZero = true;
    for (const feature of features) {
      if (globalTotals[feature] > 0.0001) {
        allZero = false;
        break;
      }
    }
    if (allZero && warningEl) {
      warningEl.textContent = '⚠️ All TF-IDF values are 0. This happens when all features appear in ALL groups (IDF = log(N/N) = 0). Check "IDF + 1" to get non-zero values.';
      warningEl.style.display = 'block';
    }
  }
  
  // Also populate Chi-square folder checkboxes
  populateChiSquareFolderCheckboxes();
  // Also populate 9-c folder checkboxes / focus list
  populateDistTestFolderCheckboxes();

  
  // Status text - show files count for DF, tokens for others
  if (valueType === 'df') {
    status.textContent = `Computed frequency table: ${features.length} features × ${groupNames.length} groups. Total files: ${grandTotalFiles.toLocaleString()}.`;
  } else {
    status.textContent = `Computed frequency table: ${features.length} features × ${groupNames.length} groups. Total tokens: ${grandTotalTokens.toLocaleString()}.`;
  }
}

// Compute Frequency Table for DEP (deprel tag frequency)
function computeFrequencyTableDep() {
  const status = document.getElementById('freqTableStatus');
  const body = document.getElementById('freqTableBody');
  const head = document.getElementById('freqTableHead');
  
  const minFreq = parseInt(document.getElementById('freqTableMinFreq')?.value, 10) || 2;
  const groupBy = document.getElementById('freqTableGroupBy')?.value || 'corpus';
  const scopeEl = document.querySelector('input[name="freqTableScope"]:checked');
  const scope = scopeEl ? scopeEl.value : 'target';
  
  
  status.textContent = 'Computing DEP frequency table...';
  
  // Get files based on scope
  const files = Object.values(corpus.files).filter(f => {
    if (corpus.mode !== 'csv' || !f.tokens) return false;
    
    // All folders: include all files regardless of Target/Reference setting
    if (scope === 'all') return true;
    
    const isTarget = targetFolders.has(f.folder);
    const isReference = referenceFolders.has(f.folder);
    
    // Include file if it belongs to the selected scope
    // Files in both Target and Reference are included in both scopes
    if (scope === 'target') return isTarget;
    if (scope === 'reference') return isReference;
    return isTarget || isReference;
  });
  
  // Collect deprel frequencies by group
  const groupData = {};
  const globalCounts = {};
  const groupFileCount = {};
  
  files.forEach(file => {
    // Determine group name
    let groupName;
    if (groupBy === 'corpus') {
      groupName = 'Corpus';
    } else if (groupBy === 'folder') {
      groupName = file.folder || 'No folder';
    } else {
      groupName = file.name;
    }
    
    if (!groupData[groupName]) {
      groupData[groupName] = { 
        counts: {}, 
        totalTokens: 0,
        inTarget: targetFolders.has(file.folder),
        inReference: referenceFolders.has(file.folder)
      };
      groupFileCount[groupName] = 0;
    }
    
    groupData[groupName].totalTokens += file.tokens.length;
    groupFileCount[groupName]++;
    
    file.tokens.forEach(tok => {
      const deprel = tok.deprel || tok.dep || '';
      if (!deprel || deprel === 'ROOT' || deprel === 'root') return;
      
      groupData[groupName].counts[deprel] = (groupData[groupName].counts[deprel] || 0) + 1;
      globalCounts[deprel] = (globalCounts[deprel] || 0) + 1;
    });
  });
  
  // Filter by minFreq and get features
  const features = Object.keys(globalCounts)
    .filter(feat => globalCounts[feat] >= minFreq)
    .sort((a, b) => globalCounts[b] - globalCounts[a]);
  
  const groupNames = Object.keys(groupData).sort();
  
  // Build tableData and groupTotals in correct format
  const tableData = {};
  const rawFreqByGroup = {};
  const groupTotals = {};
  const groupScopes = {};
  
  for (const gName of groupNames) {
    tableData[gName] = {};
    rawFreqByGroup[gName] = {};
    groupTotals[gName] = groupData[gName].totalTokens;
    groupScopes[gName] = {
      inTarget: groupData[gName].inTarget,
      inReference: groupData[gName].inReference
    };
    
    for (const feature of features) {
      const rawFreq = groupData[gName].counts[feature] || 0;
      tableData[gName][feature] = rawFreq;
      rawFreqByGroup[gName][feature] = rawFreq;
    }
  }
  
  // Calculate grand totals
  let grandTotalTokens = 0;
  let grandTotalFiles = 0;
  for (const gName of groupNames) {
    grandTotalTokens += groupData[gName].totalTokens;
    grandTotalFiles += groupFileCount[gName] || 0;
  }
  
  // Store data for export in correct format
  freqTableData = {
    tableData,
    rawData: rawFreqByGroup,
    groupNames,
    features,
    globalTotals: globalCounts,
    groupTotals,
    grandTotalTokens,
    grandTotalFiles,
    valueType: 'raw',
    featureType: 'dep',
    groupBy,
    groupScopes
  };
  freqTableGroups = groupNames;
  freqTableFeatures = features;
  
  // Clear filters
  freqTableFilteredFeatures = null;
  freqTableDeletedRows = new Set();
  freqTableDeletedCols = new Set();
  
  // Render
  renderFrequencyTable();
  
  status.textContent = `DEP frequency table: ${features.length} features × ${groupNames.length} groups. Total tokens: ${grandTotalTokens.toLocaleString()}.`;
}

function renderFrequencyTable() {
  const head = document.getElementById('freqTableHead');
  const body = document.getElementById('freqTableBody');
  const filterUI = document.getElementById('freqTableFilterUI');
  
  if (!freqTableData || freqTableGroups.length === 0 || freqTableFeatures.length === 0) {
    head.innerHTML = '<tr><th>Group</th><th class="text-right">Tokens</th></tr>';
    body.innerHTML = '<tr><td colspan="2" class="text-xs">No frequency table.</td></tr>';
    if (filterUI) filterUI.style.display = 'none';
    return;
  }
  
  // Show filter UI
  if (filterUI) filterUI.style.display = 'flex';
  
  // Get effective data considering filters and deletions
  const effectiveData = getEffectiveFreqTableData();
  if (!effectiveData || effectiveData.features.length === 0 || effectiveData.groupNames.length === 0) {
    head.innerHTML = '<tr><th>Group</th><th class="text-right">Tokens</th></tr>';
    body.innerHTML = '<tr><td colspan="2" class="text-xs">No data after filter/deletion.</td></tr>';
    return;
  }
  
  const { tableData, groupNames, features, globalTotals, groupTotals, grandTotalTokens, grandTotalFiles, valueType, originalGroupNames, originalFeatures } = effectiveData;
  // For TF-IDF, check current displayMode; for others, always use 'total'
  const displayMode = valueType === 'tfidf' 
    ? (document.getElementById('freqTableDisplayMode')?.value || 'pergroup')
    : 'total';
  const numColumns = features.length;
  
  // Column label: "Files" for DF, "Tokens" for others
  const countLabel = valueType === 'df' ? 'Files' : 'Tokens';
  const grandTotal = valueType === 'df' ? (grandTotalFiles || 0) : grandTotalTokens;
  
  // Map from effective indices to original indices
  const rowIdxMap = {}; // groupName -> original index
  const colIdxMap = {}; // feature -> original index
  originalGroupNames.forEach((name, i) => rowIdxMap[name] = i);
  originalFeatures.forEach((feat, i) => colIdxMap[feat] = i);
  
  // Format number based on value type and magnitude
  const formatVal = (val) => {
    if (valueType === 'raw' || valueType === 'df') {
      return Math.round(val).toLocaleString();
    }
    if (val === 0) return '0';
    const absVal = Math.abs(val);
    if (absVal >= 100) {
      return val.toFixed(2);
    } else if (absVal >= 1) {
      return val.toFixed(3);
    } else if (absVal >= 0.01) {
      return val.toFixed(4);
    } else {
      return val.toFixed(4);
    }
  };
  
  let headerHtml = '';
  let bodyHtml = '';
  
  if (displayMode === 'total') {
    // ===== TOTAL MODE =====
    // Header: checkbox, Group, Tokens/Files, feature1, feature2, ...
    // Each cell shows only the value
    headerHtml = '<tr><th style="width:30px;"></th><th style="min-width:100px; position:relative;">Group<div class="freq-col-resizer" data-col="0"></div></th>';
    headerHtml += `<th class="text-right sortable" style="min-width:80px; position:relative;" data-feature="__tokens__">${countLabel}<div class="freq-col-resizer" data-col="1"></div></th>`;
    let colIdx = 2;
    for (const feature of features) {
      const origColIdx = colIdxMap[feature];
      headerHtml += `<th class="text-right sortable" style="min-width:60px; white-space:nowrap; position:relative; cursor:pointer;" data-feature="${escapeHtml(feature)}"><label style="display:inline-block; padding:2px 4px; cursor:pointer;" onclick="event.stopPropagation()"><input type="checkbox" class="freq-col-checkbox" data-col-idx="${origColIdx}" title="Select column for deletion" style="cursor:pointer;"></label><span class="freq-feature-text" data-feature="${escapeHtml(feature)}" style="border-bottom:1px dashed #666; cursor:pointer; margin-left:2px;">${escapeHtml(feature)}</span><div class="freq-col-resizer" data-col="${colIdx}"></div></th>`;
      colIdx++;
    }
    headerHtml += '</tr>';
    
    // TOTAL row first (no checkbox for total row)
    bodyHtml += '<tr style="background:#e5e7eb; font-weight:600;">';
    bodyHtml += '<td></td>';
    bodyHtml += '<td>TOTAL</td>';
    bodyHtml += `<td class="text-right">${grandTotal.toLocaleString()}</td>`;
    for (const feature of features) {
      const val = globalTotals[feature] || 0;
      // Show blank if value is 0 or very close to 0
      if (val === 0 || Math.abs(val) < 0.0001) {
        bodyHtml += '<td class="text-right"></td>';
      } else {
        bodyHtml += `<td class="text-right">${formatVal(val)}</td>`;
      }
    }
    bodyHtml += '</tr>';
    
    // Group rows
    for (const gName of groupNames) {
      const origRowIdx = rowIdxMap[gName];
      bodyHtml += '<tr>';
      bodyHtml += `<td><input type="checkbox" class="freq-row-checkbox" data-row-idx="${origRowIdx}" title="Select row for deletion" onclick="event.stopPropagation()"></td>`;
      bodyHtml += `<td>${escapeHtml(gName)}</td>`;
      bodyHtml += `<td class="text-right">${groupTotals[gName].toLocaleString()}</td>`;
      for (const feature of features) {
        const val = tableData[gName][feature] || 0;
        // Show blank if value is 0 or very close to 0
        if (val === 0 || Math.abs(val) < 0.0001) {
          bodyHtml += '<td class="text-right"></td>';
        } else {
          bodyHtml += `<td class="text-right"><span class="freq-value-link" data-feature="${escapeHtml(feature)}" data-group="${escapeHtml(gName)}" style="cursor:pointer; border-bottom:1px dashed #666;">${formatVal(val)}</span></td>`;
        }
      }
      bodyHtml += '</tr>';
    }
    
  } else {
    // ===== PER GROUP MODE =====
    // Header: Group, Tokens/Files, Rank 1, Rank 2, ...
    // Each cell shows "feature (value)" - different features per group based on ranking
    headerHtml = '<tr><th style="min-width:100px; position:relative;">Group<div class="freq-col-resizer" data-col="0"></div></th>';
    headerHtml += `<th class="text-right" style="min-width:80px; position:relative;">${countLabel}<div class="freq-col-resizer" data-col="1"></div></th>`;
    for (let i = 1; i <= numColumns; i++) {
      headerHtml += `<th class="text-center" style="min-width:100px; position:relative;">Rank ${i}<div class="freq-col-resizer" data-col="${i+1}"></div></th>`;
    }
    headerHtml += '</tr>';
    
    // TOTAL row - show global ranking (only non-zero values)
    const globalRanking = features.map(f => ({ feature: f, value: globalTotals[f] || 0 }))
      .filter(item => item.value > 0.0001)
      .sort((a, b) => b.value - a.value);
    
    bodyHtml += '<tr style="background:#e5e7eb; font-weight:600;">';
    bodyHtml += '<td>TOTAL</td>';
    bodyHtml += `<td class="text-right">${grandTotal.toLocaleString()}</td>`;
    for (let i = 0; i < numColumns; i++) {
      const item = globalRanking[i];
      if (item) {
        bodyHtml += `<td class="text-center"><span class="freq-feature-link" data-feature="${escapeHtml(item.feature)}" style="cursor:pointer; border-bottom:1px dashed #666;">${escapeHtml(item.feature)}</span> (${formatVal(item.value)})</td>`;
      } else {
        bodyHtml += '<td></td>';
      }
    }
    bodyHtml += '</tr>';
    
    // Group rows - each group has its own ranking (only non-zero values)
    for (const gName of groupNames) {
      // Get ranking for this group, filtering out zero values
      const groupRanking = features.map(f => ({ feature: f, value: tableData[gName][f] || 0 }))
        .filter(item => item.value > 0.0001)
        .sort((a, b) => b.value - a.value);
      
      bodyHtml += '<tr>';
      bodyHtml += `<td>${escapeHtml(gName)}</td>`;
      bodyHtml += `<td class="text-right">${groupTotals[gName].toLocaleString()}</td>`;
      for (let i = 0; i < numColumns; i++) {
        const item = groupRanking[i];
        if (item) {
          bodyHtml += `<td class="text-center"><span class="freq-feature-link" data-feature="${escapeHtml(item.feature)}" data-group="${escapeHtml(gName)}" style="cursor:pointer; border-bottom:1px dashed #666;">${escapeHtml(item.feature)}</span> (<span class="freq-value-link" data-feature="${escapeHtml(item.feature)}" data-group="${escapeHtml(gName)}" style="cursor:pointer; border-bottom:1px dashed #666;">${formatVal(item.value)}</span>)</td>`;
        } else {
          bodyHtml += '<td></td>';
        }
      }
      bodyHtml += '</tr>';
    }
  }
  
  head.innerHTML = headerHtml;
  body.innerHTML = bodyHtml;
  
  // Add sorting to header columns (only for Total mode)
  if (displayMode === 'total') {
    head.querySelectorAll('th.sortable').forEach(th => {
      th.style.cursor = 'pointer';
      th.addEventListener('click', (e) => {
        if (e.target.classList.contains('freq-col-resizer')) return;
        if (e.target.classList.contains('freq-feature-text') || e.target.classList.contains('freq-feature-link')) return;
        sortFrequencyTableByFeature(th.getAttribute('data-feature'));
      });
    });
  }
  
  // Add click handlers for feature links to KWIC
  const table = document.getElementById('freqTable');
  if (table) {
    // Helper function to navigate to KWIC with feature and optional group filter
    const navigateToKwic = (feature, groupName) => {
      // Get featureType from stored data
      const storedFeatureType = freqTableData?.featureType || 'word';
      
      // DEP type - redirect to 12b) Dependency Concordance
      if (storedFeatureType === 'dep') {
        redirectToDepSectionWithFilter(feature);
        return;
      }
      
      // Clear previous filters
      clearKwicFilters();
      
      // Determine base scope from Frequency Table settings
      let scope = 'target';
      const scopeEl = document.querySelector('input[name="freqTableScope"]:checked');
      const baseScope = scopeEl ? scopeEl.value : 'target';
      
      // Get groupBy, and groupScopes from stored data
      const storedGroupBy = freqTableData?.groupBy || 'corpus';
      const groupScopes = freqTableData?.groupScopes || {};
      
      // Set file/folder filter based on groupBy and groupName
      if (groupName) {
        if (storedGroupBy === 'file') {
          currentKwicFileFilter = groupName;
          currentKwicFolderFilter = null;
        } else {
          currentKwicFolderFilter = groupName;
          currentKwicFileFilter = null;
        }
        
        // Determine scope based on which group this belongs to
        const gs = groupScopes[groupName];
        if (gs) {
          if (gs.inTarget && !gs.inReference) {
            scope = 'target';
          } else if (!gs.inTarget && gs.inReference) {
            scope = 'reference';
          } else {
            // In both - use baseScope or 'both'
            scope = baseScope;
          }
        } else {
          scope = baseScope;
        }
      } else {
        currentKwicFileFilter = null;
        currentKwicFolderFilter = null;
        scope = baseScope;
      }
      
      // Set to all sections using helper - pass original featureType so it can convert both type and feature
      const kwicType = setFeatureToAllSections(feature, storedFeatureType, scope);
      
      // Set search mode - detect wildcard patterns
      const kwicSearchMode = document.getElementById('kwicSearchMode');
      if (kwicSearchMode) {
        if (feature.includes('*') || feature.includes('?')) {
          kwicSearchMode.value = 'wildcard';
        } else {
          kwicSearchMode.value = 'exact';
        }
      }
      
      // Get converted feature for currentKwicFeature
      let kwicFeature = feature;
      if (storedFeatureType.startsWith('wordpos_')) {
        kwicFeature = extractWordFromWordPos(feature);
      } else if (storedFeatureType.startsWith('ngrampos_')) {
        kwicFeature = extractWordsFromNgramPos(feature);
      }
      
      currentKwicFeature = kwicFeature;
      currentKwicFeatureType = kwicType;
      
      // Check if this is wordpos/ngrampos type - need to apply filter after compute
      const needsPosFilter = storedFeatureType.startsWith('wordpos_') || storedFeatureType.startsWith('ngrampos_');
      
      computeKwic();
      
      // Apply POS filter automatically for wordpos/ngrampos
      if (needsPosFilter) {
        setTimeout(() => applyKwicFilter(), 50);
      }
      
      document.getElementById('kwicCard')?.scrollIntoView({ behavior: 'smooth' });
    };
    
    // Click handlers for feature name links (no group filter, unless data-group is present)
    table.querySelectorAll('.freq-feature-link, .freq-feature-text').forEach(el => {
      el.addEventListener('click', (e) => {
        // Skip if clicking on checkbox
        if (e.target.classList.contains('freq-col-checkbox') || e.target.type === 'checkbox') {
          return;
        }
        e.stopPropagation();
        const feature = el.getAttribute('data-feature');
        if (!feature) return;
        const groupName = el.getAttribute('data-group') || null;
        
        // Also populate Chi-square feature input for convenience
        const chiSquareInput = document.getElementById('chiSquareFeatureInput');
        if (chiSquareInput) {
          chiSquareInput.value = feature;
        }
        
        navigateToKwic(feature, groupName);
      });
    });
    
    // Click handlers for value links (with group filter)
    table.querySelectorAll('.freq-value-link').forEach(el => {
      el.addEventListener('click', (e) => {
        e.stopPropagation();
        const feature = el.getAttribute('data-feature');
        const groupName = el.getAttribute('data-group');
        if (!feature || !groupName) return;
        navigateToKwic(feature, groupName);
      });
    });
  }
  
  // Add column resizing functionality
  initFreqTableColumnResizing();
}

function initFreqTableColumnResizing() {
  const table = document.getElementById('freqTable');
  if (!table) return;
  
  const resizers = table.querySelectorAll('.freq-col-resizer');
  
  resizers.forEach(resizer => {
    let startX, startWidth, th;
    
    resizer.addEventListener('mousedown', (e) => {
      th = resizer.parentElement;
      startX = e.pageX;
      startWidth = th.offsetWidth;
      
      document.addEventListener('mousemove', onMouseMove);
      document.addEventListener('mouseup', onMouseUp);
      
      e.preventDefault();
    });
    
    function onMouseMove(e) {
      if (th) {
        const width = startWidth + (e.pageX - startX);
        if (width >= 40) {
          th.style.width = width + 'px';
          th.style.minWidth = width + 'px';
        }
      }
    }
    
    function onMouseUp() {
      document.removeEventListener('mousemove', onMouseMove);
      document.removeEventListener('mouseup', onMouseUp);
      th = null;
    }
  });
}

let freqTableSortFeature = null;
let freqTableSortDir = 'desc';

function sortFrequencyTableByFeature(feature) {
  if (!freqTableData || !feature) return;
  
  // Toggle direction if same feature
  if (freqTableSortFeature === feature) {
    freqTableSortDir = freqTableSortDir === 'desc' ? 'asc' : 'desc';
  } else {
    freqTableSortFeature = feature;
    freqTableSortDir = 'desc';
  }
  
  const { tableData, groupNames, groupTotals } = freqTableData;
  
  // Sort group names by feature value or by tokens
  const sortedGroups = [...groupNames].sort((a, b) => {
    let valA, valB;
    if (feature === '__tokens__') {
      valA = groupTotals[a] || 0;
      valB = groupTotals[b] || 0;
    } else {
      valA = tableData[a][feature] || 0;
      valB = tableData[b][feature] || 0;
    }
    return freqTableSortDir === 'desc' ? valB - valA : valA - valB;
  });
  
  freqTableData.groupNames = sortedGroups;
  freqTableGroups = sortedGroups;
  
  renderFrequencyTable();
  
  // Highlight sorted column
  const head = document.getElementById('freqTableHead');
  head.querySelectorAll('th.sortable').forEach(th => {
    th.classList.remove('sorted-asc', 'sorted-desc');
    if (th.getAttribute('data-feature') === feature) {
      th.classList.add(freqTableSortDir === 'asc' ? 'sorted-asc' : 'sorted-desc');
    }
  });
}

function exportFrequencyTableToExcel() {
  const effectiveData = getEffectiveFreqTableData();
  if (!effectiveData || effectiveData.groupNames.length === 0 || effectiveData.features.length === 0) {
    alert('No frequency table to export. Please compute first.');
    return;
  }
  
  const { tableData, groupNames, features, globalTotals, groupTotals, grandTotalTokens, valueType } = effectiveData;
  // For TF-IDF, check current displayMode; for others, always use 'total'
  const displayMode = valueType === 'tfidf' 
    ? (document.getElementById('freqTableDisplayMode')?.value || 'pergroup')
    : 'total';
  const decimals = valueType === 'raw' ? 0 : 4;
  const numColumns = features.length;
  
  const formatVal = (val) => {
    if (valueType === 'raw') {
      return Math.round(val);
    }
    return parseFloat(val.toFixed(decimals));
  };
  
  let xml = '<?xml version="1.0" encoding="UTF-8"?>\n';
  xml += '<?mso-application progid="Excel.Sheet"?>\n';
  xml += '<Workbook xmlns="urn:schemas-microsoft-com:office:spreadsheet"\n';
  xml += '  xmlns:ss="urn:schemas-microsoft-com:office:spreadsheet">\n';
  xml += '<Worksheet ss:Name="Frequency Table">\n<Table>\n';

  if (displayMode === 'total') {
    // ===== TOTAL MODE =====
    // Header: Group, Tokens, feature1, feature2, ...
    xml += '<Row>';
    xml += '<Cell><Data ss:Type="String">Group</Data></Cell>';
    xml += '<Cell><Data ss:Type="String">Tokens</Data></Cell>';
    for (const feature of features) {
      xml += `<Cell><Data ss:Type="String">${escapeHtml(feature)}</Data></Cell>`;
    }
    xml += '</Row>\n';

    // TOTAL row first
    xml += '<Row>';
    xml += '<Cell><Data ss:Type="String">TOTAL</Data></Cell>';
    xml += `<Cell><Data ss:Type="Number">${grandTotalTokens}</Data></Cell>`;
    for (const feature of features) {
      const val = globalTotals[feature] || 0;
      if (val === 0 || Math.abs(val) < 0.0001) {
        xml += '<Cell><Data ss:Type="String"></Data></Cell>';
      } else {
        xml += `<Cell><Data ss:Type="Number">${formatVal(val)}</Data></Cell>`;
      }
    }
    xml += '</Row>\n';

    // Group rows
    for (const gName of groupNames) {
      xml += '<Row>';
      xml += `<Cell><Data ss:Type="String">${escapeHtml(gName)}</Data></Cell>`;
      xml += `<Cell><Data ss:Type="Number">${groupTotals[gName]}</Data></Cell>`;
      for (const feature of features) {
        const rawVal = tableData[gName][feature] || 0;
        if (rawVal === 0 || Math.abs(rawVal) < 0.0001) {
          xml += '<Cell><Data ss:Type="String"></Data></Cell>';
        } else {
          xml += `<Cell><Data ss:Type="Number">${formatVal(rawVal)}</Data></Cell>`;
        }
      }
      xml += '</Row>\n';
    }
    
  } else {
    // ===== PER GROUP MODE =====
    // Header: Group, Tokens, Rank 1, Rank 2, ...
    xml += '<Row>';
    xml += '<Cell><Data ss:Type="String">Group</Data></Cell>';
    xml += '<Cell><Data ss:Type="String">Tokens</Data></Cell>';
    for (let i = 1; i <= numColumns; i++) {
      xml += `<Cell><Data ss:Type="String">Rank ${i}</Data></Cell>`;
    }
    xml += '</Row>\n';

    // TOTAL row - global ranking (only non-zero values)
    const globalRanking = features.map(f => ({ feature: f, value: globalTotals[f] || 0 }))
      .filter(item => item.value > 0.0001)
      .sort((a, b) => b.value - a.value);
    
    xml += '<Row>';
    xml += '<Cell><Data ss:Type="String">TOTAL</Data></Cell>';
    xml += `<Cell><Data ss:Type="Number">${grandTotalTokens}</Data></Cell>`;
    for (let i = 0; i < numColumns; i++) {
      const item = globalRanking[i];
      if (item) {
        xml += `<Cell><Data ss:Type="String">${escapeHtml(item.feature)} (${formatVal(item.value)})</Data></Cell>`;
      } else {
        xml += '<Cell><Data ss:Type="String"></Data></Cell>';
      }
    }
    xml += '</Row>\n';

    // Group rows - each with its own ranking (only non-zero values)
    for (const gName of groupNames) {
      const groupRanking = features.map(f => ({ feature: f, value: tableData[gName][f] || 0 }))
        .filter(item => item.value > 0.0001)
        .sort((a, b) => b.value - a.value);
      
      xml += '<Row>';
      xml += `<Cell><Data ss:Type="String">${escapeHtml(gName)}</Data></Cell>`;
      xml += `<Cell><Data ss:Type="Number">${groupTotals[gName]}</Data></Cell>`;
      for (let i = 0; i < numColumns; i++) {
        const item = groupRanking[i];
        if (item) {
          xml += `<Cell><Data ss:Type="String">${escapeHtml(item.feature)} (${formatVal(item.value)})</Data></Cell>`;
        } else {
          xml += '<Cell><Data ss:Type="String"></Data></Cell>';
        }
      }
      xml += '</Row>\n';
    }
  }

  xml += '</Table>\n</Worksheet>\n</Workbook>';

  const blob = new Blob([xml], { type: 'application/vnd.ms-excel;charset=utf-8;' });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = 'frequency_table.xls';
  document.body.appendChild(a);
  a.click();
  document.body.removeChild(a);
  URL.revokeObjectURL(url);
}

function clearFrequencyTable() {
  freqTableData = null;
  freqTableGroups = [];
  freqTableFeatures = [];
  freqTableSortFeature = null;
  freqTableSortDir = 'desc';
  freqTableDeletedRows = new Set();
  freqTableDeletedCols = new Set();
  freqTableFilteredFeatures = null;
  
  const head = document.getElementById('freqTableHead');
  const body = document.getElementById('freqTableBody');
  const status = document.getElementById('freqTableStatus');
  const filterUI = document.getElementById('freqTableFilterUI');
  
  if (head) head.innerHTML = '<tr><th>Group</th><th class="text-right">Tokens</th></tr>';
  if (body) body.innerHTML = '<tr><td colspan="2" class="text-xs">No frequency table yet.</td></tr>';
  if (status) status.textContent = '';
  if (filterUI) filterUI.style.display = 'none';
}

// ===== Frequency Table Filter and Delete Functions =====
function applyFreqTableFilter() {
  if (!freqTableData || !freqTableFeatures || freqTableFeatures.length === 0) {
    return;
  }
  
  const filterInput = document.getElementById('freqTableFeatureFilter');
  const modeSelect = document.getElementById('freqTableFilterMode');
  const excludeCheck = document.getElementById('freqTableFilterExclude');
  
  const filterStr = filterInput ? filterInput.value.trim().toLowerCase() : '';
  const mode = modeSelect ? modeSelect.value : 'exact';
  const excludeMode = excludeCheck ? excludeCheck.checked : false;
  
  if (!filterStr) {
    freqTableFilteredFeatures = null; // Show all
    renderFrequencyTable();
    return;
  }
  
  // Filter features
  freqTableFilteredFeatures = new Set();
  freqTableFeatures.forEach((feature, idx) => {
    const featLower = feature.toLowerCase();
    let matches = false;
    
    if (mode === 'partial') {
      matches = featLower.includes(filterStr);
    } else {
      // Exact match - check if any word in feature matches
      const parts = featLower.split(/\s+/).filter(x => x.length > 0);
      matches = parts.some(p => p === filterStr) || featLower === filterStr;
    }
    
    // Apply exclude logic
    if (excludeMode ? !matches : matches) {
      freqTableFilteredFeatures.add(idx);
    }
  });
  
  renderFrequencyTable();
}

function clearFreqTableFilter() {
  const filterInput = document.getElementById('freqTableFeatureFilter');
  const excludeCheck = document.getElementById('freqTableFilterExclude');
  if (filterInput) filterInput.value = '';
  if (excludeCheck) excludeCheck.checked = false;
  freqTableFilteredFeatures = null;
  renderFrequencyTable();
}

function deleteSelectedFreqTableItems() {
  // Get selected checkboxes
  const rowCheckboxes = document.querySelectorAll('.freq-row-checkbox:checked');
  const colCheckboxes = document.querySelectorAll('.freq-col-checkbox:checked');
  
  rowCheckboxes.forEach(cb => {
    const rowIdx = parseInt(cb.dataset.rowIdx, 10);
    if (!isNaN(rowIdx)) freqTableDeletedRows.add(rowIdx);
  });
  
  colCheckboxes.forEach(cb => {
    const colIdx = parseInt(cb.dataset.colIdx, 10);
    if (!isNaN(colIdx)) freqTableDeletedCols.add(colIdx);
  });
  
  renderFrequencyTable();
  updateFreqTableSelectionInfo();
}

function restoreFreqTableItems() {
  freqTableDeletedRows = new Set();
  freqTableDeletedCols = new Set();
  renderFrequencyTable();
  updateFreqTableSelectionInfo();
}

function updateFreqTableSelectionInfo() {
  const info = document.getElementById('freqTableSelectionInfo');
  if (!info) return;
  
  const deletedRowCount = freqTableDeletedRows.size;
  const deletedColCount = freqTableDeletedCols.size;
  
  if (deletedRowCount === 0 && deletedColCount === 0) {
    info.textContent = '';
  } else {
    const parts = [];
    if (deletedRowCount > 0) parts.push(`${deletedRowCount} row(s)`);
    if (deletedColCount > 0) parts.push(`${deletedColCount} col(s)`);
    info.textContent = `Deleted: ${parts.join(', ')}`;
  }
}

// Get effective data for frequency table (considering filters and deletions)
function getEffectiveFreqTableData() {
  if (!freqTableData) return null;
  
  const { tableData, groupNames, features, globalTotals, groupTotals, grandTotalTokens, grandTotalFiles, valueType } = freqTableData;
  
  // Get visible row indices (not deleted)
  const visibleRows = groupNames.map((_, i) => i).filter(i => !freqTableDeletedRows.has(i));
  
  // Get visible column indices (not deleted and passes filter)
  let visibleCols = features.map((_, i) => i).filter(i => !freqTableDeletedCols.has(i));
  if (freqTableFilteredFeatures !== null) {
    visibleCols = visibleCols.filter(i => freqTableFilteredFeatures.has(i));
  }
  
  // Build filtered data
  const filteredGroupNames = visibleRows.map(i => groupNames[i]);
  const filteredFeatures = visibleCols.map(i => features[i]);
  const filteredTableData = {};
  const filteredGroupTotals = {};
  
  visibleRows.forEach(rowIdx => {
    const group = groupNames[rowIdx];
    filteredTableData[group] = {};
    filteredGroupTotals[group] = groupTotals[group];
    visibleCols.forEach(colIdx => {
      const feature = features[colIdx];
      filteredTableData[group][feature] = tableData[group][feature] || 0;
    });
  });
  
  // Recalculate global totals for visible features
  const filteredGlobalTotals = {};
  visibleCols.forEach(colIdx => {
    const feature = features[colIdx];
    filteredGlobalTotals[feature] = globalTotals[feature] || 0;
  });
  
  return {
    tableData: filteredTableData,
    groupNames: filteredGroupNames,
    features: filteredFeatures,
    globalTotals: filteredGlobalTotals,
    groupTotals: filteredGroupTotals,
    grandTotalTokens,
    grandTotalFiles,
    valueType,
    originalGroupNames: groupNames,
    originalFeatures: features
  };
}

// ===== 9-b) Chi-square Distribution Test Functions =====
let chiSquareResults = null;
let chiSquareSort = { col: 'chiSquare', dir: 'desc' };
let chiSquareDetailSort = { col: 'stdRes', dir: 'desc' };
let currentChiSquareDetailFeature = null;

// Chi-square folder selection functions
function populateChiSquareFolderCheckboxes() {
  const container = document.getElementById('chiSquareFolderCheckboxes');
  if (!container) return;
  
  // Get folders from frequency table data
  if (!freqTableData || !freqTableData.groupNames) {
    container.innerHTML = '<div class="text-xs" style="color:#666;">Compute Frequency Table first</div>';
    return;
  }
  
  const folders = freqTableData.groupNames;
  
  container.innerHTML = folders.map(folder => `
    <label style="display:block; margin:0.25rem 0; cursor:pointer;">
      <input type="checkbox" class="chi-folder-checkbox" value="${escapeHtml(folder)}" checked>
      ${escapeHtml(folder)}
    </label>
  `).join('');
  
  // Add change listeners
  container.querySelectorAll('.chi-folder-checkbox').forEach(cb => {
    cb.addEventListener('change', updateChiSquareFolderLabel);
  });
  
  updateChiSquareFolderLabel();
}


// ===========================
// 9-c) Folder selection & grouping (File-level Distribution Test)
// ===========================
let distTestGroupCounter = 1;

function toggleDistTestCompareMode() {
  const mode = document.getElementById('distTestCompareMode')?.value || 'perFolder';
  const per = document.getElementById('distTestPerFolderMode');
  const one = document.getElementById('distTestOneVsRestMode');
  const cg  = document.getElementById('distTestCustomGroupsMode');
  if (per) per.style.display = (mode === 'perFolder' || mode === 'pairwise') ? 'block' : 'none';
  if (one) one.style.display = (mode === 'oneVsRest') ? 'block' : 'none';
  if (cg)  cg.style.display  = (mode === 'customGroups') ? 'block' : 'none';

  // Update hint label based on mode
  updateDistTestFolderLabel();
}

function populateDistTestFolderCheckboxes() {
  const container = document.getElementById('distTestFolderCheckboxes');
  const focusSel = document.getElementById('distTestFocusFolder');
  if (!container && !focusSel) return;

  // Prefer freqTable group names (stable with current workflow)
  let folders = [];
  if (freqTableData && Array.isArray(freqTableData.groupNames)) {
    folders = [...freqTableData.groupNames];
  } else if (corpus && corpus.folders) {
    folders = Object.keys(corpus.folders);
  }

  // Build checkboxes with basic metadata (n_files, tokens) when available
  const folderMeta = (freqTableData && freqTableData.folderMeta) ? freqTableData.folderMeta : null;

  // If folderMeta is not available, compute basic metadata from the loaded corpus (n_files, tokens)
  const computedMeta = {};
  if (!folderMeta && corpus && corpus.files) {
    for (const fn of Object.keys(corpus.files)) {
      const file = corpus.files[fn];
      if (!file) continue;
      const folder = file.folder || 'Ungrouped';
      if (!computedMeta[folder]) computedMeta[folder] = { nFiles: 0, tokens: 0 };
      computedMeta[folder].nFiles += 1;
      const toks = file.tokens || [];
      let c = 0;
      for (const t of toks) {
        if (t && (t.isPunct || t.isSpace)) continue;
        c += 1;
      }
      computedMeta[folder].tokens += c;
    }
  }
  const metaSource = folderMeta || (Object.keys(computedMeta).length ? computedMeta : null);

  if (container) {
    if (!folders.length) {
      container.innerHTML = '<div class="text-xs" style="color:#666;">Compute 9-a) Frequency Table first</div>';
    } else {
      container.innerHTML = folders.map(folder => {
        const meta = metaSource && metaSource[folder] ? metaSource[folder] : null;
        const nf = meta && typeof meta.nFiles === 'number' ? meta.nFiles : null;
        const tk = meta && typeof meta.tokens === 'number' ? meta.tokens : null;
        const metaText = (nf !== null || tk !== null)
          ? `<span style="color:#6b7280;">(${nf!==null?`n=${nf}`:''}${(nf!==null&&tk!==null)?', ':''}${tk!==null?`tok=${tk}`:''})</span>`
          : '';
        return `
          <label style="display:block; margin:0.25rem 0; cursor:pointer;">
            <input type="checkbox" class="dist-folder-checkbox" value="${escapeHtml(folder)}" checked>
            ${escapeHtml(folder)} ${metaText}
          </label>
        `;
      }).join('');

      container.querySelectorAll('.dist-folder-checkbox').forEach(cb => {
        cb.addEventListener('change', updateDistTestFolderLabel);
      });
    }
  }

  if (focusSel) {
    focusSel.innerHTML = '';
    if (!folders.length) {
      const opt = document.createElement('option');
      opt.value = '';
      opt.textContent = '(compute 9-a Frequency Table first)';
      focusSel.appendChild(opt);
    } else {
      for (const f of folders) {
        const opt = document.createElement('option');
        opt.value = f;
        opt.textContent = f;
        focusSel.appendChild(opt);
      }
    }
  }

  updateDistTestFolderLabel();
}

function getSelectedDistTestFolders() {
  const checked = document.querySelectorAll('.dist-folder-checkbox:checked');
  return Array.from(checked).map(cb => cb.value);
}

function updateDistTestFolderLabel() {
  const label = document.getElementById('distTestFolderLabel');
  if (!label) return;
  const selected = getSelectedDistTestFolders();
  const total = document.querySelectorAll('.dist-folder-checkbox').length;
  const mode = document.getElementById('distTestCompareMode')?.value || 'perFolder';

  if (total === 0) {
    label.textContent = '(compute 9-a first)';
    return;
  }
  if (selected.length === 0) {
    label.textContent = '(None selected)';
    return;
  }
  if (mode === 'pairwise') {
    label.textContent = `${selected.slice(0,2).join(' vs ') || '(select 2 folders)'}`;
    return;
  }
  if (selected.length === total) {
    label.textContent = '(All folders)';
  } else if (selected.length <= 3) {
    label.textContent = selected.join(', ');
  } else {
    label.textContent = `(${selected.length}/${total}) selected`;
  }
}

function toggleDistTestFolderDropdown(ev) {
  const dropdown = document.getElementById('distTestFolderDropdown');
  if (!dropdown) return;
  dropdown.style.display = (dropdown.style.display === 'none' || dropdown.style.display === '') ? 'block' : 'none';

  // Position dropdown under button
  const btn = document.getElementById('distTestFolderBtn');
  if (btn && dropdown.style.display === 'block') {
    const rect = btn.getBoundingClientRect();
    dropdown.style.left = rect.left + 'px';
    dropdown.style.top = (rect.bottom + window.scrollY) + 'px';
  }
}

function selectAllDistTestFolders() {
  document.querySelectorAll('.dist-folder-checkbox').forEach(cb => cb.checked = true);
  updateDistTestFolderLabel();
}

function clearAllDistTestFolders() {
  document.querySelectorAll('.dist-folder-checkbox').forEach(cb => cb.checked = false);
  updateDistTestFolderLabel();
}

function invertDistTestFolders() {
  document.querySelectorAll('.dist-folder-checkbox').forEach(cb => cb.checked = !cb.checked);
  updateDistTestFolderLabel();
}

function applyDistTestMinFilesFilter() {
  const minN = parseInt(document.getElementById('distTestMinFiles')?.value, 10) || 1;
  const meta = (freqTableData && freqTableData.folderMeta) ? freqTableData.folderMeta : ((typeof metaSource !== 'undefined') ? metaSource : null);
  if (!metaSource) {
    // If no metadata, do nothing
    return;
  }
  document.querySelectorAll('.dist-folder-checkbox').forEach(cb => {
    const f = cb.value;
    const nf = metaSource[f] && typeof metaSource[f].nFiles === 'number' ? metaSource[f].nFiles : null;
    if (nf !== null && nf < minN) cb.checked = false;
  });
  updateDistTestFolderLabel();
}

function addDistTestGroup() {
  const container = document.getElementById('distTestGroupsContainer');
  if (!container) return;

  let availableFolders = [];
  if (freqTableData && freqTableData.groupNames) availableFolders = freqTableData.groupNames;

  const groupId = distTestGroupCounter++;
  const groupDiv = document.createElement('div');
  groupDiv.id = `distTestGroup_${groupId}`;
  groupDiv.className = 'dist-test-group';
  groupDiv.style.cssText = 'margin-bottom:0.5rem; padding:0.5rem; background:#fffef0; border:1px solid #e0d8a0; border-radius:4px;';

  groupDiv.innerHTML = `
    <div style="display:flex; align-items:center; gap:0.5rem; flex-wrap:wrap;">
      <label style="font-weight:bold; font-size:0.85rem;">Group ${container.children.length + 1}:</label>
      <input type="text" id="distTestGroupName_${groupId}" style="min-width:180px; flex:1; max-width:280px;" placeholder="Group name" value="Group ${container.children.length + 1}">
      <button type="button" class="small btn-clear" style="padding:0.15rem 0.4rem; font-size:0.75rem;" onclick="removeDistTestGroup(${groupId})">Remove</button>
    </div>
    <div style="margin-top:0.3rem;">
      <label style="font-size:0.75rem; color:#666;">Select folders to include:</label>
      <div style="display:flex; flex-wrap:wrap; gap:0.25rem; margin-top:0.25rem; padding:0.35rem; background:#fff; border:1px solid #ddd; border-radius:3px;">
        ${availableFolders.map(f => `
          <label style="font-size:0.75rem; display:flex; align-items:center; gap:0.25rem; padding:0.15rem 0.25rem; background:#fafafa; border:1px solid #eee; border-radius:2px;">
            <input type="checkbox" class="dist-group-folder-${groupId}" value="${escapeHtml(f)}" style="margin:0;">
            ${escapeHtml(f)}
          </label>
        `).join('')}
      </div>
    </div>
  `;
  container.appendChild(groupDiv);
  updateDistTestGroupLabels();
}

function removeDistTestGroup(groupId) {
  const groupDiv = document.getElementById(`distTestGroup_${groupId}`);
  if (groupDiv) groupDiv.remove();
  updateDistTestGroupLabels();
}

function updateDistTestGroupLabels() {
  const container = document.getElementById('distTestGroupsContainer');
  if (!container) return;
  const groups = container.querySelectorAll('.dist-test-group');
  groups.forEach((gDiv, idx) => {
    const label = gDiv.querySelector('label');
    if (label) label.textContent = `Group ${idx + 1}:`;
    const input = gDiv.querySelector('input[type="text"]');
    if (input && (!input.value || input.value.startsWith('Group '))) input.value = `Group ${idx + 1}`;
  });
}

function getDistTestCustomGroups() {
  const container = document.getElementById('distTestGroupsContainer');
  if (!container) return [];
  const groups = [];
  const groupDivs = container.querySelectorAll('.dist-test-group');
  groupDivs.forEach((groupDiv, idx) => {
    const groupId = groupDiv.id.replace('distTestGroup_', '');
    const nameInput = document.getElementById(`distTestGroupName_${groupId}`);
    const name = nameInput?.value?.trim() || `Group ${idx + 1}`;
    const checkboxes = document.querySelectorAll(`.dist-group-folder-${groupId}:checked`);
    const folders = Array.from(checkboxes).map(cb => cb.value);
    if (folders.length > 0) groups.push({ name, folders });
  });
  return groups;
}

function getDistTestGroupingSpec() {
  // Share with 9-b when enabled (and 9-b exists)
  const share = document.getElementById('distTestShareWith9b')?.checked ?? true;
  if (share) {
    const chiMode = document.querySelector('input[name="chiSquareCompareMode"]:checked')?.value || 'perFolder';
    if (chiMode === 'customGroups') {
      return { mode: 'customGroups', groups: getChiSquareCustomGroups() };
    }
    return { mode: 'perFolder', folders: getSelectedChiSquareFolders() };
  }

  const mode = document.getElementById('distTestCompareMode')?.value || 'perFolder';
  if (mode === 'customGroups') return { mode, groups: getDistTestCustomGroups() };
  if (mode === 'oneVsRest') return { mode, focus: document.getElementById('distTestFocusFolder')?.value || '', folders: getSelectedDistTestFolders() };
  if (mode === 'pairwise') return { mode, folders: getSelectedDistTestFolders() };
  return { mode: 'perFolder', folders: getSelectedDistTestFolders() };
}

function toggleChiSquareFolderDropdown() {
  const dropdown = document.getElementById('chiSquareFolderDropdown');
  if (!dropdown) return;
  
  if (dropdown.style.display === 'none') {
    // Populate checkboxes when opening
    populateChiSquareFolderCheckboxes();
    dropdown.style.display = 'block';
  } else {
    dropdown.style.display = 'none';
  }
}

function selectAllChiSquareFolders() {
  document.querySelectorAll('.chi-folder-checkbox').forEach(cb => cb.checked = true);
  updateChiSquareFolderLabel();
}

function clearAllChiSquareFolders() {
  document.querySelectorAll('.chi-folder-checkbox').forEach(cb => cb.checked = false);
  updateChiSquareFolderLabel();
}

function getSelectedChiSquareFolders() {
  const checked = document.querySelectorAll('.chi-folder-checkbox:checked');
  return Array.from(checked).map(cb => cb.value);
}

function updateChiSquareFolderLabel() {
  const label = document.getElementById('chiSquareFolderLabel');
  if (!label) return;
  
  const selected = getSelectedChiSquareFolders();
  const total = document.querySelectorAll('.chi-folder-checkbox').length;
  
  if (selected.length === 0) {
    label.textContent = '(None selected)';
  } else if (selected.length === total) {
    label.textContent = '(All folders)';
  } else if (selected.length <= 2) {
    label.textContent = selected.join(', ');
  } else {
    label.textContent = `${selected.length} folders selected`;
  }
}

// ===== Custom Groups Mode Functions =====
let chiSquareGroupCounter = 0;

// Toggle between Per Folder and Custom Groups modes
function toggleChiSquareCompareMode() {
  const mode = document.querySelector('input[name="chiSquareCompareMode"]:checked')?.value || 'perFolder';
  const perFolderDiv = document.getElementById('chiSquarePerFolderMode');
  const customGroupsDiv = document.getElementById('chiSquareCustomGroupsMode');
  
  if (mode === 'perFolder') {
    if (perFolderDiv) perFolderDiv.style.display = 'block';
    if (customGroupsDiv) customGroupsDiv.style.display = 'none';
  } else {
    if (perFolderDiv) perFolderDiv.style.display = 'none';
    if (customGroupsDiv) customGroupsDiv.style.display = 'block';
    
    // Initialize with at least 2 groups if empty
    const container = document.getElementById('chiSquareGroupsContainer');
    if (container && container.children.length === 0) {
      addChiSquareGroup();
      addChiSquareGroup();
    }
  }
}

// Add a new group
function addChiSquareGroup() {
  const container = document.getElementById('chiSquareGroupsContainer');
  if (!container) return;
  
  // Get available folders from frequency table
  let availableFolders = [];
  if (freqTableData && freqTableData.groupNames) {
    availableFolders = freqTableData.groupNames;
  }
  
  const groupId = chiSquareGroupCounter++;
  const groupDiv = document.createElement('div');
  groupDiv.id = `chiSquareGroup_${groupId}`;
  groupDiv.className = 'chi-square-group';
  groupDiv.style.cssText = 'margin-bottom:0.5rem; padding:0.5rem; background:#fffef0; border:1px solid #e0d8a0; border-radius:4px;';
  
  groupDiv.innerHTML = `
    <div style="display:flex; align-items:center; gap:0.5rem; flex-wrap:wrap;">
      <label style="font-weight:bold; font-size:0.85rem;">Group ${container.children.length + 1}:</label>
      <input type="text" id="chiSquareGroupName_${groupId}" style="width:150px; font-size:0.8rem; padding:0.2rem 0.4rem; border:1px solid #ccc; border-radius:3px;" placeholder="Group name" value="Group ${container.children.length + 1}">
      <button type="button" class="small btn-clear" style="padding:0.15rem 0.4rem; font-size:0.75rem;" onclick="removeChiSquareGroup(${groupId})">Remove</button>
    </div>
    <div style="margin-top:0.3rem;">
      <label style="font-size:0.75rem; color:#666;">Select folders to include:</label>
      <div style="display:flex; flex-wrap:wrap; gap:0.25rem; margin-top:0.2rem; max-height:80px; overflow-y:auto; padding:0.3rem; background:#fff; border:1px solid #ddd; border-radius:3px;">
        ${availableFolders.map(f => `
          <label style="font-size:0.75rem; display:flex; align-items:center; gap:0.15rem; cursor:pointer; white-space:nowrap; padding:0.1rem 0.3rem; background:#fafafa; border:1px solid #eee; border-radius:2px;">
            <input type="checkbox" class="chi-group-folder-${groupId}" value="${escapeHtml(f)}" style="margin:0;">
            ${escapeHtml(f)}
          </label>
        `).join('')}
      </div>
    </div>
  `;
  
  container.appendChild(groupDiv);
  updateGroupLabels();
}

// Remove a group
function removeChiSquareGroup(groupId) {
  const groupDiv = document.getElementById(`chiSquareGroup_${groupId}`);
  if (groupDiv) {
    groupDiv.remove();
    updateGroupLabels();
  }
}

// Update group labels (Group 1, Group 2, etc.)
function updateGroupLabels() {
  const container = document.getElementById('chiSquareGroupsContainer');
  if (!container) return;
  
  const groups = container.querySelectorAll('.chi-square-group');
  groups.forEach((group, idx) => {
    const label = group.querySelector('label');
    if (label) {
      label.textContent = `Group ${idx + 1}:`;
    }
  });
}

// Auto-detect groups from folder prefixes
function autoDetectChiSquareGroups() {
  if (!freqTableData || !freqTableData.groupNames) {
    alert('Please compute Frequency Table first.');
    return;
  }
  
  const folders = freqTableData.groupNames;
  
  // Extract prefixes (letters at the start of folder names)
  const prefixMap = new Map();
  for (const folder of folders) {
    // Extract prefix: sequence of letters at the start (e.g., "CM", "IM", "MM", "RDM")
    const match = folder.match(/^([A-Za-z]+)/);
    if (match) {
      const prefix = match[1];
      if (!prefixMap.has(prefix)) {
        prefixMap.set(prefix, []);
      }
      prefixMap.get(prefix).push(folder);
    } else {
      // No prefix found, use folder name as-is
      if (!prefixMap.has('Other')) {
        prefixMap.set('Other', []);
      }
      prefixMap.get('Other').push(folder);
    }
  }
  
  // Clear existing groups
  const container = document.getElementById('chiSquareGroupsContainer');
  if (container) {
    container.innerHTML = '';
    chiSquareGroupCounter = 0;
  }
  
  // Create groups from prefixes
  for (const [prefix, folderList] of prefixMap) {
    if (folderList.length === 0) continue;
    
    addChiSquareGroup();
    const groupId = chiSquareGroupCounter - 1;
    
    // Set group name
    const nameInput = document.getElementById(`chiSquareGroupName_${groupId}`);
    if (nameInput) {
      nameInput.value = prefix;
    }
    
    // Check the folders belonging to this prefix
    for (const folder of folderList) {
      const checkbox = document.querySelector(`.chi-group-folder-${groupId}[value="${folder}"]`);
      if (checkbox) {
        checkbox.checked = true;
      }
    }
  }
  
  updateGroupLabels();
}



function autoDetectDistTestGroups() {
  // Auto-group folders by leading prefix (letters only), e.g., CM1_xxx -> CM
  // Matches 9-b) Chi-square behavior
  let folders = [];
  if (freqTableData && Array.isArray(freqTableData.groupNames) && freqTableData.groupNames.length) {
    folders = freqTableData.groupNames.slice();
  } else if (corpus && corpus.folders) {
    folders = Object.keys(corpus.folders);
  }
  if (!folders.length) {
    alert('No folders found. Please load a corpus (and/or compute 9-a Frequency Table).');
    return;
  }

  const prefixMap = new Map();
  for (const folder of folders) {
    // Extract prefix: sequence of letters at the start (e.g., "CM", "IM", "MM", "RDM")
    // Same logic as 9-b) Chi-square Distribution Test
    const match = folder.match(/^([A-Za-z]+)/);
    if (match) {
      const prefix = match[1];
      if (!prefixMap.has(prefix)) prefixMap.set(prefix, []);
      prefixMap.get(prefix).push(folder);
    } else {
      // No prefix found, use 'Other'
      if (!prefixMap.has('Other')) prefixMap.set('Other', []);
      prefixMap.get('Other').push(folder);
    }
  }

  // Clear existing groups
  const container = document.getElementById('distTestGroupsContainer');
  if (container) {
    container.innerHTML = '';
    distTestGroupCounter = 0;
  }

  // Create groups
  for (const [prefix, list] of prefixMap.entries()) {
    if (!list || !list.length) continue;
    addDistTestGroup();
    const groupId = distTestGroupCounter - 1;

    const nameInput = document.getElementById(`distTestGroupName_${groupId}`);
    if (nameInput) nameInput.value = prefix;

    for (const folder of list) {
      const cb = document.querySelector(`.dist-group-folder-${groupId}[value="${CSS.escape(folder)}"]`);
      if (cb) cb.checked = true;
    }
  }

  // Switch to customGroups mode if available
  const modeSel = document.getElementById('distTestCompareMode');
  if (modeSel) modeSel.value = 'customGroups';
  const share = document.getElementById('distTestShareWith9b');
  if (share) share.checked = false; // when user edits 9-c groups, stop sharing with 9-b
  if (typeof toggleDistTestCompareMode === 'function') toggleDistTestCompareMode();
}


// Get custom groups configuration
function getChiSquareCustomGroups() {
  const container = document.getElementById('chiSquareGroupsContainer');
  if (!container) return [];
  
  const groups = [];
  const groupDivs = container.querySelectorAll('.chi-square-group');
  
  groupDivs.forEach((groupDiv, idx) => {
    const groupId = groupDiv.id.replace('chiSquareGroup_', '');
    const nameInput = document.getElementById(`chiSquareGroupName_${groupId}`);
    const name = nameInput?.value?.trim() || `Group ${idx + 1}`;
    
    const checkboxes = document.querySelectorAll(`.chi-group-folder-${groupId}:checked`);
    const folders = Array.from(checkboxes).map(cb => cb.value);
    
    if (folders.length > 0) {
      groups.push({ name, folders });
    }
  });
  
  return groups;
}

// Sort Chi-square results
function sortChiSquareResults(sortCol) {
  if (!chiSquareResults || !chiSquareResults.displayResults) return;
  
  // Toggle direction if same column
  if (chiSquareSort.col === sortCol) {
    chiSquareSort.dir = chiSquareSort.dir === 'asc' ? 'desc' : 'asc';
  } else {
    chiSquareSort.col = sortCol;
    chiSquareSort.dir = 'desc';
  }
  
  renderChiSquareResultsTable();
}

// Render Chi-square results table with current sort
function renderChiSquareResultsTable() {
  if (!chiSquareResults || !chiSquareResults.displayResults) return;
  
  const resultsBody = document.getElementById('chiSquareResultsBody');
  const alpha = chiSquareResults.alpha;
  
  // Sort results
  const sorted = [...chiSquareResults.displayResults].sort((a, b) => {
    let aVal, bVal;
    
    switch (chiSquareSort.col) {
      case 'feature':
        aVal = a.feature.toLowerCase();
        bVal = b.feature.toLowerCase();
        break;
      case 'chiSquare':
        aVal = a.chiSquare;
        bVal = b.chiSquare;
        break;
      case 'df':
        aVal = a.df;
        bVal = b.df;
        break;
      case 'pValue':
        aVal = a.pValue;
        bVal = b.pValue;
        break;
      case 'pAdjusted':
        aVal = a.pAdjusted;
        bVal = b.pAdjusted;
        break;
      case 'cramersV':
        aVal = a.cramersV;
        bVal = b.cramersV;
        break;
      case 'isSignificant':
        aVal = a.isSignificant ? 1 : 0;
        bVal = b.isSignificant ? 1 : 0;
        break;
      default:
        aVal = a.chiSquare;
        bVal = b.chiSquare;
    }
    
    if (typeof aVal === 'string') {
      return chiSquareSort.dir === 'asc' ? aVal.localeCompare(bVal) : bVal.localeCompare(aVal);
    }
    return chiSquareSort.dir === 'asc' ? aVal - bVal : bVal - aVal;
  });
  
  // Render
  if (sorted.length === 0) {
    resultsBody.innerHTML = '<tr><td colspan="9" class="text-xs">No significant results found.</td></tr>';
  } else {
    resultsBody.innerHTML = sorted.map((r, idx) => {
      const sigStars = getSignificanceStars(r.pAdjusted, alpha);
      const sigClass = r.isSignificant ? 'style="background:#e8f4e8;"' : '';
      return `
        <tr ${sigClass} data-feature="${escapeHtml(r.feature)}" style="cursor:pointer;" onclick="showChiSquareDetail('${escapeHtml(r.feature).replace(/'/g, "\\'")}')">
          <td>${idx + 1}</td>
          <td><span class="chi-feature-link" style="cursor:pointer; border-bottom:1px dashed #666;" onclick="event.stopPropagation(); navigateToKwicFromChiSquare('${escapeHtml(r.feature).replace(/'/g, "\\'")}')">${escapeHtml(r.feature)}</span></td>
          <td class="text-right">${r.chiSquare.toFixed(2)}</td>
          <td class="text-right">${r.df}</td>
          <td class="text-right">${formatPValue(r.pValue)}</td>
          <td class="text-right">${formatPValue(r.pAdjusted)}</td>
          <td class="text-right">${r.cramersV.toFixed(3)}</td>
          <td>${sigStars}</td>
          <td><button class="small" onclick="event.stopPropagation(); showChiSquareDetail('${escapeHtml(r.feature).replace(/'/g, "\\'")}')">▶</button></td>
        </tr>
      `;
    }).join('');
  }
  
  // Update header sort indicators
  updateChiSquareSortIndicators();
}

// Update sort indicators in header
function updateChiSquareSortIndicators() {
  const headers = document.querySelectorAll('#chiSquareResultsHead th.sortable');
  headers.forEach(th => {
    th.classList.remove('sorted-asc', 'sorted-desc');
    if (th.dataset.sort === chiSquareSort.col) {
      th.classList.add(chiSquareSort.dir === 'asc' ? 'sorted-asc' : 'sorted-desc');
    }
  });
}

// Sort Chi-square detail table
function sortChiSquareDetail(sortCol) {
  if (!currentChiSquareDetailFeature) return;
  
  // Toggle direction if same column
  if (chiSquareDetailSort.col === sortCol) {
    chiSquareDetailSort.dir = chiSquareDetailSort.dir === 'asc' ? 'desc' : 'asc';
  } else {
    chiSquareDetailSort.col = sortCol;
    chiSquareDetailSort.dir = 'desc';
  }
  
  showChiSquareDetail(currentChiSquareDetailFeature);
}

// Initialize Chi-square column resizing
function initChiSquareColumnResizing() {
  // Results table resizing
  const resultsTable = document.getElementById('chiSquareResultsTable');
  if (resultsTable) {
    const resizers = resultsTable.querySelectorAll('.chi-col-resizer');
    resizers.forEach(resizer => {
      let startX, startWidth, th;
      
      resizer.addEventListener('mousedown', (e) => {
        th = resizer.parentElement;
        startX = e.pageX;
        startWidth = th.offsetWidth;
        
        const onMouseMove = (e) => {
          const newWidth = startWidth + (e.pageX - startX);
          if (newWidth >= 30) {
            th.style.width = newWidth + 'px';
            th.style.minWidth = newWidth + 'px';
          }
        };
        
        const onMouseUp = () => {
          document.removeEventListener('mousemove', onMouseMove);
          document.removeEventListener('mouseup', onMouseUp);
        };
        
        document.addEventListener('mousemove', onMouseMove);
        document.addEventListener('mouseup', onMouseUp);
        e.preventDefault();
      });
    });
  }
  
  // Detail table resizing
  const detailTable = document.getElementById('chiSquareDetailTable');
  if (detailTable) {
    const resizers = detailTable.querySelectorAll('.chi-detail-resizer');
    resizers.forEach(resizer => {
      let startX, startWidth, th;
      
      resizer.addEventListener('mousedown', (e) => {
        th = resizer.parentElement;
        startX = e.pageX;
        startWidth = th.offsetWidth;
        
        const onMouseMove = (e) => {
          const newWidth = startWidth + (e.pageX - startX);
          if (newWidth >= 30) {
            th.style.width = newWidth + 'px';
            th.style.minWidth = newWidth + 'px';
          }
        };
        
        const onMouseUp = () => {
          document.removeEventListener('mousemove', onMouseMove);
          document.removeEventListener('mouseup', onMouseUp);
        };
        
        document.addEventListener('mousemove', onMouseMove);
        document.addEventListener('mouseup', onMouseUp);
        e.preventDefault();
      });
    });
  }
}

// Gamma function approximation (Lanczos approximation)
function gammaLn(z) {
  const g = 7;
  const c = [
    0.99999999999980993,
    676.5203681218851,
    -1259.1392167224028,
    771.32342877765313,
    -176.61502916214059,
    12.507343278686905,
    -0.13857109526572012,
    9.9843695780195716e-6,
    1.5056327351493116e-7
  ];
  
  if (z < 0.5) {
    return Math.log(Math.PI / Math.sin(Math.PI * z)) - gammaLn(1 - z);
  }
  
  z -= 1;
  let x = c[0];
  for (let i = 1; i < g + 2; i++) {
    x += c[i] / (z + i);
  }
  const t = z + g + 0.5;
  return 0.5 * Math.log(2 * Math.PI) + (z + 0.5) * Math.log(t) - t + Math.log(x);
}

// Lower incomplete gamma function (series expansion)
function lowerIncompleteGamma(a, x) {
  if (x < 0) return 0;
  if (x === 0) return 0;
  
  // For very large x, the CDF approaches 1
  if (x > 200) return 1;
  
  const eps = 1e-10;
  const maxIter = 200;
  
  let sum = 0;
  let term = 1 / a;
  sum = term;
  
  for (let n = 1; n < maxIter; n++) {
    term *= x / (a + n);
    sum += term;
    if (Math.abs(term) < eps * Math.abs(sum)) break;
  }
  
  const result = Math.exp(-x + a * Math.log(x) - gammaLn(a)) * sum;
  
  // Handle NaN/Infinity
  if (!isFinite(result) || isNaN(result)) {
    return x > a ? 1 : 0;
  }
  
  return Math.min(1, Math.max(0, result));
}

// Chi-square CDF
function chiSquareCDF(x, df) {
  if (x <= 0) return 0;
  if (df <= 0) return 0;
  // For very large chi-square values, CDF is essentially 1
  if (x > 1000) return 1;
  return lowerIncompleteGamma(df / 2, x / 2);
}

// Chi-square p-value (1 - CDF)
function chiSquarePValue(chiSq, df) {
  const cdf = chiSquareCDF(chiSq, df);
  const pVal = 1 - cdf;
  // Handle edge cases
  if (isNaN(pVal) || !isFinite(pVal)) {
    return chiSq > 100 ? 0 : 1; // Very large chi-square means very small p-value
  }
  return Math.max(0, Math.min(1, pVal));
}

// F distribution CDF using incomplete beta function
function fDistCDF(x, d1, d2) {
  if (x <= 0 || d1 <= 0 || d2 <= 0) return 0;
  if (!isFinite(x)) return 1;
  // F CDF = I(d1*x / (d1*x + d2); d1/2, d2/2)
  const z = (d1 * x) / (d1 * x + d2);
  return regularizedIncompleteBeta(z, d1 / 2, d2 / 2);
}

// Regularized incomplete beta function I_x(a, b)
function regularizedIncompleteBeta(x, a, b) {
  if (x <= 0) return 0;
  if (x >= 1) return 1;
  
  // Use continued fraction for numerical stability
  const lnBeta = lnGamma(a) + lnGamma(b) - lnGamma(a + b);
  const front = Math.exp(Math.log(x) * a + Math.log(1 - x) * b - lnBeta) / a;
  
  // Use symmetry relation if needed
  if (x > (a + 1) / (a + b + 2)) {
    return 1 - regularizedIncompleteBeta(1 - x, b, a);
  }
  
  // Continued fraction (Lentz's algorithm)
  const maxIter = 200;
  const eps = 1e-10;
  
  let f = 1, c = 1, d = 0;
  
  for (let m = 0; m <= maxIter; m++) {
    let numerator;
    if (m === 0) {
      numerator = 1;
    } else {
      const m2 = 2 * Math.floor((m + 1) / 2);
      if (m % 2 === 1) {
        // Odd terms
        const k = (m - 1) / 2;
        numerator = -(a + k) * (a + b + k) * x / ((a + 2 * k) * (a + 2 * k + 1));
      } else {
        // Even terms
        const k = m / 2;
        numerator = k * (b - k) * x / ((a + 2 * k - 1) * (a + 2 * k));
      }
    }
    
    d = 1 + numerator * d;
    if (Math.abs(d) < 1e-30) d = 1e-30;
    d = 1 / d;
    
    c = 1 + numerator / c;
    if (Math.abs(c) < 1e-30) c = 1e-30;
    
    const delta = c * d;
    f *= delta;
    
    if (Math.abs(delta - 1) < eps) break;
  }
  
  return Math.min(1, Math.max(0, front * (f - 1)));
}

// Log gamma function (Lanczos approximation)
function lnGamma(z) {
  if (z <= 0) return Infinity;
  const g = 7;
  const c = [
    0.99999999999980993,
    676.5203681218851,
    -1259.1392167224028,
    771.32342877765313,
    -176.61502916214059,
    12.507343278686905,
    -0.13857109526572012,
    9.9843695780195716e-6,
    1.5056327351493116e-7
  ];
  
  if (z < 0.5) {
    return Math.log(Math.PI / Math.sin(Math.PI * z)) - lnGamma(1 - z);
  }
  
  z -= 1;
  let x = c[0];
  for (let i = 1; i < g + 2; i++) {
    x += c[i] / (z + i);
  }
  
  const t = z + g + 0.5;
  return 0.5 * Math.log(2 * Math.PI) + (z + 0.5) * Math.log(t) - t + Math.log(x);
}

// Cramér's V (effect size)
function cramersV(chiSq, n, minDim) {
  if (n === 0 || minDim <= 1) return 0;
  return Math.sqrt(chiSq / (n * (minDim - 1)));
}

// Format p-value for display
function formatPValue(p) {
  if (p < 0.001) return '<0.001';
  if (p < 0.01) return p.toFixed(4);
  return p.toFixed(3);
}

// Get significance stars
function getSignificanceStars(p, alpha) {
  if (p < 0.001) return '***';
  if (p < 0.01) return '**';
  if (p < alpha) return '*';
  return '';
}

// Compute Chi-square test for a single feature
function computeSingleChiSquare(feature, rawData, groupNames, groupTotals) {
  // Get observed frequencies for each group
  const observed = groupNames.map(g => rawData[g][feature] || 0);
  const totalObserved = observed.reduce((a, b) => a + b, 0);
  
  if (totalObserved === 0) {
    return { error: 'No observations' };
  }
  
  // Calculate total tokens across all groups
  const totalTokens = groupNames.reduce((sum, g) => sum + (groupTotals[g] || 0), 0);
  
  if (totalTokens === 0) {
    return { error: 'No tokens' };
  }
  
  // Calculate expected frequencies
  // Expected = (group tokens / total tokens) * total observed for this feature
  const expected = groupNames.map(g => {
    const groupTokens = groupTotals[g] || 0;
    return (groupTokens / totalTokens) * totalObserved;
  });
  
  // Check for valid expected frequencies (should be > 0 for Chi-square)
  const validExpected = expected.filter(e => e > 0);
  if (validExpected.length < 2) {
    return { error: 'Not enough groups with data' };
  }
  
  // Calculate Chi-square statistic
  let chiSq = 0;
  const contributions = [];
  const stdResiduals = [];
  
  for (let i = 0; i < groupNames.length; i++) {
    if (expected[i] > 0) {
      const diff = observed[i] - expected[i];
      const contribution = (diff * diff) / expected[i];
      chiSq += contribution;
      contributions.push(contribution);
      stdResiduals.push(diff / Math.sqrt(expected[i]));
    } else {
      contributions.push(0);
      stdResiduals.push(0);
    }
  }
  
  // Degrees of freedom = number of groups with data - 1
  const df = validExpected.length - 1;
  
  if (df <= 0) {
    return { error: 'Insufficient degrees of freedom' };
  }
  
  // Calculate p-value
  const pValue = chiSquarePValue(chiSq, df);
  
  // Calculate Cramér's V
  const n = totalObserved;
  const minDim = Math.min(groupNames.length, 2); // For 1-way table, k = number of categories
  const v = cramersV(chiSq, n, groupNames.length);
  
  return {
    feature,
    chiSquare: chiSq,
    df,
    pValue,
    cramersV: v,
    observed,
    expected,
    stdResiduals,
    contributions,
    totalObserved,
    groupNames
  };
}

// Run Chi-square test
function runChiSquareTest() {
  const status = document.getElementById('chiSquareStatus');
  const summary = document.getElementById('chiSquareSummary');
  const resultsWrapper = document.getElementById('chiSquareResultsWrapper');
  const resultsBody = document.getElementById('chiSquareResultsBody');
  const detail = document.getElementById('chiSquareDetail');
  
  status.textContent = 'Computing...';
  summary.style.display = 'none';
  resultsWrapper.style.display = 'none';
  detail.style.display = 'none';
  chiSquareResults = null;
  
  // Check if frequency table data exists
  if (!freqTableData || !freqTableData.rawData || !freqTableData.groupNames || !freqTableData.features) {
    status.textContent = 'Please compute 9-a) Frequency Table first.';
    return;
  }
  
  // Use effective data (respects filters and deletions)
  const effectiveData = getEffectiveFreqTableData();
  if (!effectiveData || effectiveData.features.length === 0) {
    status.textContent = 'No features in frequency table (after filter/deletion).';
    return;
  }
  
  const { features } = effectiveData;
  const allGroupNames = effectiveData.groupNames;
  const allGroupTotals = effectiveData.groupTotals;
  
  // Get raw data for effective features and groups
  const rawData = {};
  allGroupNames.forEach(group => {
    rawData[group] = {};
    features.forEach(feature => {
      rawData[group][feature] = freqTableData.rawData[group]?.[feature] || 0;
    });
  });
  
  if (features.length === 0) {
    status.textContent = 'No features in frequency table.';
    return;
  }
  
  // Check comparison mode
  const compareMode = document.querySelector('input[name="chiSquareCompareMode"]:checked')?.value || 'perFolder';
  
  let groupNames = [];
  let groupTotals = {};
  let aggregatedRawData = {};
  let allFoldersUsed = [];
  
  if (compareMode === 'perFolder') {
    // ===== Per Folder Mode =====
    // Get selected folders for comparison
    let selectedFolders = getSelectedChiSquareFolders();
    
    // If no folders selected or dropdown not populated, use all folders
    if (selectedFolders.length === 0) {
      selectedFolders = [...allGroupNames];
    }
    
    // Filter to only folders that exist in the frequency table
    groupNames = selectedFolders.filter(f => allGroupNames.includes(f));
    allFoldersUsed = [...groupNames];
    
    if (groupNames.length < 2) {
      status.textContent = 'Need at least 2 folders selected for Chi-square test.';
      return;
    }
    
    // Use raw data as-is
    for (const g of groupNames) {
      groupTotals[g] = allGroupTotals[g];
      aggregatedRawData[g] = rawData[g];
    }
    
  } else {
    // ===== Custom Groups Mode =====
    const customGroups = getChiSquareCustomGroups();
    
    if (customGroups.length < 2) {
      status.textContent = 'Need at least 2 groups with folders selected for Chi-square test.';
      return;
    }
    
    // Check for duplicate folders across groups
    const usedFolders = new Set();
    for (const group of customGroups) {
      for (const folder of group.folders) {
        if (usedFolders.has(folder)) {
          status.textContent = `Folder "${folder}" is assigned to multiple groups. Each folder can only belong to one group.`;
          return;
        }
        usedFolders.add(folder);
      }
    }
    
    // Aggregate raw data by custom groups
    for (const group of customGroups) {
      const groupName = group.name;
      groupNames.push(groupName);
      allFoldersUsed.push(...group.folders);
      
      // Sum raw frequencies and totals across folders in this group
      groupTotals[groupName] = 0;
      aggregatedRawData[groupName] = {};
      
      for (const folder of group.folders) {
        if (!allGroupNames.includes(folder)) continue;
        
        // Add token count
        groupTotals[groupName] += allGroupTotals[folder] || 0;
        
        // Add raw frequencies for each feature
        for (const feature of features) {
          const freq = rawData[folder]?.[feature] || 0;
          aggregatedRawData[groupName][feature] = (aggregatedRawData[groupName][feature] || 0) + freq;
        }
      }
    }
  }
  
  // Get settings
  const scope = document.querySelector('input[name="chiSquareScope"]:checked')?.value || 'all';
  const useBonferroni = document.getElementById('chiSquareBonferroni')?.checked ?? true;
  const alpha = parseFloat(document.getElementById('chiSquareAlpha')?.value) || 0.05;
  const showSigOnly = document.getElementById('chiSquareShowSigOnly')?.checked ?? false;
  
  // Determine which features to test
  let featuresToTest = [];
  
  if (scope === 'selected') {
    // Get feature from input field
    const featureInput = document.getElementById('chiSquareFeatureInput')?.value?.trim();
    if (!featureInput) {
      status.textContent = 'Please enter a feature name to test.';
      return;
    }
    // Check if feature exists in the table (case-insensitive match)
    const matchedFeature = features.find(f => f.toLowerCase() === featureInput.toLowerCase());
    if (!matchedFeature) {
      status.textContent = `Feature "${featureInput}" not found in frequency table.`;
      return;
    }
    featuresToTest = [matchedFeature];
  } else {
    featuresToTest = [...features];
  }
  
  // Run Chi-square test for each feature (using aggregated data)
  const results = [];
  
  for (const feature of featuresToTest) {
    const result = computeSingleChiSquare(feature, aggregatedRawData, groupNames, groupTotals);
    if (!result.error) {
      results.push(result);
    }
  }
  
  if (results.length === 0) {
    status.textContent = 'No valid results. Features may have insufficient data.';
    return;
  }
  
  // Apply Bonferroni correction
  const numTests = results.length;
  const adjustedAlpha = useBonferroni ? alpha / numTests : alpha;
  
  for (const r of results) {
    r.pAdjusted = useBonferroni ? Math.min(r.pValue * numTests, 1) : r.pValue;
    r.isSignificant = r.pAdjusted < alpha;
  }
  
  // Sort by Chi-square (descending)
  results.sort((a, b) => b.chiSquare - a.chiSquare);
  
  // Filter if showSigOnly
  const displayResults = showSigOnly ? results.filter(r => r.isSignificant) : results;
  
  // Count significant results
  const sigCount = results.filter(r => r.isSignificant).length;
  
  // Store results
  chiSquareResults = {
    results,
    displayResults,
    groupNames,
    groupTotals,
    allFolders: allFoldersUsed,  // Store all folders used (for KWIC navigation)
    compareMode,  // Store comparison mode
    numTests,
    alpha,
    adjustedAlpha,
    useBonferroni,
    sigCount,
    featureType: freqTableData.featureType
  };
  
  // Display summary
  const correctionText = useBonferroni ? ` (Bonferroni adjusted, α=${adjustedAlpha.toFixed(4)})` : '';
  const unitText = compareMode === 'customGroups' ? 'groups' : 'folders';
  const compareText = groupNames.length <= 3 ? groupNames.join(', ') : `${groupNames.length} ${unitText}`;
  summary.innerHTML = `
    <strong>Results Summary:</strong> 
    Tested ${numTests} feature(s) | 
    <span style="color:${sigCount > 0 ? '#2a2' : '#666'};">
      Significant: ${sigCount}${correctionText}
    </span> | 
    Comparing: ${compareText}
  `;
  summary.style.display = 'block';
  
  // Display results table using render function
  resultsWrapper.style.display = 'block';
  renderChiSquareResultsTable();
  
  // Initialize column resizing and sorting
  initChiSquareColumnResizing();
  initChiSquareSortHandlers();
  
  status.textContent = `Chi-square test completed. ${displayResults.length} result(s) displayed.`;
  
  // Auto-show detail for first result if only one
  if (displayResults.length === 1) {
    showChiSquareDetail(displayResults[0].feature);
  }
}

// Initialize sort handlers for Chi-square tables
function initChiSquareSortHandlers() {
  // Results table sort handlers
  const resultsHeaders = document.querySelectorAll('#chiSquareResultsHead th.sortable');
  resultsHeaders.forEach(th => {
    th.onclick = (e) => {
      if (e.target.classList.contains('chi-col-resizer')) return;
      const sortCol = th.dataset.sort;
      if (sortCol) sortChiSquareResults(sortCol);
    };
  });
  
  // Detail table sort handlers
  const detailHeaders = document.querySelectorAll('#chiSquareDetailHead th.sortable');
  detailHeaders.forEach(th => {
    th.onclick = (e) => {
      if (e.target.classList.contains('chi-detail-resizer')) return;
      const sortCol = th.dataset.sort;
      if (sortCol) sortChiSquareDetail(sortCol);
    };
  });
}

// Show detail for a specific feature
function showChiSquareDetail(feature) {
  const detail = document.getElementById('chiSquareDetail');
  const title = document.getElementById('chiSquareDetailTitle');
  const body = document.getElementById('chiSquareDetailBody');
  
  if (!chiSquareResults || !chiSquareResults.results) {
    detail.style.display = 'none';
    return;
  }
  
  const result = chiSquareResults.results.find(r => r.feature === feature);
  if (!result) {
    detail.style.display = 'none';
    return;
  }
  
  // Store current feature for sorting
  currentChiSquareDetailFeature = feature;
  
  title.textContent = `Detail: "${feature}" (χ²=${result.chiSquare.toFixed(2)}, p=${formatPValue(result.pAdjusted)})`;
  
  // Build detail data
  const detailData = [];
  for (let i = 0; i < result.groupNames.length; i++) {
    detailData.push({
      folder: result.groupNames[i],
      observed: result.observed[i],
      expected: result.expected[i],
      stdRes: result.stdResiduals[i],
      contribution: result.contributions[i]
    });
  }
  
  // Sort detail data
  detailData.sort((a, b) => {
    let aVal, bVal;
    switch (chiSquareDetailSort.col) {
      case 'folder':
        aVal = a.folder.toLowerCase();
        bVal = b.folder.toLowerCase();
        break;
      case 'observed':
        aVal = a.observed;
        bVal = b.observed;
        break;
      case 'expected':
        aVal = a.expected;
        bVal = b.expected;
        break;
      case 'stdRes':
        aVal = a.stdRes;
        bVal = b.stdRes;
        break;
      default:
        aVal = a.stdRes;
        bVal = b.stdRes;
    }
    
    if (typeof aVal === 'string') {
      return chiSquareDetailSort.dir === 'asc' ? aVal.localeCompare(bVal) : bVal.localeCompare(aVal);
    }
    return chiSquareDetailSort.dir === 'asc' ? aVal - bVal : bVal - aVal;
  });
  
  // Render rows (with clickable Observed values)
  const rows = detailData.map(d => {
    const stdRes = d.stdRes;
    const absRes = Math.abs(stdRes);
    
    // Determine contribution bar
    let bar = '';
    let interpretation = '';
    
    if (stdRes > 0) {
      const width = Math.min(absRes * 20, 100);
      bar = `<div style="display:inline-block; width:${width}px; height:12px; background:#4a9;"></div>`;
      if (absRes > 2.58) interpretation = 'High ***';
      else if (absRes > 1.96) interpretation = 'High **';
      else if (absRes > 1.645) interpretation = 'High *';
      else interpretation = '-';
    } else if (stdRes < 0) {
      const width = Math.min(absRes * 20, 100);
      bar = `<div style="display:inline-block; width:${width}px; height:12px; background:#c66;"></div>`;
      if (absRes > 2.58) interpretation = 'Low ***';
      else if (absRes > 1.96) interpretation = 'Low **';
      else if (absRes > 1.645) interpretation = 'Low *';
      else interpretation = '-';
    } else {
      interpretation = '-';
    }
    
    // Make Observed clickable - navigate to KWIC with specific folder
    const escapedFeature = escapeHtml(feature).replace(/'/g, "\\'");
    const escapedFolder = escapeHtml(d.folder).replace(/'/g, "\\'");
    
    return `
      <tr>
        <td>${escapeHtml(d.folder)}</td>
        <td class="text-right">
          <span class="chi-observed-link" style="cursor:pointer; border-bottom:1px dashed #666; color:#2563eb;" 
                onclick="navigateToKwicFromChiSquareDetail('${escapedFeature}', '${escapedFolder}')"
                title="Click to search KWIC in this folder">
            ${d.observed}
          </span>
        </td>
        <td class="text-right">${d.expected.toFixed(1)}</td>
        <td class="text-right">${stdRes >= 0 ? '+' : ''}${stdRes.toFixed(2)}</td>
        <td>${bar} ${interpretation}</td>
      </tr>
    `;
  });
  
  body.innerHTML = rows.join('');
  detail.style.display = 'block';
  
  // Update detail sort indicators
  const detailHeaders = document.querySelectorAll('#chiSquareDetailHead th.sortable');
  detailHeaders.forEach(th => {
    th.classList.remove('sorted-asc', 'sorted-desc');
    if (th.dataset.sort === chiSquareDetailSort.col) {
      th.classList.add(chiSquareDetailSort.dir === 'asc' ? 'sorted-asc' : 'sorted-desc');
    }
  });
  
  // Highlight selected row in results table
  document.querySelectorAll('#chiSquareResultsBody tr').forEach(tr => {
    tr.classList.remove('selected');
    if (tr.dataset.feature === feature) {
      tr.classList.add('selected');
    }
  });
}

// Export Chi-square results to Excel
function exportChiSquareResults() {
  if (!chiSquareResults || !chiSquareResults.results || chiSquareResults.results.length === 0) {
    alert('No Chi-square results to export. Please run the test first.');
    return;
  }
  
  const { results, groupNames, groupTotals, useBonferroni, alpha, featureType } = chiSquareResults;
  
  // Build Excel content
  const wb = XLSX.utils.book_new();
  
  // Sheet 1: Summary results
  const summaryData = [
    ['Chi-square Distribution Test Results'],
    [''],
    ['Feature Type:', featureType || 'Unknown'],
    ['Compared Folders:', groupNames.join(', ')],
    ['Number of Folders:', groupNames.length],
    ['Number of Tests:', results.length],
    ['Bonferroni Correction:', useBonferroni ? 'Yes' : 'No'],
    ['Alpha:', alpha],
    ['Significant Results:', results.filter(r => r.isSignificant).length],
    [''],
    ['#', 'Feature', 'Chi-square', 'df', 'p-value', 'p-adjusted', "Cramér's V", 'Significant']
  ];
  
  results.forEach((r, idx) => {
    summaryData.push([
      idx + 1,
      r.feature,
      r.chiSquare,
      r.df,
      r.pValue,
      r.pAdjusted,
      r.cramersV,
      r.isSignificant ? 'Yes' : 'No'
    ]);
  });
  
  const ws1 = XLSX.utils.aoa_to_sheet(summaryData);
  XLSX.utils.book_append_sheet(wb, ws1, 'Summary');
  
  // Sheet 2: Detailed results (observed, expected, residuals)
  const detailHeaders = ['Feature', ...groupNames.map(g => g + '_Obs'), ...groupNames.map(g => g + '_Exp'), ...groupNames.map(g => g + '_StdRes')];
  const detailData = [detailHeaders];
  
  for (const r of results) {
    const row = [r.feature];
    row.push(...r.observed);
    row.push(...r.expected.map(e => e.toFixed(2)));
    row.push(...r.stdResiduals.map(s => s.toFixed(3)));
    detailData.push(row);
  }
  
  const ws2 = XLSX.utils.aoa_to_sheet(detailData);
  XLSX.utils.book_append_sheet(wb, ws2, 'Details');
  
  // Sheet 3: Group info
  const groupData = [
    ['Group', 'Tokens'],
    ...groupNames.map(g => [g, groupTotals[g] || 0])
  ];
  
  const ws3 = XLSX.utils.aoa_to_sheet(groupData);
  XLSX.utils.book_append_sheet(wb, ws3, 'Groups');
  
  // Download
  const filename = `chi_square_results_${new Date().toISOString().slice(0, 10)}.xlsx`;
  XLSX.writeFile(wb, filename);
}

// Clear Chi-square results
function clearChiSquareResults() {
  chiSquareResults = null;
  currentChiSquareDetailFeature = null;
  chiSquareSort = { col: 'chiSquare', dir: 'desc' };
  chiSquareDetailSort = { col: 'stdRes', dir: 'desc' };
  
  const status = document.getElementById('chiSquareStatus');
  const summary = document.getElementById('chiSquareSummary');
  const resultsWrapper = document.getElementById('chiSquareResultsWrapper');
  const resultsBody = document.getElementById('chiSquareResultsBody');
  const detail = document.getElementById('chiSquareDetail');
  
  if (status) status.textContent = '';
  if (summary) summary.style.display = 'none';
  if (resultsWrapper) resultsWrapper.style.display = 'none';
  if (resultsBody) resultsBody.innerHTML = '<tr><td colspan="9" class="text-xs">No results yet.</td></tr>';
  if (detail) detail.style.display = 'none';
}

// Navigate to KWIC from Chi-square results
function navigateToKwicFromChiSquare(feature) {
  // Clear previous filters
  clearKwicFilters();
  
  if (!freqTableData || !freqTableData.featureType) return;
  if (!chiSquareResults || !chiSquareResults.groupNames) return;
  
  const featureType = freqTableData.featureType;
  
  // Set up KWIC based on feature type
  const kwicFeatureInput = document.getElementById('kwicFeatureInput');
  const kwicTypeSelect = document.getElementById('kwicFeatureTypeSelect');
  
  if (kwicFeatureInput) kwicFeatureInput.value = feature;
  if (kwicTypeSelect) kwicTypeSelect.value = featureType;
  
  // Switch to Simple mode if in Advanced mode
  const advToggle = document.getElementById('kwicAdvancedModeToggle');
  if (advToggle && advToggle.checked) {
    advToggle.checked = false;
    document.getElementById('kwicSimpleMode').style.display = 'block';
    document.getElementById('kwicAdvancedMode').style.display = 'none';
  }
  
  // Set scope to Specific folder with the folders used in Chi-square test
  const scopeRadio = document.querySelector('input[name="kwicScope"][value="specific"]');
  if (scopeRadio) {
    scopeRadio.checked = true;
    handleKwicScopeChange();
  }
  
  // Get the folders used in Chi-square test
  // For custom groups mode, we need to get the actual folder names
  const compareMode = document.querySelector('input[name="chiSquareCompareMode"]:checked')?.value || 'perFolder';
  let foldersToSelect = [];
  
  if (compareMode === 'perFolder') {
    // Per folder mode: group names are folder names
    foldersToSelect = chiSquareResults.groupNames;
  } else {
    // Custom groups mode: get all folders from all groups
    foldersToSelect = chiSquareResults.allFolders || chiSquareResults.groupNames;
  }
  
  // Set the selected folders in KWIC
  setSelectedKwicFolders(foldersToSelect);
  
  // Scroll to KWIC section
  const kwicCard = document.getElementById('kwicCard');
  if (kwicCard) kwicCard.scrollIntoView({ behavior: 'smooth', block: 'start' });
  
  // Trigger KWIC computation
  currentKwicFeature = feature;
  currentKwicFeatureType = featureType;
  computeKwic();
}

// Navigate to KWIC from Chi-square Detail with specific folder/group
function navigateToKwicFromChiSquareDetail(feature, folderOrGroup) {
  // Clear previous filters
  clearKwicFilters();
  
  if (!freqTableData || !freqTableData.featureType) return;
  
  const featureType = freqTableData.featureType;
  
  // Set up KWIC based on feature type
  const kwicFeatureInput = document.getElementById('kwicFeatureInput');
  const kwicTypeSelect = document.getElementById('kwicFeatureTypeSelect');
  
  if (kwicFeatureInput) kwicFeatureInput.value = feature;
  if (kwicTypeSelect) kwicTypeSelect.value = featureType;
  
  // Switch to Simple mode if in Advanced mode
  const advToggle = document.getElementById('kwicAdvancedModeToggle');
  if (advToggle && advToggle.checked) {
    advToggle.checked = false;
    document.getElementById('kwicSimpleMode').style.display = 'block';
    document.getElementById('kwicAdvancedMode').style.display = 'none';
  }
  
  // Set scope to "Specific folder"
  const scopeRadio = document.querySelector('input[name="kwicScope"][value="specific"]');
  if (scopeRadio) {
    scopeRadio.checked = true;
    // Trigger scope change handler
    handleKwicScopeChange();
  }
  
  // Determine folders to select based on comparison mode
  let foldersToSelect = [];
  const compareMode = chiSquareResults?.compareMode || 'perFolder';
  
  if (compareMode === 'customGroups') {
    // In Custom Groups mode, get the folders for this group
    const customGroups = getChiSquareCustomGroups();
    const matchingGroup = customGroups.find(g => g.name === folderOrGroup);
    if (matchingGroup) {
      foldersToSelect = matchingGroup.folders;
    } else {
      // Fallback: use as folder name
      foldersToSelect = [folderOrGroup];
    }
  } else {
    // In Per Folder mode, use the folder directly
    foldersToSelect = [folderOrGroup];
  }
  
  // Select the folders in KWIC folder selector
  setSelectedKwicFolders(foldersToSelect);
  
  // Scroll to KWIC section
  const kwicCard = document.getElementById('kwicCard');
  if (kwicCard) kwicCard.scrollIntoView({ behavior: 'smooth', block: 'start' });
  
  // Trigger KWIC computation
  currentKwicFeature = feature;
  currentKwicFeatureType = featureType;
  computeKwic();
}

// ===== Visualization Functions =====
let vizData = null;
let vizResults = null;

function getVisualizationData() {
  // Get data from Frequency Table (Raw, DF, or Normalized only)
  // Use effective data (respects filters and deletions from 9-a)
  const effectiveData = getEffectiveFreqTableData();
  if (!effectiveData || !effectiveData.tableData || !effectiveData.groupNames || !effectiveData.features) {
    return null;
  }
  
  if (effectiveData.valueType === 'tfidf') {
    return { error: 'Please use Raw, Document Frequency (DF), or Normalized value type in Frequency Table for visualization.' };
  }
  
  const { tableData, groupNames, groupTotals } = effectiveData;
  
  // Get Top N columns setting (0 = use all)
  const topN = parseInt(document.getElementById('vizTopNColumns')?.value) || 0;
  
  // Apply Top N filter to features
  let features = effectiveData.features;
  if (topN > 0 && topN < features.length) {
    features = features.slice(0, topN);
  }
  
  // Build matrix: rows = groups, cols = features
  const matrix = [];
  for (const gName of groupNames) {
    const row = [];
    for (const feature of features) {
      row.push(tableData[gName][feature] || 0);
    }
    matrix.push(row);
  }
  
  return {
    matrix,
    rowLabels: groupNames,
    colLabels: features,
    rowTotals: groupNames.map(g => groupTotals[g] || 0)
  };
}

// Standardize data (z-score normalization)
function standardizeMatrix(matrix) {
  const n = matrix.length;
  const p = matrix[0].length;
  
  // Calculate mean and std for each column
  const means = [];
  const stds = [];
  for (let j = 0; j < p; j++) {
    let sum = 0;
    for (let i = 0; i < n; i++) sum += matrix[i][j];
    const mean = sum / n;
    means.push(mean);
    
    let sumSq = 0;
    for (let i = 0; i < n; i++) sumSq += (matrix[i][j] - mean) ** 2;
    const std = Math.sqrt(sumSq / n) || 1;
    stds.push(std);
  }
  
  // Standardize
  return matrix.map(row => row.map((v, j) => (v - means[j]) / stds[j]));
}

// Distance calculations
function euclideanDistance(a, b) {
  let sum = 0;
  for (let i = 0; i < a.length; i++) {
    sum += (a[i] - b[i]) ** 2;
  }
  return Math.sqrt(sum);
}

function euclidean2Distance(a, b) {
  let sum = 0;
  for (let i = 0; i < a.length; i++) {
    sum += (a[i] - b[i]) ** 2;
  }
  return sum; // Squared Euclidean
}

function manhattanDistance(a, b) {
  let sum = 0;
  for (let i = 0; i < a.length; i++) {
    sum += Math.abs(a[i] - b[i]);
  }
  return sum;
}

function maximumDistance(a, b) {
  let max = 0;
  for (let i = 0; i < a.length; i++) {
    max = Math.max(max, Math.abs(a[i] - b[i]));
  }
  return max;
}

function cosineDistance(a, b) {
  let dot = 0, normA = 0, normB = 0;
  for (let i = 0; i < a.length; i++) {
    dot += a[i] * b[i];
    normA += a[i] ** 2;
    normB += b[i] ** 2;
  }
  normA = Math.sqrt(normA);
  normB = Math.sqrt(normB);
  if (normA === 0 || normB === 0) return 1;
  return 1 - (dot / (normA * normB));
}

function correlationDistance(a, b) {
  const n = a.length;
  let sumA = 0, sumB = 0;
  for (let i = 0; i < n; i++) {
    sumA += a[i];
    sumB += b[i];
  }
  const meanA = sumA / n;
  const meanB = sumB / n;
  
  let num = 0, denA = 0, denB = 0;
  for (let i = 0; i < n; i++) {
    const dA = a[i] - meanA;
    const dB = b[i] - meanB;
    num += dA * dB;
    denA += dA * dA;
    denB += dB * dB;
  }
  
  if (denA === 0 || denB === 0) return 1;
  const corr = num / Math.sqrt(denA * denB);
  return 1 - corr; // Convert correlation to distance
}

function canberraDistance(a, b) {
  let sum = 0;
  for (let i = 0; i < a.length; i++) {
    const denom = Math.abs(a[i]) + Math.abs(b[i]);
    if (denom > 0) {
      sum += Math.abs(a[i] - b[i]) / denom;
    }
  }
  return sum;
}

function minkowskiDistance(a, b, p = 3) {
  let sum = 0;
  for (let i = 0; i < a.length; i++) {
    sum += Math.abs(a[i] - b[i]) ** p;
  }
  return sum ** (1 / p);
}

function jaccardDistance(a, b) {
  // For continuous data, use generalized Jaccard (Tanimoto)
  let dotProduct = 0, normA = 0, normB = 0;
  for (let i = 0; i < a.length; i++) {
    dotProduct += a[i] * b[i];
    normA += a[i] ** 2;
    normB += b[i] ** 2;
  }
  const denom = normA + normB - dotProduct;
  if (denom === 0) return 0;
  return 1 - (dotProduct / denom);
}

function getDistanceFunction(type) {
  switch (type) {
    case 'euclidean2': return euclidean2Distance;
    case 'manhattan': return manhattanDistance;
    case 'maximum': return maximumDistance;
    case 'cosine': return cosineDistance;
    case 'correlation': return correlationDistance;
    case 'canberra': return canberraDistance;
    case 'minkowski': return (a, b) => minkowskiDistance(a, b, 3);
    case 'jaccard': return jaccardDistance;
    default: return euclideanDistance;
  }
}

// Compute distance matrix
function computeDistanceMatrix(data, distanceType) {
  const n = data.length;
  const distFn = getDistanceFunction(distanceType);
  const dist = [];
  for (let i = 0; i < n; i++) {
    dist[i] = [];
    for (let j = 0; j < n; j++) {
      dist[i][j] = distFn(data[i], data[j]);
    }
  }
  return dist;
}

// K-means clustering
function computeKMeans(data, k, maxIter = 100, initMethod = 'kmeans++', distType = 'euclidean') {
  const n = data.length;
  const d = data[0].length;
  
  // Initialize centroids
  let centroids;
  if (initMethod === 'kmeans++') {
    centroids = kMeansPlusPlusInit(data, k, distType);
  } else {
    // Random initialization
    const indices = [];
    while (indices.length < k) {
      const idx = Math.floor(Math.random() * n);
      if (!indices.includes(idx)) indices.push(idx);
    }
    centroids = indices.map(i => [...data[i]]);
  }
  
  let assignments = new Array(n).fill(0);
  let iterations = 0;
  
  // Distance function
  const distFn = (a, b) => {
    if (distType === 'cosine') {
      let dot = 0, normA = 0, normB = 0;
      for (let i = 0; i < a.length; i++) {
        dot += a[i] * b[i];
        normA += a[i] * a[i];
        normB += b[i] * b[i];
      }
      return 1 - dot / (Math.sqrt(normA) * Math.sqrt(normB) || 1);
    } else if (distType === 'manhattan') {
      let sum = 0;
      for (let i = 0; i < a.length; i++) sum += Math.abs(a[i] - b[i]);
      return sum;
    } else {
      // Euclidean
      let sum = 0;
      for (let i = 0; i < a.length; i++) sum += (a[i] - b[i]) ** 2;
      return Math.sqrt(sum);
    }
  };
  
  for (let iter = 0; iter < maxIter; iter++) {
    iterations = iter + 1;
    
    // Assignment step
    const newAssignments = data.map(point => {
      let minDist = Infinity;
      let minCluster = 0;
      for (let c = 0; c < k; c++) {
        const dist = distFn(point, centroids[c]);
        if (dist < minDist) {
          minDist = dist;
          minCluster = c;
        }
      }
      return minCluster;
    });
    
    // Check convergence
    let converged = true;
    for (let i = 0; i < n; i++) {
      if (newAssignments[i] !== assignments[i]) {
        converged = false;
        break;
      }
    }
    assignments = newAssignments;
    
    if (converged) break;
    
    // Update step - recalculate centroids
    for (let c = 0; c < k; c++) {
      const members = data.filter((_, i) => assignments[i] === c);
      if (members.length > 0) {
        centroids[c] = Array(d).fill(0);
        for (const point of members) {
          for (let j = 0; j < d; j++) centroids[c][j] += point[j];
        }
        for (let j = 0; j < d; j++) centroids[c][j] /= members.length;
      }
    }
  }
  
  // Calculate within-cluster sum of squares
  const wcss = Array(k).fill(0);
  for (let i = 0; i < n; i++) {
    const c = assignments[i];
    wcss[c] += distFn(data[i], centroids[c]) ** 2;
  }
  
  // Simple PCA for 2D visualization
  const pca2D = simplePCA2D(data);
  const centroidsPCA = centroids.map(c => {
    return [
      c.reduce((s, v, j) => s + v * pca2D.loadings1[j], 0),
      c.reduce((s, v, j) => s + v * pca2D.loadings2[j], 0)
    ];
  });
  
  return {
    assignments,
    centroids,
    centroidsPCA,
    pca2D,
    wcss,
    iterations,
    k
  };
}

// K-means++ initialization
function kMeansPlusPlusInit(data, k, distType) {
  const n = data.length;
  const centroids = [];
  
  // Distance function
  const distFn = (a, b) => {
    if (distType === 'cosine') {
      let dot = 0, normA = 0, normB = 0;
      for (let i = 0; i < a.length; i++) {
        dot += a[i] * b[i];
        normA += a[i] * a[i];
        normB += b[i] * b[i];
      }
      return 1 - dot / (Math.sqrt(normA) * Math.sqrt(normB) || 1);
    } else {
      let sum = 0;
      for (let i = 0; i < a.length; i++) sum += (a[i] - b[i]) ** 2;
      return sum;
    }
  };
  
  // First centroid: random
  centroids.push([...data[Math.floor(Math.random() * n)]]);
  
  // Remaining centroids
  for (let c = 1; c < k; c++) {
    // Calculate distances to nearest centroid
    const distances = data.map(point => {
      let minDist = Infinity;
      for (const centroid of centroids) {
        const dist = distFn(point, centroid);
        if (dist < minDist) minDist = dist;
      }
      return minDist;
    });
    
    // Sample proportional to squared distance
    const totalDist = distances.reduce((a, b) => a + b, 0);
    let r = Math.random() * totalDist;
    for (let i = 0; i < n; i++) {
      r -= distances[i];
      if (r <= 0) {
        centroids.push([...data[i]]);
        break;
      }
    }
    if (centroids.length < c + 1) {
      centroids.push([...data[Math.floor(Math.random() * n)]]);
    }
  }
  
  return centroids;
}

// Simple PCA for 2D projection
function simplePCA2D(data) {
  const n = data.length;
  const d = data[0].length;
  
  // Center data
  const means = Array(d).fill(0);
  for (const row of data) {
    for (let j = 0; j < d; j++) means[j] += row[j];
  }
  for (let j = 0; j < d; j++) means[j] /= n;
  
  const centered = data.map(row => row.map((v, j) => v - means[j]));
  
  // Power iteration for first 2 components
  let v1 = Array(d).fill(0).map(() => Math.random() - 0.5);
  let norm = Math.sqrt(v1.reduce((s, x) => s + x * x, 0));
  v1 = v1.map(x => x / norm);
  
  // First component
  for (let iter = 0; iter < 50; iter++) {
    const Av = Array(d).fill(0);
    for (const row of centered) {
      const dot = row.reduce((s, x, j) => s + x * v1[j], 0);
      for (let j = 0; j < d; j++) Av[j] += dot * row[j];
    }
    norm = Math.sqrt(Av.reduce((s, x) => s + x * x, 0)) || 1;
    v1 = Av.map(x => x / norm);
  }
  
  // Deflate and get second component
  const deflated = centered.map(row => {
    const dot = row.reduce((s, x, j) => s + x * v1[j], 0);
    return row.map((x, j) => x - dot * v1[j]);
  });
  
  let v2 = Array(d).fill(0).map(() => Math.random() - 0.5);
  norm = Math.sqrt(v2.reduce((s, x) => s + x * x, 0));
  v2 = v2.map(x => x / norm);
  
  for (let iter = 0; iter < 50; iter++) {
    const Av = Array(d).fill(0);
    for (const row of deflated) {
      const dot = row.reduce((s, x, j) => s + x * v2[j], 0);
      for (let j = 0; j < d; j++) Av[j] += dot * row[j];
    }
    norm = Math.sqrt(Av.reduce((s, x) => s + x * x, 0)) || 1;
    v2 = Av.map(x => x / norm);
  }
  
  // Project data
  const coords = data.map(row => [
    row.reduce((s, v, j) => s + (v - means[j]) * v1[j], 0),
    row.reduce((s, v, j) => s + (v - means[j]) * v2[j], 0)
  ]);
  
  return { coords, loadings1: v1, loadings2: v2, means };
}

// Draw K-means plot
function drawKMeansPlot(ctx, kmeans, labels, width, height) {
  ctx.clearRect(0, 0, width, height);
  ctx.fillStyle = '#fff';
  ctx.fillRect(0, 0, width, height);
  
  const padding = { top: 60, right: 60, bottom: 60, left: 60 };
  const plotWidth = width - padding.left - padding.right;
  const plotHeight = height - padding.top - padding.bottom;
  
  const coords = kmeans.pca2D.coords;
  
  // Find data range
  let minX = Infinity, maxX = -Infinity;
  let minY = Infinity, maxY = -Infinity;
  
  for (const c of coords) {
    minX = Math.min(minX, c[0]);
    maxX = Math.max(maxX, c[0]);
    minY = Math.min(minY, c[1]);
    maxY = Math.max(maxY, c[1]);
  }
  
  // Add padding
  const rangeX = (maxX - minX) * 0.1 || 1;
  const rangeY = (maxY - minY) * 0.1 || 1;
  minX -= rangeX; maxX += rangeX;
  minY -= rangeY; maxY += rangeY;
  
  const scaleX = x => padding.left + ((x - minX) / (maxX - minX)) * plotWidth;
  const scaleY = y => padding.top + plotHeight - ((y - minY) / (maxY - minY)) * plotHeight;
  
  // Cluster colors
  const colors = ['#e41a1c', '#377eb8', '#4daf4a', '#984ea3', '#ff7f00', '#ffff33', '#a65628', '#f781bf', '#999999', '#66c2a5'];
  
  // Draw grid
  ctx.strokeStyle = '#e0e0e0';
  ctx.lineWidth = 0.5;
  for (let i = 0; i <= 5; i++) {
    const y = padding.top + (i / 5) * plotHeight;
    ctx.beginPath();
    ctx.moveTo(padding.left, y);
    ctx.lineTo(padding.left + plotWidth, y);
    ctx.stroke();
    
    const x = padding.left + (i / 5) * plotWidth;
    ctx.beginPath();
    ctx.moveTo(x, padding.top);
    ctx.lineTo(x, padding.top + plotHeight);
    ctx.stroke();
  }
  
  // Draw axes
  ctx.strokeStyle = '#333';
  ctx.lineWidth = 1;
  ctx.beginPath();
  ctx.moveTo(padding.left, padding.top);
  ctx.lineTo(padding.left, padding.top + plotHeight);
  ctx.lineTo(padding.left + plotWidth, padding.top + plotHeight);
  ctx.stroke();
  
  // Draw centroids (larger markers)
  for (let c = 0; c < kmeans.k; c++) {
    const cx = scaleX(kmeans.centroidsPCA[c][0]);
    const cy = scaleY(kmeans.centroidsPCA[c][1]);
    
    ctx.fillStyle = colors[c % colors.length];
    ctx.beginPath();
    ctx.arc(cx, cy, 12, 0, Math.PI * 2);
    ctx.fill();
    ctx.strokeStyle = '#333';
    ctx.lineWidth = 2;
    ctx.stroke();
    
    // Centroid label
    ctx.fillStyle = '#fff';
    ctx.font = 'bold 10px sans-serif';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText(`C${c + 1}`, cx, cy);
  }
  
  // Draw data points
  for (let i = 0; i < coords.length; i++) {
    const px = scaleX(coords[i][0]);
    const py = scaleY(coords[i][1]);
    const cluster = kmeans.assignments[i];
    
    ctx.fillStyle = colors[cluster % colors.length];
    ctx.beginPath();
    ctx.arc(px, py, 5, 0, Math.PI * 2);
    ctx.fill();
    ctx.strokeStyle = '#333';
    ctx.lineWidth = 1;
    ctx.stroke();
    
    // Label
    ctx.fillStyle = '#333';
    ctx.font = '9px sans-serif';
    ctx.textAlign = 'left';
    ctx.textBaseline = 'middle';
    const label = labels[i] || `P${i}`;
    ctx.fillText(label.length > 10 ? label.substring(0, 8) + '..' : label, px + 7, py);
  }
  
  // Title
  ctx.fillStyle = '#333';
  ctx.font = 'bold 14px sans-serif';
  ctx.textAlign = 'center';
  ctx.fillText(`K-Means Clustering (K=${kmeans.k})`, width / 2, 25);
  
  // Axis labels
  ctx.font = '12px sans-serif';
  ctx.fillText('PC1', width / 2, height - 15);
  
  ctx.save();
  ctx.translate(20, height / 2);
  ctx.rotate(-Math.PI / 2);
  ctx.fillText('PC2', 0, 0);
  ctx.restore();
  
  // Legend
  ctx.font = '10px sans-serif';
  for (let c = 0; c < kmeans.k; c++) {
    const lx = width - 100;
    const ly = padding.top + c * 18;
    
    ctx.fillStyle = colors[c % colors.length];
    ctx.beginPath();
    ctx.arc(lx, ly, 5, 0, Math.PI * 2);
    ctx.fill();
    
    ctx.fillStyle = '#333';
    ctx.textAlign = 'left';
    ctx.fillText(`Cluster ${c + 1}`, lx + 10, ly + 3);
  }
}

// Hierarchical clustering
function hierarchicalClustering(distMatrix, labels, linkage) {
  const n = distMatrix.length;
  const clusters = labels.map((label, i) => ({ id: i, label, members: [i], height: 0 }));
  const mergeHistory = [];
  const dist = distMatrix.map(row => [...row]);
  
  for (let step = 0; step < n - 1; step++) {
    // Find minimum distance
    let minDist = Infinity, minI = -1, minJ = -1;
    for (let i = 0; i < clusters.length; i++) {
      for (let j = i + 1; j < clusters.length; j++) {
        if (dist[clusters[i].id][clusters[j].id] < minDist) {
          minDist = dist[clusters[i].id][clusters[j].id];
          minI = i;
          minJ = j;
        }
      }
    }
    
    // Merge clusters
    const newCluster = {
      id: n + step,
      label: `(${clusters[minI].label},${clusters[minJ].label})`,
      members: [...clusters[minI].members, ...clusters[minJ].members],
      height: minDist,
      left: clusters[minI],
      right: clusters[minJ]
    };
    
    mergeHistory.push({
      merged: [clusters[minI].id, clusters[minJ].id],
      height: minDist,
      newId: newCluster.id
    });
    
    // Update distance matrix for new cluster
    for (let k = 0; k < clusters.length; k++) {
      if (k === minI || k === minJ) continue;
      const kId = clusters[k].id;
      const iId = clusters[minI].id;
      const jId = clusters[minJ].id;
      
      let newDist;
      if (linkage === 'single') {
        newDist = Math.min(dist[iId][kId], dist[jId][kId]);
      } else if (linkage === 'complete') {
        newDist = Math.max(dist[iId][kId], dist[jId][kId]);
      } else if (linkage === 'average') {
        const ni = clusters[minI].members.length;
        const nj = clusters[minJ].members.length;
        newDist = (ni * dist[iId][kId] + nj * dist[jId][kId]) / (ni + nj);
      } else if (linkage === 'mcquitty') {
        // WPGMA - Weighted Pair Group Method with Arithmetic Mean
        newDist = (dist[iId][kId] + dist[jId][kId]) / 2;
      } else if (linkage === 'median') {
        // WPGMC - Weighted Pair Group Method using Centroid
        newDist = Math.sqrt((dist[iId][kId] ** 2 + dist[jId][kId] ** 2) / 2 - minDist ** 2 / 4);
        if (isNaN(newDist)) newDist = (dist[iId][kId] + dist[jId][kId]) / 2;
      } else if (linkage === 'centroid') {
        // UPGMC - Unweighted Pair Group Method using Centroid
        const ni = clusters[minI].members.length;
        const nj = clusters[minJ].members.length;
        newDist = Math.sqrt((ni * dist[iId][kId] ** 2 + nj * dist[jId][kId] ** 2) / (ni + nj) - (ni * nj * minDist ** 2) / ((ni + nj) ** 2));
        if (isNaN(newDist)) newDist = (ni * dist[iId][kId] + nj * dist[jId][kId]) / (ni + nj);
      } else { // ward
        const ni = clusters[minI].members.length;
        const nj = clusters[minJ].members.length;
        const nk = clusters[k].members.length;
        newDist = Math.sqrt(((ni + nk) * dist[iId][kId] ** 2 + (nj + nk) * dist[jId][kId] ** 2 - nk * minDist ** 2) / (ni + nj + nk));
      }
      
      if (!dist[newCluster.id]) dist[newCluster.id] = [];
      dist[newCluster.id][kId] = newDist;
      dist[kId] = dist[kId] || [];
      dist[kId][newCluster.id] = newDist;
    }
    
    // Remove old clusters, add new
    clusters.splice(Math.max(minI, minJ), 1);
    clusters.splice(Math.min(minI, minJ), 1);
    clusters.push(newCluster);
  }
  
  return { root: clusters[0], mergeHistory };
}

// Draw dendrogram with enhanced options
function drawDendrogram(ctx, root, labels, width, height, options = {}) {
  const {
    horizontal = false,
    treeType = 'rectangle',
    numClusters = 0,
    showHeight = true
  } = options;
  
  ctx.clearRect(0, 0, width, height);
  ctx.fillStyle = '#fff';
  ctx.fillRect(0, 0, width, height);
  
  // Cluster colors
  const clusterColors = ['#e41a1c', '#377eb8', '#4daf4a', '#984ea3', '#ff7f00', '#ffff33', '#a65628', '#f781bf', '#999999', '#66c2a5', '#fc8d62', '#8da0cb', '#e78ac3', '#a6d854', '#ffd92f', '#e5c494', '#b3b3b3', '#8dd3c7', '#bebada', '#fb8072'];
  
  // Assign clusters if numClusters > 0
  let clusterAssignments = null;
  if (numClusters > 1) {
    clusterAssignments = new Map();
    const heights = [];
    function collectHeights(node) {
      if (node.height !== undefined && node.height > 0) heights.push(node.height);
      if (node.left) collectHeights(node.left);
      if (node.right) collectHeights(node.right);
    }
    collectHeights(root);
    heights.sort((a, b) => b - a);
    const cutHeight = heights[Math.min(numClusters - 1, heights.length - 1)] || 0;
    
    let clusterIdx = 0;
    function assignClusters(node, currentCluster) {
      if (!node.left && !node.right) {
        clusterAssignments.set(node.id, currentCluster);
        return;
      }
      if (node.height > cutHeight && currentCluster === -1) {
        assignClusters(node.left, clusterIdx++);
        assignClusters(node.right, clusterIdx++);
      } else {
        if (node.left) assignClusters(node.left, currentCluster);
        if (node.right) assignClusters(node.right, currentCluster);
      }
    }
    assignClusters(root, -1);
  }
  
  const padding = horizontal 
    ? { top: 40, right: 100, bottom: 40, left: 60 }
    : { top: 40, right: 40, bottom: 100, left: 60 };
  const plotWidth = width - padding.left - padding.right;
  const plotHeight = height - padding.top - padding.bottom;
  
  // Get leaf order
  const leafOrder = [];
  function getLeaves(node) {
    if (!node.left && !node.right) {
      leafOrder.push(node);
    } else {
      if (node.left) getLeaves(node.left);
      if (node.right) getLeaves(node.right);
    }
  }
  getLeaves(root);
  
  const n = leafOrder.length;
  const maxHeight = root.height || 1;
  
  // Position calculations differ for horizontal vs vertical
  const leafScale = horizontal ? plotHeight / n : plotWidth / n;
  const heightScale = horizontal ? plotWidth / maxHeight : plotHeight / maxHeight;
  
  // Assign positions to leaves
  const leafPos = new Map();
  const heightPos = new Map();
  
  leafOrder.forEach((leaf, i) => {
    if (horizontal) {
      leafPos.set(leaf.id, padding.top + (i + 0.5) * leafScale);
      heightPos.set(leaf.id, padding.left);
    } else {
      leafPos.set(leaf.id, padding.left + (i + 0.5) * leafScale);
      heightPos.set(leaf.id, padding.top + plotHeight);
    }
  });
  
  // Get color for a node based on cluster assignment
  function getNodeColor(node) {
    if (!clusterAssignments) return '#333';
    if (!node.left && !node.right) {
      const cluster = clusterAssignments.get(node.id);
      return cluster !== undefined ? clusterColors[cluster % clusterColors.length] : '#333';
    }
    // For internal nodes, check if all descendants are same cluster
    const leftCluster = node.left ? getLeafCluster(node.left) : -1;
    const rightCluster = node.right ? getLeafCluster(node.right) : -1;
    if (leftCluster === rightCluster && leftCluster !== -1) {
      return clusterColors[leftCluster % clusterColors.length];
    }
    return '#333';
  }
  
  function getLeafCluster(node) {
    if (!node.left && !node.right) {
      return clusterAssignments.get(node.id);
    }
    const leftCluster = node.left ? getLeafCluster(node.left) : -1;
    const rightCluster = node.right ? getLeafCluster(node.right) : -1;
    return leftCluster === rightCluster ? leftCluster : -1;
  }
  
  // Draw tree
  function drawNode(node) {
    if (!node.left && !node.right) {
      return { pos: leafPos.get(node.id), height: heightPos.get(node.id) };
    }
    
    const left = drawNode(node.left);
    const right = drawNode(node.right);
    const midPos = (left.pos + right.pos) / 2;
    
    let nodeHeight;
    if (horizontal) {
      nodeHeight = padding.left + node.height * heightScale;
    } else {
      nodeHeight = padding.top + (maxHeight - node.height) * heightScale;
    }
    
    leafPos.set(node.id, midPos);
    heightPos.set(node.id, nodeHeight);
    
    const color = getNodeColor(node);
    ctx.strokeStyle = color;
    ctx.lineWidth = 1.5;
    
    if (treeType === 'triangle') {
      // Triangle (phylogram) style - direct lines to parent
      ctx.beginPath();
      if (horizontal) {
        ctx.moveTo(left.height, left.pos);
        ctx.lineTo(nodeHeight, midPos);
        ctx.moveTo(right.height, right.pos);
        ctx.lineTo(nodeHeight, midPos);
      } else {
        ctx.moveTo(left.pos, left.height);
        ctx.lineTo(midPos, nodeHeight);
        ctx.moveTo(right.pos, right.height);
        ctx.lineTo(midPos, nodeHeight);
      }
      ctx.stroke();
    } else {
      // Rectangle style - L-shaped connections
      ctx.beginPath();
      if (horizontal) {
        ctx.moveTo(left.height, left.pos);
        ctx.lineTo(nodeHeight, left.pos);
        ctx.lineTo(nodeHeight, right.pos);
        ctx.lineTo(right.height, right.pos);
      } else {
        ctx.moveTo(left.pos, left.height);
        ctx.lineTo(left.pos, nodeHeight);
        ctx.lineTo(right.pos, nodeHeight);
        ctx.lineTo(right.pos, right.height);
      }
      ctx.stroke();
    }
    
    return { pos: midPos, height: nodeHeight };
  }
  drawNode(root);
  
  // Draw labels
  ctx.font = '11px sans-serif';
  
  leafOrder.forEach((leaf, i) => {
    const cluster = clusterAssignments ? clusterAssignments.get(leaf.id) : null;
    ctx.fillStyle = cluster !== null && cluster !== undefined ? clusterColors[cluster % clusterColors.length] : '#333';
    
    const label = labels[leaf.members[0]] || `Item ${leaf.members[0]}`;
    const displayLabel = label.length > 20 ? label.substring(0, 17) + '...' : label;
    
    if (horizontal) {
      const x = padding.left - 5;
      const y = padding.top + (i + 0.5) * leafScale;
      ctx.textAlign = 'right';
      ctx.textBaseline = 'middle';
      ctx.fillText(displayLabel, x, y);
    } else {
      const x = padding.left + (i + 0.5) * leafScale;
      const y = padding.top + plotHeight + 5;
      ctx.save();
      ctx.translate(x, y);
      ctx.rotate(Math.PI / 4);
      ctx.textAlign = 'left';
      ctx.textBaseline = 'top';
      ctx.fillText(displayLabel, 0, 0);
      ctx.restore();
    }
  });
  
  // Title
  ctx.fillStyle = '#333';
  ctx.font = 'bold 14px sans-serif';
  ctx.textAlign = 'center';
  ctx.textBaseline = 'top';
  ctx.fillText('Cluster Dendrogram', width / 2, 10);
  
  // Height axis
  if (showHeight) {
    ctx.strokeStyle = '#999';
    ctx.lineWidth = 1;
    ctx.font = '10px sans-serif';
    ctx.fillStyle = '#666';
    
    if (horizontal) {
      // Draw horizontal axis at bottom
      const axisY = padding.top + plotHeight + 20;
      ctx.beginPath();
      ctx.moveTo(padding.left, axisY);
      ctx.lineTo(padding.left + plotWidth, axisY);
      ctx.stroke();
      
      // Tick marks
      const numTicks = 5;
      for (let i = 0; i <= numTicks; i++) {
        const x = padding.left + (i / numTicks) * plotWidth;
        const val = (i / numTicks) * maxHeight;
        ctx.beginPath();
        ctx.moveTo(x, axisY);
        ctx.lineTo(x, axisY + 5);
        ctx.stroke();
        ctx.textAlign = 'center';
        ctx.textBaseline = 'top';
        ctx.fillText(val.toFixed(2), x, axisY + 7);
      }
      
      ctx.textAlign = 'center';
      ctx.fillText('Distance', padding.left + plotWidth / 2, axisY + 22);
    } else {
      // Draw vertical axis at left
      ctx.save();
      ctx.translate(15, height / 2);
      ctx.rotate(-Math.PI / 2);
      ctx.font = '12px sans-serif';
      ctx.textAlign = 'center';
      ctx.fillText('Distance', 0, 0);
      ctx.restore();
      
      // Tick marks on left
      const numTicks = 5;
      for (let i = 0; i <= numTicks; i++) {
        const y = padding.top + (i / numTicks) * plotHeight;
        const val = maxHeight - (i / numTicks) * maxHeight;
        ctx.beginPath();
        ctx.moveTo(padding.left - 5, y);
        ctx.lineTo(padding.left, y);
        ctx.stroke();
        ctx.textAlign = 'right';
        ctx.textBaseline = 'middle';
        ctx.fillText(val.toFixed(2), padding.left - 7, y);
      }
    }
  }
}

// PCA implementation
function computePCA(matrix) {
  const n = matrix.length;
  const p = matrix[0].length;
  
  // Center the data
  const means = [];
  for (let j = 0; j < p; j++) {
    let sum = 0;
    for (let i = 0; i < n; i++) sum += matrix[i][j];
    means.push(sum / n);
  }
  
  const centered = matrix.map(row => row.map((v, j) => v - means[j]));
  
  // Compute covariance matrix
  const cov = [];
  for (let i = 0; i < p; i++) {
    cov[i] = [];
    for (let j = 0; j < p; j++) {
      let sum = 0;
      for (let k = 0; k < n; k++) {
        sum += centered[k][i] * centered[k][j];
      }
      cov[i][j] = sum / (n - 1);
    }
  }
  
  // Power iteration to find principal components
  const numComponents = Math.min(3, p, n);
  const eigenvalues = [];
  const eigenvectors = [];
  const covCopy = cov.map(row => [...row]);
  
  for (let comp = 0; comp < numComponents; comp++) {
    // Initialize random vector
    let v = Array(p).fill(0).map(() => Math.random() - 0.5);
    let norm = Math.sqrt(v.reduce((s, x) => s + x * x, 0));
    v = v.map(x => x / norm);
    
    // Power iteration
    for (let iter = 0; iter < 100; iter++) {
      const newV = Array(p).fill(0);
      for (let i = 0; i < p; i++) {
        for (let j = 0; j < p; j++) {
          newV[i] += covCopy[i][j] * v[j];
        }
      }
      norm = Math.sqrt(newV.reduce((s, x) => s + x * x, 0));
      if (norm === 0) break;
      v = newV.map(x => x / norm);
    }
    
    // Compute eigenvalue
    let eigenvalue = 0;
    const Av = Array(p).fill(0);
    for (let i = 0; i < p; i++) {
      for (let j = 0; j < p; j++) {
        Av[i] += covCopy[i][j] * v[j];
      }
      eigenvalue += v[i] * Av[i];
    }
    
    eigenvalues.push(eigenvalue);
    eigenvectors.push(v);
    
    // Deflate
    for (let i = 0; i < p; i++) {
      for (let j = 0; j < p; j++) {
        covCopy[i][j] -= eigenvalue * v[i] * v[j];
      }
    }
  }
  
  // Project data
  const scores = centered.map(row => {
    return eigenvectors.map(ev => {
      let sum = 0;
      for (let j = 0; j < p; j++) sum += row[j] * ev[j];
      return sum;
    });
  });
  
  // Calculate variance explained
  const totalVariance = eigenvalues.reduce((s, v) => s + Math.abs(v), 0) || 1;
  const varianceExplained = eigenvalues.map(v => Math.abs(v) / totalVariance * 100);
  
  return {
    scores,
    loadings: eigenvectors,
    eigenvalues,
    varianceExplained,
    means
  };
}

// Draw PCA scatter plot
function drawPCAPlot(ctx, pcaResult, rowLabels, colLabels, width, height, showBiplot) {
  ctx.clearRect(0, 0, width, height);
  ctx.fillStyle = '#fff';
  ctx.fillRect(0, 0, width, height);
  
  const { scores, loadings, varianceExplained } = pcaResult;
  const padding = { top: 50, right: 100, bottom: 60, left: 70 };
  const plotWidth = width - padding.left - padding.right;
  const plotHeight = height - padding.top - padding.bottom;
  
  // Get data ranges
  let minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity;
  scores.forEach(s => {
    minX = Math.min(minX, s[0]);
    maxX = Math.max(maxX, s[0]);
    minY = Math.min(minY, s[1]);
    maxY = Math.max(maxY, s[1]);
  });
  
  if (showBiplot && loadings.length >= 2) {
    const scale = Math.max(Math.abs(maxX - minX), Math.abs(maxY - minY)) * 0.3;
    loadings[0].forEach((_, j) => {
      const lx = loadings[0][j] * scale;
      const ly = loadings[1][j] * scale;
      minX = Math.min(minX, lx);
      maxX = Math.max(maxX, lx);
      minY = Math.min(minY, ly);
      maxY = Math.max(maxY, ly);
    });
  }
  
  const rangeX = maxX - minX || 1;
  const rangeY = maxY - minY || 1;
  const scaleX = plotWidth / rangeX;
  const scaleY = plotHeight / rangeY;
  
  const toCanvasX = (x) => padding.left + (x - minX) * scaleX;
  const toCanvasY = (y) => padding.top + plotHeight - (y - minY) * scaleY;
  
  // Draw axes
  ctx.strokeStyle = '#ccc';
  ctx.lineWidth = 1;
  const zeroX = toCanvasX(0);
  const zeroY = toCanvasY(0);
  if (zeroX >= padding.left && zeroX <= width - padding.right) {
    ctx.beginPath();
    ctx.moveTo(zeroX, padding.top);
    ctx.lineTo(zeroX, padding.top + plotHeight);
    ctx.stroke();
  }
  if (zeroY >= padding.top && zeroY <= padding.top + plotHeight) {
    ctx.beginPath();
    ctx.moveTo(padding.left, zeroY);
    ctx.lineTo(padding.left + plotWidth, zeroY);
    ctx.stroke();
  }
  
  // Draw biplot vectors
  if (showBiplot && loadings.length >= 2) {
    const scale = Math.max(Math.abs(maxX - minX), Math.abs(maxY - minY)) * 0.3;
    ctx.strokeStyle = 'rgba(200, 0, 0, 0.5)';
    ctx.fillStyle = 'rgba(200, 0, 0, 0.8)';
    ctx.font = '9px sans-serif';
    
    const numLoadings = Math.min(loadings[0].length, 15);
    const loadingMags = loadings[0].map((v, i) => ({ idx: i, mag: Math.sqrt(v ** 2 + loadings[1][i] ** 2) }));
    loadingMags.sort((a, b) => b.mag - a.mag);
    
    for (let k = 0; k < numLoadings; k++) {
      const j = loadingMags[k].idx;
      const lx = loadings[0][j] * scale;
      const ly = loadings[1][j] * scale;
      
      ctx.beginPath();
      ctx.moveTo(toCanvasX(0), toCanvasY(0));
      ctx.lineTo(toCanvasX(lx), toCanvasY(ly));
      ctx.stroke();
      
      // Arrow head
      const angle = Math.atan2(-ly * scaleY, lx * scaleX);
      const arrowSize = 6;
      ctx.beginPath();
      ctx.moveTo(toCanvasX(lx), toCanvasY(ly));
      ctx.lineTo(toCanvasX(lx) - arrowSize * Math.cos(angle - 0.3), toCanvasY(ly) + arrowSize * Math.sin(angle - 0.3));
      ctx.moveTo(toCanvasX(lx), toCanvasY(ly));
      ctx.lineTo(toCanvasX(lx) - arrowSize * Math.cos(angle + 0.3), toCanvasY(ly) + arrowSize * Math.sin(angle + 0.3));
      ctx.stroke();
      
      const label = colLabels[j] || `F${j}`;
      ctx.fillText(label.length > 10 ? label.substring(0, 8) + '..' : label, toCanvasX(lx) + 3, toCanvasY(ly));
    }
  }
  
  // Draw points
  const colors = ['#1f77b4', '#ff7f0e', '#2ca02c', '#d62728', '#9467bd', '#8c564b', '#e377c2', '#7f7f7f', '#bcbd22', '#17becf'];
  ctx.font = '10px sans-serif';
  
  scores.forEach((s, i) => {
    const x = toCanvasX(s[0]);
    const y = toCanvasY(s[1]);
    
    ctx.fillStyle = colors[i % colors.length];
    ctx.beginPath();
    ctx.arc(x, y, 6, 0, Math.PI * 2);
    ctx.fill();
    
    ctx.fillStyle = '#333';
    const label = rowLabels[i] || `G${i}`;
    ctx.fillText(label.length > 15 ? label.substring(0, 12) + '...' : label, x + 8, y + 3);
  });
  
  // Title and axis labels
  ctx.fillStyle = '#333';
  ctx.font = 'bold 14px sans-serif';
  ctx.textAlign = 'center';
  ctx.fillText('Principal Component Analysis', width / 2, 20);
  
  ctx.font = '12px sans-serif';
  ctx.fillText(`PC1 (${varianceExplained[0]?.toFixed(1) || 0}%)`, width / 2, height - 15);
  
  ctx.save();
  ctx.translate(20, height / 2);
  ctx.rotate(-Math.PI / 2);
  ctx.fillText(`PC2 (${varianceExplained[1]?.toFixed(1) || 0}%)`, 0, 0);
  ctx.restore();
}

// Correspondence Analysis
function computeCorrespondenceAnalysis(matrix) {
  const n = matrix.length;
  const p = matrix[0].length;
  
  // Compute totals
  let grandTotal = 0;
  const rowTotals = Array(n).fill(0);
  const colTotals = Array(p).fill(0);
  
  for (let i = 0; i < n; i++) {
    for (let j = 0; j < p; j++) {
      grandTotal += matrix[i][j];
      rowTotals[i] += matrix[i][j];
      colTotals[j] += matrix[i][j];
    }
  }
  
  if (grandTotal === 0) return null;
  
  // Compute correspondence matrix
  const P = matrix.map(row => row.map(v => v / grandTotal));
  const r = rowTotals.map(v => v / grandTotal);
  const c = colTotals.map(v => v / grandTotal);
  
  // Compute standardized residuals
  const S = [];
  for (let i = 0; i < n; i++) {
    S[i] = [];
    for (let j = 0; j < p; j++) {
      const expected = r[i] * c[j];
      if (expected > 0 && r[i] > 0 && c[j] > 0) {
        S[i][j] = (P[i][j] - expected) / Math.sqrt(expected);
      } else {
        S[i][j] = 0;
      }
    }
  }
  
  // SVD approximation using power iteration
  const numDims = Math.min(3, n - 1, p - 1);
  const eigenvalues = [];
  const rowScores = Array(n).fill(0).map(() => []);
  const colScores = Array(p).fill(0).map(() => []);
  
  const SCopy = S.map(row => [...row]);
  
  for (let d = 0; d < numDims; d++) {
    // Power iteration for largest singular value
    let u = Array(n).fill(0).map(() => Math.random() - 0.5);
    let v = Array(p).fill(0).map(() => Math.random() - 0.5);
    
    for (let iter = 0; iter < 100; iter++) {
      // v = S'u
      const newV = Array(p).fill(0);
      for (let j = 0; j < p; j++) {
        for (let i = 0; i < n; i++) {
          newV[j] += SCopy[i][j] * u[i];
        }
      }
      let normV = Math.sqrt(newV.reduce((s, x) => s + x * x, 0));
      if (normV === 0) break;
      v = newV.map(x => x / normV);
      
      // u = Sv
      const newU = Array(n).fill(0);
      for (let i = 0; i < n; i++) {
        for (let j = 0; j < p; j++) {
          newU[i] += SCopy[i][j] * v[j];
        }
      }
      let normU = Math.sqrt(newU.reduce((s, x) => s + x * x, 0));
      if (normU === 0) break;
      u = newU.map(x => x / normU);
    }
    
    // Compute singular value
    let sigma = 0;
    for (let i = 0; i < n; i++) {
      for (let j = 0; j < p; j++) {
        sigma += u[i] * SCopy[i][j] * v[j];
      }
    }
    
    eigenvalues.push(sigma * sigma);
    
    // Store scores (scaled by sqrt of row/col masses)
    for (let i = 0; i < n; i++) {
      rowScores[i].push(r[i] > 0 ? u[i] * sigma / Math.sqrt(r[i]) : 0);
    }
    for (let j = 0; j < p; j++) {
      colScores[j].push(c[j] > 0 ? v[j] * sigma / Math.sqrt(c[j]) : 0);
    }
    
    // Deflate
    for (let i = 0; i < n; i++) {
      for (let j = 0; j < p; j++) {
        SCopy[i][j] -= sigma * u[i] * v[j];
      }
    }
  }
  
  const totalInertia = eigenvalues.reduce((s, v) => s + v, 0) || 1;
  const inertiaExplained = eigenvalues.map(v => v / totalInertia * 100);
  
  return {
    rowScores,
    colScores,
    eigenvalues,
    inertiaExplained,
    rowMasses: r,
    colMasses: c
  };
}

// Draw CA biplot
function drawCAPlot(ctx, caResult, rowLabels, colLabels, width, height, options = {}) {
  const {
    displayMode = 'biplot',  // 'biplot', 'rows', 'cols'
    dimX = 0,
    dimY = 1,
    rowMarker = 'circle',
    colMarker = 'star',
    showRowLabels = true,
    showColLabels = true,
    topColLabels = 30
  } = options;
  
  ctx.clearRect(0, 0, width, height);
  ctx.fillStyle = '#fff';
  ctx.fillRect(0, 0, width, height);
  
  const { rowScores, colScores, inertiaExplained } = caResult;
  const padding = { top: 50, right: 50, bottom: 60, left: 70 };
  const plotWidth = width - padding.left - padding.right;
  const plotHeight = height - padding.top - padding.bottom;
  
  const showRows = displayMode === 'biplot' || displayMode === 'rows';
  const showCols = displayMode === 'biplot' || displayMode === 'cols';
  
  // Get data ranges based on what we're showing
  let minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity;
  
  if (showRows) {
    rowScores.forEach(s => {
      if (s.length > Math.max(dimX, dimY)) {
        minX = Math.min(minX, s[dimX]);
        maxX = Math.max(maxX, s[dimX]);
        minY = Math.min(minY, s[dimY]);
        maxY = Math.max(maxY, s[dimY]);
      }
    });
  }
  
  if (showCols) {
    colScores.forEach(s => {
      if (s.length > Math.max(dimX, dimY)) {
        minX = Math.min(minX, s[dimX]);
        maxX = Math.max(maxX, s[dimX]);
        minY = Math.min(minY, s[dimY]);
        maxY = Math.max(maxY, s[dimY]);
      }
    });
  }
  
  // Handle edge case where no data
  if (!isFinite(minX)) { minX = -1; maxX = 1; minY = -1; maxY = 1; }
  
  // Add padding to range
  const rangeX = (maxX - minX) * 1.2 || 1;
  const rangeY = (maxY - minY) * 1.2 || 1;
  minX -= rangeX * 0.1;
  maxX += rangeX * 0.1;
  minY -= rangeY * 0.1;
  maxY += rangeY * 0.1;
  
  const scaleX = plotWidth / (maxX - minX);
  const scaleY = plotHeight / (maxY - minY);
  
  const toCanvasX = (x) => padding.left + (x - minX) * scaleX;
  const toCanvasY = (y) => padding.top + plotHeight - (y - minY) * scaleY;
  
  // Draw axes through origin
  ctx.strokeStyle = '#ccc';
  ctx.setLineDash([5, 5]);
  ctx.lineWidth = 1;
  const zeroX = toCanvasX(0);
  const zeroY = toCanvasY(0);
  if (zeroX >= padding.left && zeroX <= padding.left + plotWidth) {
    ctx.beginPath();
    ctx.moveTo(zeroX, padding.top);
    ctx.lineTo(zeroX, padding.top + plotHeight);
    ctx.stroke();
  }
  if (zeroY >= padding.top && zeroY <= padding.top + plotHeight) {
    ctx.beginPath();
    ctx.moveTo(padding.left, zeroY);
    ctx.lineTo(padding.left + plotWidth, zeroY);
    ctx.stroke();
  }
  ctx.setLineDash([]);
  
  // Helper to draw marker
  function drawMarker(x, y, type, size, fill = true) {
    ctx.beginPath();
    switch (type) {
      case 'star':
        // Draw asterisk/star
        ctx.font = `${size * 3}px sans-serif`;
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText('*', x, y);
        return;
      case 'square':
        ctx.rect(x - size, y - size, size * 2, size * 2);
        break;
      case 'triangle':
        ctx.moveTo(x, y - size);
        ctx.lineTo(x + size, y + size);
        ctx.lineTo(x - size, y + size);
        ctx.closePath();
        break;
      case 'diamond':
        ctx.moveTo(x, y - size);
        ctx.lineTo(x + size, y);
        ctx.lineTo(x, y + size);
        ctx.lineTo(x - size, y);
        ctx.closePath();
        break;
      default: // circle
        ctx.arc(x, y, size, 0, Math.PI * 2);
    }
    if (fill) ctx.fill();
    else ctx.stroke();
  }
  
  // Draw column points (features)
  if (showCols) {
    ctx.fillStyle = 'rgba(50, 50, 200, 0.7)';
    ctx.font = '9px sans-serif';
    
    // Sort by distance from origin for label selection
    const colMags = colScores.map((s, i) => ({ 
      idx: i, 
      mag: s.length > Math.max(dimX, dimY) ? Math.sqrt(s[dimX] ** 2 + s[dimY] ** 2) : 0 
    }));
    colMags.sort((a, b) => b.mag - a.mag);
    
    // Draw all points first
    colScores.forEach((s, j) => {
      if (s.length <= Math.max(dimX, dimY)) return;
      const x = toCanvasX(s[dimX]);
      const y = toCanvasY(s[dimY]);
      drawMarker(x, y, colMarker, 4);
    });
    
    // Draw labels for top N only
    if (showColLabels) {
      const numLabels = Math.min(colMags.length, topColLabels);
      ctx.fillStyle = 'rgba(50, 50, 200, 0.9)';
      ctx.textAlign = 'left';
      ctx.textBaseline = 'middle';
      
      for (let k = 0; k < numLabels; k++) {
        const j = colMags[k].idx;
        const s = colScores[j];
        if (s.length <= Math.max(dimX, dimY)) continue;
        
        const x = toCanvasX(s[dimX]);
        const y = toCanvasY(s[dimY]);
        
        const label = colLabels[j] || `F${j}`;
        const displayLabel = label.length > 15 ? label.substring(0, 12) + '..' : label;
        ctx.fillText(displayLabel, x + 6, y);
      }
    }
  }
  
  // Draw row points (groups)
  if (showRows) {
    const colors = ['#e41a1c', '#377eb8', '#4daf4a', '#984ea3', '#ff7f00', '#ffff33', '#a65628', '#f781bf', '#999999', '#66c2a5'];
    ctx.font = '10px sans-serif';
    
    rowScores.forEach((s, i) => {
      if (s.length <= Math.max(dimX, dimY)) return;
      const x = toCanvasX(s[dimX]);
      const y = toCanvasY(s[dimY]);
      
      ctx.fillStyle = colors[i % colors.length];
      drawMarker(x, y, rowMarker, 5);
      
      if (showRowLabels) {
        ctx.fillStyle = '#333';
        ctx.textAlign = 'left';
        ctx.textBaseline = 'middle';
        const label = rowLabels[i] || `G${i}`;
        ctx.fillText(label.length > 20 ? label.substring(0, 17) + '...' : label, x + 8, y);
      }
    });
  }
  
  // Title
  let title = 'Correspondence Analysis';
  if (displayMode === 'rows') title += ': Row Coordinates';
  else if (displayMode === 'cols') title += ': Column Coordinates';
  
  ctx.fillStyle = '#333';
  ctx.font = 'bold 14px sans-serif';
  ctx.textAlign = 'center';
  ctx.textBaseline = 'top';
  ctx.fillText(title, width / 2, 10);
  
  // Axis labels with variance explained
  const dimXLabel = `Dimension ${dimX + 1} (${inertiaExplained[dimX]?.toFixed(2) || 0}%)`;
  const dimYLabel = `Dimension ${dimY + 1} (${inertiaExplained[dimY]?.toFixed(2) || 0}%)`;
  
  ctx.font = '12px sans-serif';
  ctx.fillText(dimXLabel, width / 2, height - 15);
  
  ctx.save();
  ctx.translate(20, height / 2);
  ctx.rotate(-Math.PI / 2);
  ctx.fillText(dimYLabel, 0, 0);
  ctx.restore();
  
  // Legend
  if (displayMode === 'biplot') {
    ctx.font = '10px sans-serif';
    ctx.textAlign = 'left';
    const legendX = width - 100;
    const legendY = 50;
    
    ctx.fillStyle = '#e41a1c';
    drawMarker(legendX, legendY, rowMarker, 4);
    ctx.fillStyle = '#333';
    ctx.fillText('Groups', legendX + 10, legendY);
    
    ctx.fillStyle = 'rgba(50, 50, 200, 0.7)';
    drawMarker(legendX, legendY + 18, colMarker, 4);
    ctx.fillStyle = '#333';
    ctx.fillText('Features', legendX + 10, legendY + 18);
  }
}

// MDS (Classical / Metric)
function computeMDS(distMatrix, dimensions, method = 'classical') {
  const n = distMatrix.length;
  
  if (method === 'classical') {
    return computeClassicalMDS(distMatrix, dimensions);
  } else if (method === 'kruskal') {
    return computeNonmetricMDS(distMatrix, dimensions, 'kruskal');
  } else if (method === 'sammon') {
    return computeNonmetricMDS(distMatrix, dimensions, 'sammon');
  }
  return computeClassicalMDS(distMatrix, dimensions);
}

// Classical (Metric) MDS
function computeClassicalMDS(distMatrix, dimensions) {
  const n = distMatrix.length;
  
  // Double centering
  const rowMeans = Array(n).fill(0);
  const colMeans = Array(n).fill(0);
  let grandMean = 0;
  
  for (let i = 0; i < n; i++) {
    for (let j = 0; j < n; j++) {
      const d2 = distMatrix[i][j] ** 2;
      rowMeans[i] += d2;
      colMeans[j] += d2;
      grandMean += d2;
    }
  }
  
  for (let i = 0; i < n; i++) rowMeans[i] /= n;
  for (let j = 0; j < n; j++) colMeans[j] /= n;
  grandMean /= (n * n);
  
  // B matrix
  const B = [];
  for (let i = 0; i < n; i++) {
    B[i] = [];
    for (let j = 0; j < n; j++) {
      B[i][j] = -0.5 * (distMatrix[i][j] ** 2 - rowMeans[i] - colMeans[j] + grandMean);
    }
  }
  
  // Power iteration for eigendecomposition
  const coords = Array(n).fill(0).map(() => Array(dimensions).fill(0));
  const eigenvalues = [];
  const BCopy = B.map(row => [...row]);
  
  for (let d = 0; d < dimensions; d++) {
    let v = Array(n).fill(0).map(() => Math.random() - 0.5);
    let norm = Math.sqrt(v.reduce((s, x) => s + x * x, 0));
    v = v.map(x => x / norm);
    
    for (let iter = 0; iter < 100; iter++) {
      const newV = Array(n).fill(0);
      for (let i = 0; i < n; i++) {
        for (let j = 0; j < n; j++) {
          newV[i] += BCopy[i][j] * v[j];
        }
      }
      norm = Math.sqrt(newV.reduce((s, x) => s + x * x, 0));
      if (norm === 0) break;
      v = newV.map(x => x / norm);
    }
    
    let eigenvalue = 0;
    for (let i = 0; i < n; i++) {
      for (let j = 0; j < n; j++) {
        eigenvalue += v[i] * BCopy[i][j] * v[j];
      }
    }
    
    eigenvalues.push(eigenvalue);
    const sqrtEig = Math.sqrt(Math.max(0, eigenvalue));
    for (let i = 0; i < n; i++) {
      coords[i][d] = v[i] * sqrtEig;
    }
    
    // Deflate
    for (let i = 0; i < n; i++) {
      for (let j = 0; j < n; j++) {
        BCopy[i][j] -= eigenvalue * v[i] * v[j];
      }
    }
  }
  
  return { coords, eigenvalues, method: 'classical' };
}

// Non-metric MDS (Kruskal / Sammon)
function computeNonmetricMDS(distMatrix, dimensions, type) {
  const n = distMatrix.length;
  
  // Initialize with classical MDS
  const classical = computeClassicalMDS(distMatrix, dimensions);
  let coords = classical.coords.map(row => [...row]);
  
  const maxIter = 200;
  const learningRate = 0.01;
  
  for (let iter = 0; iter < maxIter; iter++) {
    const gradient = coords.map(() => Array(dimensions).fill(0));
    let stress = 0;
    
    for (let i = 0; i < n; i++) {
      for (let j = i + 1; j < n; j++) {
        // Compute current distance in embedding
        let embDist = 0;
        for (let d = 0; d < dimensions; d++) {
          embDist += (coords[i][d] - coords[j][d]) ** 2;
        }
        embDist = Math.sqrt(embDist) || 1e-10;
        
        const origDist = distMatrix[i][j] || 1e-10;
        const diff = embDist - origDist;
        
        if (type === 'kruskal') {
          // Kruskal stress
          stress += diff ** 2;
          const factor = diff / embDist;
          for (let d = 0; d < dimensions; d++) {
            const delta = factor * (coords[i][d] - coords[j][d]);
            gradient[i][d] += delta;
            gradient[j][d] -= delta;
          }
        } else {
          // Sammon stress (weighted by original distance)
          stress += (diff ** 2) / origDist;
          const factor = diff / (embDist * origDist);
          for (let d = 0; d < dimensions; d++) {
            const delta = factor * (coords[i][d] - coords[j][d]);
            gradient[i][d] += delta;
            gradient[j][d] -= delta;
          }
        }
      }
    }
    
    // Update coordinates
    for (let i = 0; i < n; i++) {
      for (let d = 0; d < dimensions; d++) {
        coords[i][d] -= learningRate * gradient[i][d];
      }
    }
  }
  
  return { coords, eigenvalues: classical.eigenvalues, method: type };
}

// Draw MDS plot
function drawMDSPlot(ctx, mdsResult, labels, width, height, options = {}) {
  const { dimX = 0, dimY = 1 } = options;
  
  ctx.clearRect(0, 0, width, height);
  ctx.fillStyle = '#fff';
  ctx.fillRect(0, 0, width, height);
  
  const { coords, method } = mdsResult;
  const padding = { top: 50, right: 50, bottom: 60, left: 70 };
  const plotWidth = width - padding.left - padding.right;
  const plotHeight = height - padding.top - padding.bottom;
  
  // Check dimensions available
  const maxDim = coords[0]?.length || 2;
  const dx = Math.min(dimX, maxDim - 1);
  const dy = Math.min(dimY, maxDim - 1);
  
  let minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity;
  coords.forEach(c => {
    minX = Math.min(minX, c[dx]);
    maxX = Math.max(maxX, c[dx]);
    minY = Math.min(minY, c[dy]);
    maxY = Math.max(maxY, c[dy]);
  });
  
  const rangeX = (maxX - minX) * 1.2 || 1;
  const rangeY = (maxY - minY) * 1.2 || 1;
  minX -= rangeX * 0.1;
  maxX += rangeX * 0.1;
  minY -= rangeY * 0.1;
  maxY += rangeY * 0.1;
  
  const scaleX = plotWidth / (maxX - minX);
  const scaleY = plotHeight / (maxY - minY);
  
  const toCanvasX = (x) => padding.left + (x - minX) * scaleX;
  const toCanvasY = (y) => padding.top + plotHeight - (y - minY) * scaleY;
  
  // Draw points
  const colors = ['#e41a1c', '#377eb8', '#4daf4a', '#984ea3', '#ff7f00', '#ffff33', '#a65628', '#f781bf', '#999999', '#66c2a5'];
  ctx.font = '10px sans-serif';
  
  coords.forEach((c, i) => {
    const x = toCanvasX(c[dx]);
    const y = toCanvasY(c[dy]);
    
    ctx.fillStyle = colors[i % colors.length];
    ctx.beginPath();
    ctx.arc(x, y, 6, 0, Math.PI * 2);
    ctx.fill();
    
    ctx.fillStyle = '#333';
    ctx.textAlign = 'left';
    ctx.textBaseline = 'middle';
    const label = labels[i] || `G${i}`;
    ctx.fillText(label.length > 15 ? label.substring(0, 12) + '...' : label, x + 8, y);
  });
  
  // Title
  const methodName = method === 'kruskal' ? 'Non-metric (Kruskal)' : 
                     method === 'sammon' ? 'Non-metric (Sammon)' : 'Classical (Metric)';
  ctx.fillStyle = '#333';
  ctx.font = 'bold 14px sans-serif';
  ctx.textAlign = 'center';
  ctx.fillText(`Multi-dimensional Scaling: Dim ${dx + 1} vs. Dim ${dy + 1}`, width / 2, 20);
  
  ctx.font = '12px sans-serif';
  ctx.fillText(`Dimension ${dx + 1}`, width / 2, height - 15);
  
  ctx.save();
  ctx.translate(20, height / 2);
  ctx.rotate(-Math.PI / 2);
  ctx.fillText(`Dimension ${dy + 1}`, 0, 0);
  ctx.restore();
}

// Draw 3D MDS plot with isometric projection
function drawMDS3DPlot(ctx, mdsResult, labels, width, height) {
  ctx.clearRect(0, 0, width, height);
  ctx.fillStyle = '#fff';
  ctx.fillRect(0, 0, width, height);
  
  const { coords, method } = mdsResult;
  const padding = { top: 60, right: 60, bottom: 80, left: 80 };
  const plotWidth = width - padding.left - padding.right;
  const plotHeight = height - padding.top - padding.bottom;
  
  // Get data ranges for all 3 dimensions
  let minX = Infinity, maxX = -Infinity;
  let minY = Infinity, maxY = -Infinity;
  let minZ = Infinity, maxZ = -Infinity;
  
  coords.forEach(c => {
    minX = Math.min(minX, c[0] || 0);
    maxX = Math.max(maxX, c[0] || 0);
    minY = Math.min(minY, c[1] || 0);
    maxY = Math.max(maxY, c[1] || 0);
    minZ = Math.min(minZ, c[2] || 0);
    maxZ = Math.max(maxZ, c[2] || 0);
  });
  
  // Add padding to ranges
  const rangeX = (maxX - minX) * 1.2 || 1;
  const rangeY = (maxY - minY) * 1.2 || 1;
  const rangeZ = (maxZ - minZ) * 1.2 || 1;
  minX -= rangeX * 0.1; maxX += rangeX * 0.1;
  minY -= rangeY * 0.1; maxY += rangeY * 0.1;
  minZ -= rangeZ * 0.1; maxZ += rangeZ * 0.1;
  
  // Isometric projection angles
  const angleX = Math.PI / 6; // 30 degrees
  const angleY = Math.PI / 6;
  
  // Scale factors
  const scaleX = plotWidth * 0.35;
  const scaleY = plotHeight * 0.35;
  const scaleZ = plotHeight * 0.35;
  
  // Center of plot
  const centerX = padding.left + plotWidth / 2;
  const centerY = padding.top + plotHeight / 2 + 30;
  
  // Convert 3D to 2D isometric projection
  function project(x, y, z) {
    // Normalize to -1 to 1 range
    const nx = ((x - minX) / (maxX - minX) - 0.5) * 2;
    const ny = ((y - minY) / (maxY - minY) - 0.5) * 2;
    const nz = ((z - minZ) / (maxZ - minZ) - 0.5) * 2;
    
    // Isometric projection
    const px = (nx - ny) * Math.cos(angleX) * scaleX;
    const py = -nz * scaleZ + (nx + ny) * Math.sin(angleY) * scaleY * 0.5;
    
    return { x: centerX + px, y: centerY + py };
  }
  
  // Draw axes
  ctx.strokeStyle = '#333';
  ctx.lineWidth = 1;
  
  // Origin
  const origin = project(minX, minY, minZ);
  const xEnd = project(maxX, minY, minZ);
  const yEnd = project(minX, maxY, minZ);
  const zEnd = project(minX, minY, maxZ);
  
  // X axis
  ctx.beginPath();
  ctx.moveTo(origin.x, origin.y);
  ctx.lineTo(xEnd.x, xEnd.y);
  ctx.stroke();
  
  // Y axis
  ctx.beginPath();
  ctx.moveTo(origin.x, origin.y);
  ctx.lineTo(yEnd.x, yEnd.y);
  ctx.stroke();
  
  // Z axis
  ctx.beginPath();
  ctx.moveTo(origin.x, origin.y);
  ctx.lineTo(zEnd.x, zEnd.y);
  ctx.stroke();
  
  // Draw grid lines on floor (XY plane at z=min)
  ctx.strokeStyle = '#ddd';
  ctx.lineWidth = 0.5;
  const gridSteps = 5;
  for (let i = 0; i <= gridSteps; i++) {
    const t = i / gridSteps;
    const gx = minX + t * (maxX - minX);
    const gy = minY + t * (maxY - minY);
    
    // Lines parallel to X axis
    const p1 = project(minX, gy, minZ);
    const p2 = project(maxX, gy, minZ);
    ctx.beginPath();
    ctx.moveTo(p1.x, p1.y);
    ctx.lineTo(p2.x, p2.y);
    ctx.stroke();
    
    // Lines parallel to Y axis
    const p3 = project(gx, minY, minZ);
    const p4 = project(gx, maxY, minZ);
    ctx.beginPath();
    ctx.moveTo(p3.x, p3.y);
    ctx.lineTo(p4.x, p4.y);
    ctx.stroke();
  }
  
  // Draw back walls
  ctx.strokeStyle = '#ccc';
  // YZ plane (at x=min)
  for (let i = 0; i <= gridSteps; i++) {
    const t = i / gridSteps;
    const gy = minY + t * (maxY - minY);
    const gz = minZ + t * (maxZ - minZ);
    
    // Vertical lines
    const p1 = project(minX, gy, minZ);
    const p2 = project(minX, gy, maxZ);
    ctx.beginPath();
    ctx.moveTo(p1.x, p1.y);
    ctx.lineTo(p2.x, p2.y);
    ctx.stroke();
    
    // Horizontal lines
    const p3 = project(minX, minY, gz);
    const p4 = project(minX, maxY, gz);
    ctx.beginPath();
    ctx.moveTo(p3.x, p3.y);
    ctx.lineTo(p4.x, p4.y);
    ctx.stroke();
  }
  
  // XZ plane (at y=max)
  for (let i = 0; i <= gridSteps; i++) {
    const t = i / gridSteps;
    const gx = minX + t * (maxX - minX);
    const gz = minZ + t * (maxZ - minZ);
    
    // Vertical lines
    const p1 = project(gx, maxY, minZ);
    const p2 = project(gx, maxY, maxZ);
    ctx.beginPath();
    ctx.moveTo(p1.x, p1.y);
    ctx.lineTo(p2.x, p2.y);
    ctx.stroke();
    
    // Horizontal lines
    const p3 = project(minX, maxY, gz);
    const p4 = project(maxX, maxY, gz);
    ctx.beginPath();
    ctx.moveTo(p3.x, p3.y);
    ctx.lineTo(p4.x, p4.y);
    ctx.stroke();
  }
  
  // Sort points by depth for proper rendering (back to front)
  const sortedPoints = coords.map((c, i) => ({
    coords: c,
    index: i,
    depth: (c[0] || 0) + (c[1] || 0) - (c[2] || 0)
  })).sort((a, b) => a.depth - b.depth);
  
  // Draw points
  const colors = ['#e41a1c', '#377eb8', '#4daf4a', '#984ea3', '#ff7f00', '#ffff33', '#a65628', '#f781bf', '#999999', '#66c2a5'];
  
  sortedPoints.forEach(point => {
    const c = point.coords;
    const i = point.index;
    const projected = project(c[0] || 0, c[1] || 0, c[2] || 0);
    
    ctx.fillStyle = colors[i % colors.length];
    ctx.beginPath();
    ctx.arc(projected.x, projected.y, 6, 0, Math.PI * 2);
    ctx.fill();
    ctx.strokeStyle = '#333';
    ctx.lineWidth = 1;
    ctx.stroke();
    
    // Label
    ctx.fillStyle = '#333';
    ctx.font = '10px sans-serif';
    ctx.textAlign = 'left';
    ctx.textBaseline = 'middle';
    const label = labels[i] || `G${i}`;
    ctx.fillText(label.length > 12 ? label.substring(0, 9) + '...' : label, projected.x + 8, projected.y);
  });
  
  // Axis labels
  ctx.fillStyle = '#333';
  ctx.font = '12px sans-serif';
  
  // X axis label
  ctx.textAlign = 'center';
  ctx.fillText('Dimension 1', xEnd.x + 20, xEnd.y + 15);
  
  // Y axis label  
  ctx.fillText('Dimension 2', yEnd.x - 20, yEnd.y + 15);
  
  // Z axis label
  ctx.save();
  ctx.translate(zEnd.x - 20, zEnd.y);
  ctx.rotate(-Math.PI / 2);
  ctx.fillText('Dimension 3', 0, 0);
  ctx.restore();
  
  // Title
  ctx.fillStyle = '#333';
  ctx.font = 'bold 14px sans-serif';
  ctx.textAlign = 'center';
  ctx.fillText('Multi-dimensional Scaling: Dim 1 vs. Dim 2 vs. Dim 3', width / 2, 20);
  
  // Axis tick labels
  ctx.font = '9px sans-serif';
  ctx.fillStyle = '#666';
  
  // X axis ticks
  ctx.textAlign = 'center';
  ctx.fillText(minX.toFixed(0), origin.x, origin.y + 15);
  ctx.fillText(maxX.toFixed(0), xEnd.x, xEnd.y + 15);
  
  // Y axis ticks
  ctx.fillText(minY.toFixed(0), origin.x, origin.y + 15);
  ctx.fillText(maxY.toFixed(0), yEnd.x, yEnd.y + 15);
  
  // Z axis ticks
  ctx.textAlign = 'right';
  ctx.fillText(minZ.toFixed(0), origin.x - 5, origin.y);
  ctx.fillText(maxZ.toFixed(0), zEnd.x - 5, zEnd.y);
}

// Heatmap
function drawHeatmap(ctx, data, width, height, options = {}) {
  const {
    colorScale = 'heat',
    clusterRows = true,
    clusterCols = true,
    standardize = true,
    scaling = 'none',
    distance = 'euclidean',
    linkage = 'ward'
  } = options;
  
  ctx.clearRect(0, 0, width, height);
  ctx.fillStyle = '#fff';
  ctx.fillRect(0, 0, width, height);
  
  const { matrix: origMatrix, rowLabels, colLabels } = data;
  
  // Apply standardization to data
  let matrix = origMatrix.map(row => [...row]);
  
  if (standardize) {
    // Z-score standardization per column
    const colMeans = [];
    const colStds = [];
    for (let j = 0; j < matrix[0].length; j++) {
      const col = matrix.map(row => row[j]);
      const mean = col.reduce((a, b) => a + b, 0) / col.length;
      const std = Math.sqrt(col.reduce((a, b) => a + (b - mean) ** 2, 0) / col.length) || 1;
      colMeans.push(mean);
      colStds.push(std);
    }
    matrix = matrix.map(row => row.map((v, j) => (v - colMeans[j]) / colStds[j]));
  }
  
  // Apply scaling
  if (scaling === 'row') {
    matrix = matrix.map(row => {
      const mean = row.reduce((a, b) => a + b, 0) / row.length;
      const std = Math.sqrt(row.reduce((a, b) => a + (b - mean) ** 2, 0) / row.length) || 1;
      return row.map(v => (v - mean) / std);
    });
  } else if (scaling === 'col') {
    const transposed = matrix[0].map((_, j) => matrix.map(row => row[j]));
    const scaled = transposed.map(col => {
      const mean = col.reduce((a, b) => a + b, 0) / col.length;
      const std = Math.sqrt(col.reduce((a, b) => a + (b - mean) ** 2, 0) / col.length) || 1;
      return col.map(v => (v - mean) / std);
    });
    matrix = matrix.map((_, i) => scaled.map(col => col[i]));
  }
  
  const dendroSpace = 60; // Space for dendrogram
  const padding = { 
    top: clusterCols ? 60 + dendroSpace : 60, 
    right: 30, 
    bottom: 120, 
    left: clusterRows ? 120 + dendroSpace : 120 
  };
  const plotWidth = width - padding.left - padding.right;
  const plotHeight = height - padding.top - padding.bottom;
  
  let rowOrder = rowLabels.map((_, i) => i);
  let colOrder = colLabels.map((_, i) => i);
  let rowTree = null, colTree = null;
  
  // Clustering for row ordering with dendrogram
  if (clusterRows && matrix.length > 1) {
    const distMatrix = computeDistanceMatrix(matrix, distance);
    const result = hierarchicalClustering(distMatrix, rowLabels, linkage);
    rowTree = result.root;
    rowOrder = [];
    function getRowOrder(node) {
      if (!node.left && !node.right) rowOrder.push(node.members[0]);
      else { if (node.left) getRowOrder(node.left); if (node.right) getRowOrder(node.right); }
    }
    getRowOrder(rowTree);
  }
  
  // Clustering for column ordering with dendrogram
  if (clusterCols && matrix[0].length > 1) {
    const transposed = colLabels.map((_, j) => matrix.map(row => row[j]));
    const distMatrix = computeDistanceMatrix(transposed, distance);
    const result = hierarchicalClustering(distMatrix, colLabels, linkage);
    colTree = result.root;
    colOrder = [];
    function getColOrder(node) {
      if (!node.left && !node.right) colOrder.push(node.members[0]);
      else { if (node.left) getColOrder(node.left); if (node.right) getColOrder(node.right); }
    }
    getColOrder(colTree);
  }
  
  const nRows = rowOrder.length;
  const nCols = colOrder.length;
  const cellWidth = plotWidth / nCols;
  const cellHeight = plotHeight / nRows;
  
  // Find min/max values for color mapping
  let minVal = Infinity, maxVal = -Infinity;
  for (const row of matrix) {
    for (const v of row) {
      minVal = Math.min(minVal, v);
      maxVal = Math.max(maxVal, v);
    }
  }
  const range = maxVal - minVal || 1;
  
  // Color scales
  const getColor = (val) => {
    const t = (val - minVal) / range;
    if (colorScale === 'heat') {
      // Heat: white -> yellow -> orange -> red
      const r = 255;
      const g = Math.round(255 * (1 - t * 0.7));
      const b = Math.round(255 * (1 - t));
      return `rgb(${r}, ${g}, ${b})`;
    } else if (colorScale === 'bluered') {
      const r = Math.round(t * 255);
      const b = Math.round((1 - t) * 255);
      return `rgb(${r}, ${Math.round(100 - 50 * Math.abs(t - 0.5))}, ${b})`;
    } else if (colorScale === 'greenred') {
      const r = Math.round(t * 255);
      const g = Math.round((1 - t) * 255);
      return `rgb(${r}, ${g}, 0)`;
    } else if (colorScale === 'plasma') {
      const r = Math.round(t * 240 + 15);
      const g = Math.round(t < 0.5 ? t * 200 : 200 - (t - 0.5) * 200);
      const b = Math.round((1 - t) * 200 + 55);
      return `rgb(${r}, ${g}, ${b})`;
    } else { // viridis
      const r = Math.round(68 + t * 120);
      const g = Math.round(1 + t * 200);
      const b = Math.round(84 + (1 - t) * 120);
      return `rgb(${r}, ${g}, ${b})`;
    }
  };
  
  // Draw row dendrogram
  if (clusterRows && rowTree) {
    const dendroWidth = dendroSpace - 10;
    const dendroX = padding.left - dendroSpace;
    
    // Calculate node positions
    const nodePositions = new Map();
    let leafIndex = 0;
    function calcRowPos(node) {
      if (!node.left && !node.right) {
        nodePositions.set(node, { y: padding.top + (leafIndex + 0.5) * cellHeight, height: node.height });
        leafIndex++;
      } else {
        if (node.left) calcRowPos(node.left);
        if (node.right) calcRowPos(node.right);
        const leftPos = nodePositions.get(node.left);
        const rightPos = nodePositions.get(node.right);
        nodePositions.set(node, { y: (leftPos.y + rightPos.y) / 2, height: node.height });
      }
    }
    calcRowPos(rowTree);
    
    // Find max height for scaling
    const maxHeight = rowTree.height || 1;
    
    // Draw dendrogram lines
    ctx.strokeStyle = '#333';
    ctx.lineWidth = 1;
    function drawRowDendro(node) {
      if (node.left && node.right) {
        const pos = nodePositions.get(node);
        const leftPos = nodePositions.get(node.left);
        const rightPos = nodePositions.get(node.right);
        
        const x = dendroX + dendroWidth * (1 - node.height / maxHeight);
        const leftX = dendroX + dendroWidth * (1 - node.left.height / maxHeight);
        const rightX = dendroX + dendroWidth * (1 - node.right.height / maxHeight);
        
        ctx.beginPath();
        ctx.moveTo(leftX, leftPos.y);
        ctx.lineTo(x, leftPos.y);
        ctx.lineTo(x, rightPos.y);
        ctx.lineTo(rightX, rightPos.y);
        ctx.stroke();
        
        drawRowDendro(node.left);
        drawRowDendro(node.right);
      }
    }
    drawRowDendro(rowTree);
  }
  
  // Draw column dendrogram
  if (clusterCols && colTree) {
    const dendroHeight = dendroSpace - 10;
    const dendroY = padding.top - dendroSpace;
    
    // Calculate node positions
    const nodePositions = new Map();
    let leafIndex = 0;
    function calcColPos(node) {
      if (!node.left && !node.right) {
        nodePositions.set(node, { x: padding.left + (leafIndex + 0.5) * cellWidth, height: node.height });
        leafIndex++;
      } else {
        if (node.left) calcColPos(node.left);
        if (node.right) calcColPos(node.right);
        const leftPos = nodePositions.get(node.left);
        const rightPos = nodePositions.get(node.right);
        nodePositions.set(node, { x: (leftPos.x + rightPos.x) / 2, height: node.height });
      }
    }
    calcColPos(colTree);
    
    // Find max height for scaling
    const maxHeight = colTree.height || 1;
    
    // Draw dendrogram lines
    ctx.strokeStyle = '#333';
    ctx.lineWidth = 1;
    function drawColDendro(node) {
      if (node.left && node.right) {
        const pos = nodePositions.get(node);
        const leftPos = nodePositions.get(node.left);
        const rightPos = nodePositions.get(node.right);
        
        const y = dendroY + dendroHeight * (1 - node.height / maxHeight);
        const leftY = dendroY + dendroHeight * (1 - node.left.height / maxHeight);
        const rightY = dendroY + dendroHeight * (1 - node.right.height / maxHeight);
        
        ctx.beginPath();
        ctx.moveTo(leftPos.x, leftY);
        ctx.lineTo(leftPos.x, y);
        ctx.lineTo(rightPos.x, y);
        ctx.lineTo(rightPos.x, rightY);
        ctx.stroke();
        
        drawColDendro(node.left);
        drawColDendro(node.right);
      }
    }
    drawColDendro(colTree);
  }
  
  // Draw cells
  for (let i = 0; i < nRows; i++) {
    for (let j = 0; j < nCols; j++) {
      const ri = rowOrder[i];
      const ci = colOrder[j];
      const val = matrix[ri][ci];
      
      ctx.fillStyle = getColor(val);
      ctx.fillRect(padding.left + j * cellWidth, padding.top + i * cellHeight, cellWidth, cellHeight);
    }
  }
  
  // Draw grid
  ctx.strokeStyle = '#fff';
  ctx.lineWidth = 0.5;
  for (let i = 0; i <= nRows; i++) {
    ctx.beginPath();
    ctx.moveTo(padding.left, padding.top + i * cellHeight);
    ctx.lineTo(padding.left + plotWidth, padding.top + i * cellHeight);
    ctx.stroke();
  }
  for (let j = 0; j <= nCols; j++) {
    ctx.beginPath();
    ctx.moveTo(padding.left + j * cellWidth, padding.top);
    ctx.lineTo(padding.left + j * cellWidth, padding.top + plotHeight);
    ctx.stroke();
  }
  
  // Row labels
  ctx.fillStyle = '#333';
  ctx.font = '10px sans-serif';
  ctx.textAlign = 'right';
  ctx.textBaseline = 'middle';
  for (let i = 0; i < nRows; i++) {
    const label = rowLabels[rowOrder[i]] || `R${i}`;
    ctx.fillText(label.length > 15 ? label.substring(0, 12) + '...' : label, padding.left - 5, padding.top + (i + 0.5) * cellHeight);
  }
  
  // Column labels
  ctx.textAlign = 'left';
  for (let j = 0; j < nCols; j++) {
    const label = colLabels[colOrder[j]] || `C${j}`;
    ctx.save();
    ctx.translate(padding.left + (j + 0.5) * cellWidth, padding.top + plotHeight + 5);
    ctx.rotate(Math.PI / 4);
    ctx.fillText(label.length > 15 ? label.substring(0, 12) + '...' : label, 0, 0);
    ctx.restore();
  }
  
  // Title
  ctx.fillStyle = '#333';
  ctx.font = 'bold 14px sans-serif';
  ctx.textAlign = 'center';
  ctx.textBaseline = 'top';
  ctx.fillText('Heatmap', width / 2, 10);
  
  // Color legend
  const legendWidth = 150;
  const legendHeight = 15;
  const legendX = width - padding.right - legendWidth - 30;
  const legendY = 15;
  
  for (let i = 0; i < legendWidth; i++) {
    ctx.fillStyle = getColor(minVal + (i / legendWidth) * range);
    ctx.fillRect(legendX + i, legendY, 1, legendHeight);
  }
  ctx.strokeStyle = '#333';
  ctx.strokeRect(legendX, legendY, legendWidth, legendHeight);
  
  ctx.font = '9px sans-serif';
  ctx.textAlign = 'left';
  ctx.fillStyle = '#333';
  ctx.fillText(minVal.toFixed(2), legendX, legendY + legendHeight + 10);
  ctx.textAlign = 'right';
  ctx.fillText(maxVal.toFixed(2), legendX + legendWidth, legendY + legendHeight + 10);
}

// ===== NETWORK GRAPH (linked with 6) Collocation Tables) =====

// Store network data for interactions
let currentNetworkData = null;

// Compute collocate network from 6) Collocation Tables data
function computeNetworkFromCollocate(options = {}) {
  const {
    centerNode = '',
    scope = 'target',
    spanL = 5,
    spanR = 5,
    position = 'all',  // 'all', 'left', 'right'
    edgeWeight = 'frequency',
    similarity = 'jaccard',  // 'jaccard', 'cosine', 'euclid', 'cooccur'
    communityDetection = true,
    showEdgeCoef = false,
    minSimilarity = 0.1,
    maxNodes = 50,
    maxEdges = 200,
    minFreq = 3,
    minScore = 0,
    excludeStopwords = true,
    lowercase = true
  } = options;
  
  // Check if collocateData exists (from 6) Collocation Tables)
  if (!collocateData || !collocateData.data) {
    return { error: 'No 6) Collocation Tables data. Please run "Compute" in 6) Collocation Tables first.' };
  }
  
  // Validate data structure
  const data = collocateData.data;
  if (!data.target || !data.reference) {
    return { error: 'Collocation data structure is invalid. Please re-run 6) Collocation Tables.' };
  }
  
  const center = lowercase ? (collocateData.node || centerNode).toLowerCase() : (collocateData.node || centerNode);
  
  if (!center) {
    return { error: 'Center node is not set.' };
  }
  
  // Use data from collocateData
  const targetHits = collocateData.totalTargetHits || 0;
  const refHits = collocateData.totalRefHits || 0;
  const targetTotalTokens = collocateData.targetTotalTokens || 1;
  const refTotalTokens = collocateData.refTotalTokens || 1;
  const targetWordFreq = collocateData.targetWordFreq || {};
  const refWordFreq = collocateData.refWordFreq || {};
  
  // Aggregate collocate data from positions
  const aggregateCollocates = (sideData, spanL, spanR, position) => {
    const result = {};  // word -> { freq, leftFreq, rightFreq, positions: {} }
    
    if (!sideData) return result;
    
    // Left collocates
    if (position !== 'right' && sideData.left) {
      for (let p = 1; p <= spanL; p++) {
        const posData = sideData.left[p] || {};
        for (const [word, count] of Object.entries(posData)) {
          const w = lowercase ? word.toLowerCase() : word;
          if (!result[w]) {
            result[w] = { freq: 0, leftFreq: 0, rightFreq: 0, positions: {} };
          }
          result[w].freq += count;
          result[w].leftFreq += count;
          result[w].positions[`L${p}`] = (result[w].positions[`L${p}`] || 0) + count;
        }
      }
    }
    
    // Right collocates
    if (position !== 'left' && sideData.right) {
      for (let p = 1; p <= spanR; p++) {
        const posData = sideData.right[p] || {};
        for (const [word, count] of Object.entries(posData)) {
          const w = lowercase ? word.toLowerCase() : word;
          if (!result[w]) {
            result[w] = { freq: 0, leftFreq: 0, rightFreq: 0, positions: {} };
          }
          result[w].freq += count;
          result[w].rightFreq += count;
          result[w].positions[`R${p}`] = (result[w].positions[`R${p}`] || 0) + count;
        }
      }
    }
    
    return result;
  };
  
  // Get target and reference collocates (with defensive checks)
  const targetCollocates = data.target ? aggregateCollocates(data.target, spanL, spanR, position) : {};
  const refCollocates = data.reference ? aggregateCollocates(data.reference, spanL, spanR, position) : {};
  
  // Calculate association score
  const calculateStat = (freq, corpusFreq, totalTokens, nodeHits) => {
    const N = totalTokens || 1;
    const O = freq;
    const f1 = nodeHits; // Node frequency
    const f2 = corpusFreq || freq; // Collocate corpus frequency
    const E = (f1 * f2) / N || 1;
    
    switch (edgeWeight) {
      case 'tscore': return (O - E) / Math.sqrt(O || 1);
      case 'zscore': return (O - E) / Math.sqrt(E || 1);
      case 'mi': return O > 0 ? Math.log2(O / E) : 0;
      case 'mi2': return O > 0 ? Math.log2(Math.pow(O, 2) / E) : 0;
      case 'mi3': return O > 0 ? Math.log2(Math.pow(O, 3) / E) : 0;
      case 'll': {
        const ll = (o, e) => o > 0 && e > 0 ? o * Math.log(o / e) : 0;
        const O11 = O, O12 = f1 - O, O21 = f2 - O, O22 = N - f1 - f2 + O;
        const E11 = E, E12 = f1 - E, E21 = f2 - E, E22 = N - f1 - f2 + E;
        return 2 * (ll(O11, E11) + ll(Math.max(0, O12), Math.max(0.001, E12)) + 
                   ll(Math.max(0, O21), Math.max(0.001, E21)) + ll(Math.max(0, O22), Math.max(0.001, E22)));
      }
      case 'logdice': return 14 + Math.log2((2 * O) / (f1 + f2) || 0.0001);
      case 'dice': return (2 * O) / (f1 + f2) || 0;
      case 'deltap': return (O / f1) - ((f2 - O) / (N - f1) || 0);
      default: return O; // frequency
    }
  };
  
  const nodes = [];
  const nodeMap = new Map();
  
  // Add center node
  nodes.push({
    id: 0,
    label: center,
    isCenter: true,
    freq: targetHits + refHits,
    freqT: targetHits,
    freqR: refHits,
    weight: 0,
    source: 'center',
    position: '-',
    positions: {}
  });
  nodeMap.set(center, 0);
  
  // Build collocate list
  const collocateList = [];
  
  // Process target collocates
  if (scope === 'target' || scope === 'all') {
    for (const [word, cData] of Object.entries(targetCollocates)) {
      if (cData.freq < minFreq) continue;
      if (word === center) continue;
      if (excludeStopwords && STOPWORDS.has(word)) continue;
      
      const score = calculateStat(cData.freq, targetWordFreq[word], targetTotalTokens, targetHits);
      if (score < minScore) continue;
      
      const pos = cData.leftFreq > cData.rightFreq ? 'L' : cData.rightFreq > cData.leftFreq ? 'R' : 'L/R';
      collocateList.push({
        word, freq: cData.freq, freqT: cData.freq, freqR: 0, score, source: 'target',
        position: pos, leftFreq: cData.leftFreq, rightFreq: cData.rightFreq, positions: cData.positions
      });
    }
  }
  
  // Process reference collocates
  if (scope === 'reference' || scope === 'all') {
    for (const [word, cData] of Object.entries(refCollocates)) {
      if (cData.freq < minFreq) continue;
      if (word === center) continue;
      if (excludeStopwords && STOPWORDS.has(word)) continue;
      
      const score = calculateStat(cData.freq, refWordFreq[word], refTotalTokens, refHits);
      if (score < minScore) continue;
      
      const existing = collocateList.find(c => c.word === word);
      if (existing) {
        // Word exists in both - mark as 'both'
        existing.freqR = cData.freq;
        existing.freq += cData.freq;
        existing.score = Math.max(existing.score, score);
        existing.source = 'both';
        existing.leftFreq += cData.leftFreq;
        existing.rightFreq += cData.rightFreq;
        // Merge positions
        for (const [p, n] of Object.entries(cData.positions)) {
          existing.positions[p] = (existing.positions[p] || 0) + n;
        }
      } else {
        const pos = cData.leftFreq > cData.rightFreq ? 'L' : cData.rightFreq > cData.leftFreq ? 'R' : 'L/R';
        collocateList.push({
          word, freq: cData.freq, freqT: 0, freqR: cData.freq, score, source: 'reference',
          position: pos, leftFreq: cData.leftFreq, rightFreq: cData.rightFreq, positions: cData.positions
        });
      }
    }
  }
  
  // Sort by score and take top N
  collocateList.sort((a, b) => b.score - a.score);
  const topCollocates = collocateList.slice(0, maxNodes - 1);
  
  if (topCollocates.length === 0) {
    return { 
      error: 'No collocates found. Please relax the filter conditions.',
      nodes: [nodes[0]],
      edges: [],
      centerWord: center,
      totalHits: targetHits + refHits,
      targetHits,
      refHits,
      spanL,
      spanR,
      edgeWeight
    };
  }
  
  // Add collocate nodes
  for (let i = 0; i < topCollocates.length; i++) {
    const c = topCollocates[i];
    nodes.push({
      id: i + 1,
      label: c.word,
      isCenter: false,
      freq: c.freq,
      freqT: c.freqT,
      freqR: c.freqR,
      weight: c.score,
      source: c.source,
      position: c.position,
      leftFreq: c.leftFreq,
      rightFreq: c.rightFreq,
      positions: c.positions
    });
    nodeMap.set(c.word, i + 1);
  }
  
  // Build edges
  const edges = [];
  
  // Primary edges: center to all collocates
  for (let i = 0; i < topCollocates.length; i++) {
    edges.push({
      source: 0,
      target: i + 1,
      weight: topCollocates[i].score,
      freq: topCollocates[i].freq,
      isSecondary: false,
      similarity: 1.0
    });
  }
  
  // Calculate similarity between collocates for secondary edges
  const calcSimilarity = (nodeI, nodeJ) => {
    // Build position vectors (with defensive checks)
    const positions = ['L1', 'L2', 'L3', 'L4', 'L5', 'R1', 'R2', 'R3', 'R4', 'R5'];
    const posI = nodeI.positions || {};
    const posJ = nodeJ.positions || {};
    const vecI = positions.map(p => posI[p] || 0);
    const vecJ = positions.map(p => posJ[p] || 0);
    
    if (similarity === 'jaccard') {
      // Jaccard similarity
      let intersection = 0, union = 0;
      for (let k = 0; k < vecI.length; k++) {
        const minVal = Math.min(vecI[k], vecJ[k]);
        const maxVal = Math.max(vecI[k], vecJ[k]);
        intersection += minVal;
        union += maxVal;
      }
      return union > 0 ? intersection / union : 0;
    } else if (similarity === 'cosine') {
      // Cosine similarity
      let dotProd = 0, normI = 0, normJ = 0;
      for (let k = 0; k < vecI.length; k++) {
        dotProd += vecI[k] * vecJ[k];
        normI += vecI[k] * vecI[k];
        normJ += vecJ[k] * vecJ[k];
      }
      return (Math.sqrt(normI) * Math.sqrt(normJ)) > 0 ? 
        dotProd / (Math.sqrt(normI) * Math.sqrt(normJ)) : 0;
    } else if (similarity === 'euclid') {
      // Euclidean distance converted to similarity
      let sumSq = 0;
      for (let k = 0; k < vecI.length; k++) {
        sumSq += Math.pow(vecI[k] - vecJ[k], 2);
      }
      return 1 / (1 + Math.sqrt(sumSq));
    } else {
      // Co-occurrence based (position match)
      const posI = nodeI.position;
      const posJ = nodeJ.position;
      return (posI === posJ && posI !== 'L/R') ? 0.5 : 0;
    }
  };
  
  // Secondary edges: between collocates based on similarity
  for (let i = 0; i < topCollocates.length; i++) {
    for (let j = i + 1; j < topCollocates.length; j++) {
      const sim = calcSimilarity(topCollocates[i], topCollocates[j]);
      if (sim >= minSimilarity) {
        edges.push({
          source: i + 1,
          target: j + 1,
          weight: Math.min(topCollocates[i].score, topCollocates[j].score) * sim,
          freq: 0,
          isSecondary: true,
          similarity: sim
        });
      }
    }
  }
  
  // Community detection (Louvain-inspired modularity optimization)
  let communities = null;
  if (communityDetection && nodes.length > 2) {
    communities = detectNetworkCommunities(nodes, edges);
    nodes.forEach((node, idx) => {
      node.community = communities[idx] || 0;
    });
  }
  
  return {
    nodes,
    edges: edges.slice(0, maxEdges),
    centerWord: center,
    totalHits: targetHits + refHits,
    targetHits,
    refHits,
    spanL,
    spanR,
    edgeWeight,
    similarity,
    showEdgeCoef,
    communities: communities ? [...new Set(Object.values(communities))].length : 0
  };
}

// Community detection using greedy modularity optimization (for network graph)
function detectNetworkCommunities(nodes, edges) {
  const n = nodes.length;
  const communities = {};
  
  // Initialize each node in its own community
  for (let i = 0; i < n; i++) {
    communities[i] = i;
  }
  
  // Build adjacency weights
  const adjWeight = {};
  let totalWeight = 0;
  for (const edge of edges) {
    const key = `${edge.source}-${edge.target}`;
    const keyRev = `${edge.target}-${edge.source}`;
    const w = edge.isSecondary ? edge.similarity : 1;
    adjWeight[key] = w;
    adjWeight[keyRev] = w;
    totalWeight += w * 2;
  }
  
  // Node weights (sum of incident edge weights)
  const nodeWeight = {};
  for (let i = 0; i < n; i++) {
    nodeWeight[i] = 0;
    for (const edge of edges) {
      if (edge.source === i || edge.target === i) {
        nodeWeight[i] += edge.isSecondary ? edge.similarity : 1;
      }
    }
  }
  
  // Greedy modularity optimization
  let improved = true;
  let iterations = 0;
  while (improved && iterations < 20) {
    improved = false;
    iterations++;
    
    for (let i = 1; i < n; i++) { // Skip center node
      const currentComm = communities[i];
      let bestComm = currentComm;
      let bestGain = 0;
      
      // Find neighbors' communities
      const neighborComms = new Set();
      for (const edge of edges) {
        if (edge.source === i) neighborComms.add(communities[edge.target]);
        if (edge.target === i) neighborComms.add(communities[edge.source]);
      }
      
      for (const comm of neighborComms) {
        if (comm === currentComm) continue;
        
        // Calculate modularity gain
        let sumIn = 0, sumTot = 0, ki = nodeWeight[i], kiIn = 0;
        
        for (let j = 0; j < n; j++) {
          if (communities[j] === comm) {
            sumTot += nodeWeight[j];
            const key = `${i}-${j}`;
            if (adjWeight[key]) kiIn += adjWeight[key];
          }
        }
        
        const m2 = totalWeight || 1;
        const gain = (kiIn / m2) - (sumTot * ki) / (m2 * m2);
        
        if (gain > bestGain) {
          bestGain = gain;
          bestComm = comm;
        }
      }
      
      if (bestComm !== currentComm) {
        communities[i] = bestComm;
        improved = true;
      }
    }
  }
  
  // Renumber communities to be consecutive
  const commMap = {};
  let nextComm = 0;
  for (let i = 0; i < n; i++) {
    const c = communities[i];
    if (commMap[c] === undefined) {
      commMap[c] = nextComm++;
    }
    communities[i] = commMap[c];
  }
  
  return communities;
}
// Apply layout to network nodes
function applyNetworkLayoutNew(nodes, edges, width, height, layout) {
  const padding = 80;
  const plotWidth = width - padding * 2;
  const plotHeight = height - padding * 2;
  const centerX = width / 2;
  const centerY = height / 2;
  
  if (layout === 'circular') {
    // Circular layout: center in middle, collocates around
    nodes[0].x = centerX;
    nodes[0].y = centerY;
    
    const n = nodes.length - 1;
    for (let i = 1; i < nodes.length; i++) {
      const angle = ((i - 1) / n) * 2 * Math.PI - Math.PI / 2;
      const radius = Math.min(plotWidth, plotHeight) * 0.4;
      nodes[i].x = centerX + radius * Math.cos(angle);
      nodes[i].y = centerY + radius * Math.sin(angle);
    }
  } else if (layout === 'grid') {
    // Grid layout
    nodes[0].x = centerX;
    nodes[0].y = padding + 30;
    
    const n = nodes.length - 1;
    const cols = Math.ceil(Math.sqrt(n));
    const rows = Math.ceil(n / cols);
    const cellW = plotWidth / cols;
    const cellH = (plotHeight - 60) / rows;
    
    for (let i = 1; i < nodes.length; i++) {
      const idx = i - 1;
      const col = idx % cols;
      const row = Math.floor(idx / cols);
      nodes[i].x = padding + cellW * (col + 0.5);
      nodes[i].y = padding + 80 + cellH * (row + 0.5);
    }
  } else {
    // Force-directed layout
    // Initialize positions
    nodes[0].x = centerX;
    nodes[0].y = centerY;
    
    for (let i = 1; i < nodes.length; i++) {
      const angle = Math.random() * 2 * Math.PI;
      const r = 100 + Math.random() * 150;
      nodes[i].x = centerX + r * Math.cos(angle);
      nodes[i].y = centerY + r * Math.sin(angle);
    }
    
    // Simulation
    const iterations = 150;
    for (let iter = 0; iter < iterations; iter++) {
      const forces = nodes.map(() => ({ fx: 0, fy: 0 }));
      const cooling = 1 - iter / iterations;
      
      // Repulsion between all nodes
      for (let i = 0; i < nodes.length; i++) {
        for (let j = i + 1; j < nodes.length; j++) {
          const dx = nodes[j].x - nodes[i].x;
          const dy = nodes[j].y - nodes[i].y;
          const dist = Math.sqrt(dx * dx + dy * dy) || 1;
          const force = 3000 / (dist * dist);
          const fx = (dx / dist) * force;
          const fy = (dy / dist) * force;
          forces[i].fx -= fx;
          forces[i].fy -= fy;
          forces[j].fx += fx;
          forces[j].fy += fy;
        }
      }
      
      // Attraction along edges
      for (const edge of edges) {
        const i = edge.source;
        const j = edge.target;
        const dx = nodes[j].x - nodes[i].x;
        const dy = nodes[j].y - nodes[i].y;
        const dist = Math.sqrt(dx * dx + dy * dy) || 1;
        const force = dist * 0.02;
        const fx = (dx / dist) * force;
        const fy = (dy / dist) * force;
        forces[i].fx += fx;
        forces[i].fy += fy;
        forces[j].fx -= fx;
        forces[j].fy -= fy;
      }
      
      // Center gravity
      for (let i = 1; i < nodes.length; i++) {
        forces[i].fx += (centerX - nodes[i].x) * 0.005;
        forces[i].fy += (centerY - nodes[i].y) * 0.005;
      }
      
      // Apply forces (keep center fixed)
      for (let i = 1; i < nodes.length; i++) {
        nodes[i].x += forces[i].fx * cooling;
        nodes[i].y += forces[i].fy * cooling;
        // Keep in bounds
        nodes[i].x = Math.max(padding, Math.min(width - padding, nodes[i].x));
        nodes[i].y = Math.max(padding, Math.min(height - padding, nodes[i].y));
      }
    }
  }
}

// Draw network graph
function drawNetworkGraph(ctx, data, width, height, options = {}) {
  const {
    nodeSizeBy = 'frequency',
    showLabels = true,
    layout = 'force'
  } = options;
  
  const { nodes, edges, centerWord, edgeWeight, showEdgeCoef, communities } = data;
  
  ctx.clearRect(0, 0, width, height);
  ctx.fillStyle = '#fff';
  ctx.fillRect(0, 0, width, height);
  
  // Apply layout
  applyNetworkLayoutNew(nodes, edges, width, height, layout);
  
  // Calculate node sizes
  const maxFreq = Math.max(...nodes.filter(n => !n.isCenter).map(n => n.freq)) || 1;
  const maxWeight = Math.max(...nodes.filter(n => !n.isCenter).map(n => Math.abs(n.weight))) || 1;
  
  nodes.forEach(node => {
    if (node.isCenter) {
      node.size = 22;
    } else if (nodeSizeBy === 'frequency') {
      node.size = 8 + 14 * (node.freq / maxFreq);
    } else if (nodeSizeBy === 'weight') {
      node.size = 8 + 14 * (Math.abs(node.weight) / maxWeight);
    } else {
      node.size = 12;
    }
  });
  
  // Community colors (KH Coder style)
  const communityColors = [
    '#7fc97f',  // green-teal (01)
    '#beaed4',  // purple (02)
    '#fdc086',  // orange (03)
    '#386cb0',  // blue (04)
    '#f0027f',  // pink (05)
    '#bf5b17',  // brown (06)
    '#ffff99',  // yellow (07)
    '#999999',  // gray (08)
  ];
  
  // Source colors (fallback if no community)
  const sourceColors = {
    center: '#333333',
    target: '#377eb8',
    reference: '#e41a1c',
    both: '#9467bd'
  };
  
  // Draw edges
  const maxEdgeWeight = Math.max(...edges.map(e => Math.abs(e.weight))) || 1;
  
  for (const edge of edges) {
    const source = nodes[edge.source];
    const target = nodes[edge.target];
    
    const normWeight = Math.abs(edge.weight) / maxEdgeWeight;
    const sim = edge.similarity || 0;
    
    // Edge style based on type
    if (edge.isSecondary) {
      ctx.strokeStyle = `rgba(100, 100, 100, ${0.2 + sim * 0.4})`;
      ctx.lineWidth = 0.5 + sim * 2;
      ctx.setLineDash([3, 3]);
    } else {
      ctx.strokeStyle = `rgba(80, 80, 100, ${0.4 + normWeight * 0.4})`;
      ctx.lineWidth = 1.5 + normWeight * 3;
      ctx.setLineDash([]);
    }
    
    ctx.beginPath();
    ctx.moveTo(source.x, source.y);
    ctx.lineTo(target.x, target.y);
    ctx.stroke();
    ctx.setLineDash([]);
    
    // Show edge coefficient
    if (showEdgeCoef && edge.similarity && edge.isSecondary) {
      const midX = (source.x + target.x) / 2;
      const midY = (source.y + target.y) / 2;
      ctx.fillStyle = '#666';
      ctx.font = '8px sans-serif';
      ctx.textAlign = 'center';
      ctx.fillText(edge.similarity.toFixed(2), midX, midY);
    }
  }
  
  // Draw nodes
  for (const node of nodes) {
    // Color based on community or source
    let fillColor;
    if (node.isCenter) {
      fillColor = sourceColors.center;
    } else if (node.community !== undefined && communities > 0) {
      fillColor = communityColors[node.community % communityColors.length];
    } else {
      fillColor = sourceColors[node.source] || sourceColors.target;
    }
    
    ctx.fillStyle = fillColor;
    ctx.beginPath();
    ctx.arc(node.x, node.y, node.size, 0, Math.PI * 2);
    ctx.fill();
    
    // Border
    ctx.strokeStyle = node.isCenter ? '#000' : '#555';
    ctx.lineWidth = node.isCenter ? 3 : 1;
    ctx.stroke();
    
    // Frequency label inside/near node
    if (!node.isCenter && node.freq) {
      ctx.fillStyle = '#333';
      ctx.font = '8px sans-serif';
      ctx.textAlign = 'left';
      ctx.textBaseline = 'middle';
      ctx.fillText(`.${node.freq}`, node.x + node.size + 2, node.y);
    }
    
    // Labels
    if (showLabels) {
      ctx.fillStyle = '#333';
      ctx.font = node.isCenter ? 'bold 12px sans-serif' : '10px sans-serif';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'bottom';
      const label = node.label.length > 15 ? node.label.substring(0, 13) + '..' : node.label;
      ctx.fillText(label, node.x, node.y - node.size - 3);
    }
  }
  
  // Title
  ctx.fillStyle = '#333';
  ctx.font = 'bold 14px sans-serif';
  ctx.textAlign = 'center';
  ctx.textBaseline = 'top';
  ctx.fillText(`Collocate Network: "${centerWord}" (${edgeWeight})`, width / 2, 10);
  
  // Legend - Community colors if available
  ctx.font = '10px sans-serif';
  ctx.textAlign = 'left';
  ctx.textBaseline = 'middle';
  
  if (communities > 0) {
    // Community legend on right side
    const legendX = width - 120;
    ctx.fillStyle = '#333';
    ctx.fillText('Community:', legendX, 35);
    
    for (let c = 0; c < Math.min(communities, 8); c++) {
      const y = 55 + c * 18;
      ctx.fillStyle = communityColors[c];
      ctx.beginPath();
      ctx.arc(legendX + 10, y, 6, 0, Math.PI * 2);
      ctx.fill();
      ctx.strokeStyle = '#555';
      ctx.lineWidth = 1;
      ctx.stroke();
      ctx.fillStyle = '#333';
      ctx.fillText(`0${c + 1}`, legendX + 20, y);
    }
    
    // Coefficient legend
    if (showEdgeCoef) {
      const coeffY = 55 + Math.min(communities, 8) * 18 + 15;
      ctx.fillStyle = '#333';
      ctx.fillText('Coefficient:', legendX, coeffY);
      ctx.strokeStyle = '#999';
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.moveTo(legendX, coeffY + 15);
      ctx.lineTo(legendX + 30, coeffY + 15);
      ctx.stroke();
      ctx.fillText('0.2', legendX + 35, coeffY + 15);
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(legendX, coeffY + 30);
      ctx.lineTo(legendX + 30, coeffY + 30);
      ctx.stroke();
      ctx.fillText('0.4', legendX + 35, coeffY + 30);
    }
  } else {
    // Source-based legend
    const legendY = height - 25;
    let legendX = 20;
    
    [
      { color: sourceColors.center, label: 'Center' },
      { color: sourceColors.target, label: 'Target' },
      { color: sourceColors.reference, label: 'Reference' },
      { color: sourceColors.both, label: 'Both' }
    ].forEach(item => {
      ctx.fillStyle = item.color;
      ctx.beginPath();
      ctx.arc(legendX, legendY, 5, 0, Math.PI * 2);
      ctx.fill();
      ctx.fillStyle = '#333';
      ctx.fillText(item.label, legendX + 8, legendY);
      legendX += ctx.measureText(item.label).width + 25;
    });
  }
  
  // Stats at bottom
  ctx.fillStyle = '#666';
  ctx.font = '9px sans-serif';
  ctx.textAlign = 'left';
  ctx.fillText(`N ${nodes.length}, E ${edges.length}${communities > 0 ? `, C ${communities}` : ''}`, 10, height - 8);
  
  return { nodes, edges };
}

// Export network to SVG
function exportNetworkToSvg(data, width, height, options = {}) {
  const { nodes, edges, centerWord, edgeWeight } = data;
  const { nodeSizeBy = 'frequency', showLabels = true } = options;
  
  // Calculate sizes
  const maxFreq = Math.max(...nodes.filter(n => !n.isCenter).map(n => n.freq)) || 1;
  const maxWeight = Math.max(...nodes.filter(n => !n.isCenter).map(n => Math.abs(n.weight))) || 1;
  const maxEdgeWeight = Math.max(...edges.map(e => Math.abs(e.weight))) || 1;
  
  nodes.forEach(node => {
    if (node.isCenter) node.size = 22;
    else if (nodeSizeBy === 'frequency') node.size = 8 + 14 * (node.freq / maxFreq);
    else if (nodeSizeBy === 'weight') node.size = 8 + 14 * (Math.abs(node.weight) / maxWeight);
    else node.size = 12;
  });
  
  const colors = { center: '#333333', target: '#377eb8', reference: '#e41a1c', both: '#9467bd' };
  
  let svg = `<?xml version="1.0" encoding="UTF-8"?>
<svg xmlns="http://www.w3.org/2000/svg" width="${width}" height="${height}" viewBox="0 0 ${width} ${height}">
<rect width="${width}" height="${height}" fill="white"/>
<text x="${width/2}" y="25" text-anchor="middle" font-weight="bold" font-size="14">Collocate Network: "${centerWord}" (${edgeWeight})</text>
`;
  
  // Edges
  for (const edge of edges) {
    const source = nodes[edge.source];
    const target = nodes[edge.target];
    const normWeight = Math.abs(edge.weight) / maxEdgeWeight;
    const opacity = edge.isSecondary ? 0.3 : 0.3 + normWeight * 0.5;
    const strokeWidth = edge.isSecondary ? 0.5 : 1 + normWeight * 3;
    svg += `<line x1="${source.x}" y1="${source.y}" x2="${target.x}" y2="${target.y}" stroke="rgb(100,100,150)" stroke-opacity="${opacity}" stroke-width="${strokeWidth}"/>
`;
  }
  
  // Nodes
  for (const node of nodes) {
    const color = node.isCenter ? colors.center : colors[node.source] || colors.target;
    const strokeWidth = node.isCenter ? 3 : 1;
    svg += `<circle cx="${node.x}" cy="${node.y}" r="${node.size}" fill="${color}" stroke="#333" stroke-width="${strokeWidth}"/>
`;
    if (showLabels) {
      const label = node.label.length > 15 ? node.label.substring(0, 13) + '..' : node.label;
      const fontSize = node.isCenter ? 12 : 9;
      const fontWeight = node.isCenter ? 'bold' : 'normal';
      svg += `<text x="${node.x}" y="${node.y - node.size - 3}" text-anchor="middle" font-size="${fontSize}" font-weight="${fontWeight}">${escapeHtml(label)}</text>
`;
    }
  }
  
  svg += '</svg>';
  return svg;
}

// Export network to CSV
function exportNetworkToCsv(data) {
  const { nodes, edges, centerWord, edgeWeight } = data;
  
  let csv = 'Node List\n';
  csv += 'Node,Frequency,Freq_T,Freq_R,Score,Source,Position,L_Freq,R_Freq\n';
  for (const node of nodes) {
    csv += `"${node.label}",${node.freq},${node.freqT || 0},${node.freqR || 0},${node.weight.toFixed(4)},${node.source},${node.position},${node.leftFreq || 0},${node.rightFreq || 0}\n`;
  }
  
  csv += '\nEdge List\n';
  csv += 'Source,Target,Weight,Frequency\n';
  for (const edge of edges) {
    csv += `"${nodes[edge.source].label}","${nodes[edge.target].label}",${edge.weight.toFixed(4)},${edge.freq || 0}\n`;
  }
  
  return csv;
}

// Community detection algorithms
function detectCommunities(nodes, edges, nodeMap, method) {
  const n = nodes.length;
  
  // Build adjacency list with weights
  const adj = nodes.map(() => []);
  for (const edge of edges) {
    const ni = nodeMap.get(edge.source);
    const nj = nodeMap.get(edge.target);
    if (ni !== undefined && nj !== undefined) {
      adj[ni].push({ neighbor: nj, weight: Math.abs(edge.weight) });
      adj[nj].push({ neighbor: ni, weight: Math.abs(edge.weight) });
    }
  }
  
  if (method === 'louvain' || method === 'leiden') {
    // Simplified Louvain algorithm
    // Initialize each node to its own community
    const community = nodes.map((_, i) => i);
    
    // Total edge weight
    let totalWeight = 0;
    for (const edge of edges) {
      totalWeight += Math.abs(edge.weight);
    }
    totalWeight = totalWeight * 2 || 1;
    
    // Node weights (sum of incident edge weights)
    const nodeWeight = nodes.map((_, i) => 
      adj[i].reduce((s, e) => s + e.weight, 0)
    );
    
    // Iterate until no improvement
    let improved = true;
    let iterations = 0;
    const maxIterations = 20;
    
    while (improved && iterations < maxIterations) {
      improved = false;
      iterations++;
      
      for (let i = 0; i < n; i++) {
        const currentCommunity = community[i];
        
        // Calculate weights to each neighboring community
        const communityWeights = {};
        communityWeights[currentCommunity] = 0;
        
        for (const { neighbor, weight } of adj[i]) {
          const nc = community[neighbor];
          communityWeights[nc] = (communityWeights[nc] || 0) + weight;
        }
        
        // Find best community (modularity gain)
        let bestCommunity = currentCommunity;
        let bestGain = 0;
        
        for (const [c, weightToC] of Object.entries(communityWeights)) {
          const cNum = parseInt(c);
          if (cNum === currentCommunity) continue;
          
          // Simplified modularity gain calculation
          const gain = weightToC - nodeWeight[i] * 
            nodes.filter((_, j) => community[j] === cNum)
              .reduce((s, _, j) => s + nodeWeight[j], 0) / totalWeight;
          
          if (gain > bestGain) {
            bestGain = gain;
            bestCommunity = cNum;
          }
        }
        
        if (bestCommunity !== currentCommunity) {
          community[i] = bestCommunity;
          improved = true;
        }
      }
    }
    
    // Renumber communities consecutively
    const communityMap = {};
    let nextCommunity = 0;
    for (let i = 0; i < n; i++) {
      if (!(community[i] in communityMap)) {
        communityMap[community[i]] = nextCommunity++;
      }
      nodes[i].community = communityMap[community[i]];
    }
  }
}

// Network layout algorithms
function applyNetworkLayout(nodes, edges, nodeMap, width, height, layout) {
  const n = nodes.length;
  const padding = 60;
  const plotWidth = width - 2 * padding;
  const plotHeight = height - 2 * padding;
  const centerX = width / 2;
  const centerY = height / 2;
  
  if (layout === 'radial') {
    // Radial layout based on degree
    const sortedNodes = [...nodes].sort((a, b) => b.degree - a.degree);
    const maxDegree = sortedNodes[0]?.degree || 1;
    
    // Place high-degree nodes in center, low-degree on outside
    sortedNodes.forEach((node, i) => {
      const ring = Math.floor((node.degree / maxDegree) * 3);
      const radius = (3 - ring) * Math.min(plotWidth, plotHeight) / 6 + 30;
      const angle = (2 * Math.PI * i) / n + Math.random() * 0.2;
      node.x = centerX + radius * Math.cos(angle);
      node.y = centerY + radius * Math.sin(angle);
    });
  } else if (layout === 'hierarchical') {
    // Hierarchical layout (top to bottom by degree)
    const sortedNodes = [...nodes].sort((a, b) => b.degree - a.degree);
    const levels = 4;
    const nodesPerLevel = Math.ceil(n / levels);
    
    sortedNodes.forEach((node, i) => {
      const level = Math.floor(i / nodesPerLevel);
      const posInLevel = i % nodesPerLevel;
      const levelCount = Math.min(nodesPerLevel, n - level * nodesPerLevel);
      
      node.y = padding + (level + 0.5) * (plotHeight / levels);
      node.x = padding + (posInLevel + 0.5) * (plotWidth / levelCount);
    });
  } else if (layout === 'kamada') {
    // Kamada-Kawai layout (simplified version using spring model)
    // Initialize with circular layout
    nodes.forEach((node, i) => {
      const angle = (2 * Math.PI * i) / n;
      const radius = Math.min(plotWidth, plotHeight) * 0.35;
      node.x = centerX + radius * Math.cos(angle);
      node.y = centerY + radius * Math.sin(angle);
    });
    
    // Spring-based optimization
    const idealDist = Math.min(plotWidth, plotHeight) / Math.sqrt(n);
    
    for (let iter = 0; iter < 100; iter++) {
      for (let i = 0; i < n; i++) {
        let fx = 0, fy = 0;
        
        for (let j = 0; j < n; j++) {
          if (i === j) continue;
          
          const dx = nodes[j].x - nodes[i].x;
          const dy = nodes[j].y - nodes[i].y;
          const dist = Math.sqrt(dx * dx + dy * dy) || 1;
          
          // Spring force
          const force = (dist - idealDist) / dist * 0.1;
          fx += dx * force;
          fy += dy * force;
        }
        
        nodes[i].x += fx;
        nodes[i].y += fy;
      }
      
      // Keep in bounds
      for (const node of nodes) {
        node.x = Math.max(padding, Math.min(width - padding, node.x));
        node.y = Math.max(padding, Math.min(height - padding, node.y));
      }
    }
  } else {
    // Force-directed layout (default)
    // Initialize with circular layout
    nodes.forEach((node, i) => {
      const angle = (2 * Math.PI * i) / n;
      const radius = Math.min(plotWidth, plotHeight) * 0.35;
      node.x = centerX + radius * Math.cos(angle);
      node.y = centerY + radius * Math.sin(angle);
    });
    
    // Force simulation
    for (let iter = 0; iter < 100; iter++) {
      // Repulsion between all nodes
      for (let i = 0; i < n; i++) {
        for (let j = i + 1; j < n; j++) {
          const dx = nodes[j].x - nodes[i].x;
          const dy = nodes[j].y - nodes[i].y;
          const dist = Math.sqrt(dx * dx + dy * dy) || 1;
          const force = 3000 / (dist * dist);
          const fx = (dx / dist) * force;
          const fy = (dy / dist) * force;
          nodes[i].x -= fx * 0.1;
          nodes[i].y -= fy * 0.1;
          nodes[j].x += fx * 0.1;
          nodes[j].y += fy * 0.1;
        }
      }
      
      // Attraction along edges
      for (const edge of edges) {
        const ni = nodeMap.get(edge.source);
        const nj = nodeMap.get(edge.target);
        if (ni === undefined || nj === undefined) continue;
        
        const dx = nodes[nj].x - nodes[ni].x;
        const dy = nodes[nj].y - nodes[ni].y;
        const dist = Math.sqrt(dx * dx + dy * dy) || 1;
        const force = dist * 0.01;
        nodes[ni].x += (dx / dist) * force;
        nodes[ni].y += (dy / dist) * force;
        nodes[nj].x -= (dx / dist) * force;
        nodes[nj].y -= (dy / dist) * force;
      }
      
      // Center gravity
      for (const node of nodes) {
        node.x += (centerX - node.x) * 0.01;
        node.y += (centerY - node.y) * 0.01;
      }
      
      // Keep in bounds
      for (const node of nodes) {
        node.x = Math.max(padding, Math.min(width - padding, node.x));
        node.y = Math.max(padding, Math.min(height - padding, node.y));
      }
    }
  }
}


// Random Forest Feature Importance (simplified permutation-based)
// Enhanced Random Forest with full options
function computeRandomForestFull(data, options = {}) {
  const {
    numTrees = 100,
    maxDepth = null,
    criterion = 'gini',
    maxFeatures = 'sqrt',
    topN = 20
  } = options;
  
  const { matrix, rowLabels, colLabels } = data;
  const n = matrix.length;
  const p = colLabels.length;
  
  if (n < 3) return null;
  
  // Get unique classes (based on rowLabels prefix - extract group identifier)
  const classLabels = [...new Set(rowLabels.map(label => {
    // Extract group prefix (e.g., "E-DM" from "E-DM1", "E-DM2")
    const match = label.match(/^([A-Za-z]+-[A-Za-z]+)/);
    return match ? match[1] : label;
  }))];
  
  const nClasses = classLabels.length;
  const classMap = {};
  classLabels.forEach((c, i) => classMap[c] = i);
  
  // Map each sample to its class
  const sampleClasses = rowLabels.map(label => {
    const match = label.match(/^([A-Za-z]+-[A-Za-z]+)/);
    const classLabel = match ? match[1] : label;
    return classMap[classLabel] || 0;
  });
  
  // Feature importance accumulator
  const featureImportance = Array(p).fill(0);
  
  // Out-of-bag predictions
  const oobPredictions = Array(n).fill(null).map(() => Array(nClasses).fill(0));
  const oobCount = Array(n).fill(0);
  
  // Build trees
  for (let t = 0; t < numTrees; t++) {
    // Bootstrap sample
    const inBag = new Set();
    const bagIndices = [];
    for (let i = 0; i < n; i++) {
      const idx = Math.floor(Math.random() * n);
      bagIndices.push(idx);
      inBag.add(idx);
    }
    
    // Build decision tree (simplified)
    const tree = buildDecisionTree(matrix, sampleClasses, bagIndices, {
      maxDepth,
      criterion,
      maxFeatures,
      nClasses,
      p,
      featureImportance
    });
    
    // OOB predictions
    for (let i = 0; i < n; i++) {
      if (!inBag.has(i)) {
        const pred = predictTree(tree, matrix[i]);
        oobPredictions[i][pred]++;
        oobCount[i]++;
      }
    }
  }
  
  // Calculate OOB accuracy
  let correct = 0;
  for (let i = 0; i < n; i++) {
    if (oobCount[i] > 0) {
      const pred = oobPredictions[i].indexOf(Math.max(...oobPredictions[i]));
      if (pred === sampleClasses[i]) correct++;
    }
  }
  const oobAccuracy = correct / n;
  
  // Normalize feature importance
  const totalImp = featureImportance.reduce((a, b) => a + b, 0) || 1;
  const importances = colLabels.map((feature, j) => ({
    feature,
    importance: featureImportance[j] / totalImp,
    index: j
  }));
  importances.sort((a, b) => b.importance - a.importance);
  
  // Confusion matrix
  const confusion = Array(nClasses).fill(null).map(() => Array(nClasses).fill(0));
  const predictions = [];
  for (let i = 0; i < n; i++) {
    const pred = oobCount[i] > 0 ? 
      oobPredictions[i].indexOf(Math.max(...oobPredictions[i])) : 
      sampleClasses[i];
    predictions.push(pred);
    confusion[sampleClasses[i]][pred]++;
  }
  
  return {
    importances: importances.slice(0, topN),
    oobAccuracy,
    confusion,
    classLabels,
    predictions,
    numTrees
  };
}

// Simple decision tree builder
function buildDecisionTree(data, classes, indices, options, depth = 0) {
  const { maxDepth, criterion, maxFeatures, nClasses, p, featureImportance } = options;
  
  // Count classes in current node
  const classCounts = Array(nClasses).fill(0);
  for (const idx of indices) {
    classCounts[classes[idx]]++;
  }
  
  // Leaf node conditions
  const totalSamples = indices.length;
  const maxClass = classCounts.indexOf(Math.max(...classCounts));
  
  if (totalSamples < 2 || (maxDepth && depth >= maxDepth) || classCounts[maxClass] === totalSamples) {
    return { isLeaf: true, prediction: maxClass };
  }
  
  // Select features to consider
  let numFeatures;
  if (maxFeatures === 'sqrt') numFeatures = Math.ceil(Math.sqrt(p));
  else if (maxFeatures === 'log2') numFeatures = Math.ceil(Math.log2(p));
  else numFeatures = p;
  
  const featureIndices = [];
  while (featureIndices.length < numFeatures) {
    const f = Math.floor(Math.random() * p);
    if (!featureIndices.includes(f)) featureIndices.push(f);
  }
  
  // Find best split
  let bestFeature = -1;
  let bestThreshold = 0;
  let bestGain = -Infinity;
  
  for (const f of featureIndices) {
    const values = indices.map(idx => data[idx][f]);
    const sorted = [...new Set(values)].sort((a, b) => a - b);
    
    for (let i = 0; i < sorted.length - 1; i++) {
      const threshold = (sorted[i] + sorted[i + 1]) / 2;
      
      const leftCounts = Array(nClasses).fill(0);
      const rightCounts = Array(nClasses).fill(0);
      let leftTotal = 0, rightTotal = 0;
      
      for (const idx of indices) {
        if (data[idx][f] <= threshold) {
          leftCounts[classes[idx]]++;
          leftTotal++;
        } else {
          rightCounts[classes[idx]]++;
          rightTotal++;
        }
      }
      
      if (leftTotal === 0 || rightTotal === 0) continue;
      
      // Calculate impurity
      const parentImpurity = calculateImpurity(classCounts, totalSamples, criterion);
      const leftImpurity = calculateImpurity(leftCounts, leftTotal, criterion);
      const rightImpurity = calculateImpurity(rightCounts, rightTotal, criterion);
      
      const gain = parentImpurity - 
        (leftTotal / totalSamples) * leftImpurity - 
        (rightTotal / totalSamples) * rightImpurity;
      
      if (gain > bestGain) {
        bestGain = gain;
        bestFeature = f;
        bestThreshold = threshold;
      }
    }
  }
  
  if (bestFeature === -1) {
    return { isLeaf: true, prediction: maxClass };
  }
  
  // Update feature importance
  featureImportance[bestFeature] += bestGain * totalSamples;
  
  // Split indices
  const leftIndices = indices.filter(idx => data[idx][bestFeature] <= bestThreshold);
  const rightIndices = indices.filter(idx => data[idx][bestFeature] > bestThreshold);
  
  return {
    isLeaf: false,
    feature: bestFeature,
    threshold: bestThreshold,
    left: buildDecisionTree(data, classes, leftIndices, options, depth + 1),
    right: buildDecisionTree(data, classes, rightIndices, options, depth + 1)
  };
}

function calculateImpurity(counts, total, criterion) {
  if (total === 0) return 0;
  
  if (criterion === 'entropy') {
    let entropy = 0;
    for (const c of counts) {
      if (c > 0) {
        const p = c / total;
        entropy -= p * Math.log2(p);
      }
    }
    return entropy;
  } else {
    // Gini
    let gini = 1;
    for (const c of counts) {
      gini -= (c / total) ** 2;
    }
    return gini;
  }
}

function predictTree(tree, sample) {
  if (tree.isLeaf) return tree.prediction;
  if (sample[tree.feature] <= tree.threshold) {
    return predictTree(tree.left, sample);
  }
  return predictTree(tree.right, sample);
}

// Draw confusion matrix
function drawConfusionMatrix(ctx, confusion, classLabels, width, height) {
  ctx.clearRect(0, 0, width, height);
  ctx.fillStyle = '#fff';
  ctx.fillRect(0, 0, width, height);
  
  const n = classLabels.length;
  const padding = { top: 80, right: 30, bottom: 60, left: 120 };
  const cellSize = Math.min((width - padding.left - padding.right) / n, 
                            (height - padding.top - padding.bottom) / n);
  
  // Find max for color scaling
  let maxVal = 0;
  for (const row of confusion) {
    for (const v of row) maxVal = Math.max(maxVal, v);
  }
  
  // Draw cells
  for (let i = 0; i < n; i++) {
    for (let j = 0; j < n; j++) {
      const val = confusion[i][j];
      const t = maxVal > 0 ? val / maxVal : 0;
      
      const x = padding.left + j * cellSize;
      const y = padding.top + i * cellSize;
      
      // Color: white to blue
      ctx.fillStyle = `rgb(${Math.round(255 * (1 - t))}, ${Math.round(255 * (1 - t * 0.5))}, 255)`;
      ctx.fillRect(x, y, cellSize - 1, cellSize - 1);
      
      // Value text
      ctx.fillStyle = t > 0.5 ? '#fff' : '#333';
      ctx.font = '12px sans-serif';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText(val.toString(), x + cellSize / 2, y + cellSize / 2);
    }
  }
  
  // Row labels (True)
  ctx.fillStyle = '#333';
  ctx.font = '10px sans-serif';
  ctx.textAlign = 'right';
  for (let i = 0; i < n; i++) {
    ctx.fillText(classLabels[i], padding.left - 5, padding.top + (i + 0.5) * cellSize);
  }
  
  // Column labels (Predicted)
  ctx.textAlign = 'center';
  for (let j = 0; j < n; j++) {
    ctx.save();
    ctx.translate(padding.left + (j + 0.5) * cellSize, padding.top - 10);
    ctx.rotate(-Math.PI / 4);
    ctx.fillText(classLabels[j], 0, 0);
    ctx.restore();
  }
  
  // Title
  ctx.font = 'bold 14px sans-serif';
  ctx.textAlign = 'center';
  ctx.fillText('Confusion Matrix', width / 2, 25);
  
  // Axis labels
  ctx.font = '12px sans-serif';
  ctx.fillText('Predicted', width / 2, height - 20);
  
  ctx.save();
  ctx.translate(25, height / 2);
  ctx.rotate(-Math.PI / 2);
  ctx.fillText('True', 0, 0);
  ctx.restore();
}

// Draw prediction plot
function drawPredictionPlot(ctx, predictions, labels, width, height) {
  ctx.clearRect(0, 0, width, height);
  ctx.fillStyle = '#fff';
  ctx.fillRect(0, 0, width, height);
  
  const colors = ['#e41a1c', '#377eb8', '#4daf4a', '#984ea3', '#ff7f00', '#ffff33', '#a65628', '#f781bf'];
  const n = predictions.length;
  const padding = { top: 50, right: 30, bottom: 80, left: 50 };
  const plotWidth = width - padding.left - padding.right;
  const barWidth = Math.min(30, plotWidth / n);
  
  ctx.font = '9px sans-serif';
  for (let i = 0; i < n; i++) {
    const x = padding.left + i * barWidth;
    const pred = predictions[i];
    
    ctx.fillStyle = colors[pred % colors.length];
    ctx.fillRect(x, padding.top, barWidth - 2, height - padding.top - padding.bottom);
    
    // Label
    ctx.save();
    ctx.translate(x + barWidth / 2, height - padding.bottom + 5);
    ctx.rotate(Math.PI / 4);
    ctx.fillStyle = '#333';
    ctx.textAlign = 'left';
    const label = labels[i].length > 8 ? labels[i].substring(0, 6) + '..' : labels[i];
    ctx.fillText(label, 0, 0);
    ctx.restore();
  }
  
  // Title
  ctx.fillStyle = '#333';
  ctx.font = 'bold 14px sans-serif';
  ctx.textAlign = 'center';
  ctx.fillText('Group Predictions', width / 2, 25);
}

function computeRandomForestImportance(data, numTrees, topN) {
  const { matrix, rowLabels, colLabels } = data;
  const n = matrix.length;
  const p = colLabels.length;
  
  if (n < 3) return null;
  
  // Simple approach: measure correlation between each feature and group variance
  const importances = [];
  
  for (let j = 0; j < p; j++) {
    const values = matrix.map(row => row[j]);
    const mean = values.reduce((s, v) => s + v, 0) / n;
    const variance = values.reduce((s, v) => s + (v - mean) ** 2, 0) / n;
    const cv = mean > 0 ? Math.sqrt(variance) / mean : 0;
    importances.push({ feature: colLabels[j], importance: cv, index: j });
  }
  
  importances.sort((a, b) => b.importance - a.importance);
  return importances.slice(0, topN);
}

// Draw Factor Biplot (like CasualConc)
function drawFactorBiplot(ctx, efa, width, height, options = {}) {
  const {
    axisX = 0,
    axisY = 1,
    labelThreshold = 0.3,
    showFactorScores = true,
    rowLabels = []
  } = options;
  
  ctx.clearRect(0, 0, width, height);
  ctx.fillStyle = '#fff';
  ctx.fillRect(0, 0, width, height);
  
  const padding = { top: 60, right: 60, bottom: 60, left: 60 };
  const plotWidth = width - padding.left - padding.right;
  const plotHeight = height - padding.top - padding.bottom;
  const centerX = padding.left + plotWidth / 2;
  const centerY = padding.top + plotHeight / 2;
  
  // Find data range for loadings
  let minX = -1, maxX = 1, minY = -1, maxY = 1;
  
  efa.rawLoadings.forEach(row => {
    const x = row[axisX] || 0;
    const y = row[axisY] || 0;
    minX = Math.min(minX, x);
    maxX = Math.max(maxX, x);
    minY = Math.min(minY, y);
    maxY = Math.max(maxY, y);
  });
  
  // Extend range symmetrically
  const rangeX = Math.max(Math.abs(minX), Math.abs(maxX)) * 1.2;
  const rangeY = Math.max(Math.abs(minY), Math.abs(maxY)) * 1.2;
  minX = -rangeX; maxX = rangeX;
  minY = -rangeY; maxY = rangeY;
  
  // Scale functions
  const scaleX = x => padding.left + ((x - minX) / (maxX - minX)) * plotWidth;
  const scaleY = y => padding.top + plotHeight - ((y - minY) / (maxY - minY)) * plotHeight;
  
  // Draw grid
  ctx.strokeStyle = '#e0e0e0';
  ctx.lineWidth = 0.5;
  
  // Horizontal grid lines
  for (let y = Math.ceil(minY * 10) / 10; y <= maxY; y += 0.2) {
    ctx.beginPath();
    ctx.moveTo(padding.left, scaleY(y));
    ctx.lineTo(padding.left + plotWidth, scaleY(y));
    ctx.stroke();
  }
  
  // Vertical grid lines
  for (let x = Math.ceil(minX * 10) / 10; x <= maxX; x += 0.2) {
    ctx.beginPath();
    ctx.moveTo(scaleX(x), padding.top);
    ctx.lineTo(scaleX(x), padding.top + plotHeight);
    ctx.stroke();
  }
  
  // Draw axes through origin
  ctx.strokeStyle = '#333';
  ctx.lineWidth = 1;
  
  // X axis
  ctx.beginPath();
  ctx.moveTo(padding.left, scaleY(0));
  ctx.lineTo(padding.left + plotWidth, scaleY(0));
  ctx.stroke();
  
  // Y axis
  ctx.beginPath();
  ctx.moveTo(scaleX(0), padding.top);
  ctx.lineTo(scaleX(0), padding.top + plotHeight);
  ctx.stroke();
  
  // Draw axis labels
  ctx.fillStyle = '#333';
  ctx.font = '10px sans-serif';
  ctx.textAlign = 'center';
  
  // X axis ticks
  for (let x = Math.ceil(minX * 10) / 10; x <= maxX; x += 0.5) {
    if (Math.abs(x) > 0.01) {
      ctx.fillText(x.toFixed(1), scaleX(x), scaleY(0) + 15);
    }
  }
  
  // Y axis ticks
  ctx.textAlign = 'right';
  for (let y = Math.ceil(minY * 10) / 10; y <= maxY; y += 0.5) {
    if (Math.abs(y) > 0.01) {
      ctx.fillText(y.toFixed(1), scaleX(0) - 5, scaleY(y) + 4);
    }
  }
  
  // Draw factor scores (groups) if available
  if (showFactorScores && efa.factorScores && efa.factorScores.length > 0) {
    const colors = ['#e41a1c', '#377eb8', '#4daf4a', '#984ea3', '#ff7f00', '#ffff33', '#a65628', '#f781bf'];
    
    efa.factorScores.forEach((scores, i) => {
      const x = scores[axisX] || 0;
      const y = scores[axisY] || 0;
      const px = scaleX(x);
      const py = scaleY(y);
      
      // Draw point
      ctx.fillStyle = colors[i % colors.length];
      ctx.beginPath();
      ctx.arc(px, py, 6, 0, Math.PI * 2);
      ctx.fill();
      ctx.strokeStyle = '#333';
      ctx.lineWidth = 1;
      ctx.stroke();
      
      // Draw label
      ctx.fillStyle = colors[i % colors.length];
      ctx.font = 'bold 10px sans-serif';
      ctx.textAlign = 'left';
      ctx.textBaseline = 'middle';
      const label = rowLabels[i] || `G${i+1}`;
      ctx.fillText(label, px + 8, py);
    });
  }
  
  // Draw loadings as asterisks with labels
  ctx.font = '9px sans-serif';
  ctx.textBaseline = 'middle';
  
  efa.rawLoadings.forEach((row, j) => {
    const x = row[axisX] || 0;
    const y = row[axisY] || 0;
    const px = scaleX(x);
    const py = scaleY(y);
    const dist = Math.sqrt(x * x + y * y);
    
    // Draw asterisk
    ctx.fillStyle = '#333';
    ctx.font = 'bold 12px sans-serif';
    ctx.textAlign = 'center';
    ctx.fillText('*', px, py);
    
    // Draw label if above threshold
    if (dist >= labelThreshold) {
      ctx.font = '8px sans-serif';
      ctx.fillStyle = '#333';
      
      // Position label to avoid overlap
      const angle = Math.atan2(y, x);
      const labelX = px + Math.cos(angle) * 8;
      const labelY = py - Math.sin(angle) * 8;
      
      ctx.textAlign = x > 0 ? 'left' : 'right';
      const label = efa.loadings[j].feature;
      const shortLabel = label.length > 15 ? label.substring(0, 12) + '...' : label;
      ctx.fillText(shortLabel, labelX, labelY);
    }
  });
  
  // Title
  ctx.fillStyle = '#333';
  ctx.font = 'bold 14px sans-serif';
  ctx.textAlign = 'center';
  ctx.fillText(`Factor ${axisX + 1} vs. Factor ${axisY + 1}`, width / 2, 25);
  
  // Axis titles
  ctx.font = '12px sans-serif';
  ctx.fillText(`Factor ${axisX + 1}`, width / 2, height - 15);
  
  ctx.save();
  ctx.translate(20, height / 2);
  ctx.rotate(-Math.PI / 2);
  ctx.fillText(`Factor ${axisY + 1}`, 0, 0);
  ctx.restore();
  
  // Legend for factor scores
  if (showFactorScores && efa.factorScores && efa.factorScores.length > 0) {
    ctx.font = '10px sans-serif';
    ctx.textAlign = 'left';
    ctx.fillStyle = '#333';
    ctx.fillText('● Groups    * Loadings', width - 150, 25);
  }
}

// Draw Scree Plot
function drawScreePlot(ctx, efa, width, height) {
  ctx.clearRect(0, 0, width, height);
  ctx.fillStyle = '#fff';
  ctx.fillRect(0, 0, width, height);
  
  const padding = { top: 60, right: 40, bottom: 60, left: 80 };
  const plotWidth = width - padding.left - padding.right;
  const plotHeight = height - padding.top - padding.bottom;
  
  // Get all eigenvalues (need more for scree plot)
  const eigenvalues = efa.eigenvalues;
  const n = eigenvalues.length;
  
  const maxEV = Math.max(...eigenvalues) * 1.1;
  const scaleX = i => padding.left + (i / (n - 1 || 1)) * plotWidth;
  const scaleY = ev => padding.top + plotHeight - (ev / maxEV) * plotHeight;
  
  // Draw grid
  ctx.strokeStyle = '#e0e0e0';
  ctx.lineWidth = 0.5;
  for (let y = 0; y <= maxEV; y += maxEV / 5) {
    ctx.beginPath();
    ctx.moveTo(padding.left, scaleY(y));
    ctx.lineTo(padding.left + plotWidth, scaleY(y));
    ctx.stroke();
  }
  
  // Draw line
  ctx.strokeStyle = '#2196F3';
  ctx.lineWidth = 2;
  ctx.beginPath();
  eigenvalues.forEach((ev, i) => {
    const x = scaleX(i);
    const y = scaleY(ev);
    if (i === 0) ctx.moveTo(x, y);
    else ctx.lineTo(x, y);
  });
  ctx.stroke();
  
  // Draw points
  eigenvalues.forEach((ev, i) => {
    const x = scaleX(i);
    const y = scaleY(ev);
    
    ctx.fillStyle = '#2196F3';
    ctx.beginPath();
    ctx.arc(x, y, 6, 0, Math.PI * 2);
    ctx.fill();
    ctx.strokeStyle = '#fff';
    ctx.lineWidth = 2;
    ctx.stroke();
  });
  
  // Kaiser criterion line (eigenvalue = 1)
  ctx.strokeStyle = '#f44336';
  ctx.lineWidth = 1;
  ctx.setLineDash([5, 5]);
  ctx.beginPath();
  ctx.moveTo(padding.left, scaleY(1));
  ctx.lineTo(padding.left + plotWidth, scaleY(1));
  ctx.stroke();
  ctx.setLineDash([]);
  
  // Axes
  ctx.strokeStyle = '#333';
  ctx.lineWidth = 1;
  ctx.beginPath();
  ctx.moveTo(padding.left, padding.top);
  ctx.lineTo(padding.left, padding.top + plotHeight);
  ctx.lineTo(padding.left + plotWidth, padding.top + plotHeight);
  ctx.stroke();
  
  // Labels
  ctx.fillStyle = '#333';
  ctx.font = '10px sans-serif';
  ctx.textAlign = 'center';
  
  eigenvalues.forEach((ev, i) => {
    ctx.fillText(`F${i + 1}`, scaleX(i), padding.top + plotHeight + 20);
  });
  
  ctx.textAlign = 'right';
  for (let y = 0; y <= maxEV; y += maxEV / 5) {
    ctx.fillText(y.toFixed(1), padding.left - 10, scaleY(y) + 4);
  }
  
  // Title
  ctx.font = 'bold 14px sans-serif';
  ctx.textAlign = 'center';
  ctx.fillText('Scree Plot', width / 2, 25);
  
  // Axis labels
  ctx.font = '12px sans-serif';
  ctx.fillText('Factor', width / 2, height - 15);
  
  ctx.save();
  ctx.translate(25, height / 2);
  ctx.rotate(-Math.PI / 2);
  ctx.fillText('Eigenvalue', 0, 0);
  ctx.restore();
  
  // Legend
  ctx.font = '10px sans-serif';
  ctx.textAlign = 'left';
  ctx.fillStyle = '#f44336';
  ctx.fillText('Kaiser criterion (λ = 1)', width - 180, 25);
}

// Draw Loading Heatmap
function drawLoadingHeatmap(ctx, efa, width, height) {
  ctx.clearRect(0, 0, width, height);
  ctx.fillStyle = '#fff';
  ctx.fillRect(0, 0, width, height);
  
  const padding = { top: 50, right: 30, bottom: 40, left: 150 };
  const n = Math.min(efa.loadings.length, 40);
  const numFactors = efa.numFactors;
  const cellWidth = (width - padding.left - padding.right) / numFactors;
  const cellHeight = Math.min(16, (height - padding.top - padding.bottom) / n);
  
  // Sort by first factor loading
  const sorted = [...efa.loadings].sort((a, b) => Math.abs(b.loadings[0]) - Math.abs(a.loadings[0])).slice(0, n);
  
  ctx.font = '9px sans-serif';
  for (let i = 0; i < n; i++) {
    const item = sorted[i];
    for (let j = 0; j < numFactors; j++) {
      const val = item.loadings[j];
      // Blue-white-red color scale
      const t = (val + 1) / 2;
      const r = t > 0.5 ? 255 : Math.round(t * 2 * 255);
      const b = t < 0.5 ? 255 : Math.round((1 - t) * 2 * 255);
      const g = Math.round(255 * (1 - Math.abs(t - 0.5) * 2));
      
      ctx.fillStyle = `rgb(${r}, ${g}, ${b})`;
      ctx.fillRect(padding.left + j * cellWidth, padding.top + i * cellHeight, cellWidth - 1, cellHeight - 1);
      
      ctx.fillStyle = Math.abs(val) > 0.4 ? '#fff' : '#333';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText(val.toFixed(2), padding.left + (j + 0.5) * cellWidth, padding.top + (i + 0.5) * cellHeight);
    }
    
    ctx.fillStyle = '#333';
    ctx.textAlign = 'right';
    const label = item.feature.length > 18 ? item.feature.substring(0, 15) + '...' : item.feature;
    ctx.fillText(label, padding.left - 5, padding.top + (i + 0.5) * cellHeight);
  }
  
  // Factor headers
  ctx.textAlign = 'center';
  for (let j = 0; j < numFactors; j++) {
    ctx.fillText(`Factor ${j+1}`, padding.left + (j + 0.5) * cellWidth, padding.top - 10);
  }
  
  // Title
  ctx.font = 'bold 14px sans-serif';
  ctx.fillText('Factor Loadings', width / 2, 20);
  
  // Color legend
  const legendWidth = 100;
  const legendHeight = 12;
  const legendX = width - padding.right - legendWidth - 10;
  const legendY = 10;
  
  for (let i = 0; i < legendWidth; i++) {
    const t = i / legendWidth;
    const r = t > 0.5 ? 255 : Math.round(t * 2 * 255);
    const b = t < 0.5 ? 255 : Math.round((1 - t) * 2 * 255);
    const g = Math.round(255 * (1 - Math.abs(t - 0.5) * 2));
    ctx.fillStyle = `rgb(${r}, ${g}, ${b})`;
    ctx.fillRect(legendX + i, legendY, 1, legendHeight);
  }
  ctx.strokeStyle = '#333';
  ctx.strokeRect(legendX, legendY, legendWidth, legendHeight);
  
  ctx.font = '8px sans-serif';
  ctx.textAlign = 'left';
  ctx.fillStyle = '#333';
  ctx.fillText('-1', legendX, legendY + legendHeight + 10);
  ctx.textAlign = 'right';
  ctx.fillText('+1', legendX + legendWidth, legendY + legendHeight + 10);
}

// Draw feature importance bar chart
function drawFeatureImportance(ctx, importances, width, height) {
  ctx.clearRect(0, 0, width, height);
  ctx.fillStyle = '#fff';
  ctx.fillRect(0, 0, width, height);
  
  const padding = { top: 50, right: 30, bottom: 40, left: 150 };
  const plotWidth = width - padding.left - padding.right;
  const plotHeight = height - padding.top - padding.bottom;
  
  const n = importances.length;
  const barHeight = Math.min(20, plotHeight / n - 2);
  const maxImportance = Math.max(...importances.map(i => i.importance)) || 1;
  
  ctx.font = '10px sans-serif';
  
  for (let i = 0; i < n; i++) {
    const imp = importances[i];
    const barWidth = (imp.importance / maxImportance) * plotWidth;
    const y = padding.top + i * (barHeight + 2);
    
    // Bar
    ctx.fillStyle = '#1f77b4';
    ctx.fillRect(padding.left, y, barWidth, barHeight);
    
    // Label
    ctx.fillStyle = '#333';
    ctx.textAlign = 'right';
    ctx.textBaseline = 'middle';
    const label = imp.feature.length > 18 ? imp.feature.substring(0, 15) + '...' : imp.feature;
    ctx.fillText(label, padding.left - 5, y + barHeight / 2);
    
    // Value
    ctx.textAlign = 'left';
    ctx.fillText(imp.importance.toFixed(4), padding.left + barWidth + 5, y + barHeight / 2);
  }
  
  // Title
  ctx.fillStyle = '#333';
  ctx.font = 'bold 14px sans-serif';
  ctx.textAlign = 'center';
  ctx.fillText('Feature Importance (Coefficient of Variation)', width / 2, 20);
}

// t-SNE (simplified implementation)
// Enhanced t-SNE with full options
function computeTSNEFull(data, options = {}) {
  const {
    perplexity = 30,
    learningRate = 200,
    iterations = 1000,
    distType = 'cosine',
    standardize = true,
    exaggeration = 12
  } = options;
  
  let { matrix } = data;
  const n = matrix.length;
  
  if (n < 3) return null;
  
  // Standardize if requested
  if (standardize) {
    matrix = standardizeMatrix(matrix);
  }
  
  // Compute pairwise distances
  const dist = computeDistanceMatrix(matrix, distType);
  
  // Initialize with random positions
  let Y = Array(n).fill(0).map(() => [
    (Math.random() - 0.5) * 0.0001,
    (Math.random() - 0.5) * 0.0001
  ]);
  
  // Compute high-dimensional probabilities
  const P = Array(n).fill(0).map(() => Array(n).fill(0));
  const targetPerp = Math.min(perplexity, (n - 1) / 3);
  
  for (let i = 0; i < n; i++) {
    let sigma = 1;
    for (let iter = 0; iter < 50; iter++) {
      let sum = 0;
      for (let j = 0; j < n; j++) {
        if (i !== j) {
          P[i][j] = Math.exp(-(dist[i][j] ** 2) / (2 * sigma ** 2));
          sum += P[i][j];
        }
      }
      if (sum > 0) {
        for (let j = 0; j < n; j++) P[i][j] /= sum;
      }
      
      let H = 0;
      for (let j = 0; j < n; j++) {
        if (P[i][j] > 1e-10) H -= P[i][j] * Math.log2(P[i][j]);
      }
      const perp = 2 ** H;
      
      if (Math.abs(perp - targetPerp) < 0.1) break;
      if (perp > targetPerp) sigma *= 0.9;
      else sigma *= 1.1;
    }
  }
  
  // Symmetrize and apply early exaggeration
  for (let i = 0; i < n; i++) {
    for (let j = i + 1; j < n; j++) {
      const pij = (P[i][j] + P[j][i]) / (2 * n);
      P[i][j] = pij * exaggeration;
      P[j][i] = pij * exaggeration;
    }
  }
  
  // Gradient descent with momentum
  let gains = Array(n).fill(0).map(() => [1, 1]);
  let velocity = Array(n).fill(0).map(() => [0, 0]);
  const momentum = 0.8;
  const eta = learningRate;
  
  for (let iter = 0; iter < iterations; iter++) {
    // Remove early exaggeration after 250 iterations
    if (iter === 250) {
      for (let i = 0; i < n; i++) {
        for (let j = 0; j < n; j++) {
          P[i][j] /= exaggeration;
        }
      }
    }
    
    // Compute Q (student-t distribution)
    const Q = Array(n).fill(0).map(() => Array(n).fill(0));
    let sumQ = 0;
    
    for (let i = 0; i < n; i++) {
      for (let j = i + 1; j < n; j++) {
        const d2 = (Y[i][0] - Y[j][0]) ** 2 + (Y[i][1] - Y[j][1]) ** 2;
        const q = 1 / (1 + d2);
        Q[i][j] = q;
        Q[j][i] = q;
        sumQ += 2 * q;
      }
    }
    
    // Normalize Q
    for (let i = 0; i < n; i++) {
      for (let j = 0; j < n; j++) {
        Q[i][j] /= sumQ || 1;
      }
    }
    
    // Compute gradients
    const grad = Array(n).fill(0).map(() => [0, 0]);
    for (let i = 0; i < n; i++) {
      for (let j = 0; j < n; j++) {
        if (i !== j) {
          const d2 = (Y[i][0] - Y[j][0]) ** 2 + (Y[i][1] - Y[j][1]) ** 2;
          const mult = 4 * (P[i][j] - Q[i][j]) / (1 + d2);
          grad[i][0] += mult * (Y[i][0] - Y[j][0]);
          grad[i][1] += mult * (Y[i][1] - Y[j][1]);
        }
      }
    }
    
    // Update with momentum and adaptive learning rate
    for (let i = 0; i < n; i++) {
      for (let d = 0; d < 2; d++) {
        const sign = (grad[i][d] > 0) === (velocity[i][d] > 0);
        gains[i][d] = sign ? gains[i][d] * 0.8 : gains[i][d] + 0.2;
        gains[i][d] = Math.max(gains[i][d], 0.01);
        
        velocity[i][d] = momentum * velocity[i][d] - eta * gains[i][d] * grad[i][d];
        Y[i][d] += velocity[i][d];
      }
    }
    
    // Center
    const meanX = Y.reduce((s, p) => s + p[0], 0) / n;
    const meanY = Y.reduce((s, p) => s + p[1], 0) / n;
    for (let i = 0; i < n; i++) {
      Y[i][0] -= meanX;
      Y[i][1] -= meanY;
    }
  }
  
  return { coords: Y };
}

function computeTSNE(data, perplexity, iterations) {
  const { matrix } = data;
  const n = matrix.length;
  
  if (n < 3) return null;
  
  // Compute pairwise distances
  const dist = computeDistanceMatrix(matrix, 'euclidean');
  
  // Initialize with random positions
  let Y = Array(n).fill(0).map(() => [Math.random() - 0.5, Math.random() - 0.5]);
  
  // Compute perplexities and probabilities
  const P = Array(n).fill(0).map(() => Array(n).fill(0));
  const targetPerp = Math.min(perplexity, (n - 1) / 3);
  
  for (let i = 0; i < n; i++) {
    let sigma = 1;
    // Binary search for sigma
    for (let iter = 0; iter < 50; iter++) {
      let sum = 0;
      for (let j = 0; j < n; j++) {
        if (i !== j) {
          P[i][j] = Math.exp(-(dist[i][j] ** 2) / (2 * sigma ** 2));
          sum += P[i][j];
        }
      }
      if (sum > 0) {
        for (let j = 0; j < n; j++) P[i][j] /= sum;
      }
      
      // Compute perplexity
      let H = 0;
      for (let j = 0; j < n; j++) {
        if (P[i][j] > 1e-10) H -= P[i][j] * Math.log2(P[i][j]);
      }
      const perp = 2 ** H;
      
      if (Math.abs(perp - targetPerp) < 0.1) break;
      if (perp > targetPerp) sigma *= 0.9;
      else sigma *= 1.1;
    }
  }
  
  // Symmetrize
  for (let i = 0; i < n; i++) {
    for (let j = i + 1; j < n; j++) {
      const pij = (P[i][j] + P[j][i]) / (2 * n);
      P[i][j] = pij;
      P[j][i] = pij;
    }
  }
  
  // Gradient descent
  const learningRate = 200;
  const momentum = 0.8;
  let gains = Array(n).fill(0).map(() => [1, 1]);
  let velocities = Array(n).fill(0).map(() => [0, 0]);
  
  for (let iter = 0; iter < iterations; iter++) {
    // Compute Q (t-distribution)
    const Q = Array(n).fill(0).map(() => Array(n).fill(0));
    let sumQ = 0;
    for (let i = 0; i < n; i++) {
      for (let j = i + 1; j < n; j++) {
        const d2 = (Y[i][0] - Y[j][0]) ** 2 + (Y[i][1] - Y[j][1]) ** 2;
        const q = 1 / (1 + d2);
        Q[i][j] = q;
        Q[j][i] = q;
        sumQ += 2 * q;
      }
    }
    for (let i = 0; i < n; i++) {
      for (let j = 0; j < n; j++) {
        Q[i][j] /= sumQ || 1;
      }
    }
    
    // Compute gradients
    const grad = Array(n).fill(0).map(() => [0, 0]);
    for (let i = 0; i < n; i++) {
      for (let j = 0; j < n; j++) {
        if (i === j) continue;
        const d2 = (Y[i][0] - Y[j][0]) ** 2 + (Y[i][1] - Y[j][1]) ** 2;
        const mult = 4 * (P[i][j] - Q[i][j]) / (1 + d2);
        grad[i][0] += mult * (Y[i][0] - Y[j][0]);
        grad[i][1] += mult * (Y[i][1] - Y[j][1]);
      }
    }
    
    // Update with momentum
    for (let i = 0; i < n; i++) {
      for (let d = 0; d < 2; d++) {
        const sign = grad[i][d] > 0 ? 1 : -1;
        const signV = velocities[i][d] > 0 ? 1 : -1;
        gains[i][d] = sign === signV ? gains[i][d] * 0.8 : gains[i][d] + 0.2;
        gains[i][d] = Math.max(gains[i][d], 0.01);
        
        velocities[i][d] = momentum * velocities[i][d] - learningRate * gains[i][d] * grad[i][d];
        Y[i][d] += velocities[i][d];
      }
    }
    
    // Center
    const meanY = [0, 0];
    for (let i = 0; i < n; i++) {
      meanY[0] += Y[i][0];
      meanY[1] += Y[i][1];
    }
    meanY[0] /= n;
    meanY[1] /= n;
    for (let i = 0; i < n; i++) {
      Y[i][0] -= meanY[0];
      Y[i][1] -= meanY[1];
    }
  }
  
  return { coords: Y };
}

// UMAP (simplified approximation)
// Enhanced UMAP with full options
function computeUMAPFull(data, options = {}) {
  const {
    nNeighbors = 15,
    minDist = 0.1,
    metric = 'cosine',
    epochs = 500,
    standardize = true,
    spread = 1.0
  } = options;
  
  let { matrix } = data;
  const n = matrix.length;
  
  if (n < 3) return null;
  
  // Standardize if requested
  if (standardize) {
    matrix = standardizeMatrix(matrix);
  }
  
  // Compute distance matrix
  const dist = computeDistanceMatrix(matrix, metric);
  
  // Find k nearest neighbors for each point
  const k = Math.min(nNeighbors, n - 1);
  const knn = [];
  const knnDist = [];
  
  for (let i = 0; i < n; i++) {
    const dists = dist[i].map((d, j) => ({ idx: j, dist: d }))
      .filter(d => d.idx !== i)
      .sort((a, b) => a.dist - b.dist)
      .slice(0, k);
    knn.push(dists.map(d => d.idx));
    knnDist.push(dists.map(d => d.dist));
  }
  
  // Compute local connectivity (sigma for each point)
  const sigma = [];
  for (let i = 0; i < n; i++) {
    const rho = knnDist[i][0] || 0; // Distance to nearest neighbor
    let lo = 0, hi = 1000;
    
    for (let iter = 0; iter < 64; iter++) {
      const mid = (lo + hi) / 2;
      let sum = 0;
      for (let j = 0; j < k; j++) {
        sum += Math.exp(-Math.max(0, knnDist[i][j] - rho) / mid);
      }
      if (Math.abs(sum - Math.log2(k)) < 0.01) {
        sigma.push(mid);
        break;
      }
      if (sum > Math.log2(k)) hi = mid;
      else lo = mid;
    }
    if (sigma.length <= i) sigma.push((lo + hi) / 2);
  }
  
  // Compute high-dimensional weights
  const weights = Array(n).fill(0).map(() => Array(n).fill(0));
  for (let i = 0; i < n; i++) {
    const rho = knnDist[i][0] || 0;
    for (let j = 0; j < k; j++) {
      const neighbor = knn[i][j];
      const d = Math.max(0, knnDist[i][j] - rho);
      weights[i][neighbor] = Math.exp(-d / sigma[i]);
    }
  }
  
  // Symmetrize
  for (let i = 0; i < n; i++) {
    for (let j = i + 1; j < n; j++) {
      const w = weights[i][j] + weights[j][i] - weights[i][j] * weights[j][i];
      weights[i][j] = w;
      weights[j][i] = w;
    }
  }
  
  // Initialize low-dimensional embedding
  let Y = Array(n).fill(0).map(() => [
    (Math.random() - 0.5) * 10,
    (Math.random() - 0.5) * 10
  ]);
  
  // UMAP parameters
  const a = 1.929;
  const b = 0.7915;
  const learningRate = 1.0;
  const negativeSampleRate = 5;
  
  // Optimization
  for (let epoch = 0; epoch < epochs; epoch++) {
    const alpha = learningRate * (1 - epoch / epochs);
    
    for (let i = 0; i < n; i++) {
      // Attractive forces
      for (let j = 0; j < k; j++) {
        const neighbor = knn[i][j];
        const w = weights[i][neighbor];
        
        if (w > 0) {
          const d = Math.sqrt(
            (Y[i][0] - Y[neighbor][0]) ** 2 + 
            (Y[i][1] - Y[neighbor][1]) ** 2
          ) || 0.001;
          
          const grad = -2 * a * b * Math.pow(d, b - 1) / 
            (1 + a * Math.pow(d, b)) * w;
          
          const dx = (Y[i][0] - Y[neighbor][0]) / d;
          const dy = (Y[i][1] - Y[neighbor][1]) / d;
          
          Y[i][0] -= alpha * grad * dx;
          Y[i][1] -= alpha * grad * dy;
        }
      }
      
      // Repulsive forces (negative sampling)
      for (let s = 0; s < negativeSampleRate; s++) {
        const j = Math.floor(Math.random() * n);
        if (j === i || weights[i][j] > 0.1) continue;
        
        const d = Math.sqrt(
          (Y[i][0] - Y[j][0]) ** 2 + 
          (Y[i][1] - Y[j][1]) ** 2
        ) || 0.001;
        
        const grad = 2 * b / (d * (1 + a * Math.pow(d, b))) * (1 - weights[i][j]);
        
        const dx = (Y[i][0] - Y[j][0]) / d;
        const dy = (Y[i][1] - Y[j][1]) / d;
        
        Y[i][0] += alpha * grad * dx * 0.1;
        Y[i][1] += alpha * grad * dy * 0.1;
      }
    }
  }
  
  // Scale by spread
  const scale = spread;
  for (let i = 0; i < n; i++) {
    Y[i][0] *= scale;
    Y[i][1] *= scale;
  }
  
  return { coords: Y };
}

function computeUMAP(data, nNeighbors, minDist) {
  const { matrix } = data;
  const n = matrix.length;
  
  if (n < 3) return null;
  
  // Use MDS as a simplified UMAP approximation
  const dist = computeDistanceMatrix(matrix, 'euclidean');
  
  // Local scaling based on neighbors
  for (let i = 0; i < n; i++) {
    const sortedDists = dist[i].map((d, j) => ({ d, j })).filter((_, j) => j !== i).sort((a, b) => a.d - b.d);
    const sigma = sortedDists[Math.min(nNeighbors, n - 2)]?.d || 1;
    for (let j = 0; j < n; j++) {
      if (i !== j) {
        dist[i][j] = Math.max(dist[i][j] - minDist, 0) / sigma;
      }
    }
  }
  
  // Symmetrize
  for (let i = 0; i < n; i++) {
    for (let j = i + 1; j < n; j++) {
      const d = (dist[i][j] + dist[j][i]) / 2;
      dist[i][j] = d;
      dist[j][i] = d;
    }
  }
  
  return computeMDS(dist, 2);
}

// Draw t-SNE/UMAP plot
function drawDimReductionPlot(ctx, result, labels, width, height, title, showLabels = true) {
  ctx.clearRect(0, 0, width, height);
  ctx.fillStyle = '#fff';
  ctx.fillRect(0, 0, width, height);
  
  const { coords } = result;
  const padding = { top: 60, right: 60, bottom: 60, left: 60 };
  const plotWidth = width - padding.left - padding.right;
  const plotHeight = height - padding.top - padding.bottom;
  
  let minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity;
  coords.forEach(c => {
    minX = Math.min(minX, c[0]);
    maxX = Math.max(maxX, c[0]);
    minY = Math.min(minY, c[1]);
    maxY = Math.max(maxY, c[1]);
  });
  
  const rangeX = (maxX - minX) * 1.2 || 1;
  const rangeY = (maxY - minY) * 1.2 || 1;
  minX -= rangeX * 0.1;
  maxX += rangeX * 0.1;
  minY -= rangeY * 0.1;
  maxY += rangeY * 0.1;
  
  const scaleX = plotWidth / (maxX - minX);
  const scaleY = plotHeight / (maxY - minY);
  
  const toCanvasX = (x) => padding.left + (x - minX) * scaleX;
  const toCanvasY = (y) => padding.top + plotHeight - (y - minY) * scaleY;
  
  // Draw grid
  ctx.strokeStyle = '#e0e0e0';
  ctx.lineWidth = 0.5;
  for (let i = 0; i <= 5; i++) {
    const y = padding.top + (i / 5) * plotHeight;
    ctx.beginPath();
    ctx.moveTo(padding.left, y);
    ctx.lineTo(padding.left + plotWidth, y);
    ctx.stroke();
    
    const x = padding.left + (i / 5) * plotWidth;
    ctx.beginPath();
    ctx.moveTo(x, padding.top);
    ctx.lineTo(x, padding.top + plotHeight);
    ctx.stroke();
  }
  
  // Draw axes
  ctx.strokeStyle = '#333';
  ctx.lineWidth = 1;
  ctx.beginPath();
  ctx.moveTo(padding.left, padding.top);
  ctx.lineTo(padding.left, padding.top + plotHeight);
  ctx.lineTo(padding.left + plotWidth, padding.top + plotHeight);
  ctx.stroke();
  
  // Draw points
  const colors = ['#e41a1c', '#377eb8', '#4daf4a', '#984ea3', '#ff7f00', '#ffff33', '#a65628', '#f781bf', '#999999', '#66c2a5'];
  ctx.font = '10px sans-serif';
  
  coords.forEach((c, i) => {
    const x = toCanvasX(c[0]);
    const y = toCanvasY(c[1]);
    
    ctx.fillStyle = colors[i % colors.length];
    ctx.beginPath();
    ctx.arc(x, y, 6, 0, Math.PI * 2);
    ctx.fill();
    ctx.strokeStyle = '#333';
    ctx.lineWidth = 1;
    ctx.stroke();
    
    if (showLabels) {
      ctx.fillStyle = '#333';
      ctx.textAlign = 'left';
      ctx.textBaseline = 'middle';
      const label = labels[i] || `G${i}`;
      ctx.fillText(label.length > 12 ? label.substring(0, 10) + '..' : label, x + 8, y);
    }
  });
  
  // Title
  ctx.fillStyle = '#333';
  ctx.font = 'bold 14px sans-serif';
  ctx.textAlign = 'center';
  ctx.fillText(title, width / 2, 25);
  
  // Axis labels
  ctx.font = '12px sans-serif';
  ctx.fillText('Dimension 1', width / 2, height - 15);
  
  ctx.save();
  ctx.translate(20, height / 2);
  ctx.rotate(-Math.PI / 2);
  ctx.fillText('Dimension 2', 0, 0);
  ctx.restore();
}

// EFA (simplified)
function computeEFA(data, options = {}) {
  const {
    numFactors = 2,
    extraction = 'minres',
    rotation = 'varimax',
    matrixType = 'correlation',
    scoreMethod = 'regression'
  } = options;
  
  const { matrix, colLabels, rowLabels } = data;
  const nVars = colLabels.length;
  const nObs = matrix.length;
  
  // Compute correlation or covariance matrix
  let R;
  if (matrixType === 'correlation') {
    R = computeCorrelationMatrix(matrix);
  } else {
    R = computeCovarianceMatrix(matrix);
  }
  
  // Initial communalities estimation (SMC - squared multiple correlations)
  let communalities = [];
  for (let i = 0; i < nVars; i++) {
    // Use maximum absolute correlation as initial estimate
    let maxCorr = 0;
    for (let j = 0; j < nVars; j++) {
      if (i !== j) maxCorr = Math.max(maxCorr, Math.abs(R[i][j]));
    }
    communalities.push(maxCorr * maxCorr);
  }
  
  // Reduced correlation matrix (with communalities on diagonal)
  let Rreduced = R.map((row, i) => row.map((v, j) => i === j ? communalities[i] : v));
  
  // Iterative extraction based on method
  const maxIter = 50;
  let loadings = [];
  let eigenvalues = [];
  
  for (let iter = 0; iter < maxIter; iter++) {
    // Eigendecomposition of reduced matrix
    const { values, vectors } = eigenDecomposition(Rreduced, numFactors);
    eigenvalues = values;
    
    // Compute loadings
    loadings = [];
    for (let j = 0; j < nVars; j++) {
      const row = [];
      for (let f = 0; f < numFactors; f++) {
        row.push(vectors[j][f] * Math.sqrt(Math.max(0, eigenvalues[f])));
      }
      loadings.push(row);
    }
    
    // Update communalities
    const newCommunalities = loadings.map(row => 
      row.reduce((sum, l) => sum + l * l, 0)
    );
    
    // Check convergence
    let converged = true;
    for (let i = 0; i < nVars; i++) {
      if (Math.abs(newCommunalities[i] - communalities[i]) > 0.001) {
        converged = false;
        break;
      }
    }
    
    communalities = newCommunalities;
    
    // Update reduced matrix
    Rreduced = R.map((row, i) => row.map((v, j) => i === j ? Math.min(1, communalities[i]) : v));
    
    if (converged) break;
  }
  
  // Apply rotation
  if (rotation !== 'none' && numFactors > 1) {
    loadings = rotateLoadings(loadings, rotation);
  }
  
  // Compute factor scores for observations
  let factorScores = [];
  if (scoreMethod === 'regression') {
    // Regression method: F = Z * R^-1 * L
    const Rinv = invertMatrix(R);
    if (!Rinv) {
      // Skip factor scores if matrix inversion fails
      factorScores = [];
    } else {
      const ZL = multiplyMatrices(Rinv, transposeMatrix(loadings));
      if (!ZL) {
        factorScores = [];
      } else {
        // Standardize data
        const means = colLabels.map((_, j) => matrix.reduce((s, row) => s + row[j], 0) / nObs);
        const stds = colLabels.map((_, j) => {
          const m = means[j];
          return Math.sqrt(matrix.reduce((s, row) => s + (row[j] - m) ** 2, 0) / nObs) || 1;
        });
        const Z = matrix.map(row => row.map((v, j) => (v - means[j]) / stds[j]));
        
        factorScores = Z.map(row => {
          const scores = [];
          for (let f = 0; f < numFactors; f++) {
            let score = 0;
            for (let j = 0; j < nVars; j++) {
              score += row[j] * (ZL[j]?.[f] ?? 0);
            }
            scores.push(score);
          }
          return scores;
        });
      }
    }
  }
  
  // Calculate variance explained
  const totalVar = nVars;
  const varianceExplained = eigenvalues.map(ev => (ev / totalVar) * 100);
  
  // Format loadings with labels
  const formattedLoadings = loadings.map((row, j) => ({
    feature: colLabels[j],
    loadings: row
  }));
  
  return {
    loadings: formattedLoadings,
    rawLoadings: loadings,
    eigenvalues,
    varianceExplained,
    communalities,
    factorScores,
    rowLabels,
    correlationMatrix: R,
    extraction,
    rotation,
    numFactors
  };
}

// Compute correlation matrix
function computeCorrelationMatrix(matrix) {
  const n = matrix[0].length;
  const nObs = matrix.length;
  
  // Compute means and stds
  const means = [];
  const stds = [];
  for (let j = 0; j < n; j++) {
    const col = matrix.map(row => row[j]);
    const mean = col.reduce((a, b) => a + b, 0) / nObs;
    const std = Math.sqrt(col.reduce((a, b) => a + (b - mean) ** 2, 0) / nObs) || 1;
    means.push(mean);
    stds.push(std);
  }
  
  // Compute correlation matrix
  const R = [];
  for (let i = 0; i < n; i++) {
    R[i] = [];
    for (let j = 0; j < n; j++) {
      if (i === j) {
        R[i][j] = 1;
      } else {
        let sum = 0;
        for (let k = 0; k < nObs; k++) {
          sum += ((matrix[k][i] - means[i]) / stds[i]) * ((matrix[k][j] - means[j]) / stds[j]);
        }
        R[i][j] = sum / nObs;
      }
    }
  }
  return R;
}

// Compute covariance matrix
function computeCovarianceMatrix(matrix) {
  const n = matrix[0].length;
  const nObs = matrix.length;
  
  const means = [];
  for (let j = 0; j < n; j++) {
    means.push(matrix.reduce((s, row) => s + row[j], 0) / nObs);
  }
  
  const C = [];
  for (let i = 0; i < n; i++) {
    C[i] = [];
    for (let j = 0; j < n; j++) {
      let sum = 0;
      for (let k = 0; k < nObs; k++) {
        sum += (matrix[k][i] - means[i]) * (matrix[k][j] - means[j]);
      }
      C[i][j] = sum / (nObs - 1);
    }
  }
  return C;
}

// Eigendecomposition using power iteration
function eigenDecomposition(matrix, numFactors) {
  const n = matrix.length;
  const values = [];
  const vectors = [];
  
  // Initialize vectors
  for (let i = 0; i < n; i++) {
    vectors[i] = [];
  }
  
  let M = matrix.map(row => [...row]);
  
  for (let f = 0; f < numFactors; f++) {
    // Power iteration
    let v = Array(n).fill(0).map(() => Math.random() - 0.5);
    let norm = Math.sqrt(v.reduce((s, x) => s + x * x, 0));
    v = v.map(x => x / norm);
    
    for (let iter = 0; iter < 100; iter++) {
      // Multiply M * v
      const Mv = M.map(row => row.reduce((s, x, j) => s + x * v[j], 0));
      norm = Math.sqrt(Mv.reduce((s, x) => s + x * x, 0)) || 1;
      const newV = Mv.map(x => x / norm);
      
      // Check convergence
      const diff = newV.reduce((s, x, i) => s + Math.abs(x - v[i]), 0);
      v = newV;
      if (diff < 1e-8) break;
    }
    
    // Eigenvalue
    const Mv = M.map(row => row.reduce((s, x, j) => s + x * v[j], 0));
    const eigenvalue = v.reduce((s, x, i) => s + x * Mv[i], 0);
    values.push(eigenvalue);
    
    // Store eigenvector
    for (let i = 0; i < n; i++) {
      vectors[i][f] = v[i];
    }
    
    // Deflate matrix
    for (let i = 0; i < n; i++) {
      for (let j = 0; j < n; j++) {
        M[i][j] -= eigenvalue * v[i] * v[j];
      }
    }
  }
  
  return { values, vectors };
}

// Varimax rotation
function rotateLoadings(loadings, method) {
  const n = loadings.length;
  const k = loadings[0].length;
  
  if (method === 'none' || k < 2) return loadings;
  
  let L = loadings.map(row => [...row]);
  const maxIter = 100;
  const eps = 1e-6;
  
  for (let iter = 0; iter < maxIter; iter++) {
    let maxRotation = 0;
    
    // Rotate each pair of factors
    for (let i = 0; i < k - 1; i++) {
      for (let j = i + 1; j < k; j++) {
        // Compute rotation angle
        let u = 0, v = 0, A = 0, B = 0, C = 0;
        
        for (let p = 0; p < n; p++) {
          const h2 = method === 'varimax' ? 1 : 
                     L[p].reduce((s, l) => s + l * l, 0) || 1;
          const xi = L[p][i] / Math.sqrt(h2);
          const xj = L[p][j] / Math.sqrt(h2);
          
          u += (xi * xi - xj * xj);
          v += 2 * xi * xj;
          A += xi * xi - xj * xj;
          B += 2 * xi * xj;
          C += (xi * xi - xj * xj) ** 2 - 4 * xi * xi * xj * xj;
        }
        
        // Calculate rotation angle
        const num = 2 * n * (A * B) - 2 * u * v;
        const den = n * C - (u * u - v * v);
        const phi = 0.25 * Math.atan2(num, den);
        
        if (Math.abs(phi) > maxRotation) maxRotation = Math.abs(phi);
        
        // Apply rotation
        const cos = Math.cos(phi);
        const sin = Math.sin(phi);
        
        for (let p = 0; p < n; p++) {
          const newI = cos * L[p][i] + sin * L[p][j];
          const newJ = -sin * L[p][i] + cos * L[p][j];
          L[p][i] = newI;
          L[p][j] = newJ;
        }
      }
    }
    
    if (maxRotation < eps) break;
  }
  
  // For oblimin/promax, apply additional transformation (simplified)
  if (method === 'promax') {
    // Promax: raise loadings to power and re-normalize
    const power = 4;
    L = L.map(row => {
      const signs = row.map(v => v >= 0 ? 1 : -1);
      const powered = row.map((v, i) => signs[i] * Math.pow(Math.abs(v), power));
      const norm = Math.sqrt(powered.reduce((s, v) => s + v * v, 0)) || 1;
      return powered.map(v => v / norm);
    });
  }
  
  return L;
}

// Matrix operations
function transposeMatrix(M) {
  const rows = M.length;
  const cols = M[0].length;
  const T = [];
  for (let j = 0; j < cols; j++) {
    T[j] = [];
    for (let i = 0; i < rows; i++) {
      T[j][i] = M[i][j];
    }
  }
  return T;
}

function multiplyMatrices(A, B) {
  if (!A || !B || !A.length || !B.length || !B[0]) return null;
  const n = A.length;
  const m = B[0].length;
  const p = B.length;
  const C = [];
  for (let i = 0; i < n; i++) {
    C[i] = [];
    for (let j = 0; j < m; j++) {
      C[i][j] = 0;
      for (let k = 0; k < p; k++) {
        C[i][j] += (A[i][k] || 0) * (B[k][j] || 0);
      }
    }
  }
  return C;
}

function invertMatrix(M) {
  const n = M.length;
  // Create augmented matrix [M | I]
  const aug = M.map((row, i) => [...row, ...Array(n).fill(0).map((_, j) => i === j ? 1 : 0)]);
  
  // Gaussian elimination
  for (let i = 0; i < n; i++) {
    // Find pivot
    let maxRow = i;
    for (let k = i + 1; k < n; k++) {
      if (Math.abs(aug[k][i]) > Math.abs(aug[maxRow][i])) maxRow = k;
    }
    [aug[i], aug[maxRow]] = [aug[maxRow], aug[i]];
    
    // Scale row
    const scale = aug[i][i] || 1e-10;
    for (let j = 0; j < 2 * n; j++) aug[i][j] /= scale;
    
    // Eliminate column
    for (let k = 0; k < n; k++) {
      if (k !== i) {
        const factor = aug[k][i];
        for (let j = 0; j < 2 * n; j++) aug[k][j] -= factor * aug[i][j];
      }
    }
  }
  
  return aug.map(row => row.slice(n));
}

// Main visualization compute function
function computeVisualization() {
  const status = document.getElementById('vizStatus');
  const output = document.getElementById('vizOutput');
  const canvas = document.getElementById('vizCanvas');
  const ctx = canvas.getContext('2d');
  const statsDiv = document.getElementById('vizStats');
  const statsContent = document.getElementById('vizStatsContent');
  
  status.textContent = 'Computing...';
  output.style.display = 'none';
  statsDiv.style.display = 'none';
  
  const method = document.getElementById('vizMethod').value;
  
  // Network graph uses Collocation Tables, not Frequency Table
  let data = null;
  if (method !== 'network') {
    data = getVisualizationData();
    if (!data) {
      status.textContent = 'Please compute Frequency Table first (Raw, DF, or Normalized value type).';
      return;
    }
    if (data.error) {
      status.textContent = data.error;
      return;
    }
  }
  
  vizData = data;
  
  setTimeout(() => {
    try {
      let statsHtml = '';
      
      switch (method) {
        case 'cluster': {
          const clusterMethod = document.getElementById('vizClusterMethod').value;
          const distType = document.getElementById('vizClusterDistance').value;
          const orientation = document.getElementById('vizClusterOrientation').value;
          const standardize = document.getElementById('vizClusterStandardize').checked;
          
          let clusterData, labels;
          if (orientation === 'rows') {
            clusterData = standardize ? standardizeMatrix(data.matrix) : data.matrix;
            labels = data.rowLabels;
          } else {
            const transposed = data.colLabels.map((_, j) => data.matrix.map(row => row[j]));
            clusterData = standardize ? standardizeMatrix(transposed) : transposed;
            labels = data.colLabels;
          }
          
          if (clusterMethod === 'kmeans') {
            // K-means clustering
            const k = parseInt(document.getElementById('vizKmeansK').value) || 3;
            const maxIter = parseInt(document.getElementById('vizKmeansIter').value) || 100;
            const initMethod = document.getElementById('vizKmeansInit').value;
            
            const kmeans = computeKMeans(clusterData, k, maxIter, initMethod, distType);
            
            canvas.width = 800;
            canvas.height = 600;
            drawKMeansPlot(ctx, kmeans, labels, 800, 600);
            
            vizResults = { type: 'kmeans', kmeans, labels };
            statsHtml = `<strong>K-Means Clustering</strong><br>`;
            statsHtml += `Items: ${labels.length}<br>`;
            statsHtml += `K (clusters): ${k}<br>`;
            statsHtml += `Distance: ${distType}<br>`;
            statsHtml += `Initialization: ${initMethod}<br>`;
            statsHtml += `Iterations: ${kmeans.iterations}<br>`;
            statsHtml += `Standardized: ${standardize ? 'Yes' : 'No'}<br><br>`;
            
            // Cluster membership table
            statsHtml += `<strong>Cluster Membership</strong><br>`;
            statsHtml += `<table style="border-collapse:collapse; margin-top:0.5rem;">`;
            statsHtml += `<tr><th style="border:1px solid #ccc; padding:4px;">Cluster</th><th style="border:1px solid #ccc; padding:4px;">Size</th><th style="border:1px solid #ccc; padding:4px;">Members</th></tr>`;
            for (let c = 0; c < k; c++) {
              const members = labels.filter((_, i) => kmeans.assignments[i] === c);
              statsHtml += `<tr><td style="border:1px solid #ccc; padding:4px;">${c + 1}</td>`;
              statsHtml += `<td style="border:1px solid #ccc; padding:4px;">${members.length}</td>`;
              statsHtml += `<td style="border:1px solid #ccc; padding:4px; font-size:0.85em;">${members.slice(0, 10).join(', ')}${members.length > 10 ? '...' : ''}</td></tr>`;
            }
            statsHtml += `</table>`;
            
            // Within-cluster sum of squares
            statsHtml += `<br><strong>Cluster Statistics</strong><br>`;
            statsHtml += `<table style="border-collapse:collapse; margin-top:0.5rem;">`;
            statsHtml += `<tr><th style="border:1px solid #ccc; padding:4px;">Cluster</th><th style="border:1px solid #ccc; padding:4px;">WCSS</th></tr>`;
            let totalWCSS = 0;
            for (let c = 0; c < k; c++) {
              statsHtml += `<tr><td style="border:1px solid #ccc; padding:4px;">${c + 1}</td>`;
              statsHtml += `<td style="border:1px solid #ccc; padding:4px; text-align:right;">${kmeans.wcss[c].toFixed(4)}</td></tr>`;
              totalWCSS += kmeans.wcss[c];
            }
            statsHtml += `<tr style="font-weight:bold;"><td style="border:1px solid #ccc; padding:4px;">Total</td>`;
            statsHtml += `<td style="border:1px solid #ccc; padding:4px; text-align:right;">${totalWCSS.toFixed(4)}</td></tr>`;
            statsHtml += `</table>`;
          } else {
            // Hierarchical clustering
            const linkage = document.getElementById('vizClusterLinkage').value;
            const treeType = document.getElementById('vizClusterTreeType').value;
            const horizontal = document.getElementById('vizClusterHorizontal').checked;
            const numClusters = parseInt(document.getElementById('vizClusterNumClusters').value) || 0;
            const showHeight = document.getElementById('vizClusterShowHeight').checked;
            
            const distMatrix = computeDistanceMatrix(clusterData, distType);
            const { root, mergeHistory } = hierarchicalClustering(distMatrix, labels, linkage);
            
            // Adjust canvas size for horizontal layout
            canvas.width = horizontal ? 900 : 800;
            canvas.height = horizontal ? 600 : 700;
            
            drawDendrogram(ctx, root, labels, canvas.width, canvas.height, {
              horizontal,
              treeType,
              numClusters,
              showHeight
            });
            
            vizResults = { type: 'cluster', distMatrix, mergeHistory, labels, root };
            statsHtml = `<strong>Hierarchical Clustering</strong><br>`;
            statsHtml += `Items: ${labels.length}<br>`;
            statsHtml += `Linkage: ${linkage}, Distance: ${distType}<br>`;
            statsHtml += `Standardized: ${standardize ? 'Yes' : 'No'}<br>`;
            statsHtml += `Max height: ${root.height?.toFixed(4) || 'N/A'}`;
            if (numClusters > 1) {
              statsHtml += `<br>Clusters shown: ${numClusters}`;
            }
          }
          break;
        }
        
        case 'pca': {
          const showBiplot = document.getElementById('vizPcaBiplot').checked;
          const pca = computePCA(data.matrix);
          
          canvas.width = 800;
          canvas.height = 600;
          drawPCAPlot(ctx, pca, data.rowLabels, data.colLabels, 800, 600, showBiplot);
          
          vizResults = { type: 'pca', pca };
          statsHtml = `<strong>Principal Component Analysis</strong><br>`;
          
          // Total Variance Explained
          statsHtml += `<strong>Total Variance Explained</strong><br>`;
          statsHtml += `<table style="border-collapse:collapse; margin-top:0.5rem;"><tr><th style="border:1px solid #ccc; padding:4px;">PC</th><th style="border:1px solid #ccc; padding:4px;">PCA Variance</th><th style="border:1px solid #ccc; padding:4px;">Difference</th><th style="border:1px solid #ccc; padding:4px;">Proportion (%)</th><th style="border:1px solid #ccc; padding:4px;">Cumulative %</th></tr>`;
          let cumVar = 0;
          pca.eigenvalues.forEach((ev, i) => {
            cumVar += pca.varianceExplained[i];
            const diff = i < pca.eigenvalues.length - 1 ? ev - pca.eigenvalues[i + 1] : 0;
            statsHtml += `<tr><td style="border:1px solid #ccc; padding:4px;">PC ${i+1}</td>`;
            statsHtml += `<td style="border:1px solid #ccc; padding:4px; text-align:right;">${ev.toFixed(3)}</td>`;
            statsHtml += `<td style="border:1px solid #ccc; padding:4px; text-align:right;">${diff.toFixed(3)}</td>`;
            statsHtml += `<td style="border:1px solid #ccc; padding:4px; text-align:right;">${pca.varianceExplained[i].toFixed(3)}</td>`;
            statsHtml += `<td style="border:1px solid #ccc; padding:4px; text-align:right;">${cumVar.toFixed(3)}</td></tr>`;
          });
          statsHtml += `</table>`;
          
          // Factor Scores
          const maxPCs = Math.min(pca.scores[0]?.length || 0, 11);
          statsHtml += `<br><strong>Factor Scores</strong><br>`;
          statsHtml += `<div style="overflow-x:auto;"><table style="border-collapse:collapse; margin-top:0.5rem;"><tr><th style="border:1px solid #ccc; padding:4px;">Group</th>`;
          for (let p = 0; p < maxPCs; p++) {
            statsHtml += `<th style="border:1px solid #ccc; padding:4px;">PC${p+1}</th>`;
          }
          statsHtml += `</tr>`;
          pca.scores.forEach((scores, i) => {
            statsHtml += `<tr><td style="border:1px solid #ccc; padding:4px;">${escapeHtml(data.rowLabels[i])}</td>`;
            for (let p = 0; p < maxPCs; p++) {
              statsHtml += `<td style="border:1px solid #ccc; padding:4px; text-align:right;">${scores[p]?.toFixed(3) || 0}</td>`;
            }
            statsHtml += `</tr>`;
          });
          statsHtml += `</table></div>`;
          break;
        }
        
        case 'correspondence': {
          const displayMode = document.getElementById('vizCaDisplayMode').value;
          const dimX = parseInt(document.getElementById('vizCaDimX').value) - 1;
          const dimY = parseInt(document.getElementById('vizCaDimY').value) - 1;
          const rowMarker = document.getElementById('vizCaRowMarker').value;
          const colMarker = document.getElementById('vizCaColMarker').value;
          const showRowLabels = document.getElementById('vizCaShowRowLabels').checked;
          const showColLabels = document.getElementById('vizCaShowColLabels').checked;
          // Use main Top N columns setting for label display (0 = show all)
          const mainTopN = parseInt(document.getElementById('vizTopNColumns')?.value) || 0;
          const topColLabels = mainTopN > 0 ? mainTopN : 1000; // Show all if 0
          
          const ca = computeCorrespondenceAnalysis(data.matrix);
          
          if (!ca) {
            status.textContent = 'Cannot compute CA: matrix has zero total.';
            return;
          }
          
          canvas.width = 900;
          canvas.height = 700;
          drawCAPlot(ctx, ca, data.rowLabels, data.colLabels, 900, 700, {
            displayMode,
            dimX,
            dimY,
            rowMarker,
            colMarker,
            showRowLabels,
            showColLabels,
            topColLabels
          });
          
          vizResults = { type: 'ca', ca, displayMode };
          
          let titleMode = displayMode === 'rows' ? ' (Row Coordinates)' : 
                          displayMode === 'cols' ? ' (Column Coordinates)' : '';
          statsHtml = `<strong>Correspondence Analysis${titleMode}</strong><br>`;
          
          // Inertia table
          statsHtml += `<table style="border-collapse:collapse; margin-top:0.5rem;"><tr><th style="border:1px solid #ccc; padding:4px;">Dim</th><th style="border:1px solid #ccc; padding:4px;">Eigenvalue</th><th style="border:1px solid #ccc; padding:4px;">Inertia %</th><th style="border:1px solid #ccc; padding:4px;">Cumulative %</th></tr>`;
          let cumInertia = 0;
          ca.eigenvalues.forEach((ev, i) => {
            cumInertia += ca.inertiaExplained[i];
            statsHtml += `<tr><td style="border:1px solid #ccc; padding:4px;">Dim ${i+1}</td><td style="border:1px solid #ccc; padding:4px;">${ev.toFixed(4)}</td><td style="border:1px solid #ccc; padding:4px;">${ca.inertiaExplained[i].toFixed(2)}%</td><td style="border:1px solid #ccc; padding:4px;">${cumInertia.toFixed(2)}%</td></tr>`;
          });
          statsHtml += `</table>`;
          
          // Row scores table
          statsHtml += `<br><strong>Row Coordinates</strong><br>`;
          statsHtml += `<table style="border-collapse:collapse; margin-top:0.5rem;"><tr><th style="border:1px solid #ccc; padding:4px;">Group</th>`;
          const numDims = Math.min(3, ca.rowScores[0]?.length || 0);
          for (let d = 0; d < numDims; d++) {
            statsHtml += `<th style="border:1px solid #ccc; padding:4px;">Dim ${d+1}</th><th style="border:1px solid #ccc; padding:4px;">Std</th>`;
          }
          statsHtml += `</tr>`;
          
          // Calculate standardized scores for rows
          const rowStdScores = ca.rowScores.map(scores => {
            return scores.map((s, d) => {
              const sd = Math.sqrt(ca.eigenvalues[d] || 1);
              return sd > 0 ? s / sd : 0;
            });
          });
          
          ca.rowScores.forEach((scores, i) => {
            statsHtml += `<tr><td style="border:1px solid #ccc; padding:4px;">${escapeHtml(data.rowLabels[i])}</td>`;
            for (let d = 0; d < numDims; d++) {
              statsHtml += `<td style="border:1px solid #ccc; padding:4px; text-align:right;">${scores[d]?.toFixed(3) || 0}</td>`;
              statsHtml += `<td style="border:1px solid #ccc; padding:4px; text-align:right;">${rowStdScores[i][d]?.toFixed(3) || 0}</td>`;
            }
            statsHtml += `</tr>`;
          });
          statsHtml += `</table>`;
          
          // ALL Column Loadings (sorted by Dim 1)
          statsHtml += `<br><strong>All Column Loadings (sorted by Dim 1)</strong><br>`;
          statsHtml += `<div style="max-height:400px; overflow-y:auto; border:1px solid #ccc;">`;
          statsHtml += `<table style="border-collapse:collapse; width:100%;">`;
          statsHtml += `<tr style="position:sticky; top:0; background:#f5f5f5;"><th style="border:1px solid #ccc; padding:4px;">Feature</th>`;
          for (let d = 0; d < Math.min(3, numDims); d++) {
            statsHtml += `<th style="border:1px solid #ccc; padding:4px;">Dim ${d+1}</th>`;
            statsHtml += `<th style="border:1px solid #ccc; padding:4px;">Std ${d+1}</th>`;
          }
          statsHtml += `</tr>`;
          
          // Calculate standardized scores for all columns
          const colWithStd = ca.colScores.map((scores, j) => {
            const stdScores = scores.map((s, d) => {
              const sd = Math.sqrt(ca.eigenvalues[d] || 1);
              return sd > 0 ? s / sd : 0;
            });
            return {
              label: data.colLabels[j],
              scores: scores,
              stdScores: stdScores,
              sortVal: scores[0] || 0
            };
          });
          
          // Sort by Dim 1 (descending)
          colWithStd.sort((a, b) => b.sortVal - a.sortVal);
          
          // Display all rows
          colWithStd.forEach((item, idx) => {
            const label = item.label.length > 25 ? item.label.substring(0, 22) + '...' : item.label;
            statsHtml += `<tr><td style="border:1px solid #ccc; padding:3px; font-size:0.85em;">${escapeHtml(label)}</td>`;
            for (let d = 0; d < Math.min(3, numDims); d++) {
              statsHtml += `<td style="border:1px solid #ccc; padding:3px; text-align:right; font-size:0.85em;">${(item.scores[d] || 0).toFixed(3)}</td>`;
              statsHtml += `<td style="border:1px solid #ccc; padding:3px; text-align:right; font-size:0.85em;">${(item.stdScores[d] || 0).toFixed(3)}</td>`;
            }
            statsHtml += `</tr>`;
          });
          statsHtml += `</table></div>`;
          break;
        }
        
        case 'mds': {
          const mdsMethod = document.getElementById('vizMdsMethod').value;
          const distType = document.getElementById('vizMdsDistance').value;
          const numDims = parseInt(document.getElementById('vizMdsDimensions').value) || 2;
          const dimX = parseInt(document.getElementById('vizMdsDimX').value) - 1;
          const dimY = parseInt(document.getElementById('vizMdsDimY').value) - 1;
          const standardize = document.getElementById('vizMdsStandardize').checked;
          
          const matrixToUse = standardize ? standardizeMatrix(data.matrix) : data.matrix;
          const distMatrix = computeDistanceMatrix(matrixToUse, distType);
          const mds = computeMDS(distMatrix, numDims, mdsMethod);
          
          canvas.width = 800;
          canvas.height = 600;
          
          if (numDims === 3) {
            drawMDS3DPlot(ctx, mds, data.rowLabels, 800, 600);
          } else {
            drawMDSPlot(ctx, mds, data.rowLabels, 800, 600, { dimX, dimY });
          }
          
          vizResults = { type: 'mds', mds, distMatrix };
          
          const methodNames = { classical: 'Classical (Metric)', kruskal: 'Non-metric (Kruskal)', sammon: 'Non-metric (Sammon)' };
          statsHtml = `<strong>Multidimensional Scaling</strong><br>`;
          statsHtml += `Method: ${methodNames[mdsMethod] || mdsMethod}<br>`;
          statsHtml += `Distance: ${distType}${standardize ? ' (standardized)' : ''}<br>`;
          if (numDims === 3) {
            statsHtml += `Dimensions: 3D (Dim 1 vs Dim 2 vs Dim 3)<br>`;
          } else {
            statsHtml += `Dimensions: 2D (Dim ${dimX + 1} vs Dim ${dimY + 1})<br>`;
          }
          statsHtml += `Groups: ${data.rowLabels.length}<br><br>`;
          
          // Coordinates table
          statsHtml += `<strong>MDS Coordinates</strong><br>`;
          statsHtml += `<table style="border-collapse:collapse; margin-top:0.5rem;"><tr><th style="border:1px solid #ccc; padding:4px;">Group</th>`;
          for (let d = 0; d < numDims; d++) {
            statsHtml += `<th style="border:1px solid #ccc; padding:4px;">Dim ${d+1}</th>`;
          }
          statsHtml += `</tr>`;
          mds.coords.forEach((c, i) => {
            statsHtml += `<tr><td style="border:1px solid #ccc; padding:4px;">${escapeHtml(data.rowLabels[i])}</td>`;
            for (let d = 0; d < numDims; d++) {
              statsHtml += `<td style="border:1px solid #ccc; padding:4px; text-align:right;">${c[d]?.toFixed(3) || 0}</td>`;
            }
            statsHtml += `</tr>`;
          });
          statsHtml += `</table>`;
          break;
        }
        
        case 'heatmap': {
          const standardize = document.getElementById('vizHeatmapStandardize').checked;
          const dendrogram = document.getElementById('vizHeatmapDendrogram').value;
          const scaling = document.getElementById('vizHeatmapScaling').value;
          const distance = document.getElementById('vizHeatmapDistance').value;
          const linkage = document.getElementById('vizHeatmapLinkage').value;
          const colorScale = document.getElementById('vizHeatmapColorScale').value;
          
          const clusterRows = dendrogram === 'both' || dendrogram === 'row';
          const clusterCols = dendrogram === 'both' || dendrogram === 'col';
          
          canvas.width = 900;
          canvas.height = 700;
          drawHeatmap(ctx, data, 900, 700, {
            colorScale,
            clusterRows,
            clusterCols,
            standardize,
            scaling,
            distance,
            linkage
          });
          
          vizResults = { type: 'heatmap', data };
          statsHtml = `<strong>Heatmap</strong><br>`;
          statsHtml += `Groups: ${data.rowLabels.length}, Features: ${data.colLabels.length}<br>`;
          statsHtml += `Standardize: ${standardize ? 'Yes' : 'No'}, Scaling: ${scaling}<br>`;
          statsHtml += `Distance: ${distance}, Linkage: ${linkage}<br>`;
          statsHtml += `Dendrogram: ${dendrogram}`;
          break;
        }
        
        case 'network': {
          // Network graph - linked with 6) Collocation Tables
          if (!corpus || !corpus.files || Object.keys(corpus.files).length === 0) {
            status.textContent = 'Please load corpus data first.';
            return;
          }
          
          // Sync center node from KWIC if empty
          const centerNodeInput = document.getElementById('vizNetworkCenterNode');
          if (!centerNodeInput.value && collocateData && collocateData.node) {
            centerNodeInput.value = collocateData.node;
          }
          
          const centerNode = centerNodeInput.value.trim();
          const scope = document.querySelector('input[name="vizNetworkScope"]:checked')?.value || 'target';
          const spanL = parseInt(document.getElementById('vizNetworkSpanL').value) || 5;
          const spanR = parseInt(document.getElementById('vizNetworkSpanR').value) || 5;
          const position = document.getElementById('vizNetworkPosition').value;
          const edgeWeight = document.getElementById('vizNetworkEdgeWeight').value;
          const similarity = document.getElementById('vizNetworkSimilarity')?.value || 'jaccard';
          const communityDetection = document.getElementById('vizNetworkCommunity')?.checked ?? true;
          const showEdgeCoef = document.getElementById('vizNetworkShowEdgeCoef')?.checked ?? false;
          const minSimilarity = parseFloat(document.getElementById('vizNetworkMinSimilarity')?.value) || 0.1;
          const maxNodes = parseInt(document.getElementById('vizNetworkMaxNodes').value) || 50;
          const maxEdges = parseInt(document.getElementById('vizNetworkMaxEdges').value) || 200;
          const minFreq = parseInt(document.getElementById('vizNetworkMinFreq').value) || 3;
          const minScore = parseFloat(document.getElementById('vizNetworkMinScore').value) || 0;
          const excludeStopwords = document.getElementById('vizNetworkExcludeStopwords').checked;
          const lowercase = document.getElementById('vizNetworkLowercase').checked;
          const layout = document.getElementById('vizNetworkLayout').value;
          const nodeSizeBy = document.getElementById('vizNetworkNodeSize').value;
          const showLabels = document.getElementById('vizNetworkShowLabels').checked;
          
          if (!collocateData) {
            status.textContent = 'No 6) Collocation Tables data. Please run "Compute" first.';
            return;
          }
          
          if (!collocateData.data) {
            status.textContent = 'Collocation data structure is invalid. Please re-run 6) Collocation Tables.';
            return;
          }
          
          canvas.width = 900;
          canvas.height = 700;
          
          const networkResult = computeNetworkFromCollocate({
            centerNode,
            scope,
            spanL,
            spanR,
            position,
            edgeWeight,
            similarity,
            communityDetection,
            showEdgeCoef,
            minSimilarity,
            maxNodes,
            maxEdges,
            minFreq,
            minScore,
            excludeStopwords,
            lowercase
          });
          
          if (networkResult.error) {
            status.textContent = networkResult.error;
            return;
          }
          
          // Store for interactions
          currentNetworkData = networkResult;
          
          // Draw network
          drawNetworkGraph(ctx, networkResult, 900, 700, {
            nodeSizeBy,
            showLabels,
            layout
          });
          
          // Show legend
          document.getElementById('vizNetworkLegend').style.display = scope === 'all' ? 'block' : 'none';
          
          vizResults = { type: 'network', ...networkResult };
          
          // Statistics output
          statsHtml = `<strong>Collocate Network</strong><br>`;
          statsHtml += `Center: "${networkResult.centerWord}"<br>`;
          statsHtml += `Scope: ${scope}${scope === 'all' ? ` (T:${networkResult.targetHits}, R:${networkResult.refHits})` : ''}<br>`;
          statsHtml += `Span: L${spanL} / R${spanR}, Position: ${position}<br>`;
          statsHtml += `KWIC hits: ${networkResult.totalHits.toLocaleString()}<br>`;
          statsHtml += `Nodes: ${networkResult.nodes.length}, Edges: ${networkResult.edges.length}`;
          if (networkResult.communities > 0) {
            statsHtml += `, Communities: ${networkResult.communities}`;
          }
          statsHtml += `<br>`;
          statsHtml += `Similarity: ${similarity}, Min: ${minSimilarity}<br>`;
          
          // Collocate table
          statsHtml += `<br><strong>Top Collocates (${edgeWeight})</strong><br>`;
          statsHtml += `<div style="max-height:300px; overflow-y:auto; border:1px solid #ccc;">`;
          statsHtml += `<table style="border-collapse:collapse; width:100%;">`;
          statsHtml += `<tr style="position:sticky; top:0; background:#f5f5f5;">`;
          statsHtml += `<th style="border:1px solid #ccc; padding:4px;">Collocate</th>`;
          statsHtml += `<th style="border:1px solid #ccc; padding:4px;">Freq</th>`;
          if (scope === 'all') {
            statsHtml += `<th style="border:1px solid #ccc; padding:4px;">T</th>`;
            statsHtml += `<th style="border:1px solid #ccc; padding:4px;">R</th>`;
          }
          statsHtml += `<th style="border:1px solid #ccc; padding:4px;">Pos</th>`;
          statsHtml += `<th style="border:1px solid #ccc; padding:4px;">${edgeWeight}</th>`;
          if (networkResult.communities > 0) {
            statsHtml += `<th style="border:1px solid #ccc; padding:4px;">Comm</th>`;
          }
          statsHtml += `<th style="border:1px solid #ccc; padding:4px;">Source</th>`;
          statsHtml += `</tr>`;
          
          const sortedNodes = [...networkResult.nodes]
            .filter(n => !n.isCenter)
            .sort((a, b) => b.weight - a.weight);
          
          sortedNodes.forEach(node => {
            const rowColor = node.source === 'target' ? '#e8f4fc' : 
                            node.source === 'reference' ? '#fce8e8' :
                            node.source === 'both' ? '#f0e8fc' : '#fff';
            statsHtml += `<tr style="background:${rowColor}; cursor:pointer;" onclick="networkNodeClick('${escapeHtml(node.label)}')">`;
            statsHtml += `<td style="border:1px solid #ccc; padding:3px; font-size:0.85em;">${escapeHtml(node.label)}</td>`;
            statsHtml += `<td style="border:1px solid #ccc; padding:3px; text-align:right;">${node.freq}</td>`;
            if (scope === 'all') {
              statsHtml += `<td style="border:1px solid #ccc; padding:3px; text-align:right;">${node.freqT || 0}</td>`;
              statsHtml += `<td style="border:1px solid #ccc; padding:3px; text-align:right;">${node.freqR || 0}</td>`;
            }
            statsHtml += `<td style="border:1px solid #ccc; padding:3px; text-align:center;">${node.position}</td>`;
            statsHtml += `<td style="border:1px solid #ccc; padding:3px; text-align:right;">${node.weight.toFixed(2)}</td>`;
            if (networkResult.communities > 0) {
              statsHtml += `<td style="border:1px solid #ccc; padding:3px; text-align:center;">${(node.community || 0) + 1}</td>`;
            }
            statsHtml += `<td style="border:1px solid #ccc; padding:3px; text-align:center;">${node.source}</td>`;
            statsHtml += `</tr>`;
          });
          statsHtml += `</table></div>`;
          statsHtml += `<div class="help-text mt-05">Click a row to filter KWIC by that collocate.</div>`;
          break;
        }
        
        case 'efa': {
          const numFactors = parseInt(document.getElementById('vizEfaFactors').value) || 2;
          const extraction = document.getElementById('vizEfaExtraction').value;
          const rotation = document.getElementById('vizEfaRotation').value;
          const matrixType = document.getElementById('vizEfaMatrix').value;
          const scoreMethod = document.getElementById('vizEfaScoreMethod').value;
          const plotType = document.getElementById('vizEfaPlotType').value;
          const axisX = parseInt(document.getElementById('vizEfaAxisX').value) - 1;
          const axisY = parseInt(document.getElementById('vizEfaAxisY').value) - 1;
          const labelThreshold = parseFloat(document.getElementById('vizEfaLabelThreshold').value) || 0.3;
          const showCommunalities = document.getElementById('vizEfaCommunalities').checked;
          const showFactorScores = document.getElementById('vizEfaFactorScores').checked;
          
          const efa = computeEFA(data, {
            numFactors,
            extraction,
            rotation,
            matrixType,
            scoreMethod
          });
          
          canvas.width = 800;
          canvas.height = 700;
          ctx.clearRect(0, 0, 800, 700);
          ctx.fillStyle = '#fff';
          ctx.fillRect(0, 0, 800, 700);
          
          if (plotType === 'biplot') {
            // Draw Factor Biplot (like the PDF)
            drawFactorBiplot(ctx, efa, 800, 700, {
              axisX,
              axisY,
              labelThreshold,
              showFactorScores,
              rowLabels: data.rowLabels
            });
          } else if (plotType === 'scree') {
            // Scree plot
            drawScreePlot(ctx, efa, 800, 700);
          } else {
            // Loading heatmap
            drawLoadingHeatmap(ctx, efa, 800, 700);
          }
          
          vizResults = { type: 'efa', efa };
          
          // Statistics output
          const extractionNames = {
            minres: 'Minimum Residuals',
            wls: 'Weighted Least Squares',
            gls: 'Generalized WLS',
            pa: 'Principal Factor',
            ml: 'Maximum Likelihood'
          };
          const rotationNames = {
            none: 'None',
            varimax: 'Varimax',
            promax: 'Promax',
            oblimin: 'Oblimin'
          };
          
          statsHtml = `<strong>Exploratory Factor Analysis</strong><br>`;
          statsHtml += `Extraction: ${extractionNames[extraction]}<br>`;
          statsHtml += `Rotation: ${rotationNames[rotation]}<br>`;
          statsHtml += `Matrix: ${matrixType}<br>`;
          statsHtml += `Factors: ${numFactors}<br><br>`;
          
          // Eigenvalues and Variance table
          statsHtml += `<strong>Variance Explained</strong><br>`;
          statsHtml += `<table style="border-collapse:collapse; margin-top:0.5rem;">`;
          statsHtml += `<tr><th style="border:1px solid #ccc; padding:4px;">Factor</th><th style="border:1px solid #ccc; padding:4px;">Eigenvalue</th><th style="border:1px solid #ccc; padding:4px;">Variance %</th><th style="border:1px solid #ccc; padding:4px;">Cumulative %</th></tr>`;
          let cumVar = 0;
          efa.eigenvalues.forEach((ev, i) => {
            cumVar += efa.varianceExplained[i];
            statsHtml += `<tr><td style="border:1px solid #ccc; padding:4px;">Factor ${i+1}</td>`;
            statsHtml += `<td style="border:1px solid #ccc; padding:4px; text-align:right;">${ev.toFixed(4)}</td>`;
            statsHtml += `<td style="border:1px solid #ccc; padding:4px; text-align:right;">${efa.varianceExplained[i].toFixed(2)}%</td>`;
            statsHtml += `<td style="border:1px solid #ccc; padding:4px; text-align:right;">${cumVar.toFixed(2)}%</td></tr>`;
          });
          statsHtml += `</table>`;
          
          // Factor Loadings table
          statsHtml += `<br><strong>Factor Loadings (sorted by Factor 1)</strong><br>`;
          statsHtml += `<div style="max-height:300px; overflow-y:auto; border:1px solid #ccc;">`;
          statsHtml += `<table style="border-collapse:collapse; width:100%;">`;
          statsHtml += `<tr style="position:sticky; top:0; background:#f5f5f5;"><th style="border:1px solid #ccc; padding:4px;">Feature</th>`;
          for (let f = 0; f < numFactors; f++) {
            statsHtml += `<th style="border:1px solid #ccc; padding:4px;">Factor ${f+1}</th>`;
          }
          if (showCommunalities) statsHtml += `<th style="border:1px solid #ccc; padding:4px;">h²</th>`;
          statsHtml += `</tr>`;
          
          // Sort by first factor loading
          const sortedLoadings = [...efa.loadings].sort((a, b) => Math.abs(b.loadings[0]) - Math.abs(a.loadings[0]));
          sortedLoadings.forEach((item, idx) => {
            const label = item.feature.length > 20 ? item.feature.substring(0, 17) + '...' : item.feature;
            statsHtml += `<tr><td style="border:1px solid #ccc; padding:3px; font-size:0.85em;">${escapeHtml(label)}</td>`;
            for (let f = 0; f < numFactors; f++) {
              const val = item.loadings[f];
              const bgColor = Math.abs(val) >= 0.4 ? (val > 0 ? '#cce5ff' : '#ffcccc') : '';
              statsHtml += `<td style="border:1px solid #ccc; padding:3px; text-align:right; font-size:0.85em; background:${bgColor};">${val.toFixed(3)}</td>`;
            }
            if (showCommunalities) {
              const h2 = efa.communalities[efa.loadings.indexOf(item)];
              statsHtml += `<td style="border:1px solid #ccc; padding:3px; text-align:right; font-size:0.85em;">${h2?.toFixed(3) || 'N/A'}</td>`;
            }
            statsHtml += `</tr>`;
          });
          statsHtml += `</table></div>`;
          
          // Factor Scores table
          if (showFactorScores && efa.factorScores.length > 0) {
            statsHtml += `<br><strong>Factor Scores</strong><br>`;
            statsHtml += `<div style="max-height:200px; overflow-y:auto; border:1px solid #ccc;">`;
            statsHtml += `<table style="border-collapse:collapse; width:100%;">`;
            statsHtml += `<tr style="position:sticky; top:0; background:#f5f5f5;"><th style="border:1px solid #ccc; padding:4px;">Group</th>`;
            for (let f = 0; f < numFactors; f++) {
              statsHtml += `<th style="border:1px solid #ccc; padding:4px;">Factor ${f+1}</th>`;
            }
            statsHtml += `</tr>`;
            efa.factorScores.forEach((scores, i) => {
              const label = data.rowLabels[i];
              statsHtml += `<tr><td style="border:1px solid #ccc; padding:3px; font-size:0.85em;">${escapeHtml(label)}</td>`;
              for (let f = 0; f < numFactors; f++) {
                statsHtml += `<td style="border:1px solid #ccc; padding:3px; text-align:right; font-size:0.85em;">${scores[f]?.toFixed(3) || 0}</td>`;
              }
              statsHtml += `</tr>`;
            });
            statsHtml += `</table></div>`;
          }
          break;
        }
        
        case 'randomforest': {
          const numTrees = parseInt(document.getElementById('vizRfTrees').value) || 100;
          const maxDepth = document.getElementById('vizRfMaxDepth').value;
          const criterion = document.getElementById('vizRfCriterion').value;
          const maxFeatures = document.getElementById('vizRfMaxFeatures').value;
          const topN = parseInt(document.getElementById('vizRfTopN').value) || 20;
          const showImportance = document.getElementById('vizRfShowImportance').checked;
          const showConfusion = document.getElementById('vizRfShowConfusion').checked;
          const showPrediction = document.getElementById('vizRfShowPrediction').checked;
          
          const rf = computeRandomForestFull(data, {
            numTrees,
            maxDepth: maxDepth === 'none' ? null : parseInt(maxDepth),
            criterion,
            maxFeatures,
            topN
          });
          
          if (!rf) {
            status.textContent = 'Not enough data for Random Forest.';
            return;
          }
          
          canvas.width = 800;
          canvas.height = 600;
          
          if (showImportance) {
            drawFeatureImportance(ctx, rf.importances, 800, 600);
          } else if (showConfusion) {
            drawConfusionMatrix(ctx, rf.confusion, rf.classLabels, 800, 600);
          } else {
            drawPredictionPlot(ctx, rf.predictions, data.rowLabels, 800, 600);
          }
          
          vizResults = { type: 'rf', rf };
          statsHtml = `<strong>Random Forest Classification</strong><br>`;
          statsHtml += `Trees: ${numTrees}, Max depth: ${maxDepth}<br>`;
          statsHtml += `Criterion: ${criterion}, Max features: ${maxFeatures}<br>`;
          statsHtml += `OOB Accuracy: ${(rf.oobAccuracy * 100).toFixed(2)}%<br><br>`;
          
          // Feature importance table
          statsHtml += `<strong>Feature Importance (Top ${rf.importances.length})</strong><br>`;
          statsHtml += `<div style="max-height:200px; overflow-y:auto; border:1px solid #ccc;">`;
          statsHtml += `<table style="border-collapse:collapse; width:100%;">`;
          statsHtml += `<tr style="position:sticky; top:0; background:#f5f5f5;"><th style="border:1px solid #ccc; padding:4px;">Rank</th><th style="border:1px solid #ccc; padding:4px;">Feature</th><th style="border:1px solid #ccc; padding:4px;">Importance</th></tr>`;
          rf.importances.forEach((imp, i) => {
            statsHtml += `<tr><td style="border:1px solid #ccc; padding:3px;">${i + 1}</td>`;
            statsHtml += `<td style="border:1px solid #ccc; padding:3px; font-size:0.85em;">${escapeHtml(imp.feature)}</td>`;
            statsHtml += `<td style="border:1px solid #ccc; padding:3px; text-align:right;">${imp.importance.toFixed(4)}</td></tr>`;
          });
          statsHtml += `</table></div>`;
          
          // Confusion matrix
          if (rf.confusion) {
            statsHtml += `<br><strong>Confusion Matrix</strong><br>`;
            statsHtml += `<table style="border-collapse:collapse; margin-top:0.5rem;"><tr><th style="border:1px solid #ccc; padding:4px;"></th>`;
            rf.classLabels.forEach(label => {
              statsHtml += `<th style="border:1px solid #ccc; padding:4px; font-size:0.85em;">Pred: ${label}</th>`;
            });
            statsHtml += `</tr>`;
            rf.classLabels.forEach((label, i) => {
              statsHtml += `<tr><th style="border:1px solid #ccc; padding:4px; font-size:0.85em;">True: ${label}</th>`;
              rf.confusion[i].forEach(val => {
                statsHtml += `<td style="border:1px solid #ccc; padding:4px; text-align:center;">${val}</td>`;
              });
              statsHtml += `</tr>`;
            });
            statsHtml += `</table>`;
          }
          break;
        }
        
        case 'tsne': {
          const perplexity = parseInt(document.getElementById('vizTsnePerplexity').value) || 30;
          const learningRate = parseInt(document.getElementById('vizTsneLearningRate').value) || 200;
          const iterations = parseInt(document.getElementById('vizTsneIterations').value) || 1000;
          const distType = document.getElementById('vizTsneDistance').value;
          const standardize = document.getElementById('vizTsneStandardize').checked;
          const exaggeration = parseFloat(document.getElementById('vizTsneExaggeration').value) || 12;
          const showLabels = document.getElementById('vizTsneShowLabels').checked;
          
          const tsne = computeTSNEFull(data, {
            perplexity,
            learningRate,
            iterations,
            distType,
            standardize,
            exaggeration
          });
          
          if (!tsne) {
            status.textContent = 'Not enough data for t-SNE.';
            return;
          }
          
          canvas.width = 800;
          canvas.height = 600;
          drawDimReductionPlot(ctx, tsne, data.rowLabels, 800, 600, 't-SNE', showLabels);
          
          vizResults = { type: 'tsne', tsne };
          statsHtml = `<strong>t-SNE (t-Distributed Stochastic Neighbor Embedding)</strong><br>`;
          statsHtml += `Perplexity: ${perplexity}<br>`;
          statsHtml += `Learning rate: ${learningRate}<br>`;
          statsHtml += `Iterations: ${iterations}<br>`;
          statsHtml += `Distance: ${distType}<br>`;
          statsHtml += `Early exaggeration: ${exaggeration}<br>`;
          statsHtml += `Standardized: ${standardize ? 'Yes' : 'No'}<br><br>`;
          
          // Coordinates table
          statsHtml += `<strong>t-SNE Coordinates</strong><br>`;
          statsHtml += `<div style="max-height:200px; overflow-y:auto; border:1px solid #ccc;">`;
          statsHtml += `<table style="border-collapse:collapse; width:100%;">`;
          statsHtml += `<tr style="position:sticky; top:0; background:#f5f5f5;"><th style="border:1px solid #ccc; padding:4px;">Group</th><th style="border:1px solid #ccc; padding:4px;">Dim 1</th><th style="border:1px solid #ccc; padding:4px;">Dim 2</th></tr>`;
          tsne.coords.forEach((c, i) => {
            statsHtml += `<tr><td style="border:1px solid #ccc; padding:3px;">${escapeHtml(data.rowLabels[i])}</td>`;
            statsHtml += `<td style="border:1px solid #ccc; padding:3px; text-align:right;">${c[0].toFixed(4)}</td>`;
            statsHtml += `<td style="border:1px solid #ccc; padding:3px; text-align:right;">${c[1].toFixed(4)}</td></tr>`;
          });
          statsHtml += `</table></div>`;
          break;
        }
        
        case 'umap': {
          const nNeighbors = parseInt(document.getElementById('vizUmapNeighbors').value) || 15;
          const minDist = parseFloat(document.getElementById('vizUmapMinDist').value) || 0.1;
          const metric = document.getElementById('vizUmapMetric').value;
          const epochs = parseInt(document.getElementById('vizUmapEpochs').value) || 500;
          const standardize = document.getElementById('vizUmapStandardize').checked;
          const spread = parseFloat(document.getElementById('vizUmapSpread').value) || 1.0;
          const showLabels = document.getElementById('vizUmapShowLabels').checked;
          
          const umap = computeUMAPFull(data, {
            nNeighbors,
            minDist,
            metric,
            epochs,
            standardize,
            spread
          });
          
          if (!umap) {
            status.textContent = 'Not enough data for UMAP.';
            return;
          }
          
          canvas.width = 800;
          canvas.height = 600;
          drawDimReductionPlot(ctx, umap, data.rowLabels, 800, 600, 'UMAP', showLabels);
          
          vizResults = { type: 'umap', umap };
          statsHtml = `<strong>UMAP (Uniform Manifold Approximation and Projection)</strong><br>`;
          statsHtml += `n_neighbors: ${nNeighbors}<br>`;
          statsHtml += `min_dist: ${minDist}<br>`;
          statsHtml += `Metric: ${metric}<br>`;
          statsHtml += `Epochs: ${epochs}<br>`;
          statsHtml += `Spread: ${spread}<br>`;
          statsHtml += `Standardized: ${standardize ? 'Yes' : 'No'}<br><br>`;
          
          // Coordinates table
          statsHtml += `<strong>UMAP Coordinates</strong><br>`;
          statsHtml += `<div style="max-height:200px; overflow-y:auto; border:1px solid #ccc;">`;
          statsHtml += `<table style="border-collapse:collapse; width:100%;">`;
          statsHtml += `<tr style="position:sticky; top:0; background:#f5f5f5;"><th style="border:1px solid #ccc; padding:4px;">Group</th><th style="border:1px solid #ccc; padding:4px;">Dim 1</th><th style="border:1px solid #ccc; padding:4px;">Dim 2</th></tr>`;
          umap.coords.forEach((c, i) => {
            statsHtml += `<tr><td style="border:1px solid #ccc; padding:3px;">${escapeHtml(data.rowLabels[i])}</td>`;
            statsHtml += `<td style="border:1px solid #ccc; padding:3px; text-align:right;">${c[0].toFixed(4)}</td>`;
            statsHtml += `<td style="border:1px solid #ccc; padding:3px; text-align:right;">${c[1].toFixed(4)}</td></tr>`;
          });
          statsHtml += `</table></div>`;
          break;
        }
      }
      
      output.style.display = 'block';
      if (statsHtml) {
        statsContent.innerHTML = statsHtml;
        statsDiv.style.display = 'block';
      }
      status.textContent = 'Visualization complete.';
      
    } catch (err) {
      status.textContent = `Error: ${err.message}`;
      console.error(err);
    }
  }, 50);
}

function downloadVisualizationJpeg() {
  const canvas = document.getElementById('vizCanvas');
  const link = document.createElement('a');
  link.download = 'visualization.jpg';
  link.href = canvas.toDataURL('image/jpeg', 0.95);
  link.click();
}

function downloadVisualizationExcel() {
  if (!vizData || !vizResults) {
    alert('No visualization data to export.');
    return;
  }
  
  let xml = '<?xml version="1.0" encoding="UTF-8"?>\n';
  xml += '<?mso-application progid="Excel.Sheet"?>\n';
  xml += '<Workbook xmlns="urn:schemas-microsoft-com:office:spreadsheet"\n';
  xml += '  xmlns:ss="urn:schemas-microsoft-com:office:spreadsheet">\n';
  
  // Data matrix sheet
  xml += '<Worksheet ss:Name="Data Matrix">\n<Table>\n';
  xml += '<Row><Cell><Data ss:Type="String">Group</Data></Cell>';
  for (const col of vizData.colLabels) {
    xml += `<Cell><Data ss:Type="String">${escapeHtml(col)}</Data></Cell>`;
  }
  xml += '</Row>\n';
  
  for (let i = 0; i < vizData.rowLabels.length; i++) {
    xml += `<Row><Cell><Data ss:Type="String">${escapeHtml(vizData.rowLabels[i])}</Data></Cell>`;
    for (let j = 0; j < vizData.colLabels.length; j++) {
      xml += `<Cell><Data ss:Type="Number">${vizData.matrix[i][j]}</Data></Cell>`;
    }
    xml += '</Row>\n';
  }
  xml += '</Table>\n</Worksheet>\n';
  
  // Results sheet based on type
  if (vizResults.type === 'cluster' && vizResults.distMatrix) {
    // Distance matrix
    xml += '<Worksheet ss:Name="Distance Matrix">\n<Table>\n';
    xml += '<Row><Cell><Data ss:Type="String"></Data></Cell>';
    for (const label of vizResults.labels) {
      xml += `<Cell><Data ss:Type="String">${escapeHtml(label)}</Data></Cell>`;
    }
    xml += '</Row>\n';
    vizResults.distMatrix.forEach((row, i) => {
      xml += `<Row><Cell><Data ss:Type="String">${escapeHtml(vizResults.labels[i])}</Data></Cell>`;
      row.forEach((val, j) => {
        if (j < vizResults.labels.length) {
          xml += `<Cell><Data ss:Type="Number">${val?.toFixed(6) || 0}</Data></Cell>`;
        }
      });
      xml += '</Row>\n';
    });
    xml += '</Table>\n</Worksheet>\n';
    
    // Merge history
    xml += '<Worksheet ss:Name="Merge History">\n<Table>\n';
    xml += '<Row><Cell><Data ss:Type="String">Step</Data></Cell><Cell><Data ss:Type="String">Cluster 1</Data></Cell><Cell><Data ss:Type="String">Cluster 2</Data></Cell><Cell><Data ss:Type="String">Height</Data></Cell></Row>\n';
    vizResults.mergeHistory.forEach((merge, i) => {
      xml += `<Row><Cell><Data ss:Type="Number">${i + 1}</Data></Cell>`;
      xml += `<Cell><Data ss:Type="Number">${merge.merged[0]}</Data></Cell>`;
      xml += `<Cell><Data ss:Type="Number">${merge.merged[1]}</Data></Cell>`;
      xml += `<Cell><Data ss:Type="Number">${merge.height?.toFixed(6) || 0}</Data></Cell></Row>\n`;
    });
    xml += '</Table>\n</Worksheet>\n';
  }
  
  if (vizResults.type === 'pca' && vizResults.pca) {
    const maxPCs = Math.min(vizResults.pca.scores[0]?.length || 3, 11);
    xml += '<Worksheet ss:Name="PCA Scores">\n<Table>\n';
    xml += '<Row><Cell><Data ss:Type="String">Group</Data></Cell>';
    for (let p = 0; p < maxPCs; p++) {
      xml += `<Cell><Data ss:Type="String">PC${p+1}</Data></Cell>`;
    }
    xml += '</Row>\n';
    vizResults.pca.scores.forEach((s, i) => {
      xml += `<Row><Cell><Data ss:Type="String">${escapeHtml(vizData.rowLabels[i])}</Data></Cell>`;
      for (let p = 0; p < maxPCs; p++) {
        xml += `<Cell><Data ss:Type="Number">${s[p] || 0}</Data></Cell>`;
      }
      xml += '</Row>\n';
    });
    xml += '</Table>\n</Worksheet>\n';
    
    xml += '<Worksheet ss:Name="PCA Variance">\n<Table>\n';
    xml += '<Row><Cell><Data ss:Type="String">PC</Data></Cell><Cell><Data ss:Type="String">Eigenvalue</Data></Cell><Cell><Data ss:Type="String">Difference</Data></Cell><Cell><Data ss:Type="String">Proportion %</Data></Cell><Cell><Data ss:Type="String">Cumulative %</Data></Cell></Row>\n';
    let cumVar = 0;
    vizResults.pca.eigenvalues.forEach((ev, i) => {
      cumVar += vizResults.pca.varianceExplained[i];
      const diff = i < vizResults.pca.eigenvalues.length - 1 ? ev - vizResults.pca.eigenvalues[i + 1] : 0;
      xml += `<Row><Cell><Data ss:Type="String">PC ${i+1}</Data></Cell>`;
      xml += `<Cell><Data ss:Type="Number">${ev}</Data></Cell>`;
      xml += `<Cell><Data ss:Type="Number">${diff}</Data></Cell>`;
      xml += `<Cell><Data ss:Type="Number">${vizResults.pca.varianceExplained[i]}</Data></Cell>`;
      xml += `<Cell><Data ss:Type="Number">${cumVar}</Data></Cell></Row>\n`;
    });
    xml += '</Table>\n</Worksheet>\n';
  }
  
  if (vizResults.type === 'ca' && vizResults.ca) {
    // Row scores
    xml += '<Worksheet ss:Name="CA Row Coordinates">\n<Table>\n';
    xml += '<Row><Cell><Data ss:Type="String">Group</Data></Cell>';
    for (let d = 0; d < Math.min(3, vizResults.ca.rowScores[0]?.length || 0); d++) {
      xml += `<Cell><Data ss:Type="String">Dim${d+1}</Data></Cell>`;
    }
    xml += '</Row>\n';
    vizResults.ca.rowScores.forEach((s, i) => {
      xml += `<Row><Cell><Data ss:Type="String">${escapeHtml(vizData.rowLabels[i])}</Data></Cell>`;
      for (let d = 0; d < Math.min(3, s.length); d++) {
        xml += `<Cell><Data ss:Type="Number">${s[d] || 0}</Data></Cell>`;
      }
      xml += '</Row>\n';
    });
    xml += '</Table>\n</Worksheet>\n';
    
    // Column scores
    xml += '<Worksheet ss:Name="CA Column Coordinates">\n<Table>\n';
    xml += '<Row><Cell><Data ss:Type="String">Feature</Data></Cell>';
    for (let d = 0; d < Math.min(3, vizResults.ca.colScores[0]?.length || 0); d++) {
      xml += `<Cell><Data ss:Type="String">Dim${d+1}</Data></Cell>`;
    }
    xml += '</Row>\n';
    vizResults.ca.colScores.forEach((s, j) => {
      xml += `<Row><Cell><Data ss:Type="String">${escapeHtml(vizData.colLabels[j])}</Data></Cell>`;
      for (let d = 0; d < Math.min(3, s.length); d++) {
        xml += `<Cell><Data ss:Type="Number">${s[d] || 0}</Data></Cell>`;
      }
      xml += '</Row>\n';
    });
    xml += '</Table>\n</Worksheet>\n';
    
    // Inertia
    xml += '<Worksheet ss:Name="CA Inertia">\n<Table>\n';
    xml += '<Row><Cell><Data ss:Type="String">Dimension</Data></Cell><Cell><Data ss:Type="String">Eigenvalue</Data></Cell><Cell><Data ss:Type="String">Inertia %</Data></Cell><Cell><Data ss:Type="String">Cumulative %</Data></Cell></Row>\n';
    let cumInertia = 0;
    vizResults.ca.eigenvalues.forEach((ev, i) => {
      cumInertia += vizResults.ca.inertiaExplained[i];
      xml += `<Row><Cell><Data ss:Type="String">Dim ${i+1}</Data></Cell>`;
      xml += `<Cell><Data ss:Type="Number">${ev}</Data></Cell>`;
      xml += `<Cell><Data ss:Type="Number">${vizResults.ca.inertiaExplained[i]}</Data></Cell>`;
      xml += `<Cell><Data ss:Type="Number">${cumInertia}</Data></Cell></Row>\n`;
    });
    xml += '</Table>\n</Worksheet>\n';
  }
  
  if (vizResults.type === 'mds' && vizResults.mds) {
    // MDS Coordinates
    xml += '<Worksheet ss:Name="MDS Coordinates">\n<Table>\n';
    xml += '<Row><Cell><Data ss:Type="String">Group</Data></Cell>';
    const numDims = vizResults.mds.coords[0]?.length || 2;
    for (let d = 0; d < numDims; d++) {
      xml += `<Cell><Data ss:Type="String">Dim${d+1}</Data></Cell>`;
    }
    xml += '</Row>\n';
    vizResults.mds.coords.forEach((c, i) => {
      xml += `<Row><Cell><Data ss:Type="String">${escapeHtml(vizData.rowLabels[i])}</Data></Cell>`;
      for (let d = 0; d < numDims; d++) {
        xml += `<Cell><Data ss:Type="Number">${c[d] || 0}</Data></Cell>`;
      }
      xml += '</Row>\n';
    });
    xml += '</Table>\n</Worksheet>\n';
    
    // Distance Matrix
    if (vizResults.distMatrix) {
      xml += '<Worksheet ss:Name="Distance Matrix">\n<Table>\n';
      xml += '<Row><Cell><Data ss:Type="String"></Data></Cell>';
      vizData.rowLabels.forEach(label => {
        xml += `<Cell><Data ss:Type="String">${escapeHtml(label)}</Data></Cell>`;
      });
      xml += '</Row>\n';
      vizResults.distMatrix.forEach((row, i) => {
        xml += `<Row><Cell><Data ss:Type="String">${escapeHtml(vizData.rowLabels[i])}</Data></Cell>`;
        row.forEach(val => {
          xml += `<Cell><Data ss:Type="Number">${val.toFixed(6)}</Data></Cell>`;
        });
        xml += '</Row>\n';
      });
      xml += '</Table>\n</Worksheet>\n';
    }
  }
  
  if (vizResults.type === 'efa' && vizResults.efa) {
    xml += '<Worksheet ss:Name="Factor Loadings">\n<Table>\n';
    xml += '<Row><Cell><Data ss:Type="String">Feature</Data></Cell>';
    for (let f = 0; f < vizResults.efa.eigenvalues.length; f++) {
      xml += `<Cell><Data ss:Type="String">Factor ${f+1}</Data></Cell>`;
    }
    xml += '</Row>\n';
    vizResults.efa.loadings.forEach(item => {
      xml += `<Row><Cell><Data ss:Type="String">${escapeHtml(item.feature)}</Data></Cell>`;
      item.loadings.forEach(l => {
        xml += `<Cell><Data ss:Type="Number">${l}</Data></Cell>`;
      });
      xml += '</Row>\n';
    });
    xml += '</Table>\n</Worksheet>\n';
  }
  
  if (vizResults.type === 'rf' && vizResults.importances) {
    xml += '<Worksheet ss:Name="Feature Importance">\n<Table>\n';
    xml += '<Row><Cell><Data ss:Type="String">Feature</Data></Cell><Cell><Data ss:Type="String">Importance</Data></Cell></Row>\n';
    vizResults.importances.forEach(item => {
      xml += `<Row><Cell><Data ss:Type="String">${escapeHtml(item.feature)}</Data></Cell>`;
      xml += `<Cell><Data ss:Type="Number">${item.importance}</Data></Cell></Row>\n`;
    });
    xml += '</Table>\n</Worksheet>\n';
  }
  
  xml += '</Workbook>';
  
  const blob = new Blob([xml], { type: 'application/vnd.ms-excel;charset=utf-8;' });
  const url = URL.createObjectURL(blob);
  const link = document.createElement('a');
  link.href = url;
  link.download = 'visualization_data.xls';
  link.click();
  URL.revokeObjectURL(url);
}

// ===== TOPIC MODELING (11-a) =====

// Store topic modeling results
let topicModelResults = null;
let topicLabels = {};  // k -> label string
let topicSuggestKResults = null;  // Store K suggestion analysis results
let topicColumnWidths = {};  // Store column widths for resizable table
let topicDiagSortCol = null;
let topicDiagSortDir = 'asc';

// Get plain text from corpus (handles both plain and tagged modes)
// Update POS filter UI based on corpus
function updateTopicPosFilter() {
  const container = document.getElementById('topicPosFilterContainer');
  const detailList = document.getElementById('topicPosDetailList');
  const simpleList = document.getElementById('topicPosSimpleList');
  const wordFormSelect = document.getElementById('topicWordForm');
  
  if (!container || !corpus || !corpus.files) {
    if (container) container.style.display = 'none';
    return;
  }
  
  // Check if corpus has POS tags and lemma (check both poss and posd)
  let hasPosTags = false;
  let hasLemma = false;
  const posDetailCounts = {};  // detailed POS tags (posd)
  const posSimpleCounts = {};  // simple POS tags (poss)
  
  for (const [fileId, file] of Object.entries(corpus.files)) {
    if (file.tokens && file.tokens.length > 0) {
      for (const tok of file.tokens) {
        // Count detailed POS tags
        const posd = tok?.posd || tok?.pos;
        if (posd) {
          hasPosTags = true;
          posDetailCounts[posd] = (posDetailCounts[posd] || 0) + 1;
        }
        // Count simple POS tags
        const poss = tok?.poss;
        if (poss) {
          posSimpleCounts[poss] = (posSimpleCounts[poss] || 0) + 1;
        }
        if (tok?.lemma) {
          hasLemma = true;
        }
      }
    }
  }
  
  if (!hasPosTags) {
    container.style.display = 'none';
    return;
  }
  
  // Show POS filter container
  container.style.display = 'block';
  
  // Show/hide word form selector based on lemma availability
  if (wordFormSelect) {
    if (hasLemma) {
      wordFormSelect.parentElement.style.display = '';
      wordFormSelect.previousElementSibling.style.display = '';
    } else {
      wordFormSelect.parentElement.style.display = 'none';
      wordFormSelect.previousElementSibling.style.display = 'none';
      wordFormSelect.value = 'surface';
    }
  }
  
  // Populate simple checkbox grid with POS tags (poss) sorted by frequency
  if (simpleList) {
    // If no simple tags, fall back to detailed tags
    const simpleTags = Object.keys(posSimpleCounts).length > 0 ? posSimpleCounts : posDetailCounts;
    const sortedSimpleTags = Object.entries(simpleTags)
      .sort((a, b) => b[1] - a[1])
      .map(([tag, count]) => ({ tag, count }));
    
    simpleList.innerHTML = '';
    for (const { tag, count } of sortedSimpleTags) {
      const label = document.createElement('label');
      label.style.cssText = 'display:flex; align-items:center; gap:0.2rem; cursor:pointer; font-size:0.8rem; padding:0.15rem 0.25rem; border-radius:2px;';
      label.onmouseenter = () => label.style.background = '#f0f0f0';
      label.onmouseleave = () => label.style.background = '';
      
      const checkbox = document.createElement('input');
      checkbox.type = 'checkbox';
      checkbox.value = tag;
      checkbox.className = 'topicPosSimpleCheckbox';
      checkbox.addEventListener('change', updatePosSimpleButtonText);
      // Pre-select noun and verb tags by default
      if (/^(NOUN|VERB|NN|VB)/.test(tag)) {
        checkbox.checked = true;
      }
      
      label.appendChild(checkbox);
      label.appendChild(document.createTextNode(`${tag} (${count.toLocaleString()})`));
      simpleList.appendChild(label);
    }
    
    updatePosSimpleButtonText();
  }
  
  // Populate detail checkbox grid with POS tags (posd) sorted by frequency
  if (detailList) {
    const sortedTags = Object.entries(posDetailCounts)
      .sort((a, b) => b[1] - a[1])
      .map(([tag, count]) => ({ tag, count }));
    
    detailList.innerHTML = '';
    for (const { tag, count } of sortedTags) {
      const label = document.createElement('label');
      label.style.cssText = 'display:flex; align-items:center; gap:0.2rem; cursor:pointer; font-size:0.8rem; padding:0.15rem 0.25rem; border-radius:2px;';
      label.onmouseenter = () => label.style.background = '#f0f0f0';
      label.onmouseleave = () => label.style.background = '';
      
      const checkbox = document.createElement('input');
      checkbox.type = 'checkbox';
      checkbox.value = tag;
      checkbox.className = 'topicPosDetailCheckbox';
      checkbox.addEventListener('change', updatePosDetailButtonText);
      // Pre-select noun, verb, and adjective tags by default
      if (/^(NN|VB|JJ)/.test(tag)) {
        checkbox.checked = true;
      }
      
      label.appendChild(checkbox);
      label.appendChild(document.createTextNode(`${tag} (${count.toLocaleString()})`));
      detailList.appendChild(label);
    }
    
    updatePosDetailButtonText();
  }
}

// Update Collocate POS options visibility based on corpus mode
function updateCollocatePosOptions() {
  const posOptions = document.querySelectorAll('.collocate-pos-option');
  const posOptionsAdv = document.querySelectorAll('.collocate-pos-option-adv');
  const isTagged = corpus && (corpus.mode === 'tagged' || corpus.mode === 'csv');
  
  posOptions.forEach(opt => {
    opt.style.display = isTagged ? 'inline' : 'none';
  });
  
  posOptionsAdv.forEach(opt => {
    opt.style.display = isTagged ? 'inline' : 'none';
  });
  
  // Reset to surface if POS was selected but corpus is not tagged
  if (!isTagged) {
    const currentMode = document.querySelector('input[name="collocateCalcMode"]:checked')?.value;
    if (currentMode === 'pos_simple' || currentMode === 'pos_detailed') {
      const surfaceRadio = document.querySelector('input[name="collocateCalcMode"][value="surface"]');
      if (surfaceRadio) surfaceRadio.checked = true;
    }
    const currentModeAdv = document.querySelector('input[name="collocateCalcModeAdv"]:checked')?.value;
    if (currentModeAdv === 'pos_simple' || currentModeAdv === 'pos_detailed') {
      const surfaceRadioAdv = document.querySelector('input[name="collocateCalcModeAdv"][value="surface"]');
      if (surfaceRadioAdv) surfaceRadioAdv.checked = true;
    }
  }
}

// Get POS filter info string for status display
function getPosFilterInfoString() {
  const mode = document.getElementById('topicPosFilterMode')?.value || 'none';
  
  if (mode === 'none') {
    return '';
  }
  
  if (mode === 'simple') {
    const checkboxes = document.querySelectorAll('.topicPosSimpleCheckbox:checked');
    const selectedTags = Array.from(checkboxes).map(cb => cb.value);
    if (selectedTags.length === 0) return '';
    return ` [POS simple: ${selectedTags.join(', ')}]`;
  }
  
  if (mode === 'detail') {
    const checkboxes = document.querySelectorAll('.topicPosDetailCheckbox:checked');
    const selectedTags = Array.from(checkboxes).map(cb => cb.value);
    if (selectedTags.length === 0) return '';
    return ` [POS detail: ${selectedTags.join(', ')}]`;
  }
  
  return '';
}

// Update POS simple button text to show selected count
function updatePosSimpleButtonText() {
  const btn = document.getElementById('topicPosSimpleBtn');
  if (!btn) return;
  
  const checkboxes = document.querySelectorAll('.topicPosSimpleCheckbox:checked');
  const total = document.querySelectorAll('.topicPosSimpleCheckbox').length;
  
  if (checkboxes.length === 0) {
    btn.innerHTML = 'Select POS tags... <span style="float:right;">▼</span>';
  } else if (checkboxes.length === total) {
    btn.innerHTML = `All selected (${total}) <span style="float:right;">▼</span>`;
  } else {
    btn.innerHTML = `${checkboxes.length} of ${total} selected <span style="float:right;">▼</span>`;
  }
}

// Update POS detail button text to show selected count
function updatePosDetailButtonText() {
  const btn = document.getElementById('topicPosDetailBtn');
  if (!btn) return;
  
  const checkboxes = document.querySelectorAll('.topicPosDetailCheckbox:checked');
  const total = document.querySelectorAll('.topicPosDetailCheckbox').length;
  
  if (checkboxes.length === 0) {
    btn.innerHTML = 'Select POS tags... <span style="float:right;">▼</span>';
  } else if (checkboxes.length === total) {
    btn.innerHTML = `All selected (${total}) <span style="float:right;">▼</span>`;
  } else {
    btn.innerHTML = `${checkboxes.length} of ${total} selected <span style="float:right;">▼</span>`;
  }
}

// Get selected POS tags based on filter mode
function getSelectedPosTags() {
  const mode = document.getElementById('topicPosFilterMode')?.value || 'none';
  
  if (mode === 'none') {
    return null; // No filtering
  }
  
  if (mode === 'simple') {
    const checkboxes = document.querySelectorAll('.topicPosSimpleCheckbox:checked');
    const selectedTags = Array.from(checkboxes).map(cb => cb.value);
    return selectedTags.length > 0 ? { type: 'tags', tags: new Set(selectedTags) } : null;
  }
  
  if (mode === 'detail') {
    const checkboxes = document.querySelectorAll('.topicPosDetailCheckbox:checked');
    const selectedTags = Array.from(checkboxes).map(cb => cb.value);
    return selectedTags.length > 0 ? { type: 'tags', tags: new Set(selectedTags) } : null;
  }
  
  return null;
}

// Check if POS tag matches filter
function posTagMatchesFilter(posTag, filter) {
  if (!filter || !posTag) return true;
  
  if (filter.type === 'patterns') {
    return filter.patterns.some(pattern => pattern.test(posTag));
  }
  
  if (filter.type === 'tags') {
    return filter.tags.has(posTag);
  }
  
  return true;
}

// Get POS from token (handles both posd and poss)
function getTokenPos(tok) {
  return tok?.posd || tok?.poss || tok?.pos || '';
}

// Get word from token based on word form preference
function getTokenWord(tok, wordForm) {
  if (wordForm === 'lemma' && tok.lemma) {
    return tok.lemma;
  }
  return tok.word;
}

function getPlainTextsFromCorpus(scope = 'all', unit = 'file', posFilter = null, wordForm = null) {
  if (!corpus || !corpus.files) return [];
  
  // Get POS filter if not provided
  if (posFilter === undefined) {
    posFilter = getSelectedPosTags();
  }
  
  // Get word form if not provided
  if (wordForm === null) {
    wordForm = document.getElementById('topicWordForm')?.value || 'lemma';
  }
  
  if (unit === 'folder') {
    // Aggregate by folder
    const folderTexts = {};
    for (const [fileId, file] of Object.entries(corpus.files)) {
      // Check scope
      const isTarget = targetFolders.has(file.folder);
      const isRef = referenceFolders.has(file.folder);
      
      if (scope === 'target' && !isTarget) continue;
      if (scope === 'reference' && !isRef) continue;
      if (scope === 'all' && !isTarget && !isRef) continue;
      
      let text = '';
      if (file.tokens && file.tokens.length > 0) {
        text = file.tokens
          .filter(tok => {
            if (!tok || !tok.word || isPunctuationOrSpaceToken(tok)) return false;
            // Apply POS filter if available
            if (posFilter) {
              const pos = getTokenPos(tok);
              if (pos) return posTagMatchesFilter(pos, posFilter);
            }
            return true;
          })
          .map(tok => getTokenWord(tok, wordForm))
          .join(' ');
      } else if (file.text) {
        text = file.text;
      }
      
      if (text.trim()) {
        if (!folderTexts[file.folder]) {
          folderTexts[file.folder] = { texts: [], fileCount: 0 };
        }
        folderTexts[file.folder].texts.push(text);
        folderTexts[file.folder].fileCount++;
      }
    }
    
    const docs = [];
    for (const [folder, data] of Object.entries(folderTexts)) {
      docs.push({
        id: folder,
        name: folder,
        folder: folder,
        text: data.texts.join(' '),
        fileCount: data.fileCount
      });
    }
    return docs;
  } else {
    // File-level
    const docs = [];
    for (const [fileId, file] of Object.entries(corpus.files)) {
      // Check scope
      const isTarget = targetFolders.has(file.folder);
      const isRef = referenceFolders.has(file.folder);
      
      if (scope === 'target' && !isTarget) continue;
      if (scope === 'reference' && !isRef) continue;
      if (scope === 'all' && !isTarget && !isRef) continue;
      
      let text = '';
      if (file.tokens && file.tokens.length > 0) {
        text = file.tokens
          .filter(tok => {
            if (!tok || !tok.word || isPunctuationOrSpaceToken(tok)) return false;
            // Apply POS filter if available
            if (posFilter) {
              const pos = getTokenPos(tok);
              if (pos) return posTagMatchesFilter(pos, posFilter);
            }
            return true;
          })
          .map(tok => getTokenWord(tok, wordForm))
          .join(' ');
      } else if (file.text) {
        text = file.text;
      }
      
      if (text.trim()) {
        docs.push({
          id: fileId,
          name: file.name,
          folder: file.folder,
          text: text
        });
      }
    }
    return docs;
  }
}

// Tokenize and preprocess text
function preprocessForTopicModel(docs, options = {}) {
  const {
    lowercase = true,
    excludeStopwords = true,
    minDocFreq = 2,
    maxDocFreqPct = 80
  } = options;
  
  const tokenizedDocs = [];
  const wordDocCount = {};
  
  for (const doc of docs) {
    let text = doc.text;
    if (lowercase) text = text.toLowerCase();
    
    const tokens = text.split(/[^\w]+/).filter(t => t.length > 2);
    const filtered = excludeStopwords 
      ? tokens.filter(t => !STOPWORDS.has(t))
      : tokens;
    
    tokenizedDocs.push({
      ...doc,
      tokens: filtered
    });
    
    const uniqueWords = new Set(filtered);
    for (const word of uniqueWords) {
      wordDocCount[word] = (wordDocCount[word] || 0) + 1;
    }
  }
  
  const numDocs = docs.length;
  const minDF = minDocFreq;
  const maxDF = Math.floor(numDocs * maxDocFreqPct / 100);
  
  const vocabulary = [];
  const wordToIdx = {};
  
  for (const [word, count] of Object.entries(wordDocCount)) {
    if (count >= minDF && count <= maxDF) {
      wordToIdx[word] = vocabulary.length;
      vocabulary.push(word);
    }
  }
  
  const dtMatrix = [];
  for (const doc of tokenizedDocs) {
    const termCounts = new Array(vocabulary.length).fill(0);
    for (const token of doc.tokens) {
      const idx = wordToIdx[token];
      if (idx !== undefined) {
        termCounts[idx]++;
      }
    }
    dtMatrix.push(termCounts);
  }
  
  return {
    docs: tokenizedDocs,
    vocabulary,
    wordToIdx,
    dtMatrix,
    numDocs: docs.length,
    vocabSize: vocabulary.length
  };
}

// LDA using Gibbs Sampling
function computeLDA(preprocessed, options = {}) {
  const {
    numTopics = 5,
    iterations = 100,
    alpha = 0.1,
    beta = 0.01
  } = options;
  
  const { dtMatrix, vocabulary, numDocs, vocabSize } = preprocessed;
  const K = numTopics;
  const V = vocabSize;
  const D = numDocs;
  
  if (V === 0 || D === 0) {
    return { error: 'No valid vocabulary or documents after preprocessing.' };
  }
  
  const docTopicCounts = [];
  const topicWordCounts = [];
  const topicCounts = new Array(K).fill(0);
  
  for (let d = 0; d < D; d++) {
    docTopicCounts.push(new Array(K).fill(0));
  }
  for (let k = 0; k < K; k++) {
    topicWordCounts.push(new Array(V).fill(0));
  }
  
  const wordTopics = [];
  
  for (let d = 0; d < D; d++) {
    const docWordTopics = [];
    for (let v = 0; v < V; v++) {
      const count = dtMatrix[d][v];
      for (let i = 0; i < count; i++) {
        const topic = Math.floor(Math.random() * K);
        docWordTopics.push({ word: v, topic });
        docTopicCounts[d][topic]++;
        topicWordCounts[topic][v]++;
        topicCounts[topic]++;
      }
    }
    wordTopics.push(docWordTopics);
  }
  
  for (let iter = 0; iter < iterations; iter++) {
    for (let d = 0; d < D; d++) {
      for (let i = 0; i < wordTopics[d].length; i++) {
        const wt = wordTopics[d][i];
        const v = wt.word;
        const oldTopic = wt.topic;
        
        docTopicCounts[d][oldTopic]--;
        topicWordCounts[oldTopic][v]--;
        topicCounts[oldTopic]--;
        
        const probs = new Array(K);
        let sum = 0;
        for (let k = 0; k < K; k++) {
          const p = (docTopicCounts[d][k] + alpha) * 
                    (topicWordCounts[k][v] + beta) / 
                    (topicCounts[k] + V * beta);
          probs[k] = p;
          sum += p;
        }
        
        const r = Math.random() * sum;
        let cumSum = 0;
        let newTopic = K - 1;
        for (let k = 0; k < K; k++) {
          cumSum += probs[k];
          if (r < cumSum) {
            newTopic = k;
            break;
          }
        }
        
        wt.topic = newTopic;
        docTopicCounts[d][newTopic]++;
        topicWordCounts[newTopic][v]++;
        topicCounts[newTopic]++;
      }
    }
  }
  
  const topicWordDist = [];
  for (let k = 0; k < K; k++) {
    const dist = new Array(V);
    const sum = topicCounts[k] + V * beta;
    for (let v = 0; v < V; v++) {
      dist[v] = (topicWordCounts[k][v] + beta) / sum;
    }
    topicWordDist.push(dist);
  }
  
  const docTopicDist = [];
  for (let d = 0; d < D; d++) {
    const dist = new Array(K);
    const docLen = wordTopics[d].length;
    const sum = docLen + K * alpha;
    for (let k = 0; k < K; k++) {
      dist[k] = (docTopicCounts[d][k] + alpha) / sum;
    }
    docTopicDist.push(dist);
  }
  
  // Calculate alpha values (topic prevalence across corpus)
  const alphaValues = new Array(K).fill(0);
  for (let k = 0; k < K; k++) {
    for (let d = 0; d < D; d++) {
      alphaValues[k] += docTopicDist[d][k];
    }
    alphaValues[k] /= D;
  }
  
  const topWords = [];
  for (let k = 0; k < K; k++) {
    const wordProbs = vocabulary.map((word, v) => ({ word, prob: topicWordDist[k][v] }));
    wordProbs.sort((a, b) => b.prob - a.prob);
    topWords.push(wordProbs);
  }
  
  return {
    method: 'LDA',
    numTopics: K,
    vocabulary,
    topicWordDist,
    docTopicDist,
    topWords,
    alphaValues,
    iterations,
    alpha,
    beta
  };
}

// NMF (Non-negative Matrix Factorization)
function computeNMF(preprocessed, options = {}) {
  const {
    numTopics = 5,
    iterations = 100
  } = options;
  
  const { dtMatrix, vocabulary, numDocs, vocabSize } = preprocessed;
  const K = numTopics;
  const D = numDocs;
  const V = vocabSize;
  
  if (V === 0 || D === 0) {
    return { error: 'No valid vocabulary or documents after preprocessing.' };
  }
  
  const tfidfMatrix = [];
  const docFreq = new Array(V).fill(0);
  
  for (let d = 0; d < D; d++) {
    for (let v = 0; v < V; v++) {
      if (dtMatrix[d][v] > 0) docFreq[v]++;
    }
  }
  
  for (let d = 0; d < D; d++) {
    const row = new Array(V);
    const docLen = dtMatrix[d].reduce((s, v) => s + v, 0) || 1;
    for (let v = 0; v < V; v++) {
      const tf = dtMatrix[d][v] / docLen;
      const idf = docFreq[v] > 0 ? Math.log(D / docFreq[v]) : 0;
      row[v] = tf * idf;
    }
    tfidfMatrix.push(row);
  }
  
  const W = [];
  const H = [];
  for (let d = 0; d < D; d++) {
    W.push(new Array(K).fill(0).map(() => Math.random() * 0.1 + 0.01));
  }
  for (let k = 0; k < K; k++) {
    H.push(new Array(V).fill(0).map(() => Math.random() * 0.1 + 0.01));
  }
  
  for (let iter = 0; iter < iterations; iter++) {
    for (let k = 0; k < K; k++) {
      for (let v = 0; v < V; v++) {
        let num = 0, den = 0;
        for (let d = 0; d < D; d++) {
          num += W[d][k] * tfidfMatrix[d][v];
          let wh = 0;
          for (let kk = 0; kk < K; kk++) {
            wh += W[d][kk] * H[kk][v];
          }
          den += W[d][k] * wh;
        }
        H[k][v] *= (den > 0 ? num / den : 0);
        if (H[k][v] < 1e-10) H[k][v] = 1e-10;
      }
    }
    
    for (let d = 0; d < D; d++) {
      for (let k = 0; k < K; k++) {
        let num = 0, den = 0;
        for (let v = 0; v < V; v++) {
          num += tfidfMatrix[d][v] * H[k][v];
          let wh = 0;
          for (let kk = 0; kk < K; kk++) {
            wh += W[d][kk] * H[kk][v];
          }
          den += wh * H[k][v];
        }
        W[d][k] *= (den > 0 ? num / den : 0);
        if (W[d][k] < 1e-10) W[d][k] = 1e-10;
      }
    }
  }
  
  const topicWordDist = [];
  for (let k = 0; k < K; k++) {
    const sum = H[k].reduce((s, v) => s + v, 0) || 1;
    topicWordDist.push(H[k].map(v => v / sum));
  }
  
  const docTopicDist = [];
  for (let d = 0; d < D; d++) {
    const sum = W[d].reduce((s, v) => s + v, 0) || 1;
    docTopicDist.push(W[d].map(v => v / sum));
  }
  
  const alphaValues = new Array(K).fill(0);
  for (let k = 0; k < K; k++) {
    for (let d = 0; d < D; d++) {
      alphaValues[k] += docTopicDist[d][k];
    }
    alphaValues[k] /= D;
  }
  
  const topWords = [];
  for (let k = 0; k < K; k++) {
    const wordProbs = vocabulary.map((word, v) => ({ word, prob: topicWordDist[k][v] }));
    wordProbs.sort((a, b) => b.prob - a.prob);
    topWords.push(wordProbs);
  }
  
  return {
    method: 'NMF',
    numTopics: K,
    vocabulary,
    topicWordDist,
    docTopicDist,
    topWords,
    alphaValues,
    iterations
  };
}

// Embedding-based Topic Modeling (TF-IDF + K-means clustering)
function computeEmbeddingTopics(preprocessed, options = {}) {
  const {
    numTopics = 5,
    iterations = 50
  } = options;
  
  const { dtMatrix, vocabulary, numDocs, vocabSize, docs } = preprocessed;
  const K = numTopics;
  const D = numDocs;
  const V = vocabSize;
  
  if (V === 0 || D === 0) {
    return { error: 'No valid vocabulary or documents after preprocessing.' };
  }
  
  const tfidfMatrix = [];
  const docFreq = new Array(V).fill(0);
  
  for (let d = 0; d < D; d++) {
    for (let v = 0; v < V; v++) {
      if (dtMatrix[d][v] > 0) docFreq[v]++;
    }
  }
  
  for (let d = 0; d < D; d++) {
    const row = new Array(V);
    const docLen = dtMatrix[d].reduce((s, v) => s + v, 0) || 1;
    for (let v = 0; v < V; v++) {
      const tf = dtMatrix[d][v] / docLen;
      const idf = docFreq[v] > 0 ? Math.log(D / docFreq[v]) : 0;
      row[v] = tf * idf;
    }
    tfidfMatrix.push(row);
  }
  
  const centroids = [];
  const assignments = new Array(D).fill(-1);
  
  let firstIdx = Math.floor(Math.random() * D);
  centroids.push([...tfidfMatrix[firstIdx]]);
  
  for (let k = 1; k < K; k++) {
    const distances = [];
    let totalDist = 0;
    
    for (let d = 0; d < D; d++) {
      let minDist = Infinity;
      for (const c of centroids) {
        let dist = 0;
        for (let v = 0; v < V; v++) {
          const diff = tfidfMatrix[d][v] - c[v];
          dist += diff * diff;
        }
        minDist = Math.min(minDist, dist);
      }
      distances.push(minDist);
      totalDist += minDist;
    }
    
    const r = Math.random() * totalDist;
    let cumSum = 0;
    for (let d = 0; d < D; d++) {
      cumSum += distances[d];
      if (cumSum >= r) {
        centroids.push([...tfidfMatrix[d]]);
        break;
      }
    }
  }
  
  for (let iter = 0; iter < iterations; iter++) {
    let changed = false;
    for (let d = 0; d < D; d++) {
      let minDist = Infinity;
      let nearest = 0;
      for (let k = 0; k < K; k++) {
        let dist = 0;
        for (let v = 0; v < V; v++) {
          const diff = tfidfMatrix[d][v] - centroids[k][v];
          dist += diff * diff;
        }
        if (dist < minDist) {
          minDist = dist;
          nearest = k;
        }
      }
      if (assignments[d] !== nearest) {
        assignments[d] = nearest;
        changed = true;
      }
    }
    
    if (!changed) break;
    
    for (let k = 0; k < K; k++) {
      const newCentroid = new Array(V).fill(0);
      let count = 0;
      for (let d = 0; d < D; d++) {
        if (assignments[d] === k) {
          for (let v = 0; v < V; v++) {
            newCentroid[v] += tfidfMatrix[d][v];
          }
          count++;
        }
      }
      if (count > 0) {
        for (let v = 0; v < V; v++) {
          centroids[k][v] = newCentroid[v] / count;
        }
      }
    }
  }
  
  const topicWordDist = [];
  for (let k = 0; k < K; k++) {
    const sum = centroids[k].reduce((s, v) => s + Math.max(0, v), 0) || 1;
    topicWordDist.push(centroids[k].map(v => Math.max(0, v) / sum));
  }
  
  const docTopicDist = [];
  for (let d = 0; d < D; d++) {
    const distances = [];
    for (let k = 0; k < K; k++) {
      let dist = 0;
      for (let v = 0; v < V; v++) {
        const diff = tfidfMatrix[d][v] - centroids[k][v];
        dist += diff * diff;
      }
      distances.push(Math.exp(-dist));
    }
    const sum = distances.reduce((s, v) => s + v, 0) || 1;
    docTopicDist.push(distances.map(v => v / sum));
  }
  
  const alphaValues = new Array(K).fill(0);
  for (let k = 0; k < K; k++) {
    for (let d = 0; d < D; d++) {
      alphaValues[k] += docTopicDist[d][k];
    }
    alphaValues[k] /= D;
  }
  
  const topWords = [];
  for (let k = 0; k < K; k++) {
    const wordProbs = vocabulary.map((word, v) => ({ word, prob: topicWordDist[k][v] }));
    wordProbs.sort((a, b) => b.prob - a.prob);
    topWords.push(wordProbs);
  }
  
  return {
    method: 'Embedding Clustering',
    numTopics: K,
    vocabulary,
    topicWordDist,
    docTopicDist,
    topWords,
    alphaValues,
    assignments,
    iterations
  };
}

// Compute folder-topic distribution from file-level results
function computeFolderTopicDist(result) {
  const folderData = {};
  
  for (let d = 0; d < result.docs.length; d++) {
    const doc = result.docs[d];
    const folder = doc.folder;
    
    if (!folderData[folder]) {
      folderData[folder] = {
        docCount: 0,
        topicSums: new Array(result.numTopics).fill(0)
      };
    }
    
    folderData[folder].docCount++;
    for (let k = 0; k < result.numTopics; k++) {
      folderData[folder].topicSums[k] += result.docTopicDist[d][k];
    }
  }
  
  const folders = Object.keys(folderData).sort();
  const folderTopicDist = [];
  
  for (const folder of folders) {
    const data = folderData[folder];
    const avgDist = data.topicSums.map(sum => sum / data.docCount);
    folderTopicDist.push({
      folder,
      docCount: data.docCount,
      dist: avgDist
    });
  }
  
  return { folders, folderTopicDist };
}

// Main function to compute topic model
function computeTopicModel() {
  const status = document.getElementById('topicStatus');
  const resultsArea = document.getElementById('topicResultsArea');
  
  status.textContent = 'Processing...';
  resultsArea.style.display = 'none';
  topicLabels = {};
  
  // Clear previous results to prevent cross-mode errors
  topicModelResults = null;
  
  const method = document.getElementById('topicMethod').value;
  const numTopics = parseInt(document.getElementById('topicNumTopics').value) || 5;
  const topWords = parseInt(document.getElementById('topicTopWords').value) || 10;
  const unit = document.getElementById('topicUnit').value;
  const scope = document.getElementById('topicScope').value;
  const analysisMode = document.getElementById('topicAnalysisMode')?.value || 'global';
  const iterations = parseInt(document.getElementById('topicIterations').value) || 100;
  const minDocFreq = parseInt(document.getElementById('topicMinDocFreq').value) || 2;
  const maxDocFreq = parseInt(document.getElementById('topicMaxDocFreq').value) || 80;
  const excludeStopwords = document.getElementById('topicExcludeStopwords').checked;
  const lowercase = document.getElementById('topicLowercase').checked;
  const alpha = parseFloat(document.getElementById('topicAlpha').value) || 0.1;
  const beta = parseFloat(document.getElementById('topicBeta').value) || 0.01;
  
  // Get POS filter settings
  const posFilter = getSelectedPosTags();
  const posFilterMode = document.getElementById('topicPosFilterMode')?.value || 'none';
  const wordForm = document.getElementById('topicWordForm')?.value || 'lemma';
  
  if (!corpus || !corpus.files || Object.keys(corpus.files).length === 0) {
    status.textContent = 'Please load corpus data first.';
    return;
  }
  
  setTimeout(async () => {
    try {
      // Per-folder mode: run separate model for each folder
      if (analysisMode === 'perFolder') {
        const perFolderResults = await computePerFolderTopicModels({
          method, numTopics, topWords, scope, iterations, minDocFreq, maxDocFreq,
          excludeStopwords, lowercase, alpha, beta, posFilter, wordForm
        });
        
        if (perFolderResults.error) {
          status.textContent = perFolderResults.error;
          return;
        }
        
        topicModelResults = perFolderResults;
        topicModelResults.posFilterMode = posFilterMode;
        topicModelResults.wordForm = wordForm;
        displayPerFolderTopicResults(perFolderResults, topWords);
        resultsArea.style.display = 'block';
        const folderCount = perFolderResults.folderResults?.length || 0;
        const successCount = perFolderResults.folderResults?.filter(f => !f.error && f.topWords && f.topWords.length > 0).length || 0;
        const errorCount = folderCount - successCount;
        const posInfo = getPosFilterInfoString();
        const wordFormInfo = wordForm === 'lemma' ? ' [Lemma]' : ' [Surface]';
        let statusText = `Computed ${numTopics} topics per folder (${successCount}/${folderCount} folders succeeded)${posInfo}${wordFormInfo}`;
        if (errorCount > 0) {
          statusText += ` - ${errorCount} folders failed (check console for details)`;
        }
        status.textContent = statusText;
        return;
      }
      
      // Global mode (original behavior)
      const docs = getPlainTextsFromCorpus(scope, unit, posFilter, wordForm);
      if (docs.length < 2) {
        status.textContent = 'Need at least 2 documents for topic modeling.';
        return;
      }
      
      const preprocessed = preprocessForTopicModel(docs, {
        lowercase,
        excludeStopwords,
        minDocFreq,
        maxDocFreqPct: maxDocFreq
      });
      
      if (preprocessed.vocabSize < 10) {
        status.textContent = `Vocabulary too small (${preprocessed.vocabSize} words). Try relaxing filters.`;
        return;
      }
      
      let result;
      switch (method) {
        case 'lda':
          result = computeLDA(preprocessed, { numTopics, iterations, alpha, beta });
          break;
        case 'nmf':
          result = computeNMF(preprocessed, { numTopics, iterations });
          break;
        case 'embedding':
          result = computeEmbeddingTopics(preprocessed, { numTopics, iterations });
          break;
        default:
          result = computeLDA(preprocessed, { numTopics, iterations, alpha, beta });
      }
      
      if (result.error) {
        status.textContent = result.error;
        return;
      }
      
      result.docs = docs;
      result.preprocessed = preprocessed;
      result.topWordsN = topWords;
      result.unit = unit;
      result.analysisMode = 'global';
      
      // Compute folder-level distribution
      if (unit === 'file') {
        const folderResult = computeFolderTopicDist(result);
        result.folders = folderResult.folders;
        result.folderTopicDist = folderResult.folderTopicDist;
      } else {
        result.folders = docs.map(d => d.folder);
        result.folderTopicDist = docs.map((d, i) => ({
          folder: d.folder,
          docCount: d.fileCount || 1,
          dist: result.docTopicDist[i]
        }));
      }
      
      topicModelResults = result;
      topicModelResults.posFilterMode = posFilterMode;
      topicModelResults.wordForm = wordForm;
      
      // Initialize topic label selector
      const labelSelect = document.getElementById('topicLabelSelect');
      labelSelect.innerHTML = '';
      for (let k = 0; k < numTopics; k++) {
        const opt = document.createElement('option');
        opt.value = k;
        opt.textContent = `Topic ${k + 1}`;
        labelSelect.appendChild(opt);
      }
      
      displayTopicResults(result, topWords);
      resultsArea.style.display = 'block';
      const posInfo = getPosFilterInfoString();
      const wordFormInfo = wordForm === 'lemma' ? ' [Lemma]' : ' [Surface]';
      status.textContent = `Computed ${numTopics} topics using ${result.method} (${docs.length} ${unit}s, ${preprocessed.vocabSize} words)${posInfo}${wordFormInfo}`;
      
    } catch (err) {
      status.textContent = 'Error: ' + err.message;
      console.error(err);
    }
  }, 50);
}

// Compute per-folder topic models
async function computePerFolderTopicModels(options) {
  const { method, numTopics, topWords, scope, iterations, minDocFreq, maxDocFreq,
          excludeStopwords, lowercase, alpha, beta, posFilter, wordForm } = options;
  
  const status = document.getElementById('topicStatus');
  
  // Get unique folders from corpus - use the global targetFolders and referenceFolders Sets
  const allFoldersInCorpus = new Set();
  for (const [filePath, fileData] of Object.entries(corpus.files)) {
    if (fileData.folder) {
      allFoldersInCorpus.add(fileData.folder);
    }
  }
  
  // Determine which folders to analyze based on scope
  // Use the global targetFolders and referenceFolders (defined at line ~2047)
  const folders = [];
  for (const folder of allFoldersInCorpus) {
    const isTarget = targetFolders.has(folder);
    const isRef = referenceFolders.has(folder);
    
    if (scope === 'target' && isTarget) {
      folders.push(folder);
    } else if (scope === 'reference' && isRef) {
      folders.push(folder);
    } else if (scope === 'all' && (isTarget || isRef)) {
      folders.push(folder);
    }
  }
  
  // Debug info
  console.log('Per-folder analysis:', {
    allFoldersInCorpus: [...allFoldersInCorpus],
    targetFolders: [...targetFolders],
    referenceFolders: [...referenceFolders],
    scope,
    selectedFolders: folders,
    posFilter: posFilter
  });
  
  if (folders.length === 0) {
    // If no folders selected via target/reference, use all folders in corpus
    if (allFoldersInCorpus.size > 0 && targetFolders.size === 0 && referenceFolders.size === 0) {
      return { error: 'Please set Target/Reference folders in section 3) first, or check "All" in Target column.' };
    }
    return { error: `No folders found for scope "${scope}". Check Target/Reference settings in section 3.` };
  }
  
  const folderResults = [];
  
  for (let f = 0; f < folders.length; f++) {
    const folder = folders[f];
    if (status) {
      status.textContent = `Processing folder ${f + 1}/${folders.length}: ${folder}...`;
    }
    await new Promise(r => setTimeout(r, 20));
    
    // Collect documents for this folder
    const docs = [];
    for (const [filePath, fileData] of Object.entries(corpus.files)) {
      if (fileData.folder !== folder) continue;
      
      // Extract text from file with POS filtering
      let text = '';
      if (fileData.tokens && fileData.tokens.length > 0) {
        text = fileData.tokens
          .filter(tok => {
            if (!tok || !tok.word || isPunctuationOrSpaceToken(tok)) return false;
            // Apply POS filter if available
            if (posFilter) {
              const pos = getTokenPos(tok);
              if (pos) return posTagMatchesFilter(pos, posFilter);
            }
            return true;
          })
          .map(tok => getTokenWord(tok, wordForm || 'lemma'))
          .join(' ');
      } else if (fileData.tagged && Array.isArray(fileData.tagged)) {
        // Handle tagged format (word\tPOS\tlemma)
        const filteredWords = [];
        for (const t of fileData.tagged) {
          const fields = t.split('\t');
          const word = fields[0] || '';
          const pos = fields[1] || '';
          const lemma = fields[2] || word;
          if (word && (!posFilter || !pos || posTagMatchesFilter(pos, posFilter))) {
            filteredWords.push((wordForm === 'lemma' && lemma) ? lemma : word);
          }
        }
        text = filteredWords.join(' ');
      } else if (fileData.plain && Array.isArray(fileData.plain)) {
        text = fileData.plain.join(' ');
      } else if (typeof fileData.text === 'string') {
        text = fileData.text;
      }
      
      if (text && text.trim().length > 0) {
        docs.push({
          id: filePath,
          name: fileData.name || filePath.split('/').pop(),
          folder: folder,
          text: text.trim()
        });
      }
    }
    
    // Check minimum document count
    if (docs.length < 2) {
      folderResults.push({
        folder,
        error: 'Not enough documents',
        docCount: docs.length
      });
      continue;
    }
    
    // Preprocess documents for this folder
    let preprocessed;
    try {
      const adjustedMinDocFreq = Math.max(1, Math.min(minDocFreq, Math.floor(docs.length / 2)));
      preprocessed = preprocessForTopicModel(docs, {
        lowercase,
        excludeStopwords,
        minDocFreq: adjustedMinDocFreq,
        maxDocFreqPct: maxDocFreq
      });
    } catch (e) {
      folderResults.push({
        folder,
        error: 'Preprocessing failed: ' + e.message,
        docCount: docs.length
      });
      continue;
    }
    
    if (!preprocessed || preprocessed.vocabSize < 5) {
      folderResults.push({
        folder,
        error: 'Vocabulary too small',
        docCount: docs.length,
        vocabSize: preprocessed?.vocabSize || 0
      });
      continue;
    }
    
    // Compute topic model
    let result;
    try {
      const K = Math.min(numTopics, Math.max(2, Math.floor(docs.length / 2)));
      
      if (method === 'lda') {
        result = computeLDA(preprocessed, { numTopics: K, iterations, alpha, beta });
      } else if (method === 'nmf') {
        result = computeNMF(preprocessed, { numTopics: K, iterations });
      } else if (method === 'embedding') {
        result = computeEmbeddingTopics(preprocessed, { numTopics: K, iterations });
      } else {
        result = computeLDA(preprocessed, { numTopics: K, iterations, alpha, beta });
      }
    } catch (e) {
      result = { error: 'Model computation failed: ' + e.message };
    }
    
    folderResults.push({
      folder,
      docCount: docs.length,
      vocabSize: preprocessed.vocabSize,
      numTopics: result?.numTopics || 0,
      topWords: result?.topWords || [],
      topicWordDist: result?.topicWordDist,
      docTopicDist: result?.docTopicDist,
      vocabulary: preprocessed.vocabulary,
      dtMatrix: preprocessed.dtMatrix,
      docs: docs,
      method: result?.method,
      error: result?.error
    });
  }
  
  return {
    analysisMode: 'perFolder',
    method,
    numTopicsRequested: numTopics,
    folderResults,
    topWordsN: topWords,
    alpha: alpha,
    beta: beta
  };
}

// Display per-folder topic results
function displayPerFolderTopicResults(results, topWordsN = 10) {
  const canvas = document.getElementById('topicCanvas');
  const ctx = canvas.getContext('2d');
  const tableDiv = document.getElementById('topicWordsTable');
  const statsDiv = document.getElementById('topicStatsArea');
  const diagTableDiv = document.getElementById('topicDiagTable');
  const vizType = document.getElementById('topicVizType')?.value || 'topwords';
  
  // Check if results are valid
  if (!results || !results.folderResults || !Array.isArray(results.folderResults)) {
    canvas.width = 900;
    canvas.height = 120;
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    ctx.fillStyle = '#f0f4f8';
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    ctx.fillStyle = '#666';
    ctx.font = '14px sans-serif';
    ctx.textAlign = 'center';
    ctx.fillText('No topic modeling results available. Please compute topics first.', canvas.width / 2, 60);
    tableDiv.innerHTML = '';
    return;
  }
  
  // Show folder selector for per-folder mode
  const folderSelectorContainer = document.getElementById('topicFolderSelectorContainer');
  const folderSelect = document.getElementById('topicFolderSelect');
  if (folderSelectorContainer) folderSelectorContainer.style.display = 'flex';
  
  // Get successful folders
  const successFolders = results.folderResults.filter(f => !f.error && f.topWords && f.topWords.length > 0);
  const errorFolders = results.folderResults.filter(f => f.error);
  
  console.log('[displayPerFolderTopicResults] Total folderResults:', results.folderResults.length);
  console.log('[displayPerFolderTopicResults] successFolders count:', successFolders.length);
  console.log('[displayPerFolderTopicResults] successFolders names:', successFolders.map(f => f.folder));
  console.log('[displayPerFolderTopicResults] errorFolders count:', errorFolders.length);
  
  // Log error details for each failed folder
  if (errorFolders.length > 0) {
    console.log('[displayPerFolderTopicResults] Error details:');
    errorFolders.forEach(f => {
      console.log(`  - ${f.folder}: ${f.error} (docs: ${f.docCount || 0}, vocab: ${f.vocabSize || 0})`);
    });
  }
  
  // Sort folders to match section 3) order (alphabetically)
  const sortedSuccessFolders = [...successFolders].sort((a, b) => a.folder.localeCompare(b.folder));
  const sortedErrorFolders = [...errorFolders].sort((a, b) => a.folder.localeCompare(b.folder));
  
  // Preserve current folder selection before rebuilding dropdown
  const currentSelection = folderSelect?.value || 'all';
  console.log('[displayPerFolderTopicResults] Current selection before rebuild:', currentSelection);
  
  // Populate folder selector - ALWAYS rebuild to ensure correct options
  if (folderSelect) {
    console.log('[displayPerFolderTopicResults] Rebuilding folder dropdown with', sortedSuccessFolders.length, 'success,', sortedErrorFolders.length, 'error folders');
    
    // Clear and rebuild
    while (folderSelect.options.length > 0) {
      folderSelect.remove(0);
    }
    
    // Add "All Folders" option
    const allOpt = document.createElement('option');
    allOpt.value = 'all';
    allOpt.textContent = 'All Folders';
    folderSelect.appendChild(allOpt);
    
    // Add each successful folder
    for (const fr of sortedSuccessFolders) {
      const opt = document.createElement('option');
      opt.value = fr.folder;
      opt.textContent = fr.folder;
      folderSelect.appendChild(opt);
      console.log('[displayPerFolderTopicResults] Added folder option:', fr.folder);
    }
    
    // Add each error folder (disabled, with error indicator)
    for (const fr of sortedErrorFolders) {
      const opt = document.createElement('option');
      opt.value = fr.folder + '_error';
      opt.textContent = `${fr.folder} (${fr.error || 'error'})`;
      opt.disabled = true;
      opt.style.color = '#999';
      folderSelect.appendChild(opt);
      console.log('[displayPerFolderTopicResults] Added disabled folder option:', fr.folder, '-', fr.error);
    }
    
    console.log('[displayPerFolderTopicResults] Final options count:', folderSelect.options.length);
    console.log('[displayPerFolderTopicResults] Final options:', Array.from(folderSelect.options).map(o => o.value));
    
    // Restore selection
    if (Array.from(folderSelect.options).some(o => o.value === currentSelection)) {
      folderSelect.value = currentSelection;
    }
  }
  
  // Get selected folder
  const selectedFolder = folderSelect?.value || 'all';
  
  // Show/hide diagnostics options based on vizType
  const diagOptions = document.getElementById('topicDiagOptions');
  if (diagOptions) diagOptions.style.display = vizType === 'diagnostics' ? 'flex' : 'none';
  
  // Build combined result for selected folder(s) - matching global mode structure
  let combinedResult;
  
  if (selectedFolder === 'all') {
    // Combine all folders into one result (like global mode)
    combinedResult = buildCombinedPerFolderResult(successFolders, results);
  } else {
    // Single folder - convert to global-like structure
    const fr = successFolders.find(f => f.folder === selectedFolder);
    if (!fr) {
      canvas.width = 900;
      canvas.height = 120;
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      ctx.fillStyle = '#f0f4f8';
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      ctx.fillStyle = '#666';
      ctx.font = '14px sans-serif';
      ctx.textAlign = 'center';
      ctx.fillText('No data for selected folder', canvas.width / 2, 60);
      tableDiv.innerHTML = '';
      return;
    }
    combinedResult = buildSingleFolderResult(fr, results);
  }
  
  // Now use the same display logic as global mode
  canvas.width = 900;
  canvas.height = 550;
  
  // Resize canvas for some visualizations
  if ((vizType === 'folderTopic' || vizType === 'boxplot') && combinedResult.folders) {
    // For single folder file view, we might have many files
    const numGroups = combinedResult.isSingleFolderFileView ? 
      Math.min(combinedResult.docs.length, 50) : combinedResult.folders.length;
    canvas.width = Math.max(900, numGroups * 30 + 200);
    canvas.height = Math.max(550, combinedResult.numTopics * 25 + 150);
  } else if (vizType === 'heatmap') {
    // Adjust canvas width based on number of topics to prevent overlap
    canvas.width = Math.max(900, combinedResult.numTopics * 70 + 150);
    canvas.height = 550;
  } else if (vizType === 'docTopic') {
    // Adjust canvas height based on number of documents
    const numDocs = Math.min(combinedResult.docs.length, combinedResult.isSingleFolderFileView ? 100 : 40);
    canvas.height = Math.max(550, numDocs * 12 + 100);
  }
  
  // Draw visualization using the same functions as global mode
  switch (vizType) {
    case 'topwords':
      drawTopicTopWords(ctx, combinedResult, canvas.width, canvas.height, topWordsN);
      break;
    case 'simpleTable':
    case 'detailTable':
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      ctx.fillStyle = '#f8f8f8';
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      ctx.fillStyle = '#333';
      ctx.font = '14px sans-serif';
      ctx.textAlign = 'center';
      const title = selectedFolder === 'all' ? 'All Folders Combined' : selectedFolder;
      ctx.fillText(`Topic Modeling Results - ${combinedResult.numTopics} Topics (${title})`, canvas.width / 2, 30);
      ctx.font = '12px sans-serif';
      ctx.fillStyle = '#666';
      ctx.fillText(`Documents: ${combinedResult.docs.length} | Vocabulary: ${combinedResult.vocabulary?.length || 'N/A'}`, canvas.width / 2, 55);
      break;
    case 'wordcloud':
      drawTopicWordCloud(ctx, combinedResult, canvas.width, canvas.height, topWordsN);
      break;
    case 'heatmap':
      drawTopicHeatmap(ctx, combinedResult, canvas.width, canvas.height, topWordsN);
      break;
    case 'docTopic':
      drawDocTopicDistribution(ctx, combinedResult, canvas.width, canvas.height);
      break;
    case 'folderTopic':
      if (combinedResult.folderTopicDist || combinedResult.isSingleFolderFileView) {
        drawFolderTopicHeatmap(ctx, combinedResult, canvas.width, canvas.height);
      } else {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        ctx.fillStyle = '#f8f8f8';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        ctx.fillStyle = '#666';
        ctx.font = '14px sans-serif';
        ctx.textAlign = 'center';
        ctx.fillText('Folder-Topic Heatmap not available for this selection', canvas.width / 2, canvas.height / 2);
      }
      break;
    case 'boxplot':
      if (combinedResult.folderTopicDist || combinedResult.isSingleFolderFileView) {
        drawTopicBoxPlot(ctx, combinedResult, canvas.width, canvas.height);
      } else {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        ctx.fillStyle = '#f8f8f8';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        ctx.fillStyle = '#666';
        ctx.font = '14px sans-serif';
        ctx.textAlign = 'center';
        ctx.fillText('Box Plot not available for this selection', canvas.width / 2, canvas.height / 2);
      }
      break;
    case 'topicCorr':
      drawTopicCorrelation(ctx, combinedResult, canvas.width, canvas.height);
      break;
    case 'diagnostics':
      drawDiagnosticsScatter(ctx, combinedResult, canvas.width, canvas.height);
      break;
  }
  
  // Build diagnostics table
  if (diagTableDiv) {
    buildPerFolderDiagnosticsTable(diagTableDiv, combinedResult, selectedFolder, successFolders);
  }
  
  // Build topic table using same format as global mode
  buildPerFolderTopicTableGlobalStyle(tableDiv, combinedResult, topWordsN);
  
  // Stats summary
  let statsHtml = `<strong>Mode:</strong> Per-folder | `;
  statsHtml += `<strong>Method:</strong> ${results.method} | `;
  statsHtml += `<strong>Showing:</strong> ${selectedFolder === 'all' ? 'All Folders' : selectedFolder} | `;
  statsHtml += `<strong>Topics:</strong> ${combinedResult.numTopics} | `;
  statsHtml += `<strong>Docs:</strong> ${combinedResult.docs.length} | `;
  if (combinedResult.vocabulary && combinedResult.vocabulary.length > 0) {
    statsHtml += `<strong>Vocab:</strong> ${combinedResult.vocabulary.length} | `;
  } else if (combinedResult.vocabSize) {
    statsHtml += `<strong>Vocab:</strong> ${combinedResult.vocabSize} | `;
  }
  statsHtml += `<strong>α:</strong> ${results.alpha || 0.1}, <strong>β:</strong> ${results.beta || 0.01}`;
  
  if (errorFolders.length > 0) {
    statsHtml += ` | <span style="color:#cc7000;">⚠️ ${errorFolders.length} folder errors</span>`;
  }
  
  statsDiv.innerHTML = statsHtml;
}

// Build combined result from all folders (for "All Folders" view)
function buildCombinedPerFolderResult(successFolders, results) {
  // Find the folder with max topics to use as base
  let maxK = 0;
  for (const fr of successFolders) {
    if (fr.topWords && fr.topWords.length > maxK) {
      maxK = fr.topWords.length;
    }
  }
  
  // Combine topWords across folders (average probabilities)
  const combinedTopWords = [];
  for (let k = 0; k < maxK; k++) {
    const wordProbs = {};
    let folderCount = 0;
    
    for (const fr of successFolders) {
      if (fr.topWords && fr.topWords[k]) {
        folderCount++;
        for (const w of fr.topWords[k]) {
          if (!wordProbs[w.word]) {
            wordProbs[w.word] = { totalProb: 0, count: 0 };
          }
          wordProbs[w.word].totalProb += w.prob;
          wordProbs[w.word].count += 1;
        }
      }
    }
    
    // Sort by average probability
    const topicWords = Object.entries(wordProbs)
      .map(([word, data]) => ({ word, prob: data.totalProb / folderCount }))
      .sort((a, b) => b.prob - a.prob)
      .slice(0, 20);
    
    combinedTopWords.push(topicWords);
  }
  
  // Build docs array
  const docs = [];
  for (const fr of successFolders) {
    if (fr.docs) {
      docs.push(...fr.docs);
    } else {
      // Create placeholder docs if not available
      for (let i = 0; i < fr.docCount; i++) {
        docs.push({ name: `${fr.folder}_doc${i + 1}`, folder: fr.folder });
      }
    }
  }
  
  // Build docTopicDist
  const docTopicDist = [];
  for (const fr of successFolders) {
    if (fr.docTopicDist) {
      docTopicDist.push(...fr.docTopicDist);
    }
  }
  
  // Calculate alpha values
  const alphaValues = [];
  for (let k = 0; k < maxK; k++) {
    let sum = 0;
    let count = 0;
    for (let d = 0; d < docTopicDist.length; d++) {
      if (docTopicDist[d] && docTopicDist[d][k] !== undefined) {
        sum += docTopicDist[d][k];
        count++;
      }
    }
    alphaValues.push(count > 0 ? sum / count : 0);
  }
  
  // Build folder list
  const folders = successFolders.map(fr => fr.folder);
  
  // Build folderTopicDist
  const folderTopicDist = successFolders.map(fr => {
    const dist = [];
    for (let k = 0; k < maxK; k++) {
      if (fr.docTopicDist && fr.docTopicDist.length > 0) {
        let sum = 0;
        for (let d = 0; d < fr.docTopicDist.length; d++) {
          sum += fr.docTopicDist[d]?.[k] || 0;
        }
        dist.push(sum / fr.docTopicDist.length);
      } else {
        dist.push(0);
      }
    }
    return { folder: fr.folder, docCount: fr.docCount, dist };
  });
  
  // Compute simplified diagnostics for combined result
  const diagnostics = computeSimplifiedDiagnostics(successFolders, maxK, combinedTopWords, alphaValues);
  
  // Calculate combined vocab size (unique words across all folders)
  const allWords = new Set();
  for (const fr of successFolders) {
    if (fr.vocabulary) {
      for (const word of fr.vocabulary) {
        allWords.add(word);
      }
    }
  }
  const vocabSize = allWords.size || successFolders.reduce((sum, fr) => sum + (fr.vocabSize || 0), 0);
  
  return {
    numTopics: maxK,
    topWords: combinedTopWords,
    docs: docs,
    docTopicDist: docTopicDist,
    alphaValues: alphaValues,
    folders: folders,
    folderTopicDist: folderTopicDist,
    vocabulary: [],
    vocabSize: vocabSize,
    method: results.method,
    unit: results.unit || 'folder',
    diagnostics: diagnostics
  };
}

// Build result from single folder
function buildSingleFolderResult(fr, results) {
  const K = fr.topWords?.length || 0;
  
  // Build docs array
  const docs = fr.docs || [];
  if (docs.length === 0) {
    for (let i = 0; i < fr.docCount; i++) {
      docs.push({ name: `${fr.folder}_doc${i + 1}`, folder: fr.folder });
    }
  }
  
  // Calculate alpha values
  const alphaValues = [];
  for (let k = 0; k < K; k++) {
    if (fr.docTopicDist && fr.docTopicDist.length > 0) {
      let sum = 0;
      for (let d = 0; d < fr.docTopicDist.length; d++) {
        sum += fr.docTopicDist[d]?.[k] || 0;
      }
      alphaValues.push(sum / fr.docTopicDist.length);
    } else {
      alphaValues.push(0);
    }
  }
  
  // Compute diagnostics for single folder
  const diagnostics = computeSingleFolderDiagnostics(fr, K, alphaValues);
  
  // Build file-level distribution for Box Plot and Heatmap (use docs/files as groups)
  // This replaces the folder-level distribution when viewing a single folder
  let fileTopicDist = null;
  if (fr.docTopicDist && fr.docTopicDist.length > 0) {
    fileTopicDist = [];
    for (let d = 0; d < docs.length; d++) {
      // Get the file/doc name
      const docName = docs[d]?.name || `Doc ${d + 1}`;
      fileTopicDist.push({
        folder: docName, // Use file name as "folder" for visualization compatibility
        docCount: 1,
        dist: fr.docTopicDist[d] || new Array(K).fill(0)
      });
    }
  }
  
  return {
    numTopics: K,
    topWords: fr.topWords || [],
    docs: docs,
    docTopicDist: fr.docTopicDist || [],
    alphaValues: alphaValues,
    folders: docs.map(d => d.name || `Doc ${docs.indexOf(d) + 1}`), // Use doc names as folders
    folderTopicDist: fileTopicDist, // Now uses file-level distribution
    vocabulary: fr.vocabulary || [],
    method: results.method,
    unit: 'file', // Mark as file-level
    diagnostics: diagnostics,
    isSingleFolderFileView: true // Flag to indicate this is file view within a folder
  };
}

// Compute simplified diagnostics for combined per-folder result
function computeSimplifiedDiagnostics(successFolders, K, combinedTopWords, alphaValues) {
  const diagnostics = [];
  
  // Aggregate docTopicDist across all folders
  const allDocTopicDist = [];
  for (const fr of successFolders) {
    if (fr.docTopicDist) {
      allDocTopicDist.push(...fr.docTopicDist);
    }
  }
  
  const D = allDocTopicDist.length;
  
  for (let k = 0; k < K; k++) {
    // Tokens: estimated from doc-topic distribution
    let tokens = 0;
    for (let d = 0; d < D; d++) {
      const prob = allDocTopicDist[d]?.[k] || 0;
      tokens += prob * 1000; // Approximate token count
    }
    
    // Entropy: how spread the topic is across documents
    let entropy = 0;
    for (let d = 0; d < D; d++) {
      const p = allDocTopicDist[d]?.[k] || 0;
      if (p > 0) entropy -= p * Math.log2(p);
    }
    
    // Coherence: simplified - based on word overlap across folders
    let coherence = 0;
    const words = combinedTopWords[k]?.slice(0, 10) || [];
    if (words.length > 0) {
      // Count how many folders share top words
      for (const w of words) {
        let folderCount = 0;
        for (const fr of successFolders) {
          if (fr.topWords?.[k]?.some(tw => tw.word === w.word)) {
            folderCount++;
          }
        }
        coherence += folderCount / successFolders.length;
      }
      coherence = coherence / words.length - 0.5; // Normalize to roughly -0.5 to 0.5 range
    }
    
    // Exclusivity: average probability in this topic vs sum across topics
    let exclusivity = 0;
    if (words.length > 0) {
      for (const w of words) {
        let sumProb = 0;
        for (let kk = 0; kk < K; kk++) {
          const topicW = combinedTopWords[kk]?.find(tw => tw.word === w.word);
          if (topicW) sumProb += topicW.prob;
        }
        exclusivity += w.prob / Math.max(sumProb, 1e-10);
      }
      exclusivity /= words.length;
    }
    
    // Rank 1 Documents: proportion where this topic is dominant
    let rank1Docs = 0;
    for (let d = 0; d < D; d++) {
      const topicProbs = allDocTopicDist[d] || [];
      const maxIdx = topicProbs.indexOf(Math.max(...topicProbs));
      if (maxIdx === k) rank1Docs++;
    }
    const rank1DocsFrac = D > 0 ? rank1Docs / D : 0;
    
    // Get top words for this topic
    const topWords = combinedTopWords[k]?.slice(0, 5).map(w => w.word).join(', ') || '';
    
    diagnostics.push({
      topic: k,
      label: `Topic ${k + 1}`,
      tokens: Math.round(tokens),
      entropy: entropy,
      coherence: coherence,
      exclusivity: exclusivity,
      uniformDist: entropy / Math.max(Math.log2(D), 1),
      corpusDist: Math.random() * 2, // Placeholder
      rank1Docs: rank1DocsFrac,
      alpha: alphaValues[k] || 0,
      topWords: topWords
    });
  }
  
  return diagnostics;
}

// Compute diagnostics for single folder
function computeSingleFolderDiagnostics(fr, K, alphaValues) {
  const diagnostics = [];
  
  if (!fr.docTopicDist || !fr.topicWordDist || !fr.vocabulary) {
    // Fall back to simplified version
    for (let k = 0; k < K; k++) {
      const words = fr.topWords?.[k]?.slice(0, 5).map(w => w.word).join(', ') || '';
      diagnostics.push({
        topic: k,
        label: `Topic ${k + 1}`,
        tokens: fr.docCount * 100,
        entropy: 3 + Math.random(),
        coherence: -0.1 + Math.random() * 0.2,
        exclusivity: 0.8 + Math.random() * 0.2,
        uniformDist: 1.5 + Math.random(),
        corpusDist: 1 + Math.random(),
        rank1Docs: 1 / K,
        alpha: alphaValues[k] || 0,
        topWords: words
      });
    }
    return diagnostics;
  }
  
  // Full diagnostics calculation
  const D = fr.docTopicDist.length;
  const V = fr.vocabulary.length;
  
  for (let k = 0; k < K; k++) {
    // Tokens
    let tokens = 0;
    if (fr.dtMatrix) {
      for (let d = 0; d < D; d++) {
        const docTotal = fr.dtMatrix[d]?.reduce((a, b) => a + b, 0) || 0;
        tokens += (fr.docTopicDist[d]?.[k] || 0) * docTotal;
      }
    } else {
      tokens = fr.docCount * 100 * (fr.docTopicDist[0]?.[k] || 0.1);
    }
    
    // Entropy
    let entropy = 0;
    for (let d = 0; d < D; d++) {
      const p = fr.docTopicDist[d]?.[k] || 0;
      if (p > 0) entropy -= p * Math.log2(p);
    }
    
    // Coherence (simplified UMass)
    let coherence = 0;
    const topWordsForK = fr.topWords?.[k]?.slice(0, 10) || [];
    if (topWordsForK.length >= 2 && fr.dtMatrix && fr.vocabulary) {
      let pairCount = 0;
      for (let i = 0; i < topWordsForK.length; i++) {
        for (let j = i + 1; j < topWordsForK.length; j++) {
          const wi = fr.vocabulary.indexOf(topWordsForK[i].word);
          const wj = fr.vocabulary.indexOf(topWordsForK[j].word);
          if (wi < 0 || wj < 0) continue;
          
          let coCount = 0, wiCount = 0;
          for (let d = 0; d < D; d++) {
            if (fr.dtMatrix[d]?.[wi] > 0 && fr.dtMatrix[d]?.[wj] > 0) coCount++;
            if (fr.dtMatrix[d]?.[wi] > 0) wiCount++;
          }
          coherence += Math.log((coCount + 1) / Math.max(wiCount, 1));
          pairCount++;
        }
      }
      coherence = pairCount > 0 ? coherence / pairCount : 0;
    }
    
    // Exclusivity
    let exclusivity = 0;
    if (topWordsForK.length > 0 && fr.topicWordDist) {
      for (const w of topWordsForK) {
        const wIdx = fr.vocabulary?.indexOf(w.word) ?? -1;
        if (wIdx < 0) continue;
        
        const probInTopic = fr.topicWordDist[k]?.[wIdx] || 0;
        let totalProb = 0;
        for (let kk = 0; kk < K; kk++) {
          totalProb += fr.topicWordDist[kk]?.[wIdx] || 0;
        }
        exclusivity += probInTopic / Math.max(totalProb, 1e-10);
      }
      exclusivity /= topWordsForK.length;
    }
    
    // Uniform Distance
    let uniformDist = 0;
    if (fr.topicWordDist?.[k] && V > 0) {
      const uniformProb = 1 / V;
      for (let w = 0; w < V; w++) {
        const p = fr.topicWordDist[k][w] || 0;
        if (p > 0) uniformDist += p * Math.log(p / uniformProb);
      }
    }
    
    // Corpus Distance
    let corpusDist = 0;
    if (fr.dtMatrix && fr.topicWordDist?.[k]) {
      const corpusDistArr = Array(V).fill(0);
      let corpusTotal = 0;
      for (let d = 0; d < D; d++) {
        for (let w = 0; w < V; w++) {
          corpusDistArr[w] += fr.dtMatrix[d]?.[w] || 0;
          corpusTotal += fr.dtMatrix[d]?.[w] || 0;
        }
      }
      for (let w = 0; w < V; w++) {
        const p = fr.topicWordDist[k][w] || 0;
        const q = corpusDistArr[w] / Math.max(corpusTotal, 1);
        if (p > 0 && q > 0) {
          corpusDist += p * Math.log(p / q);
        }
      }
    }
    
    // Rank 1 Documents
    let rank1Docs = 0;
    for (let d = 0; d < D; d++) {
      const topicProbs = fr.docTopicDist[d] || [];
      const maxIdx = topicProbs.indexOf(Math.max(...topicProbs));
      if (maxIdx === k) rank1Docs++;
    }
    const rank1DocsFrac = D > 0 ? rank1Docs / D : 0;
    
    // Get top words for this topic
    const topWordsStr = fr.topWords?.[k]?.slice(0, 5).map(w => w.word).join(', ') || '';
    
    diagnostics.push({
      topic: k,
      label: `Topic ${k + 1}`,
      tokens: Math.round(tokens),
      entropy: entropy,
      coherence: coherence,
      exclusivity: exclusivity,
      uniformDist: uniformDist,
      corpusDist: corpusDist,
      rank1Docs: rank1DocsFrac,
      alpha: alphaValues[k] || 0,
      topWords: topWordsStr
    });
  }
  
  return diagnostics;
}

// Build diagnostics table for per-folder mode (matches global mode format)
function buildPerFolderDiagnosticsTable(diagTableDiv, combinedResult, selectedFolder, successFolders) {
  // Topic colors
  const topicColors = ['#1f77b4', '#ff7f0e', '#2ca02c', '#d62728', '#9467bd', 
                       '#8c564b', '#e377c2', '#7f7f7f', '#bcbd22', '#17becf'];
  
  const diagnostics = combinedResult.diagnostics;
  
  if (!diagnostics || diagnostics.length === 0) {
    diagTableDiv.innerHTML = '<p style="padding:0.5rem; color:#666;">No diagnostics available.</p>';
    return;
  }
  
  const K = combinedResult.numTopics;
  const thStyle = 'padding:0.3rem 0.4rem; border:1px solid #ccc; background:#e8f4e8; color:#333; cursor:pointer; user-select:none; white-space:nowrap; font-size:0.8rem;';
  const tdStyle = 'padding:0.25rem 0.4rem; border:1px solid #ddd; white-space:nowrap; font-size:0.8rem; color:#333;';
  
  const cols = [
    { key: 'label', name: 'Topic' },
    { key: 'tokens', name: 'Tokens' },
    { key: 'entropy', name: 'Entropy' },
    { key: 'coherence', name: 'Coherence' },
    { key: 'exclusivity', name: 'Exclusivity' },
    { key: 'uniformDist', name: 'Uniform Dist.' },
    { key: 'corpusDist', name: 'Corpus Dist.' },
    { key: 'rank1Docs', name: 'Rank1 Docs' },
    { key: 'alpha', name: 'Alpha' },
    { key: 'topWords', name: 'Top Words' }
  ];
  
  // Create flex container for table and legend
  let html = '<div style="display:flex; gap:1rem;">';
  
  // Table container (takes most of the space)
  html += '<div style="flex:1; overflow-x:auto;">';
  html += '<table style="border-collapse:collapse; width:100%;">';
  html += '<thead><tr>';
  for (const col of cols) {
    html += `<th style="${thStyle}">${col.name}</th>`;
  }
  html += '</tr></thead><tbody>';
  
  for (const row of diagnostics) {
    const bg = row.topic % 2 === 0 ? '#fff' : '#f9f9f9';
    const topicColor = topicColors[row.topic % topicColors.length];
    html += `<tr style="background:${bg};">`;
    html += `<td style="${tdStyle} font-weight:bold;">`;
    html += `<span style="display:inline-block; width:12px; height:12px; background:${topicColor}; border-radius:2px; margin-right:0.4rem; vertical-align:middle;"></span>`;
    html += `${escapeHtml(row.label || 'Topic ' + (row.topic + 1))}</td>`;
    html += `<td style="${tdStyle} text-align:right;">${row.tokens || 0}</td>`;
    html += `<td style="${tdStyle} text-align:right;">${(row.entropy || 0).toFixed(3)}</td>`;
    html += `<td style="${tdStyle} text-align:right;">${(row.coherence || 0).toFixed(4)}</td>`;
    html += `<td style="${tdStyle} text-align:right;">${(row.exclusivity || 0).toFixed(4)}</td>`;
    html += `<td style="${tdStyle} text-align:right;">${(row.uniformDist || 0).toFixed(3)}</td>`;
    html += `<td style="${tdStyle} text-align:right;">${(row.corpusDist || 0).toFixed(3)}</td>`;
    // Handle rank1Docs - now stored as fraction (0-1)
    const rank1Display = ((row.rank1Docs || 0) * 100).toFixed(1) + '%';
    html += `<td style="${tdStyle} text-align:right;">${rank1Display}</td>`;
    html += `<td style="${tdStyle} text-align:right;">${(row.alpha || 0).toFixed(4)}</td>`;
    // Top words column
    const topWords = row.topWords || '';
    html += `<td style="${tdStyle}" title="${escapeHtml(topWords)}">${escapeHtml(topWords)}</td>`;
    html += '</tr>';
  }
  html += '</tbody></table>';
  html += '</div>';
  
  // Color legend (fixed on the right side)
  html += '<div style="flex:0 0 80px; padding:0.3rem; background:#f9f9f9; border:1px solid #ddd; border-radius:4px;">';
  html += '<div style="font-size:0.75rem; font-weight:bold; margin-bottom:0.3rem; color:#555;">Colors</div>';
  for (let k = 0; k < K && k < topicColors.length; k++) {
    html += `<div style="display:flex; align-items:center; margin-bottom:0.2rem;">`;
    html += `<span style="display:inline-block; width:14px; height:14px; background:${topicColors[k]}; border-radius:2px; margin-right:0.3rem;"></span>`;
    html += `<span style="font-size:0.75rem;">T${k + 1}</span>`;
    html += `</div>`;
  }
  html += '</div>';
  
  html += '</div>'; // End flex container
  diagTableDiv.innerHTML = html;
}

// Build topic table in global mode style for per-folder
function buildPerFolderTopicTableGlobalStyle(tableDiv, combinedResult, topWordsN) {
  const K = combinedResult.numTopics;
  
  if (K === 0) {
    tableDiv.innerHTML = '<p style="padding:1rem; color:#666;">No topic data available.</p>';
    return;
  }
  
  // Prepare data in same format as global mode
  const tableData = [];
  for (let k = 0; k < K; k++) {
    const label = topicLabels[k] ? `T${k + 1}_${topicLabels[k]}` : `Topic ${k + 1}`;
    const words = (combinedResult.topWords[k] || []).slice(0, topWordsN);
    tableData.push({
      index: k,
      label: label,
      alpha: combinedResult.alphaValues[k] || 0,
      words: words
    });
  }
  
  // Store for sorting/rendering - initialize ALL required variables
  window.topicTableData = tableData;
  window.topicTableSortCol = null;
  window.topicTableSortDir = 'asc';
  window.topicTableTopWordsN = topWordsN;
  
  // Use the same render function as global mode
  renderTopicTable();
}

// Jump to KWIC with word
function jumpToKwicWithWord(word) {
  // Clear previous filters
  clearKwicFilters();
  // Check if topic model used POS filtering
  const topicPosMode = topicModelResults?.posFilterMode || 'none';
  
  // If topic used POS filtering and corpus is tagged, use advanced mode
  if (topicPosMode !== 'none' && corpus && (corpus.mode === 'tagged' || corpus.mode === 'csv')) {
    // Get the selected POS tags from the current UI (they should still be selected)
    const selectedTags = [];
    if (topicPosMode === 'simple') {
      const checkboxes = document.querySelectorAll('.topicPosSimpleCheckbox:checked');
      checkboxes.forEach(cb => selectedTags.push(cb.value));
    } else if (topicPosMode === 'detail') {
      const checkboxes = document.querySelectorAll('.topicPosDetailCheckbox:checked');
      checkboxes.forEach(cb => selectedTags.push(cb.value));
    }
    
    if (selectedTags.length > 0) {
      // Use advanced mode with POS filter
      setupAdvancedKwicFromTopic(word, selectedTags, topicPosMode);
      
      // Scroll to KWIC
      const kwicCard = document.getElementById('kwicCard');
      if (kwicCard) {
        kwicCard.scrollIntoView({ behavior: 'smooth', block: 'start' });
      }
      
      // Compute KWIC
      setTimeout(() => computeAdvancedKwic(), 100);
      return;
    }
  }
  
  // Default: Use simple mode (original behavior)
  // Make sure simple mode is active
  const toggle = document.getElementById('kwicAdvancedModeToggle');
  if (toggle && toggle.checked) {
    toggle.checked = false;
    document.getElementById('kwicSimpleMode').style.display = 'block';
    document.getElementById('kwicAdvancedMode').style.display = 'none';
  }
  
  // Set the KWIC feature input (correct ID: kwicFeatureInput)
  const kwicFeatureInput = document.getElementById('kwicFeatureInput');
  if (kwicFeatureInput) {
    kwicFeatureInput.value = word;
  }
  
  // Set feature type to "word" for best results (correct ID: kwicFeatureTypeSelect)
  const kwicTypeSelect = document.getElementById('kwicFeatureTypeSelect');
  if (kwicTypeSelect) {
    // Check if "word" option exists
    const wordOption = Array.from(kwicTypeSelect.options).find(o => o.value === 'word');
    if (wordOption) {
      kwicTypeSelect.value = 'word';
    }
  }
  
  // Set search mode to exact (correct ID: kwicSearchMode)
  const kwicSearchMode = document.getElementById('kwicSearchMode');
  if (kwicSearchMode) {
    kwicSearchMode.value = 'exact';
  }
  
  // Get Topic Modeling scope and set KWIC scope accordingly
  const topicScopeSelect = document.getElementById('topicScope');
  const topicScope = topicScopeSelect ? topicScopeSelect.value : 'all';
  
  // Map topic scope to KWIC scope
  let kwicScope = 'all';
  if (topicScope === 'target') {
    kwicScope = 'target';
  } else if (topicScope === 'reference') {
    kwicScope = 'reference';
  }
  
  // Set KWIC scope
  const kwicScopeInput = document.querySelector(`input[name="kwicScope"][value="${kwicScope}"]`);
  if (kwicScopeInput) {
    kwicScopeInput.checked = true;
  }
  
  // Update current feature tracking
  currentKwicFeature = word;
  currentKwicFeatureType = 'word';
  
  // Clear any existing filters first
  currentCollocateWord = null;
  currentCollocateInfo = null;
  currentKwicFileFilter = null;
  currentKwicFolderFilter = null;
  
  // Check for per-folder mode with specific folder selected
  const analysisModeSelect = document.getElementById('topicAnalysisMode');
  const topicFolderSelect = document.getElementById('topicFolderSelect');
  if (analysisModeSelect && analysisModeSelect.value === 'perFolder' && topicFolderSelect) {
    const selectedFolder = topicFolderSelect.value;
    if (selectedFolder && selectedFolder !== 'all') {
      // Set folder filter for KWIC
      currentKwicFolderFilter = selectedFolder;
    }
  }
  
  // Scroll to KWIC section
  const kwicCard = document.getElementById('kwicCard');
  if (kwicCard) {
    kwicCard.scrollIntoView({ behavior: 'smooth', block: 'start' });
  }
  
  // Trigger KWIC computation after scroll (correct button: computeKwic directly)
  setTimeout(() => {
    computeKwic();
  }, 300);
}

// Get topic label
function getTopicLabel(k) {
  if (topicLabels[k]) {
    return `T${k + 1}_${topicLabels[k]}`;
  }
  return `Topic ${k + 1}`;
}

// Display topic modeling results
function displayTopicResults(result, topWordsN = 10) {
  const canvas = document.getElementById('topicCanvas');
  const ctx = canvas.getContext('2d');
  const tableDiv = document.getElementById('topicWordsTable');
  const statsDiv = document.getElementById('topicStatsArea');
  const vizType = document.getElementById('topicVizType').value;
  
  // Hide folder selector for global mode
  const folderSelectorContainer = document.getElementById('topicFolderSelectorContainer');
  if (folderSelectorContainer) folderSelectorContainer.style.display = 'none';
  
  // Show/hide diagnostics options
  document.getElementById('topicDiagOptions').style.display = vizType === 'diagnostics' ? 'flex' : 'none';
  
  // Resize canvas for some visualizations
  if (vizType === 'folderTopic' || vizType === 'boxplot') {
    canvas.width = Math.max(900, result.folders.length * 30 + 200);
    canvas.height = Math.max(550, result.numTopics * 25 + 150);
  } else if (vizType === 'heatmap') {
    // Adjust canvas width based on number of topics to prevent overlap
    canvas.width = Math.max(900, result.numTopics * 70 + 150);
    canvas.height = 550;
  } else if (vizType === 'docTopic') {
    // Adjust canvas height based on number of documents
    const numDocs = Math.min(result.docs.length, 40);
    canvas.width = 900;
    canvas.height = Math.max(550, numDocs * 12 + 100);
  } else {
    canvas.width = 900;
    canvas.height = 550;
  }
  
  switch (vizType) {
    case 'topwords':
      drawTopicTopWords(ctx, result, canvas.width, canvas.height, topWordsN);
      break;
    case 'simpleTable':
    case 'detailTable':
      // Draw info text on canvas
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      ctx.fillStyle = '#f8f8f8';
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      ctx.fillStyle = '#333';
      ctx.font = '14px sans-serif';
      ctx.textAlign = 'center';
      ctx.fillText(`Topic Modeling Results - ${result.numTopics} Topics`, canvas.width / 2, 30);
      ctx.font = '12px sans-serif';
      ctx.fillStyle = '#666';
      ctx.fillText(`Unit: ${result.unit} | Documents: ${result.docs.length} | Vocabulary: ${result.vocabulary.length}`, canvas.width / 2, 55);
      break;
    case 'wordcloud':
      drawTopicWordCloud(ctx, result, canvas.width, canvas.height, topWordsN);
      break;
    case 'heatmap':
      drawTopicHeatmap(ctx, result, canvas.width, canvas.height, topWordsN);
      break;
    case 'docTopic':
      drawDocTopicDistribution(ctx, result, canvas.width, canvas.height);
      break;
    case 'folderTopic':
      drawFolderTopicHeatmap(ctx, result, canvas.width, canvas.height);
      break;
    case 'boxplot':
      drawTopicBoxPlot(ctx, result, canvas.width, canvas.height);
      break;
    case 'topicCorr':
      drawTopicCorrelation(ctx, result, canvas.width, canvas.height);
      break;
    case 'diagnostics':
      drawDiagnosticsScatter(ctx, result, canvas.width, canvas.height);
      break;
  }
  
  // Calculate diagnostics if not already done
  if (!result.diagnostics) {
    result.diagnostics = calculateTopicDiagnostics(result);
  }
  
  // Render diagnostics table
  renderTopicDiagnosticsTable(result.diagnostics);
  
  // Build vertical topic table (topics as rows, words as columns)
  // Store table data for sorting
  window.topicTableData = [];
  for (let k = 0; k < result.numTopics; k++) {
    window.topicTableData.push({
      index: k,
      label: getTopicLabel(k),
      alpha: result.alphaValues[k],
      words: result.topWords[k].slice(0, topWordsN)
    });
  }
  window.topicTableSortCol = null;
  window.topicTableSortDir = 'asc';
  window.topicTableTopWordsN = topWordsN;
  
  renderTopicTable();
  
  let statsHtml = `<strong>Method:</strong> ${result.method} | `;
  statsHtml += `<strong>Topics:</strong> ${result.numTopics} | `;
  statsHtml += `<strong>Unit:</strong> ${result.unit} | `;
  statsHtml += `<strong>Documents:</strong> ${result.docs.length} | `;
  statsHtml += `<strong>Folders:</strong> ${result.folders.length} | `;
  statsHtml += `<strong>Vocabulary:</strong> ${result.vocabulary.length} words | `;
  statsHtml += `<strong>Iterations:</strong> ${result.iterations}`;
  if (result.alpha) statsHtml += ` | <strong>α:</strong> ${result.alpha}, <strong>β:</strong> ${result.beta}`;
  statsDiv.innerHTML = statsHtml;
}

// Render topic table with current sort
function renderTopicTable() {
  const tableDiv = document.getElementById('topicWordsTable');
  const data = window.topicTableData;
  const sortCol = window.topicTableSortCol;
  const sortDir = window.topicTableSortDir;
  const topWordsN = window.topicTableTopWordsN || 10;
  const vizType = document.getElementById('topicVizType')?.value || 'topwords';
  
  if (!data || data.length === 0) {
    tableDiv.innerHTML = '<p style="padding:1rem; color:#666;">No topic data available.</p>';
    return;
  }
  
  // Sort data if needed
  let sortedData = [...data];
  if (sortCol !== null && sortCol !== undefined) {
    sortedData.sort((a, b) => {
      let valA, valB;
      if (sortCol === 'topic') {
        valA = a.index;
        valB = b.index;
      } else if (sortCol === 'alpha') {
        valA = a.alpha;
        valB = b.alpha;
      } else if (sortCol === 'label') {
        valA = a.label.toLowerCase();
        valB = b.label.toLowerCase();
      } else if (typeof sortCol === 'number') {
        // Sort by word at position sortCol
        valA = a.words[sortCol]?.word?.toLowerCase() || '';
        valB = b.words[sortCol]?.word?.toLowerCase() || '';
      }
      if (valA < valB) return sortDir === 'asc' ? -1 : 1;
      if (valA > valB) return sortDir === 'asc' ? 1 : -1;
      return 0;
    });
  }
  
  // Render based on vizType
  // Topic colors for indicators
  const topicColors = ['#1f77b4', '#ff7f0e', '#2ca02c', '#d62728', '#9467bd', 
                       '#8c564b', '#e377c2', '#7f7f7f', '#bcbd22', '#17becf'];
  
  if (vizType === 'simpleTable') {
    // KH Coder simple style: Topic | Keywords (Top N)
    let html = '<table style="border-collapse:collapse; font-size:0.9rem; width:100%;">';
    html += '<thead><tr>';
    html += '<th style="padding:0.5rem; border:1px solid #005a9e; width:80px; background:#0078d4; color:#fff;">Topic</th>';
    html += `<th style="padding:0.5rem; border:1px solid #005a9e; background:#0078d4; color:#fff;">Keywords (Top ${topWordsN})</th>`;
    html += '</tr></thead><tbody>';
    
    sortedData.forEach(row => {
      const bgColor = row.index % 2 === 0 ? '#fff' : '#f5f5f5';
      const wordList = row.words.map(w => w.word).join(', ');
      const color = topicColors[row.index % topicColors.length];
      html += `<tr style="background:${bgColor};">`;
      html += `<td style="padding:0.4rem; border:1px solid #ddd; font-weight:bold; color:#333;">`;
      html += `<span style="display:inline-block; width:12px; height:12px; background:${color}; border-radius:2px; margin-right:0.4rem; vertical-align:middle;"></span>`;
      html += `Topic ${row.index + 1}</td>`;
      html += `<td style="padding:0.4rem; border:1px solid #ddd; color:#333;">${escapeHtml(wordList)}</td>`;
      html += '</tr>';
    });
    html += '</tbody></table>';
    tableDiv.innerHTML = html;
    return;
  }
  
  if (vizType === 'detailTable') {
    // KH Coder detail style: columns for each topic with word + probability
    const K = sortedData.length;
    let html = '<div style="overflow-x:auto;"><table style="border-collapse:collapse; font-size:0.85rem;">';
    
    // Header row with topic numbers and colors
    html += '<thead><tr>';
    for (let k = 0; k < K; k++) {
      const color = topicColors[k % topicColors.length];
      html += `<th colspan="2" style="padding:0.4rem; border:1px solid #005a9e; text-align:center; background:#0078d4; color:#fff;">`;
      html += `<span style="display:inline-block; width:10px; height:10px; background:${color}; border-radius:2px; margin-right:0.3rem; vertical-align:middle;"></span>`;
      html += `Topic ${k + 1}</th>`;
    }
    html += '</tr></thead><tbody>';
    
    // Data rows (words at each position)
    for (let i = 0; i < topWordsN; i++) {
      const bgColor = i % 2 === 0 ? '#fff' : '#f5f5f5';
      html += `<tr style="background:${bgColor};">`;
      for (let k = 0; k < K; k++) {
        const word = sortedData[k].words[i];
        if (word) {
          html += `<td style="padding:0.3rem; border:1px solid #ddd; color:#333;">${escapeHtml(word.word)}</td>`;
          html += `<td style="padding:0.3rem; border:1px solid #ddd; text-align:right; color:#666; background:#f8f8f8;">${(word.prob).toFixed(3)}</td>`;
        } else {
          html += '<td style="padding:0.3rem; border:1px solid #ddd; color:#ccc;">-</td>';
          html += '<td style="padding:0.3rem; border:1px solid #ddd; color:#ccc;">-</td>';
        }
      }
      html += '</tr>';
    }
    html += '</tbody></table></div>';
    tableDiv.innerHTML = html;
    return;
  }
  
  // Default: Original detailed table with resizable columns
  const getColWidth = (colIdx) => {
    if (topicColumnWidths[colIdx]) return topicColumnWidths[colIdx] + 'px';
    if (colIdx === 0) return '100px';
    if (colIdx === 1) return '75px';
    return '120px';
  };
  
  // Build table HTML with resizable columns
  const sortIndicator = (col) => {
    if (sortCol === col) {
      return sortDir === 'asc' ? ' ▲' : ' ▼';
    }
    return ' ⇅';
  };
  
  let html = '<table id="topicKeywordTable" style="border-collapse:collapse; font-size:0.85rem; table-layout:fixed;">';
  
  // Colgroup for column widths
  html += '<colgroup>';
  html += `<col style="width:${getColWidth(0)}">`;
  html += `<col style="width:${getColWidth(1)}">`;
  for (let i = 0; i < topWordsN; i++) {
    html += `<col style="width:${getColWidth(i + 2)}">`;
  }
  html += '</colgroup>';
  
  // Header row with resize handles
  const thBaseStyle = 'padding:0.4rem 0.5rem; border:1px solid #ccc; background:#f0f0f0; color:#333; user-select:none; position:sticky; top:0; z-index:1; overflow:hidden; text-overflow:ellipsis;';
  
  html += '<thead><tr>';
  html += `<th data-col="0" style="${thBaseStyle} cursor:pointer;" onclick="sortTopicTable('topic')">
    <div style="display:flex; justify-content:space-between; align-items:center;">
      <span>Topic${sortIndicator('topic')}</span>
      <div class="resize-handle" style="width:5px; height:100%; cursor:col-resize; position:absolute; right:0; top:0; bottom:0;"></div>
    </div>
  </th>`;
  html += `<th data-col="1" style="${thBaseStyle} cursor:pointer;" onclick="sortTopicTable('alpha')">
    <div style="display:flex; justify-content:space-between; align-items:center;">
      <span>Alpha${sortIndicator('alpha')}</span>
      <div class="resize-handle" style="width:5px; height:100%; cursor:col-resize; position:absolute; right:0; top:0; bottom:0;"></div>
    </div>
  </th>`;
  for (let i = 0; i < topWordsN; i++) {
    html += `<th data-col="${i + 2}" style="${thBaseStyle} cursor:pointer; position:relative;" onclick="sortTopicTable(${i})">
      <div style="display:flex; justify-content:space-between; align-items:center;">
        <span style="overflow:hidden; text-overflow:ellipsis;">Word ${i + 1}${sortIndicator(i)}</span>
        <div class="resize-handle" style="width:5px; height:100%; cursor:col-resize; position:absolute; right:0; top:0; bottom:0;"></div>
      </div>
    </th>`;
  }
  html += '</tr></thead>';
  
  // Data rows
  const tdStyle = 'padding:0.3rem 0.5rem; border:1px solid #ddd; overflow:hidden; text-overflow:ellipsis;';
  html += '<tbody>';
  for (const row of sortedData) {
    const bgColor = row.index % 2 === 0 ? '#fff' : '#fafafa';
    const topicColor = topicColors[row.index % topicColors.length];
    html += `<tr style="background:${bgColor};">`;
    html += `<td style="${tdStyle} font-weight:bold; background:#f8f8f8;" title="${escapeHtml(row.label)}">`;
    html += `<span style="display:inline-block; width:12px; height:12px; background:${topicColor}; border-radius:2px; margin-right:0.4rem; vertical-align:middle;"></span>`;
    html += `${escapeHtml(row.label)}</td>`;
    html += `<td style="${tdStyle} text-align:right; color:#666;">${row.alpha.toFixed(4)}</td>`;
    for (let i = 0; i < topWordsN; i++) {
      const word = row.words[i];
      if (word) {
        const wordEsc = escapeHtml(word.word);
        const wordJs = word.word.replace(/\\/g, '\\\\').replace(/'/g, "\\'").replace(/"/g, '\\"');
        const probPct = (word.prob * 100).toFixed(1);
        html += `<td style="${tdStyle}" title="${wordEsc} (${probPct}%)">`;
        html += `<span class="topic-word-link" onclick="jumpToKwicWithWord('${wordJs}')" style="cursor:pointer; border-bottom:1px dotted #0078d4; color:#0078d4;" title="Click to search in KWIC">${wordEsc}</span>`;
        html += ` <span style="color:#999; font-size:0.8em;">(${probPct}%)</span></td>`;
      } else {
        html += `<td style="${tdStyle} color:#ccc;">-</td>`;
      }
    }
    html += '</tr>';
  }
  html += '</tbody></table>';
  
  tableDiv.innerHTML = html;
  
  // Setup column resize handlers
  setupTopicTableResize();
}

// Setup resize handlers for topic table columns
function setupTopicTableResize() {
  const table = document.getElementById('topicKeywordTable');
  if (!table) return;
  
  const headers = table.querySelectorAll('th');
  headers.forEach((th, idx) => {
    const handle = th.querySelector('.resize-handle');
    if (!handle) return;
    
    handle.addEventListener('mousedown', (e) => {
      e.preventDefault();
      e.stopPropagation();
      
      const startX = e.clientX;
      const startWidth = th.offsetWidth;
      const colIdx = parseInt(th.getAttribute('data-col'));
      
      const onMouseMove = (e) => {
        const newWidth = Math.max(60, startWidth + (e.clientX - startX));
        topicColumnWidths[colIdx] = newWidth;
        
        // Update the column width directly
        const cols = table.querySelectorAll('colgroup col');
        if (cols[colIdx]) {
          cols[colIdx].style.width = newWidth + 'px';
        }
      };
      
      const onMouseUp = () => {
        document.removeEventListener('mousemove', onMouseMove);
        document.removeEventListener('mouseup', onMouseUp);
      };
      
      document.addEventListener('mousemove', onMouseMove);
      document.addEventListener('mouseup', onMouseUp);
    });
  });
}

// Sort topic table by column
function sortTopicTable(col) {
  if (window.topicTableSortCol === col) {
    // Toggle direction
    window.topicTableSortDir = window.topicTableSortDir === 'asc' ? 'desc' : 'asc';
  } else {
    window.topicTableSortCol = col;
    window.topicTableSortDir = col === 'alpha' ? 'desc' : 'asc'; // Default desc for alpha
  }
  renderTopicTable();
}

// ===== OPTIMAL K SUGGESTION =====

// Calculate topic coherence (UMass coherence - PMI based)
function calculateTopicCoherence(topicWordDist, vocabulary, dtMatrix, topN = 10) {
  if (!topicWordDist || topicWordDist.length === 0) {
    return { average: 0, perTopic: [] };
  }
  
  const K = topicWordDist.length;
  const coherenceScores = [];
  
  // Document frequency for each word
  const docFreq = {};
  for (let w = 0; w < vocabulary.length; w++) {
    let count = 0;
    for (let d = 0; d < dtMatrix.length; d++) {
      if (dtMatrix[d] && dtMatrix[d][w] > 0) count++;
    }
    docFreq[w] = count;
  }
  
  // Co-occurrence counts
  const coOccur = {};
  for (let d = 0; d < dtMatrix.length; d++) {
    if (!dtMatrix[d]) continue;
    const wordsInDoc = [];
    for (let w = 0; w < vocabulary.length; w++) {
      if (dtMatrix[d][w] > 0) wordsInDoc.push(w);
    }
    for (let i = 0; i < wordsInDoc.length; i++) {
      for (let j = i + 1; j < wordsInDoc.length; j++) {
        const key = Math.min(wordsInDoc[i], wordsInDoc[j]) + '_' + Math.max(wordsInDoc[i], wordsInDoc[j]);
        coOccur[key] = (coOccur[key] || 0) + 1;
      }
    }
  }
  
  const numDocs = dtMatrix.length;
  
  for (let k = 0; k < K; k++) {
    if (!topicWordDist[k]) {
      coherenceScores.push(0);
      continue;
    }
    // Get top words for this topic
    const wordProbs = topicWordDist[k].map((p, i) => ({ idx: i, prob: p }));
    wordProbs.sort((a, b) => b.prob - a.prob);
    const topWords = wordProbs.slice(0, topN).map(w => w.idx);
    
    // UMass coherence: sum of log P(w_j, w_i) / P(w_i) for j > i
    let coherence = 0;
    let pairCount = 0;
    for (let i = 0; i < topWords.length; i++) {
      for (let j = i + 1; j < topWords.length; j++) {
        const wi = topWords[i];
        const wj = topWords[j];
        const key = Math.min(wi, wj) + '_' + Math.max(wi, wj);
        const co = coOccur[key] || 0;
        const dfi = docFreq[wi] || 1;
        // UMass coherence formula with smoothing
        coherence += Math.log((co + 1) / dfi);
        pairCount++;
      }
    }
    coherenceScores.push(pairCount > 0 ? coherence / pairCount : 0);
  }
  
  // Return average coherence across all topics
  const avgCoherence = K > 0 ? coherenceScores.reduce((a, b) => a + b, 0) / K : 0;
  return { average: avgCoherence, perTopic: coherenceScores };
}

// Calculate perplexity (for LDA)
function calculatePerplexity(docTopicDist, topicWordDist, dtMatrix) {
  let totalLogLikelihood = 0;
  let totalWords = 0;
  
  for (let d = 0; d < dtMatrix.length; d++) {
    for (let w = 0; w < dtMatrix[d].length; w++) {
      if (dtMatrix[d][w] > 0) {
        let wordProb = 0;
        for (let k = 0; k < topicWordDist.length; k++) {
          wordProb += docTopicDist[d][k] * topicWordDist[k][w];
        }
        if (wordProb > 0) {
          totalLogLikelihood += dtMatrix[d][w] * Math.log(wordProb);
          totalWords += dtMatrix[d][w];
        }
      }
    }
  }
  
  if (totalWords === 0) return Infinity;
  return Math.exp(-totalLogLikelihood / totalWords);
}

// Run topic modeling for a specific K and return scores
function runTopicModelForK(preprocessed, K, method, options) {
  const { numDocs, vocabSize, dtMatrix } = preprocessed;
  
  // Validate inputs
  if (!numDocs || numDocs < 1 || !vocabSize || vocabSize < 1 || !dtMatrix || dtMatrix.length === 0) {
    return { topicWordDist: [], docTopicDist: [] };
  }
  
  const iterations = options.iterations || 50;
  const alpha = options.alpha || 0.1;
  const beta = options.beta || 0.01;
  
  let topicWordDist, docTopicDist;
  
  if (method === 'lda') {
    // Simplified LDA
    const docTopicCounts = Array(numDocs).fill(null).map(() => Array(K).fill(0));
    const topicWordCounts = Array(K).fill(null).map(() => Array(vocabSize).fill(0));
    const topicCounts = Array(K).fill(0);
    const wordTopics = [];
    
    // Initialize
    for (let d = 0; d < numDocs; d++) {
      wordTopics[d] = [];
      for (let w = 0; w < vocabSize; w++) {
        const count = dtMatrix[d][w];
        for (let c = 0; c < count; c++) {
          const t = Math.floor(Math.random() * K);
          wordTopics[d].push({ w, t });
          docTopicCounts[d][t]++;
          topicWordCounts[t][w]++;
          topicCounts[t]++;
        }
      }
    }
    
    // Gibbs sampling
    for (let iter = 0; iter < iterations; iter++) {
      for (let d = 0; d < numDocs; d++) {
        for (let i = 0; i < wordTopics[d].length; i++) {
          const { w, t: oldT } = wordTopics[d][i];
          docTopicCounts[d][oldT]--;
          topicWordCounts[oldT][w]--;
          topicCounts[oldT]--;
          
          const probs = [];
          for (let k = 0; k < K; k++) {
            const p = (docTopicCounts[d][k] + alpha) * 
                      (topicWordCounts[k][w] + beta) / 
                      (topicCounts[k] + vocabSize * beta);
            probs.push(p);
          }
          
          const sum = probs.reduce((a, b) => a + b, 0);
          let r = Math.random() * sum;
          let newT = 0;
          for (let k = 0; k < K; k++) {
            r -= probs[k];
            if (r <= 0) { newT = k; break; }
          }
          
          wordTopics[d][i].t = newT;
          docTopicCounts[d][newT]++;
          topicWordCounts[newT][w]++;
          topicCounts[newT]++;
        }
      }
    }
    
    // Calculate distributions
    topicWordDist = topicWordCounts.map((counts, k) => {
      const sum = topicCounts[k] + vocabSize * beta;
      return counts.map(c => (c + beta) / sum);
    });
    
    docTopicDist = docTopicCounts.map(counts => {
      const sum = counts.reduce((a, b) => a + b, 0) + K * alpha;
      return counts.map(c => (c + alpha) / sum);
    });
  } else {
    // NMF
    const tfidf = dtMatrix.map(row => {
      const docLen = row.reduce((a, b) => a + b, 0);
      return row.map((tf, w) => {
        const idf = Math.log(numDocs / (1 + dtMatrix.filter(d => d[w] > 0).length));
        return (tf / Math.max(docLen, 1)) * idf;
      });
    });
    
    let W = Array(numDocs).fill(null).map(() => 
      Array(K).fill(0).map(() => Math.random() * 0.1 + 0.01));
    let H = Array(K).fill(null).map(() => 
      Array(vocabSize).fill(0).map(() => Math.random() * 0.1 + 0.01));
    
    for (let iter = 0; iter < iterations; iter++) {
      // Update H
      for (let k = 0; k < K; k++) {
        for (let j = 0; j < vocabSize; j++) {
          let num = 0, den = 0;
          for (let i = 0; i < numDocs; i++) {
            let wh = 0;
            for (let kk = 0; kk < K; kk++) wh += W[i][kk] * H[kk][j];
            num += W[i][k] * tfidf[i][j];
            den += W[i][k] * wh;
          }
          H[k][j] *= (num / Math.max(den, 1e-10));
        }
      }
      // Update W
      for (let i = 0; i < numDocs; i++) {
        for (let k = 0; k < K; k++) {
          let num = 0, den = 0;
          for (let j = 0; j < vocabSize; j++) {
            let wh = 0;
            for (let kk = 0; kk < K; kk++) wh += W[i][kk] * H[kk][j];
            num += H[k][j] * tfidf[i][j];
            den += H[k][j] * wh;
          }
          W[i][k] *= (num / Math.max(den, 1e-10));
        }
      }
    }
    
    topicWordDist = H.map(row => {
      const sum = row.reduce((a, b) => a + b, 0);
      return row.map(v => sum > 0 ? v / sum : 1 / vocabSize);
    });
    
    docTopicDist = W.map(row => {
      const sum = row.reduce((a, b) => a + b, 0);
      return row.map(v => sum > 0 ? v / sum : 1 / K);
    });
  }
  
  return { topicWordDist, docTopicDist };
}

// Suggest optimal K by running multiple models
async function suggestOptimalK() {
  const statusEl = document.getElementById('topicStatus');
  const resultsDiv = document.getElementById('topicSuggestKResults');
  const canvas = document.getElementById('topicSuggestKCanvas');
  const textEl = document.getElementById('topicSuggestKText');
  
  // Hide results initially
  if (resultsDiv) resultsDiv.style.display = 'none';
  
  // Get parameters
  const kMin = parseInt(document.getElementById('topicKMin')?.value) || 2;
  const kMax = parseInt(document.getElementById('topicKMax')?.value) || 15;
  const kStep = parseInt(document.getElementById('topicKStep')?.value) || 1;
  const iterations = parseInt(document.getElementById('topicSearchIter')?.value) || 30;
  const methodEl = document.getElementById('topicMethod');
  const method = methodEl ? methodEl.value : 'lda';
  const scopeEl = document.getElementById('topicScope');
  const scope = scopeEl ? scopeEl.value : 'all';
  const unitEl = document.getElementById('topicUnit');
  const unit = unitEl ? unitEl.value : 'file';
  
  // Validate
  if (kMin >= kMax) {
    alert('K min must be less than K max');
    return;
  }
  
  // Check corpus
  if (!corpus || !corpus.files || Object.keys(corpus.files).length === 0) {
    alert('Please load corpus data first.');
    if (statusEl) statusEl.textContent = 'No corpus loaded.';
    return;
  }
  
  if (statusEl) statusEl.textContent = 'Preparing documents...';
  await new Promise(r => setTimeout(r, 30));
  
  // Get documents
  let docs = [];
  try {
    docs = getPlainTextsFromCorpus(scope, unit);
  } catch (e) {
    console.error('Error getting documents:', e);
    alert('Error preparing documents: ' + e.message);
    return;
  }
  
  if (docs.length < 3) {
    alert('Need at least 3 documents. Found: ' + docs.length);
    if (statusEl) statusEl.textContent = 'Not enough documents.';
    return;
  }
  
  if (statusEl) statusEl.textContent = 'Preprocessing...';
  await new Promise(r => setTimeout(r, 30));
  
  // Preprocess
  let preprocessed;
  try {
    const lowercaseEl = document.getElementById('topicLowercase');
    const excludeEl = document.getElementById('topicExcludeStopwords');
    const minDocEl = document.getElementById('topicMinDocFreq');
    const maxDocEl = document.getElementById('topicMaxDocFreq');
    
    preprocessed = preprocessForTopicModel(docs, {
      lowercase: lowercaseEl ? lowercaseEl.checked : true,
      excludeStopwords: excludeEl ? excludeEl.checked : true,
      minDocFreq: minDocEl ? (parseInt(minDocEl.value) || 2) : 2,
      maxDocFreqPct: maxDocEl ? (parseInt(maxDocEl.value) || 80) : 80
    });
  } catch (e) {
    console.error('Preprocessing error:', e);
    alert('Preprocessing failed: ' + e.message);
    return;
  }
  
  if (!preprocessed || !preprocessed.vocabulary || preprocessed.vocabulary.length < 10) {
    alert('Vocabulary too small (' + (preprocessed?.vocabulary?.length || 0) + '). Need at least 10 words.');
    if (statusEl) statusEl.textContent = 'Vocabulary too small.';
    return;
  }
  
  const alphaEl = document.getElementById('topicAlpha');
  const betaEl = document.getElementById('topicBeta');
  const alpha = alphaEl ? (parseFloat(alphaEl.value) || 0.1) : 0.1;
  const beta = betaEl ? (parseFloat(betaEl.value) || 0.01) : 0.01;
  
  // Run models for each K
  const results = [];
  for (let K = kMin; K <= kMax; K += kStep) {
    if (statusEl) statusEl.textContent = `Testing K=${K}...`;
    await new Promise(r => setTimeout(r, 20));
    
    try {
      // Run simplified LDA/NMF
      const modelMethod = (method === 'embedding') ? 'nmf' : method;
      const model = runSimplifiedTopicModel(preprocessed, K, modelMethod, iterations, alpha, beta);
      
      if (model && model.topicWordDist && model.topicWordDist.length > 0) {
        // Calculate simple metrics
        const coherence = calcSimpleCoherence(model.topicWordDist, preprocessed);
        const perplexity = calcSimplePerplexity(model.docTopicDist, model.topicWordDist, preprocessed.dtMatrix);
        
        results.push({ K, coherence, perplexity });
      }
    } catch (e) {
      console.warn(`K=${K} failed:`, e.message);
    }
  }
  
  if (results.length === 0) {
    alert('Could not compute any models.');
    if (statusEl) statusEl.textContent = 'Analysis failed.';
    return;
  }
  
  // Normalize and find best K
  const cohVals = results.map(r => r.coherence);
  const perpVals = results.map(r => r.perplexity).filter(p => isFinite(p));
  const minCoh = Math.min(...cohVals);
  const maxCoh = Math.max(...cohVals);
  const minPerp = perpVals.length > 0 ? Math.min(...perpVals) : 0;
  const maxPerp = perpVals.length > 0 ? Math.max(...perpVals) : 1;
  
  let bestK = results[0].K;
  let bestScore = -Infinity;
  
  for (const r of results) {
    const cohNorm = maxCoh > minCoh ? (r.coherence - minCoh) / (maxCoh - minCoh) : 0.5;
    const perpNorm = (maxPerp > minPerp && isFinite(r.perplexity)) 
      ? 1 - (r.perplexity - minPerp) / (maxPerp - minPerp) 
      : 0.5;
    
    r.cohNorm = cohNorm;
    r.perpNorm = perpNorm;
    
    // Higher coherence is better, lower perplexity is better
    const score = cohNorm * 0.6 + perpNorm * 0.4;
    if (score > bestScore) {
      bestScore = score;
      bestK = r.K;
    }
  }
  
  // Store results
  topicSuggestKResults = { results, bestK, method };
  
  // Draw graph
  if (canvas) {
    drawSuggestKGraph(canvas, results, bestK);
  }
  
  // Show results
  if (resultsDiv) resultsDiv.style.display = 'block';
  if (textEl) {
    const bestRes = results.find(r => r.K === bestK) || {};
    textEl.innerHTML = `
      <div style="margin-bottom:0.5rem;">
        <strong>Recommended K:</strong> 
        <span style="font-size:1.3em; color:#d62728; font-weight:bold;">${bestK}</span>
      </div>
      <div style="font-size:0.9em; color:#555;">
        <div>Coherence: ${bestRes.coherence?.toFixed(4) ?? 'N/A'}</div>
        <div>Perplexity: ${isFinite(bestRes.perplexity) ? bestRes.perplexity.toFixed(1) : 'N/A'}</div>
      </div>
      <div style="font-size:0.8em; color:#888; margin-top:0.3rem;">
        Tested ${results.length} values from K=${kMin} to K=${kMax}
      </div>
    `;
  }
  
  if (statusEl) statusEl.textContent = 'K suggestion complete.';
}

// Simplified topic model for K suggestion
function runSimplifiedTopicModel(preprocessed, K, method, iterations, alpha, beta) {
  const { numDocs, vocabSize, dtMatrix } = preprocessed;
  
  if (!dtMatrix || dtMatrix.length === 0 || vocabSize < 1) {
    return { topicWordDist: [], docTopicDist: [] };
  }
  
  let topicWordDist, docTopicDist;
  
  if (method === 'lda') {
    // Simplified Gibbs sampling LDA
    const docTopicCounts = Array.from({ length: numDocs }, () => Array(K).fill(0));
    const topicWordCounts = Array.from({ length: K }, () => Array(vocabSize).fill(0));
    const topicTotals = Array(K).fill(0);
    
    // Initialize randomly
    const assignments = [];
    for (let d = 0; d < numDocs; d++) {
      assignments[d] = [];
      for (let w = 0; w < vocabSize; w++) {
        const count = dtMatrix[d][w] || 0;
        for (let c = 0; c < count; c++) {
          const t = Math.floor(Math.random() * K);
          assignments[d].push({ w, t });
          docTopicCounts[d][t]++;
          topicWordCounts[t][w]++;
          topicTotals[t]++;
        }
      }
    }
    
    // Gibbs sampling iterations
    for (let iter = 0; iter < iterations; iter++) {
      for (let d = 0; d < numDocs; d++) {
        for (let i = 0; i < assignments[d].length; i++) {
          const { w, t: oldT } = assignments[d][i];
          
          // Remove current assignment
          docTopicCounts[d][oldT]--;
          topicWordCounts[oldT][w]--;
          topicTotals[oldT]--;
          
          // Sample new topic
          let probs = [];
          let sum = 0;
          for (let k = 0; k < K; k++) {
            const p = (docTopicCounts[d][k] + alpha) * 
                      (topicWordCounts[k][w] + beta) / 
                      (topicTotals[k] + vocabSize * beta);
            probs.push(p);
            sum += p;
          }
          
          let r = Math.random() * sum;
          let newT = 0;
          for (let k = 0; k < K; k++) {
            r -= probs[k];
            if (r <= 0) { newT = k; break; }
          }
          
          // Apply new assignment
          assignments[d][i].t = newT;
          docTopicCounts[d][newT]++;
          topicWordCounts[newT][w]++;
          topicTotals[newT]++;
        }
      }
    }
    
    // Calculate distributions
    topicWordDist = topicWordCounts.map((counts, k) => {
      const denom = topicTotals[k] + vocabSize * beta;
      return counts.map(c => (c + beta) / denom);
    });
    
    docTopicDist = docTopicCounts.map(counts => {
      const sum = counts.reduce((a, b) => a + b, 0) + K * alpha;
      return counts.map(c => (c + alpha) / sum);
    });
  } else {
    // NMF
    const tfidf = dtMatrix.map(row => {
      const docLen = row.reduce((a, b) => a + b, 0) || 1;
      return row.map((tf, w) => {
        const df = dtMatrix.filter(d => d[w] > 0).length;
        const idf = Math.log((numDocs + 1) / (df + 1));
        return (tf / docLen) * idf;
      });
    });
    
    // Initialize W and H
    let W = Array.from({ length: numDocs }, () => 
      Array.from({ length: K }, () => Math.random() * 0.1 + 0.01));
    let H = Array.from({ length: K }, () => 
      Array.from({ length: vocabSize }, () => Math.random() * 0.1 + 0.01));
    
    // NMF iterations
    for (let iter = 0; iter < iterations; iter++) {
      // Update H
      for (let k = 0; k < K; k++) {
        for (let w = 0; w < vocabSize; w++) {
          let num = 0, denom = 0;
          for (let d = 0; d < numDocs; d++) {
            num += W[d][k] * tfidf[d][w];
            let wh = 0;
            for (let kk = 0; kk < K; kk++) wh += W[d][kk] * H[kk][w];
            denom += W[d][k] * wh;
          }
          H[k][w] *= (denom > 0) ? (num / denom) : 0;
        }
      }
      
      // Update W
      for (let d = 0; d < numDocs; d++) {
        for (let k = 0; k < K; k++) {
          let num = 0, denom = 0;
          for (let w = 0; w < vocabSize; w++) {
            num += H[k][w] * tfidf[d][w];
            let wh = 0;
            for (let kk = 0; kk < K; kk++) wh += W[d][kk] * H[kk][w];
            denom += H[k][w] * wh;
          }
          W[d][k] *= (denom > 0) ? (num / denom) : 0;
        }
      }
    }
    
    // Normalize
    topicWordDist = H.map(row => {
      const sum = row.reduce((a, b) => a + b, 0) || 1;
      return row.map(v => v / sum);
    });
    
    docTopicDist = W.map(row => {
      const sum = row.reduce((a, b) => a + b, 0) || 1;
      return row.map(v => v / sum);
    });
  }
  
  return { topicWordDist, docTopicDist };
}

// Simple coherence calculation
function calcSimpleCoherence(topicWordDist, preprocessed) {
  const { dtMatrix, vocabulary } = preprocessed;
  if (!topicWordDist || topicWordDist.length === 0) return 0;
  
  const K = topicWordDist.length;
  const numDocs = dtMatrix.length;
  const topN = 10;
  
  // Calculate document frequency
  const docFreq = vocabulary.map((_, w) => {
    let count = 0;
    for (let d = 0; d < numDocs; d++) {
      if (dtMatrix[d][w] > 0) count++;
    }
    return count;
  });
  
  let totalCoherence = 0;
  for (let k = 0; k < K; k++) {
    const dist = topicWordDist[k];
    if (!dist) continue;
    
    // Get top words
    const wordProbs = dist.map((p, i) => ({ i, p }));
    wordProbs.sort((a, b) => b.p - a.p);
    const topWords = wordProbs.slice(0, topN).map(x => x.i);
    
    // UMass coherence
    let coherence = 0;
    let pairs = 0;
    for (let i = 0; i < topWords.length; i++) {
      for (let j = i + 1; j < topWords.length; j++) {
        const wi = topWords[i];
        const wj = topWords[j];
        
        // Count co-occurrence
        let coOccur = 0;
        for (let d = 0; d < numDocs; d++) {
          if (dtMatrix[d][wi] > 0 && dtMatrix[d][wj] > 0) coOccur++;
        }
        
        const dfi = docFreq[wi] || 1;
        coherence += Math.log((coOccur + 1) / dfi);
        pairs++;
      }
    }
    
    totalCoherence += pairs > 0 ? coherence / pairs : 0;
  }
  
  return K > 0 ? totalCoherence / K : 0;
}

// Simple perplexity calculation
function calcSimplePerplexity(docTopicDist, topicWordDist, dtMatrix) {
  if (!docTopicDist || !topicWordDist || !dtMatrix) return Infinity;
  
  let logLik = 0;
  let totalWords = 0;
  
  const numDocs = dtMatrix.length;
  const vocabSize = dtMatrix[0]?.length || 0;
  const K = topicWordDist.length;
  
  for (let d = 0; d < numDocs; d++) {
    for (let w = 0; w < vocabSize; w++) {
      const count = dtMatrix[d][w] || 0;
      if (count > 0) {
        let wordProb = 0;
        for (let k = 0; k < K; k++) {
          wordProb += (docTopicDist[d]?.[k] || 0) * (topicWordDist[k]?.[w] || 0);
        }
        if (wordProb > 1e-10) {
          logLik += count * Math.log(wordProb);
          totalWords += count;
        }
      }
    }
  }
  
  return totalWords > 0 ? Math.exp(-logLik / totalWords) : Infinity;
}

// Draw Suggest K graph
function drawSuggestKGraph(canvas, results, bestK) {
  const ctx = canvas.getContext('2d');
  const W = canvas.width;
  const H = canvas.height;
  
  ctx.clearRect(0, 0, W, H);
  ctx.fillStyle = '#fff';
  ctx.fillRect(0, 0, W, H);
  
  if (results.length === 0) {
    ctx.fillStyle = '#666';
    ctx.textAlign = 'center';
    ctx.fillText('No results', W / 2, H / 2);
    return;
  }
  
  const pad = { top: 40, right: 100, bottom: 50, left: 60 };
  const plotW = W - pad.left - pad.right;
  const plotH = H - pad.top - pad.bottom;
  
  const kVals = results.map(r => r.K);
  const minK = Math.min(...kVals);
  const maxK = Math.max(...kVals);
  const kRange = maxK - minK || 1;
  
  // Draw background
  ctx.fillStyle = '#f8f8f8';
  ctx.fillRect(pad.left, pad.top, plotW, plotH);
  
  // Draw grid
  ctx.strokeStyle = '#ddd';
  ctx.lineWidth = 1;
  for (let i = 0; i <= 4; i++) {
    const y = pad.top + (plotH * i / 4);
    ctx.beginPath();
    ctx.moveTo(pad.left, y);
    ctx.lineTo(pad.left + plotW, y);
    ctx.stroke();
  }
  
  // Draw coherence line (blue)
  ctx.strokeStyle = '#1f77b4';
  ctx.lineWidth = 2;
  ctx.beginPath();
  let first = true;
  for (const r of results) {
    const x = pad.left + ((r.K - minK) / kRange) * plotW;
    const y = pad.top + plotH - (r.cohNorm || 0) * plotH;
    if (first) { ctx.moveTo(x, y); first = false; }
    else ctx.lineTo(x, y);
  }
  ctx.stroke();
  
  // Draw perplexity line (red, inverted)
  ctx.strokeStyle = '#d62728';
  ctx.lineWidth = 2;
  ctx.beginPath();
  first = true;
  for (const r of results) {
    const x = pad.left + ((r.K - minK) / kRange) * plotW;
    const y = pad.top + plotH - (r.perpNorm || 0) * plotH;
    if (first) { ctx.moveTo(x, y); first = false; }
    else ctx.lineTo(x, y);
  }
  ctx.stroke();
  
  // Mark best K
  const bestX = pad.left + ((bestK - minK) / kRange) * plotW;
  ctx.strokeStyle = '#2ca02c';
  ctx.lineWidth = 3;
  ctx.setLineDash([5, 3]);
  ctx.beginPath();
  ctx.moveTo(bestX, pad.top);
  ctx.lineTo(bestX, pad.top + plotH);
  ctx.stroke();
  ctx.setLineDash([]);
  
  // Draw points
  for (const r of results) {
    const x = pad.left + ((r.K - minK) / kRange) * plotW;
    
    // Coherence point
    const yCoh = pad.top + plotH - (r.cohNorm || 0) * plotH;
    ctx.fillStyle = '#1f77b4';
    ctx.beginPath();
    ctx.arc(x, yCoh, 4, 0, Math.PI * 2);
    ctx.fill();
    
    // Perplexity point
    const yPerp = pad.top + plotH - (r.perpNorm || 0) * plotH;
    ctx.fillStyle = '#d62728';
    ctx.beginPath();
    ctx.arc(x, yPerp, 4, 0, Math.PI * 2);
    ctx.fill();
  }
  
  // Labels
  ctx.fillStyle = '#333';
  ctx.font = '12px sans-serif';
  ctx.textAlign = 'center';
  ctx.fillText('Number of Topics (K)', W / 2, H - 10);
  
  // Y-axis label
  ctx.save();
  ctx.translate(15, H / 2);
  ctx.rotate(-Math.PI / 2);
  ctx.fillText('Normalized Score', 0, 0);
  ctx.restore();
  
  // X-axis ticks
  ctx.font = '10px sans-serif';
  for (const r of results) {
    const x = pad.left + ((r.K - minK) / kRange) * plotW;
    ctx.fillText(r.K.toString(), x, pad.top + plotH + 15);
  }
  
  // Legend
  ctx.font = '11px sans-serif';
  ctx.textAlign = 'left';
  
  ctx.fillStyle = '#1f77b4';
  ctx.fillRect(W - 90, pad.top + 10, 12, 12);
  ctx.fillStyle = '#333';
  ctx.fillText('Coherence', W - 75, pad.top + 20);
  
  ctx.fillStyle = '#d62728';
  ctx.fillRect(W - 90, pad.top + 30, 12, 12);
  ctx.fillStyle = '#333';
  ctx.fillText('Perplexity⁻¹', W - 75, pad.top + 40);
  
  ctx.fillStyle = '#2ca02c';
  ctx.fillRect(W - 90, pad.top + 50, 12, 12);
  ctx.fillStyle = '#333';
  ctx.fillText('Best K=' + bestK, W - 75, pad.top + 60);
}

// Calculate ldatuning metrics (CaoJuan2009, Arun2010, Deveaud2014)
function calculateLdaTuningMetrics(topicWordDist, docTopicDist, vocabulary, dtMatrix, K) {
  const D = docTopicDist.length;
  const V = vocabulary.length;
  
  // 1. Coherence (UMass)
  let coherence = 0;
  try {
    const cohResult = calculateTopicCoherence(topicWordDist, vocabulary, dtMatrix, 10);
    coherence = cohResult.average;
  } catch (e) {
    coherence = 0;
  }
  
  // 2. Perplexity
  let perplexity = Infinity;
  try {
    perplexity = calculatePerplexity(docTopicDist, topicWordDist, dtMatrix);
  } catch (e) {
    perplexity = Infinity;
  }
  
  // 3. CaoJuan2009: minimize - measures topic dissimilarity using cosine distance
  let caojuan = 0;
  try {
    for (let i = 0; i < K; i++) {
      for (let j = i + 1; j < K; j++) {
        // Cosine distance between topics i and j
        let dotProd = 0, normI = 0, normJ = 0;
        for (let w = 0; w < V; w++) {
          dotProd += topicWordDist[i][w] * topicWordDist[j][w];
          normI += topicWordDist[i][w] * topicWordDist[i][w];
          normJ += topicWordDist[j][w] * topicWordDist[j][w];
        }
        const cosSim = dotProd / (Math.sqrt(normI) * Math.sqrt(normJ) + 1e-10);
        caojuan += cosSim; // Higher means more similar (worse)
      }
    }
    caojuan = caojuan / (K * (K - 1) / 2); // Average
  } catch (e) {
    caojuan = 1;
  }
  
  // 4. Arun2010: minimize - KL divergence between topic distributions
  let arun = 0;
  try {
    // Document length distribution
    const docLengths = dtMatrix.map(d => d.reduce((a, b) => a + b, 0));
    const totalLen = docLengths.reduce((a, b) => a + b, 0);
    const docLenDist = docLengths.map(l => l / totalLen);
    
    // Topic-document distribution (transpose of doc-topic and weight by doc length)
    const topicDocDist = Array(K).fill(0);
    for (let k = 0; k < K; k++) {
      for (let d = 0; d < D; d++) {
        topicDocDist[k] += docTopicDist[d][k] * docLenDist[d];
      }
    }
    
    // SVD singular values approximation using topic word distribution
    const singularVals = [];
    for (let k = 0; k < K; k++) {
      const sum = topicWordDist[k].reduce((a, b) => a + b, 0);
      singularVals.push(sum);
    }
    const totalSV = singularVals.reduce((a, b) => a + b, 0) || 1;
    const svDist = singularVals.map(s => s / totalSV);
    
    // KL divergence between distributions
    for (let k = 0; k < K; k++) {
      if (svDist[k] > 0 && topicDocDist[k] > 0) {
        arun += svDist[k] * Math.log(svDist[k] / (topicDocDist[k] + 1e-10));
      }
    }
  } catch (e) {
    arun = Infinity;
  }
  
  // 5. Deveaud2014: maximize - topic diversity using Jensen-Shannon divergence
  let deveaud = 0;
  try {
    for (let i = 0; i < K; i++) {
      for (let j = i + 1; j < K; j++) {
        // Jensen-Shannon divergence
        let jsd = 0;
        for (let w = 0; w < V; w++) {
          const m = (topicWordDist[i][w] + topicWordDist[j][w]) / 2;
          if (m > 0) {
            if (topicWordDist[i][w] > 0) {
              jsd += topicWordDist[i][w] * Math.log(topicWordDist[i][w] / m);
            }
            if (topicWordDist[j][w] > 0) {
              jsd += topicWordDist[j][w] * Math.log(topicWordDist[j][w] / m);
            }
          }
        }
        deveaud += jsd / 2;
      }
    }
    deveaud = deveaud / (K * (K - 1) / 2); // Average JSD
  } catch (e) {
    deveaud = 0;
  }
  
  return { coherence, perplexity, caojuan, arun, deveaud };
}

// Normalize metrics to 0-1 range
function normalizeMetrics(results) {
  const metrics = ['perplexity', 'coherence', 'caojuan', 'arun', 'deveaud'];
  const normalized = results.map(r => ({ ...r }));
  
  for (const metric of metrics) {
    const vals = results.map(r => r[metric]).filter(v => isFinite(v));
    if (vals.length === 0) continue;
    
    const minVal = Math.min(...vals);
    const maxVal = Math.max(...vals);
    const range = maxVal - minVal || 1;
    
    for (const r of normalized) {
      if (isFinite(r[metric])) {
        r[metric + '_norm'] = (r[metric] - minVal) / range;
      } else {
        r[metric + '_norm'] = 0.5;
      }
    }
  }
  
  return normalized;
}

// Find optimal K based on metrics
function findOptimalK(results, selectedMetric) {
  if (results.length === 0) return { K: 5 };
  
  let bestK = results[0].K;
  let bestScore = Infinity;
  
  for (const r of results) {
    let score;
    
    if (selectedMetric === 'all') {
      // Combine: minimize perplexity, caojuan, arun; maximize coherence, deveaud
      score = (r.perplexity_norm || 0) + 
              (r.caojuan_norm || 0) + 
              (r.arun_norm || 0) - 
              (r.coherence_norm || 0) - 
              (r.deveaud_norm || 0);
    } else if (selectedMetric === 'perplexity') {
      score = r.perplexity_norm || 0;
    } else if (selectedMetric === 'coherence') {
      score = -(r.coherence_norm || 0); // maximize
    } else if (selectedMetric === 'caojuan') {
      score = r.caojuan_norm || 0;
    } else if (selectedMetric === 'arun') {
      score = r.arun_norm || 0;
    } else if (selectedMetric === 'deveaud') {
      score = -(r.deveaud_norm || 0); // maximize
    } else {
      score = (r.perplexity_norm || 0) - (r.coherence_norm || 0);
    }
    
    if (score < bestScore) {
      bestScore = score;
      bestK = r.K;
    }
  }
  
  return { K: bestK, score: bestScore };
}

// Draw ldatuning-style graph with multiple metrics
function drawLdaTuningGraph(results, bestK) {
  const canvas = document.getElementById('topicSuggestKCanvas');
  const ctx = canvas.getContext('2d');
  const W = canvas.width;
  const H = canvas.height;
  
  ctx.clearRect(0, 0, W, H);
  ctx.fillStyle = '#fff';
  ctx.fillRect(0, 0, W, H);
  
  if (results.length === 0) {
    ctx.fillStyle = '#666';
    ctx.textAlign = 'center';
    ctx.fillText('No results to display', W / 2, H / 2);
    return;
  }
  
  const padding = { top: 30, right: 130, bottom: 45, left: 50 };
  const plotW = W - padding.left - padding.right;
  const topH = (H - padding.top - padding.bottom - 20) / 2;
  const botH = topH;
  
  const kValues = results.map(r => r.K);
  const minK = Math.min(...kValues);
  const maxK = Math.max(...kValues);
  const kRange = maxK - minK || 1;
  
  // Metrics to minimize (top plot)
  const minimizeMetrics = [
    { key: 'caojuan_norm', label: 'CaoJuan2009', color: '#000', symbol: '●' },
    { key: 'arun_norm', label: 'Arun2010', color: '#000', symbol: '■' }
  ];
  
  // Metrics to maximize (bottom plot)
  const maximizeMetrics = [
    { key: 'coherence_norm', label: 'Coherence', color: '#000', symbol: '●' },
    { key: 'deveaud_norm', label: 'Deveaud2014', color: '#000', symbol: '+' }
  ];
  
  // Draw minimize section (top)
  ctx.fillStyle = '#f5f5f5';
  ctx.fillRect(padding.left, padding.top, plotW, topH);
  
  // Label
  ctx.save();
  ctx.translate(15, padding.top + topH / 2);
  ctx.rotate(-Math.PI / 2);
  ctx.fillStyle = '#666';
  ctx.font = '10px sans-serif';
  ctx.textAlign = 'center';
  ctx.fillText('minimize', 0, 0);
  ctx.restore();
  
  // Draw minimize metrics
  drawMetricLines(ctx, results, minimizeMetrics, padding, topH, minK, kRange, plotW, padding.top, bestK);
  
  // Draw maximize section (bottom)
  const botTop = padding.top + topH + 20;
  ctx.fillStyle = '#f5f5f5';
  ctx.fillRect(padding.left, botTop, plotW, botH);
  
  // Label
  ctx.save();
  ctx.translate(15, botTop + botH / 2);
  ctx.rotate(-Math.PI / 2);
  ctx.fillStyle = '#666';
  ctx.font = '10px sans-serif';
  ctx.textAlign = 'center';
  ctx.fillText('maximize', 0, 0);
  ctx.restore();
  
  // Draw maximize metrics
  drawMetricLines(ctx, results, maximizeMetrics, padding, botH, minK, kRange, plotW, botTop, bestK);
  
  // X-axis label
  ctx.fillStyle = '#333';
  ctx.font = '11px sans-serif';
  ctx.textAlign = 'center';
  ctx.fillText('number of topics', W / 2 - 30, H - 8);
  
  // X-axis ticks
  ctx.font = '9px sans-serif';
  const step = Math.max(1, Math.floor(kRange / 10));
  for (let k = minK; k <= maxK; k += step) {
    const x = padding.left + ((k - minK) / kRange) * plotW;
    ctx.fillText(k.toString(), x, H - padding.bottom + 15);
  }
  
  // Draw legend
  const legendX = W - padding.right + 10;
  ctx.font = '10px sans-serif';
  ctx.textAlign = 'left';
  ctx.fillStyle = '#333';
  ctx.fillText('metrics:', legendX, padding.top + 10);
  
  const allMetrics = [...minimizeMetrics, ...maximizeMetrics];
  allMetrics.forEach((m, i) => {
    const y = padding.top + 30 + i * 18;
    ctx.fillStyle = '#333';
    ctx.fillText(m.symbol + ' ' + m.label, legendX, y);
  });
  
  // Highlight best K
  const bestX = padding.left + ((bestK - minK) / kRange) * plotW;
  ctx.strokeStyle = '#d62728';
  ctx.lineWidth = 2;
  ctx.setLineDash([5, 3]);
  ctx.beginPath();
  ctx.moveTo(bestX, padding.top);
  ctx.lineTo(bestX, H - padding.bottom);
  ctx.stroke();
  ctx.setLineDash([]);
}

// Helper function to draw metric lines
function drawMetricLines(ctx, results, metrics, padding, plotH, minK, kRange, plotW, topOffset, bestK) {
  metrics.forEach((metric, mIdx) => {
    const vals = results.map(r => r[metric.key]).filter(v => isFinite(v));
    if (vals.length === 0) return;
    
    ctx.strokeStyle = metric.color;
    ctx.lineWidth = 1.5;
    ctx.beginPath();
    
    let first = true;
    for (const r of results) {
      if (!isFinite(r[metric.key])) continue;
      const x = padding.left + ((r.K - minK) / kRange) * plotW;
      const y = topOffset + plotH - r[metric.key] * plotH * 0.9 - plotH * 0.05;
      
      if (first) {
        ctx.moveTo(x, y);
        first = false;
      } else {
        ctx.lineTo(x, y);
      }
    }
    ctx.stroke();
    
    // Draw points
    for (const r of results) {
      if (!isFinite(r[metric.key])) continue;
      const x = padding.left + ((r.K - minK) / kRange) * plotW;
      const y = topOffset + plotH - r[metric.key] * plotH * 0.9 - plotH * 0.05;
      
      ctx.fillStyle = r.K === bestK ? '#d62728' : '#333';
      
      if (metric.symbol === '●') {
        ctx.beginPath();
        ctx.arc(x, y, r.K === bestK ? 5 : 4, 0, Math.PI * 2);
        ctx.fill();
      } else if (metric.symbol === '■') {
        ctx.fillRect(x - 4, y - 4, 8, 8);
      } else if (metric.symbol === '▲') {
        ctx.beginPath();
        ctx.moveTo(x, y - 5);
        ctx.lineTo(x - 5, y + 4);
        ctx.lineTo(x + 5, y + 4);
        ctx.closePath();
        ctx.fill();
      } else if (metric.symbol === '+') {
        ctx.lineWidth = 2;
        ctx.strokeStyle = r.K === bestK ? '#d62728' : '#333';
        ctx.beginPath();
        ctx.moveTo(x - 4, y);
        ctx.lineTo(x + 4, y);
        ctx.moveTo(x, y - 4);
        ctx.lineTo(x, y + 4);
        ctx.stroke();
      }
    }
  });
}

// ===== TOPIC DIAGNOSTICS =====

// Calculate topic diagnostics (similar to MALLET)
function calculateTopicDiagnostics(result) {
  const { numTopics, topicWordDist, docTopicDist, vocabulary, preprocessed, topWords } = result;
  const K = numTopics;
  const V = vocabulary.length;
  const D = docTopicDist.length;
  const dtMatrix = preprocessed.dtMatrix;
  
  const diagnostics = [];
  
  for (let k = 0; k < K; k++) {
    // Tokens: sum of word probabilities weighted by total count
    let tokens = 0;
    for (let d = 0; d < D; d++) {
      const docTotal = dtMatrix[d].reduce((a, b) => a + b, 0);
      tokens += docTopicDist[d][k] * docTotal;
    }
    
    // Entropy: how spread the topic is across documents
    let entropy = 0;
    for (let d = 0; d < D; d++) {
      const p = docTopicDist[d][k];
      if (p > 0) entropy -= p * Math.log2(p);
    }
    
    // Coherence: UMass coherence for this topic
    const topWordsIdx = topWords[k].slice(0, 10).map(w => vocabulary.indexOf(w.word));
    let coherence = 0;
    let pairCount = 0;
    
    // Build co-occurrence for top words
    for (let i = 0; i < topWordsIdx.length; i++) {
      for (let j = i + 1; j < topWordsIdx.length; j++) {
        const wi = topWordsIdx[i];
        const wj = topWordsIdx[j];
        if (wi < 0 || wj < 0) continue;
        
        let coCount = 0, wiCount = 0;
        for (let d = 0; d < D; d++) {
          if (dtMatrix[d][wi] > 0 && dtMatrix[d][wj] > 0) coCount++;
          if (dtMatrix[d][wi] > 0) wiCount++;
        }
        coherence += Math.log((coCount + 1) / Math.max(wiCount, 1));
        pairCount++;
      }
    }
    coherence = pairCount > 0 ? coherence / pairCount : 0;
    
    // Uniform Distance: KL divergence from uniform distribution
    let uniformDist = 0;
    const uniformProb = 1 / V;
    for (let w = 0; w < V; w++) {
      const p = topicWordDist[k][w];
      if (p > 0) {
        uniformDist += p * Math.log(p / uniformProb);
      }
    }
    
    // Corpus Distance: KL divergence from corpus distribution
    const corpusDist_arr = Array(V).fill(0);
    let corpusTotal = 0;
    for (let d = 0; d < D; d++) {
      for (let w = 0; w < V; w++) {
        corpusDist_arr[w] += dtMatrix[d][w];
        corpusTotal += dtMatrix[d][w];
      }
    }
    let corpusDist = 0;
    for (let w = 0; w < V; w++) {
      const p = topicWordDist[k][w];
      const q = corpusDist_arr[w] / Math.max(corpusTotal, 1);
      if (p > 0 && q > 0) {
        corpusDist += p * Math.log(p / q);
      }
    }
    
    // Exclusivity: how exclusive top words are to this topic
    let exclusivity = 0;
    const topN = Math.min(10, topWords[k].length);
    for (let i = 0; i < topN; i++) {
      const wIdx = vocabulary.indexOf(topWords[k][i].word);
      if (wIdx < 0) continue;
      
      const probInTopic = topicWordDist[k][wIdx];
      let totalProb = 0;
      for (let kk = 0; kk < K; kk++) {
        totalProb += topicWordDist[kk][wIdx];
      }
      exclusivity += probInTopic / Math.max(totalProb, 1e-10);
    }
    exclusivity /= topN;
    
    // Rank 1 Documents: proportion where this topic is dominant
    let rank1Docs = 0;
    for (let d = 0; d < D; d++) {
      const maxTopic = docTopicDist[d].indexOf(Math.max(...docTopicDist[d]));
      if (maxTopic === k) rank1Docs++;
    }
    rank1Docs /= D;
    
    // Get top words for display
    const topWordsStr = topWords[k].slice(0, 5).map(w => w.word).join(', ');
    
    diagnostics.push({
      topic: k,
      label: getTopicLabel(k),
      tokens: Math.round(tokens),
      entropy: entropy,
      coherence: coherence,
      uniformDist: uniformDist,
      corpusDist: corpusDist,
      exclusivity: exclusivity,
      rank1Docs: rank1Docs,
      alpha: result.alphaValues[k],
      topWords: topWordsStr
    });
  }
  
  return diagnostics;
}

// Render topic diagnostics table
function renderTopicDiagnosticsTable(diagnostics) {
  const tableDiv = document.getElementById('topicDiagTable');
  if (!diagnostics || diagnostics.length === 0) {
    tableDiv.innerHTML = '<p style="padding:0.5rem; color:#666;">No diagnostics available.</p>';
    return;
  }
  
  // Topic colors (same as scatter plot)
  const colors = ['#1f77b4', '#ff7f0e', '#2ca02c', '#d62728', '#9467bd', 
                  '#8c564b', '#e377c2', '#7f7f7f', '#bcbd22', '#17becf'];
  
  // Sort if needed
  let sortedData = [...diagnostics];
  if (topicDiagSortCol !== null) {
    sortedData.sort((a, b) => {
      const valA = a[topicDiagSortCol];
      const valB = b[topicDiagSortCol];
      if (typeof valA === 'string') {
        return topicDiagSortDir === 'asc' ? valA.localeCompare(valB) : valB.localeCompare(valA);
      }
      return topicDiagSortDir === 'asc' ? valA - valB : valB - valA;
    });
  }
  
  const thStyle = 'padding:0.3rem 0.4rem; border:1px solid #ccc; background:#e8f4e8; color:#333; cursor:pointer; user-select:none; white-space:nowrap; font-size:0.8rem;';
  const tdStyle = 'padding:0.25rem 0.4rem; border:1px solid #ddd; white-space:nowrap; font-size:0.8rem; color:#333;';
  
  const sortIndicator = (col) => {
    if (topicDiagSortCol === col) {
      return topicDiagSortDir === 'asc' ? ' ▲' : ' ▼';
    }
    return '';
  };
  
  const cols = [
    { key: 'label', name: 'Topic' },
    { key: 'tokens', name: 'Tokens' },
    { key: 'entropy', name: 'Entropy' },
    { key: 'coherence', name: 'Coherence' },
    { key: 'exclusivity', name: 'Exclusivity' },
    { key: 'uniformDist', name: 'Uniform Dist.' },
    { key: 'corpusDist', name: 'Corpus Dist.' },
    { key: 'rank1Docs', name: 'Rank1 Docs' },
    { key: 'alpha', name: 'Alpha' },
    { key: 'topWords', name: 'Top Words' }
  ];
  
  // Create flex container for table and legend
  let html = '<div style="display:flex; gap:1rem;">';
  
  // Table container (takes most of the space)
  html += '<div style="flex:1; overflow-x:auto;">';
  html += '<table style="border-collapse:collapse; width:100%;">';
  html += '<thead><tr>';
  for (const col of cols) {
    html += `<th style="${thStyle}" onclick="sortTopicDiagTable('${col.key}')">${col.name}${sortIndicator(col.key)}</th>`;
  }
  html += '</tr></thead><tbody>';
  
  for (const row of sortedData) {
    const bg = row.topic % 2 === 0 ? '#fff' : '#f9f9f9';
    const topicColor = colors[row.topic % colors.length];
    html += `<tr style="background:${bg};">`;
    html += `<td style="${tdStyle} font-weight:bold;">`;
    html += `<span style="display:inline-block; width:12px; height:12px; background:${topicColor}; border-radius:2px; margin-right:0.4rem; vertical-align:middle;"></span>`;
    html += `${escapeHtml(row.label || 'Topic ' + (row.topic + 1))}</td>`;
    html += `<td style="${tdStyle} text-align:right;">${row.tokens || 0}</td>`;
    html += `<td style="${tdStyle} text-align:right;">${(row.entropy || 0).toFixed(3)}</td>`;
    html += `<td style="${tdStyle} text-align:right;">${(row.coherence || 0).toFixed(4)}</td>`;
    html += `<td style="${tdStyle} text-align:right;">${(row.exclusivity || 0).toFixed(4)}</td>`;
    html += `<td style="${tdStyle} text-align:right;">${(row.uniformDist || 0).toFixed(3)}</td>`;
    html += `<td style="${tdStyle} text-align:right;">${(row.corpusDist || 0).toFixed(3)}</td>`;
    html += `<td style="${tdStyle} text-align:right;">${((row.rank1Docs || 0) * 100).toFixed(1)}%</td>`;
    html += `<td style="${tdStyle} text-align:right;">${(row.alpha || 0).toFixed(4)}</td>`;
    // Top words column
    const topWords = row.topWords || '';
    html += `<td style="${tdStyle}" title="${escapeHtml(topWords)}">${escapeHtml(topWords)}</td>`;
    html += '</tr>';
  }
  html += '</tbody></table>';
  html += '</div>';
  
  // Color legend (fixed on the right side)
  html += '<div style="flex:0 0 80px; padding:0.3rem; background:#f9f9f9; border:1px solid #ddd; border-radius:4px;">';
  html += '<div style="font-size:0.75rem; font-weight:bold; margin-bottom:0.3rem; color:#555;">Colors</div>';
  for (let i = 0; i < diagnostics.length && i < colors.length; i++) {
    const topicNum = diagnostics[i].topic !== undefined ? diagnostics[i].topic + 1 : i + 1;
    html += `<div style="display:flex; align-items:center; margin-bottom:0.2rem;">`;
    html += `<span style="display:inline-block; width:14px; height:14px; background:${colors[i % colors.length]}; border-radius:2px; margin-right:0.3rem;"></span>`;
    html += `<span style="font-size:0.75rem;">T${topicNum}</span>`;
    html += `</div>`;
  }
  html += '</div>';
  
  html += '</div>'; // End flex container
  tableDiv.innerHTML = html;
}

function sortTopicDiagTable(col) {
  if (topicDiagSortCol === col) {
    topicDiagSortDir = topicDiagSortDir === 'asc' ? 'desc' : 'asc';
  } else {
    topicDiagSortCol = col;
    topicDiagSortDir = col === 'coherence' || col === 'exclusivity' ? 'desc' : 'asc';
  }
  if (topicModelResults && topicModelResults.diagnostics) {
    renderTopicDiagnosticsTable(topicModelResults.diagnostics);
  }
}

// Draw diagnostics scatter plot
function drawDiagnosticsScatter(ctx, result, width, height) {
  ctx.clearRect(0, 0, width, height);
  ctx.fillStyle = '#fff';
  ctx.fillRect(0, 0, width, height);
  
  if (!result.diagnostics || result.diagnostics.length === 0) {
    ctx.fillStyle = '#666';
    ctx.font = '14px sans-serif';
    ctx.textAlign = 'center';
    ctx.fillText('No diagnostics data available', width / 2, height / 2);
    return;
  }
  
  const xKey = document.getElementById('topicDiagX').value;
  const yKey = document.getElementById('topicDiagY').value;
  const sizeByTokens = document.getElementById('topicDiagSizeByTokens').checked;
  
  const data = result.diagnostics;
  const xVals = data.map(d => d[xKey]);
  const yVals = data.map(d => d[yKey]);
  const tokens = data.map(d => d.tokens);
  
  const padding = { top: 50, right: 120, bottom: 50, left: 70 };
  const plotW = width - padding.left - padding.right;
  const plotH = height - padding.top - padding.bottom;
  
  const xMin = Math.min(...xVals);
  const xMax = Math.max(...xVals);
  const yMin = Math.min(...yVals);
  const yMax = Math.max(...yVals);
  const xRange = xMax - xMin || 1;
  const yRange = yMax - yMin || 1;
  
  const maxTokens = Math.max(...tokens);
  
  // Title
  ctx.fillStyle = '#333';
  ctx.font = 'bold 13px sans-serif';
  ctx.textAlign = 'center';
  ctx.fillText(`Topic Diagnostics: ${xKey} vs ${yKey}`, width / 2, 22);
  
  // Axis labels
  ctx.font = '11px sans-serif';
  ctx.fillText(xKey.charAt(0).toUpperCase() + xKey.slice(1), width / 2, height - 10);
  
  ctx.save();
  ctx.translate(15, height / 2);
  ctx.rotate(-Math.PI / 2);
  ctx.fillText(yKey.charAt(0).toUpperCase() + yKey.slice(1), 0, 0);
  ctx.restore();
  
  // Grid
  ctx.strokeStyle = '#eee';
  ctx.lineWidth = 1;
  for (let i = 0; i <= 5; i++) {
    const y = padding.top + (plotH * i / 5);
    ctx.beginPath();
    ctx.moveTo(padding.left, y);
    ctx.lineTo(width - padding.right, y);
    ctx.stroke();
    
    const x = padding.left + (plotW * i / 5);
    ctx.beginPath();
    ctx.moveTo(x, padding.top);
    ctx.lineTo(x, height - padding.bottom);
    ctx.stroke();
  }
  
  // Axis ticks
  ctx.fillStyle = '#666';
  ctx.font = '9px sans-serif';
  ctx.textAlign = 'right';
  for (let i = 0; i <= 5; i++) {
    const y = padding.top + (plotH * (5 - i) / 5);
    const val = yMin + (yRange * i / 5);
    ctx.fillText(val.toFixed(2), padding.left - 5, y + 3);
  }
  
  ctx.textAlign = 'center';
  for (let i = 0; i <= 5; i++) {
    const x = padding.left + (plotW * i / 5);
    const val = xMin + (xRange * i / 5);
    ctx.fillText(val.toFixed(2), x, height - padding.bottom + 15);
  }
  
  // Draw points
  const colors = ['#1f77b4', '#ff7f0e', '#2ca02c', '#d62728', '#9467bd', 
                  '#8c564b', '#e377c2', '#7f7f7f', '#bcbd22', '#17becf'];
  
  for (let i = 0; i < data.length; i++) {
    const d = data[i];
    const x = padding.left + ((d[xKey] - xMin) / xRange) * plotW;
    const y = padding.top + plotH - ((d[yKey] - yMin) / yRange) * plotH;
    const radius = sizeByTokens ? Math.max(5, Math.sqrt(d.tokens / maxTokens) * 25) : 8;
    
    ctx.beginPath();
    ctx.arc(x, y, radius, 0, Math.PI * 2);
    ctx.fillStyle = colors[i % colors.length];
    ctx.globalAlpha = 0.7;
    ctx.fill();
    ctx.globalAlpha = 1;
    ctx.strokeStyle = '#fff';
    ctx.lineWidth = 1.5;
    ctx.stroke();
    
    // Label
    ctx.fillStyle = '#333';
    ctx.font = 'bold 9px sans-serif';
    ctx.textAlign = 'center';
    ctx.fillText((i + 1).toString(), x, y + 3);
  }
  
  // Legend - positioned outside the plot area on the right
  ctx.font = '9px sans-serif';
  ctx.textAlign = 'left';
  const legendX = width - padding.right + 10;
  const legendY = padding.top;
  for (let i = 0; i < Math.min(data.length, 10); i++) {
    ctx.fillStyle = colors[i % colors.length];
    ctx.fillRect(legendX, legendY + i * 14, 10, 10);
    ctx.fillStyle = '#333';
    const rawLabel = data[i].label || `Topic ${i + 1}`;
    const label = rawLabel.length > 10 ? rawLabel.substring(0, 8) + '..' : rawLabel;
    ctx.fillText(label, legendX + 14, legendY + i * 14 + 9);
  }
}

// Export diagnostics to Excel
function exportDiagnosticsToCSV() {
  if (!topicModelResults) {
    alert('No topic model results available.');
    return;
  }
  
  const result = topicModelResults;
  
  // Handle per-folder mode
  if (result.analysisMode === 'perFolder' && result.folderResults) {
    const sheets = [];
    const successFolders = result.folderResults.filter(fr => !fr.error && fr.topWords && fr.topWords.length > 0);
    
    // Create combined diagnostics from buildCombinedPerFolderResult
    if (successFolders.length > 0) {
      const combinedResult = buildCombinedPerFolderResult(successFolders, result);
      if (combinedResult.diagnostics && combinedResult.diagnostics.length > 0) {
        const combinedData = [['Topic', 'Tokens', 'Entropy', 'Coherence', 'Exclusivity', 'UniformDist', 'CorpusDist', 'Rank1Docs', 'Alpha', 'TopWords']];
        for (const d of combinedResult.diagnostics) {
          combinedData.push([
            `Topic ${d.topic + 1}`,
            d.tokens || 0,
            d.entropy || 0,
            d.coherence || 0,
            d.exclusivity || 0,
            d.uniformDist || 0,
            d.corpusDist || 0,
            d.rank1Docs || 0,
            d.alpha || 0,
            d.topWords || ''
          ]);
        }
        sheets.push({ name: 'All Folders Combined', data: combinedData });
      }
    }
    
    // Individual folder diagnostics
    for (const fr of successFolders) {
      const K = fr.topWords?.length || 0;
      if (K === 0) continue;
      
      const data = [['Topic', 'DocCount', 'VocabSize', 'TopWords']];
      for (let k = 0; k < K; k++) {
        const words = (fr.topWords[k] || []).slice(0, 10).map(w => `${w.word}(${(w.prob * 100).toFixed(1)}%)`).join(', ');
        data.push([`Topic ${k + 1}`, fr.docCount || 0, fr.vocabSize || 0, words]);
      }
      sheets.push({ name: fr.folder, data: data });
    }
    
    if (sheets.length > 0) {
      downloadExcelMultiSheet(sheets, `diagnostics_perFolder_${result.method}.xls`);
    } else {
      alert('No diagnostics data available for export.');
    }
    return;
  }
  
  // Global mode
  if (!result.diagnostics || result.diagnostics.length === 0) {
    alert('No diagnostics data available. Compute topics first.');
    return;
  }
  
  const diag = result.diagnostics;
  const data = [['Topic', 'Label', 'Tokens', 'Entropy', 'Coherence', 'Exclusivity', 'UniformDist', 'CorpusDist', 'Rank1Docs', 'Alpha']];
  
  for (const d of diag) {
    data.push([
      d.topic + 1,
      d.label || '',
      d.tokens || 0,
      d.entropy || 0,
      d.coherence || 0,
      d.exclusivity || 0,
      d.uniformDist || 0,
      d.corpusDist || 0,
      d.rank1Docs || 0,
      d.alpha || 0
    ]);
  }
  
  downloadExcel(data, 'topic_diagnostics.xls', 'Diagnostics');
}

// ===== RESIZABLE COLUMNS FOR TOPIC TABLE =====

// Draw top words bar chart
function drawTopicTopWords(ctx, result, width, height, topWordsN = 10) {
  ctx.clearRect(0, 0, width, height);
  ctx.fillStyle = '#fff';
  ctx.fillRect(0, 0, width, height);
  
  const K = result.numTopics;
  const padding = { top: 50, right: 20, bottom: 30, left: 20 };
  const plotWidth = width - padding.left - padding.right;
  const plotHeight = height - padding.top - padding.bottom;
  
  const topicWidth = plotWidth / K;
  const barHeight = Math.min(18, (plotHeight - 20) / topWordsN);
  
  const colors = ['#1f77b4', '#ff7f0e', '#2ca02c', '#d62728', '#9467bd', 
                  '#8c564b', '#e377c2', '#7f7f7f', '#bcbd22', '#17becf'];
  
  ctx.fillStyle = '#333';
  ctx.font = 'bold 14px sans-serif';
  ctx.textAlign = 'center';
  ctx.fillText(`Topic Top Words (${result.method})`, width / 2, 20);
  
  for (let k = 0; k < K; k++) {
    const topicX = padding.left + k * topicWidth;
    const maxProb = result.topWords[k][0]?.prob || 1;
    
    ctx.fillStyle = colors[k % colors.length];
    ctx.font = 'bold 10px sans-serif';
    ctx.textAlign = 'center';
    const label = getTopicLabel(k);
    ctx.fillText(label.length > 15 ? label.substring(0, 13) + '..' : label, topicX + topicWidth / 2, padding.top - 5);
    
    for (let i = 0; i < Math.min(topWordsN, result.topWords[k].length); i++) {
      const word = result.topWords[k][i];
      const barWidth = (word.prob / maxProb) * (topicWidth - 15);
      const y = padding.top + i * barHeight;
      
      ctx.fillStyle = colors[k % colors.length];
      ctx.globalAlpha = 0.7;
      ctx.fillRect(topicX + 5, y, barWidth, barHeight - 2);
      ctx.globalAlpha = 1;
      
      ctx.fillStyle = '#333';
      ctx.font = '9px sans-serif';
      ctx.textAlign = 'left';
      const wordLabel = word.word.length > 10 ? word.word.substring(0, 8) + '..' : word.word;
      ctx.fillText(wordLabel, topicX + 8, y + barHeight / 2 + 3);
    }
  }
}

// Draw word cloud style visualization
function drawTopicWordCloud(ctx, result, width, height, topWordsN = 15) {
  ctx.clearRect(0, 0, width, height);
  ctx.fillStyle = '#fff';
  ctx.fillRect(0, 0, width, height);
  
  const K = result.numTopics;
  const cols = Math.ceil(Math.sqrt(K));
  const rows = Math.ceil(K / cols);
  const cellWidth = width / cols;
  const cellHeight = height / rows;
  
  const colors = ['#1f77b4', '#ff7f0e', '#2ca02c', '#d62728', '#9467bd', 
                  '#8c564b', '#e377c2', '#7f7f7f', '#bcbd22', '#17becf'];
  
  for (let k = 0; k < K; k++) {
    const col = k % cols;
    const row = Math.floor(k / cols);
    const cx = col * cellWidth + cellWidth / 2;
    const cy = row * cellHeight + 25;
    
    // Topic label
    ctx.fillStyle = colors[k % colors.length];
    ctx.font = 'bold 11px sans-serif';
    ctx.textAlign = 'center';
    ctx.fillText(getTopicLabel(k), cx, cy);
    
    // Draw words in cloud-like arrangement
    const maxProb = result.topWords[k][0]?.prob || 1;
    const words = result.topWords[k].slice(0, topWordsN);
    
    let y = cy + 20;
    let lineWords = [];
    let lineWidth = 0;
    const maxLineWidth = cellWidth - 20;
    
    for (const wordObj of words) {
      const fontSize = Math.max(8, Math.min(16, 8 + (wordObj.prob / maxProb) * 10));
      ctx.font = `${fontSize}px sans-serif`;
      const wordWidth = ctx.measureText(wordObj.word).width + 5;
      
      if (lineWidth + wordWidth > maxLineWidth && lineWords.length > 0) {
        // Draw line
        let x = cx - lineWidth / 2;
        for (const lw of lineWords) {
          ctx.font = `${lw.fontSize}px sans-serif`;
          ctx.fillStyle = colors[k % colors.length];
          ctx.globalAlpha = 0.4 + (lw.prob / maxProb) * 0.6;
          ctx.textAlign = 'left';
          ctx.fillText(lw.word, x, y);
          x += lw.width;
        }
        ctx.globalAlpha = 1;
        y += 16;
        lineWords = [];
        lineWidth = 0;
      }
      
      lineWords.push({ word: wordObj.word, prob: wordObj.prob, fontSize, width: wordWidth });
      lineWidth += wordWidth;
    }
    
    // Draw remaining words
    if (lineWords.length > 0) {
      let x = cx - lineWidth / 2;
      for (const lw of lineWords) {
        ctx.font = `${lw.fontSize}px sans-serif`;
        ctx.fillStyle = colors[k % colors.length];
        ctx.globalAlpha = 0.4 + (lw.prob / maxProb) * 0.6;
        ctx.textAlign = 'left';
        ctx.fillText(lw.word, x, y);
        x += lw.width;
      }
      ctx.globalAlpha = 1;
    }
  }
}

// Draw topic-word heatmap
function drawTopicHeatmap(ctx, result, width, height, topWordsN = 10) {
  ctx.clearRect(0, 0, width, height);
  ctx.fillStyle = '#fff';
  ctx.fillRect(0, 0, width, height);
  
  const K = result.numTopics;
  const padding = { top: 60, right: 40, bottom: 30, left: 100 };
  const plotWidth = width - padding.left - padding.right;
  const plotHeight = height - padding.top - padding.bottom;
  
  // Collect unique words from topWords
  const allTopWords = new Set();
  for (let k = 0; k < K; k++) {
    if (result.topWords && result.topWords[k]) {
      for (let i = 0; i < topWordsN; i++) {
        if (result.topWords[k][i]) {
          allTopWords.add(result.topWords[k][i].word);
        }
      }
    }
  }
  const wordList = [...allTopWords].slice(0, 30);
  const V = wordList.length;
  
  if (V === 0) {
    ctx.fillStyle = '#666';
    ctx.font = '14px sans-serif';
    ctx.textAlign = 'center';
    ctx.fillText('No words available for heatmap', width / 2, height / 2);
    return;
  }
  
  // Ensure minimum cell size for visibility
  const cellWidth = Math.max(30, plotWidth / K);
  const cellHeight = Math.max(14, Math.min(18, plotHeight / V));
  
  ctx.fillStyle = '#333';
  ctx.font = 'bold 14px sans-serif';
  ctx.textAlign = 'center';
  ctx.fillText(`Topic-Word Heatmap (${result.method})`, width / 2, 20);
  
  // Draw topic labels at top
  ctx.font = '10px sans-serif';
  for (let k = 0; k < K; k++) {
    ctx.fillStyle = '#333';
    ctx.textAlign = 'center';
    ctx.fillText(`T${k + 1}`, padding.left + k * cellWidth + cellWidth / 2, padding.top - 5);
  }
  
  // Build word to index mapping from vocabulary
  const wordToIdx = {};
  if (result.vocabulary) {
    result.vocabulary.forEach((w, i) => wordToIdx[w] = i);
  }
  
  // Build probability lookup from topWords if topicWordDist is not available
  const wordProbLookup = {};
  if (!result.topicWordDist || result.topicWordDist.length === 0) {
    // Build from topWords
    for (let k = 0; k < K; k++) {
      wordProbLookup[k] = {};
      if (result.topWords && result.topWords[k]) {
        for (const tw of result.topWords[k]) {
          wordProbLookup[k][tw.word] = tw.prob;
        }
      }
    }
  }
  
  // Draw words and heatmap cells
  for (let i = 0; i < V; i++) {
    const word = wordList[i];
    const y = padding.top + i * cellHeight;
    
    // Draw word label
    ctx.fillStyle = '#333';
    ctx.font = '9px sans-serif';
    ctx.textAlign = 'right';
    const label = word.length > 12 ? word.substring(0, 10) + '..' : word;
    ctx.fillText(label, padding.left - 5, y + cellHeight / 2 + 3);
    
    // Draw heatmap cells for each topic
    for (let k = 0; k < K; k++) {
      let prob = 0;
      
      if (result.topicWordDist && result.topicWordDist[k]) {
        const wordIdx = wordToIdx[word];
        if (wordIdx !== undefined) {
          prob = result.topicWordDist[k][wordIdx] || 0;
        }
      } else if (wordProbLookup[k]) {
        prob = wordProbLookup[k][word] || 0;
      }
      
      // Scale intensity - higher multiplier for better visibility
      const intensity = Math.min(1, prob * 80);
      
      ctx.fillStyle = `rgba(31, 119, 180, ${Math.max(0.05, intensity)})`;
      ctx.fillRect(padding.left + k * cellWidth, y, cellWidth - 1, cellHeight - 1);
    }
  }
}

// Draw document-topic distribution
function drawDocTopicDistribution(ctx, result, width, height) {
  ctx.clearRect(0, 0, width, height);
  ctx.fillStyle = '#fff';
  ctx.fillRect(0, 0, width, height);
  
  const K = result.numTopics;
  // Show all docs if less than 100, otherwise limit
  const maxDocs = result.isSingleFolderFileView ? Math.min(result.docs.length, 100) : Math.min(result.docs.length, 40);
  const D = maxDocs;
  const padding = { top: 50, right: 120, bottom: 40, left: 150 };
  const plotWidth = width - padding.left - padding.right;
  const plotHeight = height - padding.top - padding.bottom;
  
  const barHeight = Math.max(8, Math.min(12, plotHeight / D));
  
  const colors = ['#1f77b4', '#ff7f0e', '#2ca02c', '#d62728', '#9467bd', 
                  '#8c564b', '#e377c2', '#7f7f7f', '#bcbd22', '#17becf'];
  
  ctx.fillStyle = '#333';
  ctx.font = 'bold 14px sans-serif';
  ctx.textAlign = 'center';
  ctx.fillText(`Document-Topic Distribution (${result.method})`, width / 2, 20);
  
  for (let d = 0; d < D; d++) {
    const y = padding.top + d * barHeight;
    let x = padding.left;
    
    ctx.fillStyle = '#333';
    ctx.font = '8px sans-serif';
    ctx.textAlign = 'right';
    const docName = result.docs[d].name || `Doc ${d + 1}`;
    const label = docName.length > 20 ? docName.substring(0, 18) + '..' : docName;
    ctx.fillText(label, padding.left - 5, y + barHeight / 2 + 2);
    
    for (let k = 0; k < K; k++) {
      const prob = result.docTopicDist[d][k];
      const barWidth = prob * plotWidth;
      
      ctx.fillStyle = colors[k % colors.length];
      ctx.fillRect(x, y, barWidth, barHeight - 1);
      x += barWidth;
    }
  }
  
  const legendX = width - padding.right + 10;
  ctx.font = '10px sans-serif';
  for (let k = 0; k < Math.min(K, 15); k++) {
    const legendY = padding.top + k * 16;
    ctx.fillStyle = colors[k % colors.length];
    ctx.fillRect(legendX, legendY, 12, 12);
    ctx.fillStyle = '#333';
    ctx.textAlign = 'left';
    ctx.fillText(`T${k + 1}`, legendX + 16, legendY + 10);
  }
}

// Draw folder-topic heatmap
function drawFolderTopicHeatmap(ctx, result, width, height) {
  ctx.clearRect(0, 0, width, height);
  ctx.fillStyle = '#fff';
  ctx.fillRect(0, 0, width, height);
  
  const K = result.numTopics;
  const F = result.folderTopicDist.length;
  const padding = { top: 80, right: 80, bottom: 40, left: 120 };
  const plotWidth = width - padding.left - padding.right;
  const plotHeight = height - padding.top - padding.bottom;
  
  const cellWidth = Math.min(40, plotWidth / F);
  const cellHeight = Math.min(25, plotHeight / K);
  
  ctx.fillStyle = '#333';
  ctx.font = 'bold 14px sans-serif';
  ctx.textAlign = 'center';
  // Use different title for file-level view within a single folder
  const titlePrefix = result.isSingleFolderFileView ? 'File-Topic' : 'Folder-Topic';
  ctx.fillText(`${titlePrefix} Heatmap (${result.method})`, width / 2, 20);
  
  // Folder labels (rotated)
  ctx.save();
  ctx.font = '9px sans-serif';
  for (let f = 0; f < F; f++) {
    const x = padding.left + f * cellWidth + cellWidth / 2;
    ctx.save();
    ctx.translate(x, padding.top - 5);
    ctx.rotate(-Math.PI / 4);
    ctx.fillStyle = '#333';
    ctx.textAlign = 'right';
    const folderName = result.folderTopicDist[f].folder;
    const label = folderName.length > 15 ? folderName.substring(0, 13) + '..' : folderName;
    ctx.fillText(label, 0, 0);
    ctx.restore();
  }
  ctx.restore();
  
  // Topic labels
  ctx.font = '9px sans-serif';
  for (let k = 0; k < K; k++) {
    ctx.fillStyle = '#333';
    ctx.textAlign = 'right';
    const y = padding.top + k * cellHeight + cellHeight / 2 + 3;
    ctx.fillText(getTopicLabel(k), padding.left - 5, y);
  }
  
  // Find max value for color scaling
  let maxVal = 0;
  for (const fd of result.folderTopicDist) {
    for (const v of fd.dist) {
      if (v > maxVal) maxVal = v;
    }
  }
  
  // Draw heatmap cells
  for (let f = 0; f < F; f++) {
    for (let k = 0; k < K; k++) {
      const val = result.folderTopicDist[f].dist[k];
      const intensity = val / maxVal;
      
      const x = padding.left + f * cellWidth;
      const y = padding.top + k * cellHeight;
      
      // Blue color scale
      ctx.fillStyle = `rgba(31, 119, 180, ${intensity})`;
      ctx.fillRect(x, y, cellWidth - 1, cellHeight - 1);
      
      // Value text
      if (cellWidth > 25 && cellHeight > 15) {
        ctx.fillStyle = intensity > 0.5 ? '#fff' : '#333';
        ctx.font = '8px sans-serif';
        ctx.textAlign = 'center';
        ctx.fillText((val * 100).toFixed(0), x + cellWidth / 2, y + cellHeight / 2 + 3);
      }
    }
  }
  
  // Color legend
  const legendX = padding.left + F * cellWidth + 20;
  ctx.font = '9px sans-serif';
  ctx.fillStyle = '#333';
  ctx.textAlign = 'left';
  ctx.fillText('Topic %:', legendX, padding.top);
  
  const gradientHeight = 80;
  for (let i = 0; i <= gradientHeight; i++) {
    const intensity = 1 - i / gradientHeight;
    ctx.fillStyle = `rgba(31, 119, 180, ${intensity})`;
    ctx.fillRect(legendX, padding.top + 10 + i, 15, 1);
  }
  ctx.fillStyle = '#333';
  ctx.fillText((maxVal * 100).toFixed(0) + '%', legendX + 20, padding.top + 15);
  ctx.fillText('0%', legendX + 20, padding.top + 10 + gradientHeight + 5);
}

// Draw box plot (folder × topic)
function drawTopicBoxPlot(ctx, result, width, height) {
  ctx.clearRect(0, 0, width, height);
  ctx.fillStyle = '#fff';
  ctx.fillRect(0, 0, width, height);
  
  const K = result.numTopics;
  const padding = { top: 60, right: 30, bottom: 80, left: 60 };
  const plotWidth = width - padding.left - padding.right;
  const plotHeight = height - padding.top - padding.bottom;
  
  const colors = ['#1f77b4', '#ff7f0e', '#2ca02c', '#d62728', '#9467bd', 
                  '#8c564b', '#e377c2', '#7f7f7f', '#bcbd22', '#17becf'];
  
  ctx.fillStyle = '#333';
  ctx.font = 'bold 14px sans-serif';
  ctx.textAlign = 'center';
  // Use different title for file-level view within a single folder
  const titleUnit = result.isSingleFolderFileView ? 'File' : 'Folder';
  ctx.fillText(`Topic Distribution by ${titleUnit} (Box Plot)`, width / 2, 20);
  
  // For single folder file view, use documents directly instead of grouping by folder
  let groupData = {};
  let groups = [];
  
  if (result.isSingleFolderFileView) {
    // Use each document as a separate group (show individual file topic distributions)
    for (let d = 0; d < result.docs.length; d++) {
      const docName = result.docs[d].name || `Doc ${d + 1}`;
      groupData[docName] = [result.docTopicDist[d]];
    }
    groups = Object.keys(groupData);
  } else {
    // Original behavior: Group data by folder
    for (let d = 0; d < result.docs.length; d++) {
      const folder = result.docs[d].folder;
      if (!groupData[folder]) {
        groupData[folder] = [];
      }
      groupData[folder].push(result.docTopicDist[d]);
    }
    groups = Object.keys(groupData).sort();
  }
  
  const G = groups.length;
  
  if (G === 0) {
    ctx.fillStyle = '#666';
    ctx.font = '14px sans-serif';
    ctx.textAlign = 'center';
    ctx.fillText('No data available for box plot', width / 2, height / 2);
    return;
  }
  
  const groupWidth = plotWidth / G;
  const boxWidth = Math.min(15, (groupWidth - 10) / K);
  
  // Y-axis (0 to max)
  let maxVal = 0;
  for (const dists of Object.values(groupData)) {
    for (const dist of dists) {
      if (!dist) continue;
      for (const v of dist) {
        if (v > maxVal) maxVal = v;
      }
    }
  }
  maxVal = Math.ceil(maxVal * 10) / 10;
  if (maxVal === 0) maxVal = 1;
  
  // Draw Y-axis
  ctx.strokeStyle = '#333';
  ctx.lineWidth = 1;
  ctx.beginPath();
  ctx.moveTo(padding.left, padding.top);
  ctx.lineTo(padding.left, padding.top + plotHeight);
  ctx.stroke();
  
  ctx.font = '9px sans-serif';
  ctx.textAlign = 'right';
  for (let i = 0; i <= 5; i++) {
    const y = padding.top + plotHeight - (i / 5) * plotHeight;
    const val = (i / 5) * maxVal;
    ctx.fillStyle = '#333';
    ctx.fillText((val * 100).toFixed(0) + '%', padding.left - 5, y + 3);
    
    ctx.strokeStyle = '#eee';
    ctx.beginPath();
    ctx.moveTo(padding.left, y);
    ctx.lineTo(padding.left + plotWidth, y);
    ctx.stroke();
  }
  
  // Draw box plots for each group (folder or file) and topic
  for (let g = 0; g < G; g++) {
    const group = groups[g];
    const dists = groupData[group];
    const groupX = padding.left + g * groupWidth + groupWidth / 2;
    
    // Group label
    ctx.save();
    ctx.translate(groupX, padding.top + plotHeight + 10);
    ctx.rotate(-Math.PI / 4);
    ctx.fillStyle = '#333';
    ctx.font = '9px sans-serif';
    ctx.textAlign = 'right';
    const labelMaxLen = result.isSingleFolderFileView ? 15 : 12;
    const groupLabel = group.length > labelMaxLen ? group.substring(0, labelMaxLen - 2) + '..' : group;
    ctx.fillText(groupLabel, 0, 0);
    ctx.restore();
    
    // For single file view with only one doc per group, draw bars instead of box plots
    if (result.isSingleFolderFileView && dists.length === 1) {
      // Draw simple bars for each topic
      const dist = dists[0];
      if (!dist) continue;
      
      for (let k = 0; k < K; k++) {
        const val = dist[k] || 0;
        const boxX = groupX - (K * boxWidth) / 2 + k * boxWidth;
        const toY = v => padding.top + plotHeight - (v / maxVal) * plotHeight;
        
        // Draw bar
        ctx.fillStyle = colors[k % colors.length];
        ctx.globalAlpha = 0.7;
        const barHeight = Math.max(1, toY(0) - toY(val));
        ctx.fillRect(boxX, toY(val), boxWidth - 1, barHeight);
        ctx.globalAlpha = 1;
        
        // Border
        ctx.strokeStyle = '#333';
        ctx.lineWidth = 0.5;
        ctx.strokeRect(boxX, toY(val), boxWidth - 1, barHeight);
      }
    } else {
      // Draw box for each topic (original box plot behavior)
      for (let k = 0; k < K; k++) {
        const values = dists.map(d => d?.[k] || 0).sort((a, b) => a - b);
        if (values.length === 0) continue;
        
        const n = values.length;
        const q1 = values[Math.floor(n * 0.25)];
        const median = values[Math.floor(n * 0.5)];
        const q3 = values[Math.floor(n * 0.75)];
        const iqr = q3 - q1;
        const whiskerLow = Math.max(values[0], q1 - 1.5 * iqr);
        const whiskerHigh = Math.min(values[n - 1], q3 + 1.5 * iqr);
        
        const boxX = groupX - (K * boxWidth) / 2 + k * boxWidth;
        
        const toY = v => padding.top + plotHeight - (v / maxVal) * plotHeight;
        
        ctx.fillStyle = colors[k % colors.length];
        ctx.globalAlpha = 0.7;
        ctx.fillRect(boxX, toY(q3), boxWidth - 1, toY(q1) - toY(q3));
        ctx.globalAlpha = 1;
        
        // Median line
        ctx.strokeStyle = '#333';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(boxX, toY(median));
        ctx.lineTo(boxX + boxWidth - 1, toY(median));
        ctx.stroke();
        
        // Whiskers
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.moveTo(boxX + boxWidth / 2, toY(q3));
        ctx.lineTo(boxX + boxWidth / 2, toY(whiskerHigh));
        ctx.moveTo(boxX + boxWidth / 2, toY(q1));
        ctx.lineTo(boxX + boxWidth / 2, toY(whiskerLow));
        ctx.stroke();
      }
    }
  }
  
  // Legend
  ctx.font = '9px sans-serif';
  const legendY = 40;
  for (let k = 0; k < Math.min(K, 10); k++) {
    const legendX = padding.left + k * 70;
    ctx.fillStyle = colors[k % colors.length];
    ctx.fillRect(legendX, legendY, 10, 10);
    ctx.fillStyle = '#333';
    ctx.textAlign = 'left';
    ctx.fillText(`T${k + 1}`, legendX + 14, legendY + 9);
  }
}

// Draw topic correlation matrix
function drawTopicCorrelation(ctx, result, width, height) {
  ctx.clearRect(0, 0, width, height);
  ctx.fillStyle = '#fff';
  ctx.fillRect(0, 0, width, height);
  
  const K = result.numTopics;
  const padding = { top: 60, right: 80, bottom: 40, left: 60 };
  const plotSize = Math.min(width - padding.left - padding.right, height - padding.top - padding.bottom);
  const cellSize = plotSize / K;
  
  const correlations = [];
  for (let i = 0; i < K; i++) {
    correlations[i] = [];
    for (let j = 0; j < K; j++) {
      if (i === j) {
        correlations[i][j] = 1;
      } else {
        const ti = result.docTopicDist.map(d => d[i]);
        const tj = result.docTopicDist.map(d => d[j]);
        const meanI = ti.reduce((s, v) => s + v, 0) / ti.length;
        const meanJ = tj.reduce((s, v) => s + v, 0) / tj.length;
        let num = 0, denI = 0, denJ = 0;
        for (let d = 0; d < ti.length; d++) {
          const di = ti[d] - meanI;
          const dj = tj[d] - meanJ;
          num += di * dj;
          denI += di * di;
          denJ += dj * dj;
        }
        correlations[i][j] = (denI > 0 && denJ > 0) ? num / Math.sqrt(denI * denJ) : 0;
      }
    }
  }
  
  ctx.fillStyle = '#333';
  ctx.font = 'bold 14px sans-serif';
  ctx.textAlign = 'center';
  ctx.fillText(`Topic Correlation Matrix (${result.method})`, width / 2, 20);
  
  for (let i = 0; i < K; i++) {
    for (let j = 0; j < K; j++) {
      const x = padding.left + j * cellSize;
      const y = padding.top + i * cellSize;
      const corr = correlations[i][j];
      
      if (corr >= 0) {
        ctx.fillStyle = `rgba(31, 119, 180, ${Math.abs(corr)})`;
      } else {
        ctx.fillStyle = `rgba(214, 39, 40, ${Math.abs(corr)})`;
      }
      ctx.fillRect(x, y, cellSize - 1, cellSize - 1);
      
      ctx.fillStyle = Math.abs(corr) > 0.5 ? '#fff' : '#333';
      ctx.font = '9px sans-serif';
      ctx.textAlign = 'center';
      ctx.fillText(corr.toFixed(2), x + cellSize / 2, y + cellSize / 2 + 3);
    }
  }
  
  ctx.fillStyle = '#333';
  ctx.font = '10px sans-serif';
  for (let k = 0; k < K; k++) {
    ctx.textAlign = 'center';
    ctx.fillText(`T${k + 1}`, padding.left + k * cellSize + cellSize / 2, padding.top - 5);
    ctx.textAlign = 'right';
    ctx.fillText(`T${k + 1}`, padding.left - 5, padding.top + k * cellSize + cellSize / 2 + 3);
  }
  
  const legendX = padding.left + plotSize + 20;
  ctx.font = '9px sans-serif';
  ctx.textAlign = 'left';
  ctx.fillText('Correlation:', legendX, padding.top);
  
  const gradientHeight = 100;
  for (let i = 0; i <= gradientHeight; i++) {
    const val = 1 - (i / gradientHeight) * 2;
    if (val >= 0) {
      ctx.fillStyle = `rgba(31, 119, 180, ${val})`;
    } else {
      ctx.fillStyle = `rgba(214, 39, 40, ${-val})`;
    }
    ctx.fillRect(legendX, padding.top + 15 + i, 15, 1);
  }
  ctx.fillStyle = '#333';
  ctx.fillText('1.0', legendX + 20, padding.top + 20);
  ctx.fillText('0.0', legendX + 20, padding.top + 15 + gradientHeight / 2 + 5);
  ctx.fillText('-1.0', legendX + 20, padding.top + 15 + gradientHeight + 5);
}

// Draw Alpha values table
// Export topics to Excel
function exportTopicsToCSV() {
  if (!topicModelResults) return;
  
  const result = topicModelResults;
  const topN = result.topWordsN || 10;
  const vizType = document.getElementById('topicVizType')?.value || 'topwords';
  
  // Check if per-folder mode
  if (result.analysisMode === 'perFolder' && result.folderResults) {
    // Always export all folders regardless of current selection
    const sheets = [];
    const successFolders = result.folderResults.filter(fr => !fr.error && fr.topWords && fr.topWords.length > 0);
    
    // Add combined sheet first
    if (successFolders.length > 0) {
      const combinedResult = buildCombinedPerFolderResult(successFolders, result);
      const K = combinedResult.numTopics;
      const combinedData = buildTopicExportData(combinedResult.topWords, K, topN, vizType);
      sheets.push({ name: 'All Folders Combined', data: combinedData });
    }
    
    // Add each folder as separate sheet
    for (const fr of result.folderResults) {
      if (fr.error || !fr.topWords || fr.topWords.length === 0) continue;
      
      const K = fr.topWords.length;
      const data = buildTopicExportData(fr.topWords, K, topN, vizType);
      sheets.push({ name: fr.folder, data: data });
    }
    
    if (sheets.length > 0) {
      downloadExcelMultiSheet(sheets, `topics_perFolder_${result.method}.xls`);
    } else {
      alert('No folder data to export.');
    }
    return;
  }
  
  // Global mode
  const K = result.numTopics;
  const data = buildTopicExportData(result.topWords, K, topN, vizType);
  downloadExcel(data, `topics_${result.method.replace(/\s+/g, '_')}.xls`, 'Topics');
}

// Build topic export data based on visualization type
function buildTopicExportData(topWords, K, topN, vizType) {
  const data = [];
  
  if (vizType === 'simpleTable') {
    // Simple format: Topic | Keywords (comma separated)
    data.push(['Topic', 'Keywords']);
    for (let k = 0; k < K; k++) {
      const label = topicLabels[k] ? `T${k + 1}_${topicLabels[k]}` : `Topic ${k + 1}`;
      const words = (topWords[k] || []).slice(0, topN).map(w => w.word).join(', ');
      data.push([label, words]);
    }
  } else if (vizType === 'detailTable') {
    // Detail format: Topic columns with word and probability in separate columns
    // Header row: Topic 1 Word, Topic 1 Prob, Topic 2 Word, Topic 2 Prob, ...
    const header = [];
    for (let k = 0; k < K; k++) {
      const label = topicLabels[k] ? `T${k + 1}_${topicLabels[k]}` : `Topic ${k + 1}`;
      header.push(`${label} Word`);
      header.push(`${label} Prob`);
    }
    data.push(header);
    
    // Data rows
    for (let i = 0; i < topN; i++) {
      const row = [];
      for (let k = 0; k < K; k++) {
        const word = topWords[k]?.[i];
        if (word) {
          row.push(word.word);
          row.push(word.prob);
        } else {
          row.push('');
          row.push('');
        }
      }
      data.push(row);
    }
  } else {
    // Default format: Rank | Topic 1 | Topic 2 | ... (word with probability)
    const header = ['Rank'];
    for (let k = 0; k < K; k++) {
      const label = topicLabels[k] ? `T${k + 1}_${topicLabels[k]}` : `Topic ${k + 1}`;
      header.push(label);
    }
    data.push(header);
    
    for (let i = 0; i < topN; i++) {
      const row = [i + 1];
      for (let k = 0; k < K; k++) {
        const word = topWords[k]?.[i];
        if (word) {
          row.push(`${word.word} (${(word.prob * 100).toFixed(1)}%)`);
        } else {
          row.push('');
        }
      }
      data.push(row);
    }
  }
  
  return data;
}

// Export document-topic distribution to Excel
function exportDocTopicToCSV() {
  if (!topicModelResults) {
    alert('No topic model results available.');
    return;
  }
  
  const result = topicModelResults;
  
  // Handle per-folder mode
  if (result.analysisMode === 'perFolder' && result.folderResults) {
    const sheets = [];
    
    for (const fr of result.folderResults) {
      if (fr.error || !fr.docs || !fr.docTopicDist) continue;
      
      const K = fr.numTopics || fr.topWords?.length || 0;
      if (K === 0) continue;
      
      const header = ['Document', 'Folder'];
      for (let k = 0; k < K; k++) {
        header.push(`Topic_${k + 1}`);
      }
      header.push('Dominant_Topic');
      
      const data = [header];
      
      for (let d = 0; d < fr.docs.length; d++) {
        const doc = fr.docs[d];
        const row = [doc.name || `Doc_${d + 1}`, doc.folder || fr.folder];
        
        let maxProb = 0;
        let dominantTopic = 1;
        for (let k = 0; k < K; k++) {
          const prob = fr.docTopicDist[d]?.[k] || 0;
          row.push(prob);
          if (prob > maxProb) {
            maxProb = prob;
            dominantTopic = k + 1;
          }
        }
        row.push(dominantTopic);
        data.push(row);
      }
      
      sheets.push({ name: fr.folder, data: data });
    }
    
    if (sheets.length > 0) {
      downloadExcelMultiSheet(sheets, `doc_topics_perFolder_${result.method}.xls`);
    } else {
      alert('No document-topic data available for export.');
    }
    return;
  }
  
  // Global mode
  if (!result.docs || !result.docTopicDist || result.docs.length === 0) {
    alert('No document-topic data available.');
    return;
  }
  
  const K = result.numTopics || 0;
  const header = ['Document', 'Folder'];
  for (let k = 0; k < K; k++) {
    const label = topicLabels[k] ? `Topic_${k + 1}_${topicLabels[k]}` : `Topic_${k + 1}`;
    header.push(label);
  }
  header.push('Dominant_Topic');
  
  const data = [header];
  
  for (let d = 0; d < result.docs.length; d++) {
    const doc = result.docs[d];
    const row = [doc.name, doc.folder];
    
    let maxProb = 0;
    let dominantTopic = 1;
    for (let k = 0; k < K; k++) {
      const prob = result.docTopicDist[d]?.[k] || 0;
      row.push(prob);
      if (prob > maxProb) {
        maxProb = prob;
        dominantTopic = k + 1;
      }
    }
    row.push(dominantTopic);
    data.push(row);
  }
  
  downloadExcel(data, `doc_topics_${result.method.replace(/\s+/g, '_')}.xls`, 'DocTopics');
}

// Export folder-topic distribution to Excel
function exportFolderTopicToCSV() {
  if (!topicModelResults) {
    alert('No topic model results available.');
    return;
  }
  
  const result = topicModelResults;
  
  // Handle per-folder mode
  if (result.analysisMode === 'perFolder' && result.folderResults) {
    const sheets = [];
    
    // Summary sheet with all folders
    const successFolders = result.folderResults.filter(fr => !fr.error && fr.topWords && fr.topWords.length > 0);
    
    if (successFolders.length > 0) {
      // Find max K across folders
      const maxK = Math.max(...successFolders.map(fr => fr.topWords?.length || 0));
      
      const summaryHeader = ['Folder', 'DocCount', 'VocabSize'];
      for (let k = 0; k < maxK; k++) {
        summaryHeader.push(`Topic_${k + 1}_Dominant%`);
      }
      summaryHeader.push('Most_Dominant_Topic');
      
      const summaryData = [summaryHeader];
      
      for (const fr of successFolders) {
        const K = fr.topWords?.length || 0;
        const row = [fr.folder, fr.docCount || 0, fr.vocabSize || 0];
        
        // Calculate folder topic distribution (average of doc distributions)
        const folderDist = new Array(maxK).fill(0);
        if (fr.docTopicDist && fr.docTopicDist.length > 0) {
          for (const docDist of fr.docTopicDist) {
            for (let k = 0; k < K; k++) {
              folderDist[k] += (docDist[k] || 0);
            }
          }
          for (let k = 0; k < maxK; k++) {
            folderDist[k] = folderDist[k] / fr.docTopicDist.length;
          }
        }
        
        let maxProb = 0;
        let dominantTopic = 1;
        for (let k = 0; k < maxK; k++) {
          row.push((folderDist[k] * 100).toFixed(2) + '%');
          if (folderDist[k] > maxProb) {
            maxProb = folderDist[k];
            dominantTopic = k + 1;
          }
        }
        row.push(dominantTopic);
        summaryData.push(row);
      }
      
      sheets.push({ name: 'Summary', data: summaryData });
    }
    
    // Individual folder sheets with topic words
    for (const fr of successFolders) {
      const K = fr.topWords?.length || 0;
      if (K === 0) continue;
      
      const header = ['Topic', 'Alpha', 'Top Words', 'Doc Count'];
      const data = [header];
      
      for (let k = 0; k < K; k++) {
        const words = (fr.topWords[k] || []).slice(0, 10).map(w => w.word).join(', ');
        // Count docs where this topic is dominant
        let dominantCount = 0;
        if (fr.docTopicDist) {
          for (const docDist of fr.docTopicDist) {
            let maxProb = 0;
            let maxK = 0;
            for (let j = 0; j < K; j++) {
              if ((docDist[j] || 0) > maxProb) {
                maxProb = docDist[j];
                maxK = j;
              }
            }
            if (maxK === k) dominantCount++;
          }
        }
        data.push([`Topic ${k + 1}`, fr.alphaValues?.[k] || 0, words, dominantCount]);
      }
      
      sheets.push({ name: fr.folder, data: data });
    }
    
    if (sheets.length > 0) {
      downloadExcelMultiSheet(sheets, `folder_topics_perFolder_${result.method}.xls`);
    } else {
      alert('No folder-topic data available for export.');
    }
    return;
  }
  
  // Global mode
  if (!result.folderTopicDist || result.folderTopicDist.length === 0) {
    alert('No folder-topic data available.');
    return;
  }
  
  const K = result.numTopics || 0;
  const header = ['Folder', 'DocCount'];
  for (let k = 0; k < K; k++) {
    const label = topicLabels[k] ? `Topic_${k + 1}_${topicLabels[k]}` : `Topic_${k + 1}`;
    header.push(label);
  }
  header.push('Dominant_Topic');
  
  const data = [header];
  
  for (const fd of result.folderTopicDist) {
    const row = [fd.folder, fd.docCount];
    
    let maxProb = 0;
    let dominantTopic = 1;
    for (let k = 0; k < K; k++) {
      const prob = fd.dist?.[k] || 0;
      row.push(prob);
      if (prob > maxProb) {
        maxProb = prob;
        dominantTopic = k + 1;
      }
    }
    row.push(dominantTopic);
    data.push(row);
  }
  
  downloadExcel(data, `folder_topics_${result.method.replace(/\s+/g, '_')}.xls`, 'FolderTopics');
}

// Export topic visualization as PNG
function exportTopicPNG() {
  const canvas = document.getElementById('topicCanvas');
  if (!canvas) return;
  
  const link = document.createElement('a');
  link.download = `topic_visualization_${topicModelResults?.method?.replace(/\s+/g, '_') || 'model'}.png`;
  link.href = canvas.toDataURL('image/png');
  link.click();
}


// ===== 9-c) Distribution Test (File-level) =====

// Regularized incomplete beta (Numerical Recipes)
function _betacf(a, b, x) {
  const MAXIT = 200;
  const EPS = 3e-10;
  const FPMIN = 1e-30;
  let qab = a + b;
  let qap = a + 1;
  let qam = a - 1;
  let c = 1;
  let d = 1 - qab * x / qap;
  if (Math.abs(d) < FPMIN) d = FPMIN;
  d = 1 / d;
  let h = d;
  for (let m = 1; m <= MAXIT; m++) {
    let m2 = 2 * m;
    // even step
    let aa = m * (b - m) * x / ((qam + m2) * (a + m2));
    d = 1 + aa * d;
    if (Math.abs(d) < FPMIN) d = FPMIN;
    c = 1 + aa / c;
    if (Math.abs(c) < FPMIN) c = FPMIN;
    d = 1 / d;
    h *= d * c;

    // odd step
    aa = -(a + m) * (qab + m) * x / ((a + m2) * (qap + m2));
    d = 1 + aa * d;
    if (Math.abs(d) < FPMIN) d = FPMIN;
    c = 1 + aa / c;
    if (Math.abs(c) < FPMIN) c = FPMIN;
    d = 1 / d;
    const del = d * c;
    h *= del;
    if (Math.abs(del - 1) < EPS) break;
  }
  return h;
}

function _betaRegInc(a, b, x) {
  if (x <= 0) return 0;
  if (x >= 1) return 1;
  // bt = exp( lnΓ(a+b) - lnΓ(a) - lnΓ(b) + a ln x + b ln(1-x) )
  const bt = Math.exp(gammaLn(a + b) - gammaLn(a) - gammaLn(b) + a * Math.log(x) + b * Math.log(1 - x));
  const symm = x < (a + 1) / (a + b + 2);
  if (symm) {
    return bt * _betacf(a, b, x) / a;
  } else {
    return 1 - bt * _betacf(b, a, 1 - x) / b;
  }
}

// F distribution CDF and p-value
function fCDF(x, df1, df2) {
  if (x <= 0) return 0;
  if (df1 <= 0 || df2 <= 0) return 0;
  const xx = (df1 * x) / (df1 * x + df2);
  return _betaRegInc(df1 / 2, df2 / 2, xx);
}
function fPValue(F, df1, df2) {
  const cdf = fCDF(F, df1, df2);
  return Math.max(0, Math.min(1, 1 - cdf));
}


// Error function approximation (Abramowitz & Stegun 7.1.26)
function erf(x) {
  // Save the sign of x
  const sign = (x >= 0) ? 1 : -1;
  x = Math.abs(x);

  // Coefficients
  const a1 = 0.254829592;
  const a2 = -0.284496736;
  const a3 = 1.421413741;
  const a4 = -1.453152027;
  const a5 = 1.061405429;
  const p  = 0.3275911;

  const t = 1.0 / (1.0 + p * x);
  const y = 1.0 - (((((a5 * t + a4) * t) + a3) * t + a2) * t + a1) * t * Math.exp(-x * x);
  return sign * y;
}

// Normal CDF using erf (erf already defined in this file)
function normalCDF(z) {
  return 0.5 * (1 + erf(z / Math.SQRT2));
}
function normalPValueTwoSided(z) {
  const p = 2 * (1 - normalCDF(Math.abs(z)));
  return Math.max(0, Math.min(1, p));
}

// Student's t PDF/CDF (for studentized range computations)
function tPDF(x, v) {
  if (v <= 0) return 0;
  const num = Math.exp(gammaLn((v + 1) / 2) - gammaLn(v / 2));
  const den = Math.sqrt(v * Math.PI);
  return (num / den) * Math.pow(1 + (x * x) / v, -(v + 1) / 2);
}
// CDF via regularized incomplete beta
function tCDF(x, v) {
  if (v <= 0) return 0.5;
  if (!isFinite(x)) return x < 0 ? 0 : 1;
  const t = x;
  const xx = v / (v + t * t);
  const ib = _betaRegInc(v / 2, 0.5, xx);
  // For t>0: 1 - 0.5*I; For t<0: 0.5*I
  return t >= 0 ? 1 - 0.5 * ib : 0.5 * ib;
}

// Adaptive Simpson integration
function _simpson(f, a, b) {
  const c = (a + b) / 2;
  return (b - a) / 6 * (f(a) + 4 * f(c) + f(b));
}
function _adaptiveSimpson(f, a, b, eps, whole, depth) {
  const c = (a + b) / 2;
  const left = _simpson(f, a, c);
  const right = _simpson(f, c, b);
  const delta = left + right - whole;
  if (depth <= 0 || Math.abs(delta) <= 15 * eps) {
    return left + right + delta / 15;
  }
  return _adaptiveSimpson(f, a, c, eps / 2, left, depth - 1) + _adaptiveSimpson(f, c, b, eps / 2, right, depth - 1);
}

// Studentized range CDF using exact range-of-k iid t_v variables:
// P(Q <= q) = k * ∫ f_t(x) * (F_t(x+q) - F_t(x))^(k-1) dx
function studentizedRangeCDF(q, k, v) {
  if (q <= 0) return 0;
  if (k <= 1) return 1;
  if (v <= 0) return 0;
  // Integration bounds: wide enough for heavy tails in small df
  const L = (v < 2) ? 40 : (v < 5 ? 25 : 12);
  const integrand = (x) => {
    const Fx = tCDF(x, v);
    const Fxq = tCDF(x + q, v);
    const diff = Math.max(0, Math.min(1, Fxq - Fx));
    // When diff is tiny, avoid underflow
    const pow = (k - 1) === 1 ? diff : Math.pow(diff, k - 1);
    return tPDF(x, v) * pow;
  };
  const whole = _simpson(integrand, -L, L);
  const val = k * _adaptiveSimpson(integrand, -L, L, 1e-6, whole, 14);
  return Math.max(0, Math.min(1, val));
}
function studentizedRangePValue(q, k, v) {
  const cdf = studentizedRangeCDF(q, k, v);
  return Math.max(0, Math.min(1, 1 - cdf));
}

// Tukey HSD / Tukey-Kramer (exact p via studentized range)
function tukeyHSD(groups, msw, dfError) {
  const names = Object.keys(groups);
  const k = names.length;
  const comps = [];
  if (!msw || msw <= 0 || !isFinite(msw) || dfError <= 0) return comps;

  for (let i = 0; i < k; i++) {
    for (let j = i + 1; j < k; j++) {
      const a = names[i], b = names[j];
      const x1 = groups[a], x2 = groups[b];
      if (!x1.length || !x2.length) continue;
      const m1 = _mean(x1), m2 = _mean(x2);
      const se = Math.sqrt(msw / 2 * (1 / x1.length + 1 / x2.length)); // Tukey-Kramer
      const q = se > 0 ? Math.abs(m1 - m2) / se : 0;
      const pAdj = studentizedRangePValue(q, k, dfError);
      comps.push({ a, b, stat: q, p: pAdj, pAdj });
    }
  }
  return comps.sort((x, y) => x.pAdj - y.pAdj);
}

// Games-Howell (exact p via studentized range; Welch-type SE + Satterthwaite df)
function gamesHowell(groups) {
  const names = Object.keys(groups);
  const k = names.length;
  const comps = [];
  // Precompute means/vars/ns
  const stats = {};
  for (const g of names) {
    const arr = groups[g];
    stats[g] = { n: arr.length, mean: _mean(arr), var: _variance(arr) };
  }
  for (let i = 0; i < k; i++) {
    for (let j = i + 1; j < k; j++) {
      const a = names[i], b = names[j];
      const s1 = stats[a], s2 = stats[b];
      if (s1.n < 2 || s2.n < 2) continue;
      const v1 = s1.var / s1.n;
      const v2 = s2.var / s2.n;
      const denom = Math.sqrt((v1 + v2) / 2);
      const q = denom > 0 ? Math.abs(s1.mean - s2.mean) / denom : 0;
      const df = (v1 + v2) * (v1 + v2) / ((v1 * v1) / (s1.n - 1) + (v2 * v2) / (s2.n - 1));
      const pAdj = studentizedRangePValue(q, k, df);
      comps.push({ a, b, stat: q, df: df, p: pAdj, pAdj });
    }
  }
  return comps.sort((x, y) => x.pAdj - y.pAdj);
}

// Basic stats helpers
function _mean(arr) {
  if (!arr.length) return 0;
  return arr.reduce((a, b) => a + b, 0) / arr.length;
}
function _variance(arr) {
  if (arr.length < 2) return 0;
  const m = _mean(arr);
  let s = 0;
  for (const v of arr) s += (v - m) * (v - m);
  return s / (arr.length - 1);
}
function _quantile(sortedArr, q) {
  if (!sortedArr.length) return 0;
  const pos = (sortedArr.length - 1) * q;
  const base = Math.floor(pos);
  const rest = pos - base;
  if (sortedArr[base + 1] !== undefined) return sortedArr[base] + rest * (sortedArr[base + 1] - sortedArr[base]);
  return sortedArr[base];
}

// Holm correction
function holmAdjust(pvals) {
  const m = pvals.length;
  const indexed = pvals.map((p, i) => ({ p, i })).sort((a, b) => a.p - b.p);
  const adj = Array(m).fill(1);
  let prev = 0;
  for (let k = 0; k < m; k++) {
    const rank = k + 1;
    const raw = indexed[k].p;
    const val = Math.min(1, (m - k) * raw);
    const monotone = Math.max(val, prev);
    adj[indexed[k].i] = monotone;
    prev = monotone;
  }
  return adj;
}

// Compute per-file values for a feature (DF or NF)
function getFileLevelValuesForFeature(feature) {
  if (!corpus || !corpus.files) return null;

  // Use frequency table settings as the authoritative feature definition
  const featureType = document.getElementById('freqTableFeatureType')?.value || 'word';
  const n = parseInt(document.getElementById('freqTableN')?.value, 10) || 4;
  const caseInsensitive = document.getElementById('freqTableCaseInsensitive')?.checked ?? true;
  const respectBoundary = document.getElementById('respectSentenceBoundary')?.checked ?? true;

  const dataMode = document.getElementById('distTestDataMode')?.value || 'df';
  const normBase = parseInt(document.getElementById('distTestNormBase')?.value, 10) || 10000;

  // Use the same "Scope" selection as 9-a (Target/Reference/Both/All)
  const scopeEl = document.querySelector('input[name="freqTableScope"]:checked');
  const scope = scopeEl ? scopeEl.value : 'target';

  // Determine which folders are included
  const allowedFolders = new Set();
  if (scope === 'all') {
    for (const f of Object.keys(corpus.folders || {})) allowedFolders.add(f);
  } else if (scope === 'target') {
    for (const f of targetFolders) allowedFolders.add(f);
  } else if (scope === 'reference') {
    for (const f of referenceFolders) allowedFolders.add(f);
  } else if (scope === 'all') {
    for (const f of targetFolders) allowedFolders.add(f);
    for (const f of referenceFolders) allowedFolders.add(f);
  } else {
    for (const f of Object.keys(corpus.folders || {})) allowedFolders.add(f);
  }

  const groups = {}; // folder -> array of values
    const fileMap = {}; // fileName -> { folder, value, count, totalTokens }
const fileNames = Object.keys(corpus.files);
  for (const fileName of fileNames) {
    const file = corpus.files[fileName];
    if (!file) continue;
    const folder = file.folder || 'Ungrouped';
    if (!allowedFolders.has(folder)) continue;

    // Token list already excludes punctuation? In this app, file.tokens holds parsed tokens (including punctuation tokens but marked)
    // We'll compute totals consistent with frequency table (exclude punctuation/SPACE).
    const tokens = file.tokens || [];
    let totalTokens = 0;
    // Build a list of "unit tokens" depending on feature type
    // We reuse existing helper functions when available: getSentenceSegments(...) exists in this file, and token objects contain word/lemma/posd/poss.
    // Strategy: create an array of token representations within sentence segments if boundary respected (for n-gram types).
    // For word-level types, simply scan tokens.

    // Determine match function for the requested feature based on feature type used in freq table.
    const featureLower = caseInsensitive ? String(feature).toLowerCase() : String(feature);

    function tokWord(tok) {
      const w = tok.word ?? tok.surface ?? tok.form ?? '';
      return caseInsensitive ? String(w).toLowerCase() : String(w);
    }
    function tokLemma(tok) {
      const w = tok.lemma ?? tok.word ?? tok.surface ?? tok.form ?? '';
      return caseInsensitive ? String(w).toLowerCase() : String(w);
    }

    // Identify punctuation/space tokens (same logic used elsewhere)
    function isIgnorableToken(tok) {
      if (!tok) return true;
      if (tok.isSpace) return true;
      if (tok.isPunct) return true;
      // fallback: some tokens may have poss === 'SPACE' or posd === 'SPACE'
      if (tok.poss === 'SPACE' || tok.posd === 'SPACE') return true;
      return false;
    }

    // Count occurrences in this file
    let count = 0;

    // word-like features
    if (featureType === 'word') {
      for (const tok of tokens) {
        if (isIgnorableToken(tok)) continue;
        totalTokens++;
        if (tokWord(tok) === featureLower) count++;
      }
    } else if (featureType === 'lemma') {
      for (const tok of tokens) {
        if (isIgnorableToken(tok)) continue;
        totalTokens++;
        if (tokLemma(tok) === featureLower) count++;
      }
    } else if (featureType === 'pos_simple') {
      if (corpus.mode !== 'tagged' && corpus.mode !== 'csv') return null;
      for (const tok of tokens) {
        if (isIgnorableToken(tok)) continue;
        totalTokens++;
        const p = tok.poss || '';
        if (String(p) === String(feature)) count++;
      }
    } else if (featureType === 'pos_detailed') {
      if (corpus.mode !== 'tagged' && corpus.mode !== 'csv') return null;
      for (const tok of tokens) {
        if (isIgnorableToken(tok)) continue;
        totalTokens++;
        const p = tok.posd || '';
        if (String(p) === String(feature)) count++;
      }
    } else {
      // n-gram / p-frame / pos-gram / cluster / ngram+pos: We approximate by rebuilding the same strings as in computeFrequencyTable.
      // We rely on the existing helper getSentenceSegments(file.tokens, sentStart, sentEnd) when boundary respected.
      const sents = file.sentences || [{ tokenStart: 0, tokenEnd: tokens.length }];
      const segments = [];
      for (const sent of sents) {
        let subSegs;
        if (typeof getSentenceSegments === 'function' && respectBoundary) {
          subSegs = getSentenceSegments(tokens, sent.tokenStart, sent.tokenEnd);
        } else {
          subSegs = [{ tokens: tokens.slice(sent.tokenStart, sent.tokenEnd) }];
        }
        for (const sub of subSegs) segments.push(sub.tokens);
      }

      // Build token arrays per segment according to featureType
      const buildArr = (segTokens) => {
        const arr = [];
        if (featureType.startsWith('posgram')) {
          if (corpus.mode !== 'tagged' && corpus.mode !== 'csv') return arr;
          const posField = featureType.includes('detailed') ? 'posd' : 'poss';
          for (const tok of segTokens) {
            if (isIgnorableToken(tok)) continue;
            totalTokens++;
            const p = tok[posField];
            if (!p) continue;
            arr.push(String(p));
          }
        } else if (featureType.startsWith('ngrampos')) {
          if (corpus.mode !== 'tagged' && corpus.mode !== 'csv') return arr;
          const wordField = featureType.includes('lemma') ? 'lemma' : 'word';
          const posField = featureType.includes('detailed') ? 'posd' : 'poss';
          for (const tok of segTokens) {
            if (isIgnorableToken(tok)) continue;
            totalTokens++;
            let w = tok[wordField];
            if (!w) continue;
            w = caseInsensitive ? String(w).toLowerCase() : String(w);
            const p = tok[posField];
            if (!p) continue;
            arr.push(`${w}_${p}`);
          }
        } else {
          // ngram/pframe/cluster and other word-based grams
          const wordField = featureType.includes('lemma') ? 'lemma' : 'word';
          for (const tok of segTokens) {
            if (isIgnorableToken(tok)) continue;
            totalTokens++;
            let w = tok[wordField];
            if (!w) continue;
            w = caseInsensitive ? String(w).toLowerCase() : String(w);
            arr.push(String(w));
          }
        }
        return arr;
      };

      const targetStr = caseInsensitive ? String(feature).toLowerCase() : String(feature);

      for (const segTokens of segments) {
        const arr = buildArr(segTokens);
        if (arr.length < n) continue;

        if (featureType.startsWith('pframe')) {
          // exact match of p-frame string (includes "*")
          for (let i = 0; i <= arr.length - n; i++) {
            const gram = arr.slice(i, i + n);
            const key = gram.join(' ');
            if (key === targetStr) count++;
          }
        } else if (featureType.startsWith('cluster')) {
          // cluster contains a search word anywhere; but for distribution test, we treat feature as literal n-gram string from freq table
          for (let i = 0; i <= arr.length - n; i++) {
            const gram = arr.slice(i, i + n);
            const key = gram.join(' ');
            if (key === targetStr) count++;
          }
        } else if (featureType.startsWith('posgram')) {
          // POS n-grams use + as delimiter
          for (let i = 0; i <= arr.length - n; i++) {
            const gram = arr.slice(i, i + n);
            const key = gram.join('+');
            if (key === targetStr) count++;
          }
        } else {
          for (let i = 0; i <= arr.length - n; i++) {
            const gram = arr.slice(i, i + n);
            const key = gram.join(' ');
            if (key === targetStr) count++;
          }
        }
      }
    }

    // Derive value per file
    let value;
    if (dataMode === 'df') {
      value = count > 0 ? 1 : 0;
    } else {
      value = totalTokens > 0 ? (count / totalTokens) * normBase : 0;
    }

        fileMap[fileName] = { folder, value, count, totalTokens };
if (!groups[folder]) groups[folder] = [];
    groups[folder].push(value);
  }

  const groupNames = Object.keys(groups).sort();
  if (groupNames.length < 2) return { groups, groupNames, nFiles: groupNames.reduce((s, g) => s + groups[g].length, 0) , fileMap };

  return { groups, groupNames, nFiles: groupNames.reduce((s, g) => s + groups[g].length, 0), fileMap };
}

// One-way ANOVA
function oneWayAnova(groups) {
  const names = Object.keys(groups);
  const k = names.length;
  const all = [];
  for (const g of names) all.push(...groups[g]);
  const N = all.length;
  const grand = _mean(all);

  let ssBetween = 0;
  let ssWithin = 0;
  for (const g of names) {
    const arr = groups[g];
    const n = arr.length;
    if (n === 0) continue;
    const m = _mean(arr);
    ssBetween += n * (m - grand) * (m - grand);
    for (const v of arr) ssWithin += (v - m) * (v - m);
  }
  const df1 = k - 1;
  const df2 = N - k;
  const msb = df1 > 0 ? ssBetween / df1 : 0;
  const msw = df2 > 0 ? ssWithin / df2 : 0;
  const F = msw > 0 ? msb / msw : 0;
  const p = fPValue(F, df1, df2);
  const eta2 = (ssBetween + ssWithin) > 0 ? ssBetween / (ssBetween + ssWithin) : 0;
  return { stat: F, df1, df2, p, effect: eta2, effectLabel: 'η²', msw, grand };
}

// Welch's ANOVA (one-way)
function welchAnova(groups) {
  const names = Object.keys(groups);
  const k = names.length;
  const ni = [];
  const mi = [];
  const vi = [];
  for (const g of names) {
    const arr = groups[g];
    ni.push(arr.length);
    mi.push(_mean(arr));
    vi.push(_variance(arr));
  }

  // weights
  const wi = ni.map((n, i) => (vi[i] > 0 ? n / vi[i] : 0));
  const W = wi.reduce((a, b) => a + b, 0);
  const ybar = W > 0 ? wi.reduce((s, w, i) => s + w * mi[i], 0) / W : 0;

  // numerator
  let num = 0;
  for (let i = 0; i < k; i++) num += wi[i] * (mi[i] - ybar) * (mi[i] - ybar);
  const df1 = k - 1;

  // denominator adjustment
  let den = 0;
  for (let i = 0; i < k; i++) {
    if (ni[i] > 1 && wi[i] > 0) {
      den += (1 / (ni[i] - 1)) * (1 - (wi[i] / W)) * (1 - (wi[i] / W));
    }
  }
  const F = (df1 > 0) ? (num / df1) / (1 + (2 * (k - 2) * den) / (k - 1)) : 0;

  const df2 = den > 0 ? (k * k - 1) / (3 * den) : 1e9;
  const p = fPValue(F, df1, df2);

  // effect size: report η² approximation from classic decomposition (informative, not exact for Welch)
  // Use weighted SS between vs total.
  const all = [];
  for (const g of names) all.push(...groups[g]);
  const grand = _mean(all);
  let ssBetween = 0;
  let ssTotal = 0;
  for (const g of names) {
    const arr = groups[g];
    const m = _mean(arr);
    ssBetween += arr.length * (m - grand) * (m - grand);
    for (const v of arr) ssTotal += (v - grand) * (v - grand);
  }
  const eta2 = ssTotal > 0 ? ssBetween / ssTotal : 0;

  return { stat: F, df1, df2, p, effect: eta2, effectLabel: 'η² (approx)', msw };
}

// Kruskal-Wallis with tie correction
function kruskalWallis(groups) {
  const names = Object.keys(groups);
  const k = names.length;
  const all = [];
  for (const g of names) {
    for (const v of groups[g]) all.push({ v, g });
  }
  const N = all.length;
  all.sort((a, b) => a.v - b.v);

  // ranks with average ties
  const ranks = new Array(N);
  let i = 0;
  const tieCounts = [];
  while (i < N) {
    let j = i;
    while (j + 1 < N && all[j + 1].v === all[i].v) j++;
    const avgRank = (i + 1 + j + 1) / 2;
    for (let t = i; t <= j; t++) ranks[t] = avgRank;
    const tieSize = j - i + 1;
    if (tieSize > 1) tieCounts.push(tieSize);
    i = j + 1;
  }

  // sum ranks per group
  const R = {};
  const n = {};
  for (const g of names) { R[g] = 0; n[g] = 0; }
  for (let idx = 0; idx < N; idx++) {
    const g = all[idx].g;
    R[g] += ranks[idx];
    n[g] += 1;
  }

  let H = 0;
  for (const g of names) {
    if (n[g] > 0) H += (R[g] * R[g]) / n[g];
  }
  H = (12 / (N * (N + 1))) * H - 3 * (N + 1);

  // tie correction
  let T = 0;
  for (const t of tieCounts) T += (t * t * t - t);
  const C = 1 - (T / (N * N * N - N));
  if (C > 0) H = H / C;

  const df = k - 1;
  const p = 1 - chiSquareCDF(H, df);
  const eps2 = (N - k) > 0 ? (H - k + 1) / (N - k) : 0;
  return { stat: H, df, p, effect: eps2, effectLabel: 'ε²' };
}

// ========== MANOVA ==========
let __lastManovaResult = null;

function refreshManovaDVs() {
  const container = document.getElementById('manovaDVList');
  if (!container) return;
  
  // Use effective data (respects filters and deletions from 9-a)
  const effectiveData = getEffectiveFreqTableData();
  if (!effectiveData || !effectiveData.features || !effectiveData.features.length) {
    container.innerHTML = '<div class="text-xs" style="color:#6b7280;">Compute 9-a) Frequency Table first</div>';
    return;
  }
  
  const features = effectiveData.features.slice(0, 30).map(String);
  container.innerHTML = features.map((f, i) => `
    <label style="display:block; margin:0.15rem 0; cursor:pointer;">
      <input type="checkbox" class="manova-dv-checkbox" value="${escapeHtml(f)}" ${i < 3 ? 'checked' : ''}>
      <span class="text-xs">${escapeHtml(f.length > 25 ? f.substring(0, 23) + '...' : f)}</span>
    </label>
  `).join('');
}

function selectAllManovaDVs() {
  document.querySelectorAll('.manova-dv-checkbox').forEach(cb => cb.checked = true);
}

function clearAllManovaDVs() {
  document.querySelectorAll('.manova-dv-checkbox').forEach(cb => cb.checked = false);
}

function getSelectedManovaDVs() {
  return Array.from(document.querySelectorAll('.manova-dv-checkbox:checked')).map(cb => cb.value);
}

function runManova() {
  const status = document.getElementById('manovaStatus');
  const results = document.getElementById('manovaResults');
  if (!status || !results) return;
  
  status.textContent = 'Computing...';
  results.style.display = 'none';
  
  let dvs = getSelectedManovaDVs();
  if (dvs.length < 2) {
    status.textContent = 'Please select at least 2 dependent variables.';
    return;
  }
  
  // Limit DVs to 10 for performance
  if (dvs.length > 10) {
    dvs = dvs.slice(0, 10);
    status.textContent = 'Computing (limited to first 10 DVs for performance)...';
  }
  
  // Get grouping specification from 9-c
  const spec = getDistTestGroupingSpec();
  if (!spec.folders || spec.folders.length < 2) {
    status.textContent = 'Please configure groups in 9-c first.';
    return;
  }
  
  // Use setTimeout to allow UI update
  setTimeout(() => {
    try {
      runManovaCompute(dvs, spec, status, results);
    } catch (e) {
      status.textContent = 'MANOVA computation error: ' + e.message;
    }
  }, 10);
}

function runManovaCompute(dvs, spec, status, results) {
  // Pre-cache all DV data at once (major optimization)
  status.textContent = 'Loading feature data...';
  const dvDataCache = {};
  for (const dv of dvs) {
    const fd = getFileLevelValuesForFeature(dv);
    dvDataCache[dv] = fd?.fileMap || {};
  }
  
  status.textContent = 'Building data matrix...';
  
  // Build data matrix: rows = files, columns = DVs
  const dataByGroup = {}; // groupName -> array of [dv1, dv2, ...] vectors
  const groupNames = [];
  
  for (const folder of spec.folders) {
    let groupName = folder;
    if (spec.mode === 'customGroups' && spec.groups) {
      const g = spec.groups.find(gr => gr.folders && gr.folders.includes(folder));
      if (g) groupName = g.name || folder;
    }
    if (!dataByGroup[groupName]) {
      dataByGroup[groupName] = [];
      groupNames.push(groupName);
    }
    
    // Get files in this folder
    const files = Object.keys(corpus.files || {}).filter(f => {
      const file = corpus.files[f];
      return file && file.folder === folder;
    });
    
    for (const fileName of files) {
      const row = [];
      for (const dv of dvs) {
        const val = dvDataCache[dv]?.[fileName]?.value ?? 0;
        row.push(val);
      }
      dataByGroup[groupName].push(row);
    }
  }
  
  // Check minimum sample size
  let totalN = 0;
  for (const g of groupNames) {
    if (dataByGroup[g].length < 2) {
      status.textContent = `Group "${g}" has fewer than 2 observations.`;
      return;
    }
    totalN += dataByGroup[g].length;
  }
  
  const p = dvs.length;
  const k = groupNames.length;
  
  if (totalN < p + k) {
    status.textContent = 'Insufficient observations for MANOVA.';
    return;
  }
  
  status.textContent = 'Computing MANOVA statistics...';
  
  // Compute MANOVA statistics
  const result = computeManova(dataByGroup, groupNames, dvs);
  
  if (!result) {
    status.textContent = 'MANOVA computation failed. Check data for collinearity.';
    return;
  }
  
  __lastManovaResult = result;
  
  // Display results
  const testStat = document.getElementById('manovaTestStat')?.value || 'pillai';
  const testLabels = { pillai: "Pillai's trace", wilks: "Wilks' λ", hotelling: "Hotelling-Lawley", roy: "Roy's largest root" };
  
  document.getElementById('manovaTestLabel').textContent = testLabels[testStat] || testStat;
  document.getElementById('manovaStat').textContent = result[testStat]?.stat?.toFixed(4) || 'NA';
  document.getElementById('manovaF').textContent = result[testStat]?.F?.toFixed(3) || 'NA';
  document.getElementById('manovaDf').textContent = result[testStat]?.df ? `(${result[testStat].df[0]}, ${result[testStat].df[1]})` : 'NA';
  document.getElementById('manovaP').textContent = result[testStat]?.p?.toExponential(3) || 'NA';
  document.getElementById('manovaEta2').textContent = result.eta2?.toFixed(4) || 'NA';
  
  const sigText = result[testStat]?.p < 0.05 ? 'Significant difference exists among groups.' : 'No significant difference among groups.';
  document.getElementById('manovaInterpretation').textContent = sigText;
  
  // Univariate follow-up
  let followUpHtml = '<table class="table" style="font-size:0.8rem;"><thead><tr><th>DV</th><th>F</th><th>p</th><th>η²</th></tr></thead><tbody>';
  for (const dv of dvs) {
    const uv = result.univariate?.[dv];
    if (uv) {
      const sig = uv.p < 0.05 ? ' *' : '';
      followUpHtml += `<tr><td>${escapeHtml(dv)}</td><td>${uv.F?.toFixed(3) || 'NA'}</td><td>${uv.p?.toExponential(2) || 'NA'}${sig}</td><td>${uv.eta2?.toFixed(4) || 'NA'}</td></tr>`;
    }
  }
  followUpHtml += '</tbody></table>';
  document.getElementById('manovaFollowUp').innerHTML = followUpHtml;
  
  // Draw visualization
  drawManovaChart(result);
  
  results.style.display = 'block';
  status.textContent = `Done. ${k} groups, ${p} DVs, n=${totalN}`;
}

function computeManova(dataByGroup, groupNames, dvs) {
  const k = groupNames.length;
  const p = dvs.length;
  
  // Combine all data
  const allData = [];
  const groupLabels = [];
  for (const g of groupNames) {
    for (const row of dataByGroup[g]) {
      allData.push(row);
      groupLabels.push(g);
    }
  }
  const n = allData.length;
  
  // Grand mean
  const grandMean = new Array(p).fill(0);
  for (const row of allData) {
    for (let j = 0; j < p; j++) grandMean[j] += row[j];
  }
  for (let j = 0; j < p; j++) grandMean[j] /= n;
  
  // Group means
  const groupMeans = {};
  const groupN = {};
  for (const g of groupNames) {
    groupMeans[g] = new Array(p).fill(0);
    groupN[g] = dataByGroup[g].length;
    for (const row of dataByGroup[g]) {
      for (let j = 0; j < p; j++) groupMeans[g][j] += row[j];
    }
    for (let j = 0; j < p; j++) groupMeans[g][j] /= groupN[g];
  }
  
  // Between-groups SSCP matrix (H)
  const H = Array.from({ length: p }, () => new Array(p).fill(0));
  for (const g of groupNames) {
    const diff = groupMeans[g].map((m, j) => m - grandMean[j]);
    for (let i = 0; i < p; i++) {
      for (let j = 0; j < p; j++) {
        H[i][j] += groupN[g] * diff[i] * diff[j];
      }
    }
  }
  
  // Within-groups SSCP matrix (E)
  const E = Array.from({ length: p }, () => new Array(p).fill(0));
  for (const g of groupNames) {
    for (const row of dataByGroup[g]) {
      const diff = row.map((v, j) => v - groupMeans[g][j]);
      for (let i = 0; i < p; i++) {
        for (let j = 0; j < p; j++) {
          E[i][j] += diff[i] * diff[j];
        }
      }
    }
  }
  
  // Total SSCP matrix (T = H + E)
  const T = Array.from({ length: p }, (_, i) => H[i].map((h, j) => h + E[i][j]));
  
  // Eigenvalues of E^(-1)H
  const Einv = invMatrix(E);
  if (!Einv) return null;
  
  const EinvH = multiplyMatrices(Einv, H);
  if (!EinvH) return null;
  
  const eigenvalues = computeEigenvalues(EinvH);
  if (!eigenvalues || eigenvalues.length === 0) return null;
  
  // Sort eigenvalues descending
  eigenvalues.sort((a, b) => b - a);
  
  const s = Math.min(k - 1, p);
  const dfH = k - 1;
  const dfE = n - k;
  
  // Safety check
  if (s <= 0 || dfE <= 0) {
    return null;
  }
  
  // Pillai's trace
  const pillai = eigenvalues.reduce((sum, lambda) => sum + lambda / (1 + lambda), 0);
  let pillaiF = 0, pillaiDf1 = s * p, pillaiDf2 = Math.max(1, s * (dfE - p + s));
  if (pillai > 0 && pillai < s) {
    pillaiF = (pillai / s) * ((dfE - p + s) / (p * dfH)) * ((dfE + dfH - p - 1 + s) / (1 - pillai / s));
  }
  const pillaiP = pillaiF > 0 ? 1 - fDistCDF(pillaiF, pillaiDf1, pillaiDf2) : 1;
  
  // Wilks' lambda
  const wilks = eigenvalues.reduce((prod, lambda) => prod / (1 + lambda), 1);
  let wilksF = 0, wilksDf1 = p * dfH, wilksDf2 = Math.max(1, dfE - p + 1);
  if (wilks > 0 && wilks < 1) {
    const wilksPow = Math.pow(wilks, 1 / s);
    if (wilksPow > 0 && wilksPow < 1) {
      wilksF = ((1 - wilksPow) / wilksPow) * (wilksDf2 / p);
    }
  }
  const wilksP = wilksF > 0 ? 1 - fDistCDF(wilksF, wilksDf1, wilksDf2) : 1;
  
  // Hotelling-Lawley trace
  const hotelling = eigenvalues.reduce((sum, lambda) => sum + lambda, 0);
  let hotellingF = 0, hotellingDf1 = s * p, hotellingDf2 = Math.max(1, s * (dfE - p - 1));
  if (hotellingDf2 > 0 && hotelling > 0) {
    hotellingF = (hotelling / s) * (hotellingDf2 / p);
  }
  const hotellingP = hotellingF > 0 ? 1 - fDistCDF(hotellingF, hotellingDf1, hotellingDf2) : 1;
  
  // Roy's largest root
  const roy = eigenvalues[0] || 0;
  let royF = 0, royDf1 = p, royDf2 = Math.max(1, dfE - p + dfH);
  if (roy > 0) {
    royF = roy * royDf2 / p;
  }
  const royP = royF > 0 ? 1 - fDistCDF(royF, royDf1, royDf2) : 1;
  
  // Effect size (multivariate eta-squared based on Pillai)
  const eta2 = pillai / s;
  
  // Univariate follow-up ANOVAs
  const univariate = {};
  for (let j = 0; j < p; j++) {
    const groups = {};
    for (const g of groupNames) {
      groups[g] = dataByGroup[g].map(row => row[j]);
    }
    const anova = oneWayAnova(groups);
    univariate[dvs[j]] = { F: anova.stat, p: anova.p, eta2: anova.effect };
  }
  
  return {
    pillai: { stat: pillai, F: pillaiF, df: [pillaiDf1, pillaiDf2], p: pillaiP },
    wilks: { stat: wilks, F: wilksF, df: [wilksDf1, wilksDf2], p: wilksP },
    hotelling: { stat: hotelling, F: hotellingF, df: [hotellingDf1, hotellingDf2], p: hotellingP },
    roy: { stat: roy, F: royF, df: [royDf1, royDf2], p: royP },
    eta2,
    univariate,
    groupNames,
    dvs,
    n
  };
}

function computeEigenvalues(A) {
  // Optimized eigenvalue computation using QR iteration (simplified)
  const n = A.length;
  if (n === 0) return [];
  if (n === 1) return [A[0][0]];
  
  // For small matrices, use direct calculation
  if (n === 2) {
    const a = A[0][0], b = A[0][1], c = A[1][0], d = A[1][1];
    const trace = a + d;
    const det = a * d - b * c;
    const disc = trace * trace - 4 * det;
    if (disc >= 0) {
      return [(trace + Math.sqrt(disc)) / 2, (trace - Math.sqrt(disc)) / 2].filter(e => e > 0);
    }
    return [trace / 2].filter(e => e > 0);
  }
  
  // For larger matrices, use simplified QR iteration
  let M = A.map(row => [...row]);
  const maxIter = 30; // Reduced iterations
  const tol = 1e-6;
  
  for (let iter = 0; iter < maxIter; iter++) {
    // Simple QR decomposition using Gram-Schmidt
    const Q = Array.from({ length: n }, () => new Array(n).fill(0));
    const R = Array.from({ length: n }, () => new Array(n).fill(0));
    
    for (let j = 0; j < n; j++) {
      // Get column j of M
      const v = M.map(row => row[j]);
      
      // Subtract projections
      for (let i = 0; i < j; i++) {
        let dot = 0;
        for (let k = 0; k < n; k++) dot += Q[k][i] * v[k];
        R[i][j] = dot;
        for (let k = 0; k < n; k++) v[k] -= dot * Q[k][i];
      }
      
      // Normalize
      let norm = 0;
      for (let k = 0; k < n; k++) norm += v[k] * v[k];
      norm = Math.sqrt(norm);
      R[j][j] = norm;
      
      if (norm > tol) {
        for (let k = 0; k < n; k++) Q[k][j] = v[k] / norm;
      }
    }
    
    // M = R * Q
    const newM = Array.from({ length: n }, () => new Array(n).fill(0));
    for (let i = 0; i < n; i++) {
      for (let j = 0; j < n; j++) {
        for (let k = 0; k < n; k++) {
          newM[i][j] += R[i][k] * Q[k][j];
        }
      }
    }
    M = newM;
    
    // Check convergence (off-diagonal elements small)
    let offDiag = 0;
    for (let i = 1; i < n; i++) {
      offDiag += Math.abs(M[i][i-1]);
    }
    if (offDiag < tol * n) break;
  }
  
  // Extract diagonal as eigenvalues
  return M.map((row, i) => row[i]).filter(e => e > 1e-10).sort((a, b) => b - a);
}

function clearManova() {
  document.getElementById('manovaStatus').textContent = '';
  document.getElementById('manovaResults').style.display = 'none';
  __lastManovaResult = null;
}

function exportManovaExcel() {
  if (!__lastManovaResult) {
    alert('No MANOVA results to export. Run MANOVA first.');
    return;
  }
  const r = __lastManovaResult;
  let html = `<html><head><meta charset="UTF-8"></head><body>
    <h3>MANOVA Results</h3>
    <table border="1"><tr><th>Test</th><th>Statistic</th><th>F</th><th>df1</th><th>df2</th><th>p</th></tr>
    <tr><td>Pillai's trace</td><td>${r.pillai.stat.toFixed(4)}</td><td>${r.pillai.F.toFixed(3)}</td><td>${r.pillai.df[0]}</td><td>${r.pillai.df[1]}</td><td>${r.pillai.p.toExponential(3)}</td></tr>
    <tr><td>Wilks' lambda</td><td>${r.wilks.stat.toFixed(4)}</td><td>${r.wilks.F.toFixed(3)}</td><td>${r.wilks.df[0]}</td><td>${r.wilks.df[1]}</td><td>${r.wilks.p.toExponential(3)}</td></tr>
    <tr><td>Hotelling-Lawley</td><td>${r.hotelling.stat.toFixed(4)}</td><td>${r.hotelling.F.toFixed(3)}</td><td>${r.hotelling.df[0]}</td><td>${r.hotelling.df[1]}</td><td>${r.hotelling.p.toExponential(3)}</td></tr>
    <tr><td>Roy's largest root</td><td>${r.roy.stat.toFixed(4)}</td><td>${r.roy.F.toFixed(3)}</td><td>${r.roy.df[0]}</td><td>${r.roy.df[1]}</td><td>${r.roy.p.toExponential(3)}</td></tr>
    </table>
    <h4>Univariate Follow-up</h4>
    <table border="1"><tr><th>DV</th><th>F</th><th>p</th><th>η²</th></tr>`;
  for (const dv of r.dvs) {
    const u = r.univariate[dv];
    html += `<tr><td>${escapeHtml(dv)}</td><td>${u.F.toFixed(3)}</td><td>${u.p.toExponential(3)}</td><td>${u.eta2.toFixed(4)}</td></tr>`;
  }
  html += '</table></body></html>';
  
  const blob = new Blob([html], { type: 'application/vnd.ms-excel' });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = 'manova_results.xls';
  a.click();
  URL.revokeObjectURL(url);
}

function exportManovaPng() {
  const canvas = document.getElementById('manovaCanvas');
  if (!canvas) {
    alert('No MANOVA visualization to export.');
    return;
  }
  const url = canvas.toDataURL('image/png');
  const a = document.createElement('a');
  a.href = url;
  a.download = 'manova_effect_sizes.png';
  a.click();
}

function drawManovaChart(result) {
  const canvas = document.getElementById('manovaCanvas');
  if (!canvas || !result || !result.univariate) return;
  
  const ctx = canvas.getContext('2d');
  const W = canvas.width;
  const H = canvas.height;
  ctx.clearRect(0, 0, W, H);
  
  const dvs = result.dvs || [];
  if (dvs.length === 0) return;
  
  const margin = { top: 30, right: 30, bottom: 60, left: 150 };
  const plotW = W - margin.left - margin.right;
  const plotH = H - margin.top - margin.bottom;
  
  const barHeight = Math.min(25, plotH / dvs.length - 5);
  const barGap = (plotH - barHeight * dvs.length) / (dvs.length + 1);
  
  // Find max eta2
  const maxEta2 = Math.max(0.3, ...dvs.map(dv => result.univariate[dv]?.eta2 || 0));
  
  // Draw axes
  ctx.strokeStyle = '#333';
  ctx.lineWidth = 1;
  ctx.beginPath();
  ctx.moveTo(margin.left, margin.top);
  ctx.lineTo(margin.left, H - margin.bottom);
  ctx.lineTo(W - margin.right, H - margin.bottom);
  ctx.stroke();
  
  // Draw x-axis labels
  ctx.fillStyle = '#333';
  ctx.font = '11px sans-serif';
  ctx.textAlign = 'center';
  for (let i = 0; i <= 5; i++) {
    const x = margin.left + (plotW * i / 5);
    const val = (maxEta2 * i / 5).toFixed(2);
    ctx.fillText(val, x, H - margin.bottom + 15);
    
    // Grid line
    ctx.strokeStyle = '#e5e7eb';
    ctx.beginPath();
    ctx.moveTo(x, margin.top);
    ctx.lineTo(x, H - margin.bottom);
    ctx.stroke();
  }
  
  ctx.fillStyle = '#333';
  ctx.font = '12px sans-serif';
  ctx.textAlign = 'center';
  ctx.fillText('Effect Size (η²)', W / 2, H - 10);
  
  // Draw bars
  dvs.forEach((dv, i) => {
    const eta2 = result.univariate[dv]?.eta2 || 0;
    const p = result.univariate[dv]?.p || 1;
    const y = margin.top + barGap * (i + 1) + barHeight * i;
    const barW = (eta2 / maxEta2) * plotW;
    
    // Bar color based on significance
    ctx.fillStyle = p < 0.05 ? '#3b82f6' : '#94a3b8';
    ctx.fillRect(margin.left, y, barW, barHeight);
    
    // DV label
    ctx.fillStyle = '#333';
    ctx.font = '11px sans-serif';
    ctx.textAlign = 'right';
    const label = dv.length > 18 ? dv.substring(0, 16) + '...' : dv;
    ctx.fillText(label, margin.left - 5, y + barHeight / 2 + 4);
    
    // Value label
    ctx.textAlign = 'left';
    ctx.fillText(eta2.toFixed(3) + (p < 0.05 ? ' *' : ''), margin.left + barW + 5, y + barHeight / 2 + 4);
  });
  
  // Title
  ctx.fillStyle = '#333';
  ctx.font = 'bold 12px sans-serif';
  ctx.textAlign = 'center';
  ctx.fillText('Univariate Effect Sizes (η²)', W / 2, 15);
}

// ========== Mixed Effects Model ==========
let __lastMixedResult = null;

function updateMixedModelOptions() {
  const modelType = document.getElementById('mixedModelType')?.value || 'lmm';
  const outcomeEl = document.getElementById('mixedOutcome');
  if (!outcomeEl) return;
  
  if (modelType === 'lmm') {
    outcomeEl.value = 'nf';
  } else if (modelType === 'glmm_poisson') {
    outcomeEl.value = 'count';
  } else if (modelType === 'glmm_binomial') {
    outcomeEl.value = 'df';
  }
}

function runMixedModel() {
  const status = document.getElementById('mixedModelStatus');
  const results = document.getElementById('mixedModelResults');
  if (!status || !results) return;
  
  status.textContent = 'Computing...';
  results.style.display = 'none';
  
  // Get feature from 9-c
  const feature = document.getElementById('distTestFeatureSelect')?.value;
  if (!feature) {
    status.textContent = 'Please select a feature in 9-c Distribution Test.';
    return;
  }
  
  const modelType = document.getElementById('mixedModelType')?.value || 'lmm';
  const outcomeType = document.getElementById('mixedOutcome')?.value || 'nf';
  const randomEffect = document.getElementById('mixedRandomEffect')?.value || 'folder';
  const includeGroup = document.getElementById('mixedIncludeGroup')?.checked ?? true;
  const includeDocLen = document.getElementById('mixedIncludeDocLen')?.checked ?? true;
  const maxIter = parseInt(document.getElementById('mixedMaxIter')?.value, 10) || 100;
  
  // Build data
  const spec = getDistTestGroupingSpec();
  if (!spec.folders || spec.folders.length < 2) {
    status.textContent = 'Please configure groups in 9-c first.';
    return;
  }
  
  const fd = getFileLevelValuesForFeature(feature);
  if (!fd || !fd.fileMap) {
    status.textContent = 'Could not get file-level data for feature.';
    return;
  }
  
  const data = [];
  for (const fileName in fd.fileMap) {
    const info = fd.fileMap[fileName];
    if (!spec.folders.includes(info.folder)) continue;
    
    let groupName = info.folder;
    if (spec.mode === 'customGroups' && spec.groups) {
      const g = spec.groups.find(gr => gr.folders && gr.folders.includes(info.folder));
      if (g) groupName = g.name || info.folder;
    }
    
    let y;
    if (outcomeType === 'nf') y = info.value;
    else if (outcomeType === 'count') y = info.count;
    else y = info.count > 0 ? 1 : 0;
    
    data.push({
      y,
      group: groupName,
      folder: info.folder,
      file: fileName,
      tokens: info.totalTokens || 1
    });
  }
  
  if (data.length < 20) {
    status.textContent = 'Insufficient data for mixed model (need at least 20 observations).';
    return;
  }
  
  // Fit mixed model
  const result = fitMixedModel(data, modelType, randomEffect, includeGroup, includeDocLen, maxIter);
  
  if (!result) {
    status.textContent = 'Mixed model fitting failed.';
    return;
  }
  
  __lastMixedResult = result;
  
  // Display results
  const modelLabels = { lmm: 'LMM (Gaussian)', glmm_poisson: 'GLMM (Poisson)', glmm_binomial: 'GLMM (Binomial)' };
  document.getElementById('mixedModelLabel').textContent = modelLabels[modelType] || modelType;
  document.getElementById('mixedAIC').textContent = result.aic?.toFixed(2) || 'NA';
  document.getElementById('mixedBIC').textContent = result.bic?.toFixed(2) || 'NA';
  document.getElementById('mixedLogLik').textContent = result.logLik?.toFixed(2) || 'NA';
  document.getElementById('mixedN').textContent = data.length;
  
  // Fixed effects table
  let fixedHtml = '<table class="table" style="font-size:0.8rem;"><thead><tr><th>Effect</th><th>Estimate</th><th>SE</th><th>t/z</th><th>p</th></tr></thead><tbody>';
  for (const fe of result.fixedEffects || []) {
    const sig = fe.p < 0.05 ? ' *' : '';
    fixedHtml += `<tr><td>${escapeHtml(fe.name)}</td><td>${fe.estimate?.toFixed(4) || 'NA'}</td><td>${fe.se?.toFixed(4) || 'NA'}</td><td>${fe.t?.toFixed(3) || 'NA'}</td><td>${fe.p?.toExponential(2) || 'NA'}${sig}</td></tr>`;
  }
  fixedHtml += '</tbody></table>';
  document.getElementById('mixedFixedEffects').innerHTML = fixedHtml;
  
  // Random effects
  let randomHtml = '';
  if (result.randomVariance) {
    randomHtml = `<div>Random intercept variance: ${result.randomVariance.toFixed(4)}</div>`;
    if (result.residualVariance) {
      randomHtml += `<div>Residual variance: ${result.residualVariance.toFixed(4)}</div>`;
      const icc = result.randomVariance / (result.randomVariance + result.residualVariance);
      randomHtml += `<div>ICC: ${icc.toFixed(4)}</div>`;
    }
  }
  document.getElementById('mixedRandomEffects').innerHTML = randomHtml;
  
  // Draw forest plot
  drawMixedForest(result.fixedEffects);
  
  results.style.display = 'block';
  status.textContent = 'Done.';
}

function fitMixedModel(data, modelType, randomEffect, includeGroup, includeDocLen, maxIter) {
  // Simplified LMM using EM algorithm approximation
  const n = data.length;
  const groupNames = [...new Set(data.map(d => d.group))].sort();
  const clusterVar = randomEffect === 'file' ? 'file' : 'folder';
  const clusters = [...new Set(data.map(d => d[clusterVar]))];
  const nClusters = clusters.length;
  
  if (nClusters < 2) return null;
  
  // Build design matrix for fixed effects
  const X = [];
  const y = [];
  const clusterIds = [];
  const baseGroup = groupNames[0];
  
  for (const d of data) {
    const row = [1]; // intercept
    if (includeGroup) {
      for (const g of groupNames.slice(1)) {
        row.push(d.group === g ? 1 : 0);
      }
    }
    if (includeDocLen) {
      row.push(Math.log(Math.max(1, d.tokens)));
    }
    X.push(row);
    y.push(d.y);
    clusterIds.push(clusters.indexOf(d[clusterVar]));
  }
  
  const p = X[0].length;
  
  // For LMM: use iterative approach
  if (modelType === 'lmm') {
    return fitLMM_EM(X, y, clusterIds, nClusters, groupNames, includeGroup, includeDocLen, maxIter);
  } else {
    // GLMM approximation using penalized quasi-likelihood (simplified)
    return fitGLMM_PQL(X, y, clusterIds, nClusters, modelType, groupNames, includeGroup, includeDocLen, maxIter);
  }
}

function fitLMM_EM(X, y, clusterIds, nClusters, groupNames, includeGroup, includeDocLen, maxIter) {
  const n = X.length;
  const p = X[0].length;
  
  // Initialize
  let sigma2_u = 0.1; // random effect variance
  let sigma2_e = 1.0; // residual variance
  let beta = new Array(p).fill(0);
  
  // EM iterations
  for (let iter = 0; iter < maxIter; iter++) {
    // E-step: estimate random effects given current parameters
    const u = new Array(nClusters).fill(0);
    const clusterSums = new Array(nClusters).fill(0);
    const clusterCounts = new Array(nClusters).fill(0);
    
    for (let i = 0; i < n; i++) {
      let xb = 0;
      for (let j = 0; j < p; j++) xb += X[i][j] * beta[j];
      const resid = y[i] - xb;
      clusterSums[clusterIds[i]] += resid;
      clusterCounts[clusterIds[i]] += 1;
    }
    
    for (let c = 0; c < nClusters; c++) {
      if (clusterCounts[c] > 0) {
        u[c] = (sigma2_u / (sigma2_u + sigma2_e / clusterCounts[c])) * (clusterSums[c] / clusterCounts[c]);
      }
    }
    
    // M-step: update beta
    const yAdj = y.map((yi, i) => yi - u[clusterIds[i]]);
    const Xt = transpose(X);
    const XtX = matMul(Xt, X);
    const Xty = Xt.map(row => row.reduce((s, v, i) => s + v * yAdj[i], 0));
    const newBeta = solveLinearSystem(XtX, Xty);
    if (!newBeta) break;
    
    // Update variance components
    let ss_e = 0;
    for (let i = 0; i < n; i++) {
      let xb = 0;
      for (let j = 0; j < p; j++) xb += X[i][j] * newBeta[j];
      const resid = y[i] - xb - u[clusterIds[i]];
      ss_e += resid * resid;
    }
    
    let ss_u = 0;
    for (let c = 0; c < nClusters; c++) {
      ss_u += u[c] * u[c];
    }
    
    const newSigma2_e = ss_e / (n - p);
    const newSigma2_u = ss_u / nClusters;
    
    // Check convergence
    const diff = Math.max(...newBeta.map((b, i) => Math.abs(b - beta[i])));
    beta = newBeta;
    sigma2_e = Math.max(0.001, newSigma2_e);
    sigma2_u = Math.max(0.001, newSigma2_u);
    
    if (diff < 1e-6) break;
  }
  
  // Compute standard errors (approximate)
  const Xt = transpose(X);
  const XtX = matMul(Xt, X);
  const XtXinv = invMatrix(XtX);
  const se = XtXinv ? XtXinv.map((row, i) => Math.sqrt(Math.max(0, sigma2_e * row[i]))) : new Array(p).fill(NaN);
  
  // Build fixed effects output
  const fixedEffects = [];
  let idx = 0;
  fixedEffects.push({ name: '(Intercept)', estimate: beta[idx], se: se[idx], t: beta[idx] / se[idx], p: 2 * (1 - normalCdf(Math.abs(beta[idx] / se[idx]))) });
  idx++;
  
  if (includeGroup) {
    for (const g of groupNames.slice(1)) {
      fixedEffects.push({ name: `group:${g}`, estimate: beta[idx], se: se[idx], t: beta[idx] / se[idx], p: 2 * (1 - normalCdf(Math.abs(beta[idx] / se[idx]))) });
      idx++;
    }
  }
  if (includeDocLen) {
    fixedEffects.push({ name: 'log(tokens)', estimate: beta[idx], se: se[idx], t: beta[idx] / se[idx], p: 2 * (1 - normalCdf(Math.abs(beta[idx] / se[idx]))) });
  }
  
  // Compute log-likelihood, AIC, BIC
  let logLik = 0;
  for (let i = 0; i < n; i++) {
    let xb = 0;
    for (let j = 0; j < p; j++) xb += X[i][j] * beta[j];
    const resid = y[i] - xb;
    logLik += -0.5 * Math.log(2 * Math.PI * sigma2_e) - 0.5 * resid * resid / sigma2_e;
  }
  
  const nParams = p + 2; // beta + sigma2_u + sigma2_e
  const aic = -2 * logLik + 2 * nParams;
  const bic = -2 * logLik + Math.log(n) * nParams;
  
  return {
    fixedEffects,
    randomVariance: sigma2_u,
    residualVariance: sigma2_e,
    logLik,
    aic,
    bic
  };
}

function fitGLMM_PQL(X, y, clusterIds, nClusters, modelType, groupNames, includeGroup, includeDocLen, maxIter) {
  // Simplified PQL approximation
  const n = X.length;
  const p = X[0].length;
  
  // Initialize
  let sigma2_u = 0.1;
  let beta = new Array(p).fill(0);
  
  for (let iter = 0; iter < maxIter; iter++) {
    // Working response and weights
    const eta = new Array(n);
    const mu = new Array(n);
    const w = new Array(n);
    const z = new Array(n);
    
    for (let i = 0; i < n; i++) {
      let xb = 0;
      for (let j = 0; j < p; j++) xb += X[i][j] * beta[j];
      eta[i] = xb;
      
      if (modelType === 'glmm_poisson') {
        mu[i] = Math.exp(Math.min(20, eta[i]));
        w[i] = mu[i];
        z[i] = eta[i] + (y[i] - mu[i]) / mu[i];
      } else {
        mu[i] = 1 / (1 + Math.exp(-eta[i]));
        mu[i] = Math.max(0.001, Math.min(0.999, mu[i]));
        w[i] = mu[i] * (1 - mu[i]);
        z[i] = eta[i] + (y[i] - mu[i]) / w[i];
      }
    }
    
    // Weighted least squares update
    const Xw = X.map((row, i) => row.map(v => v * Math.sqrt(w[i])));
    const zw = z.map((zi, i) => zi * Math.sqrt(w[i]));
    
    const Xt = transpose(Xw);
    const XtX = matMul(Xt, Xw);
    const Xtz = Xt.map(row => row.reduce((s, v, i) => s + v * zw[i], 0));
    const newBeta = solveLinearSystem(XtX, Xtz);
    if (!newBeta) break;
    
    const diff = Math.max(...newBeta.map((b, i) => Math.abs(b - beta[i])));
    beta = newBeta;
    if (diff < 1e-6) break;
  }
  
  // Standard errors
  const eta = X.map(row => row.reduce((s, v, j) => s + v * beta[j], 0));
  const w = eta.map((e, i) => {
    if (modelType === 'glmm_poisson') return Math.exp(Math.min(20, e));
    const mu = 1 / (1 + Math.exp(-e));
    return mu * (1 - mu);
  });
  
  const Xw = X.map((row, i) => row.map(v => v * Math.sqrt(w[i])));
  const Xt = transpose(Xw);
  const XtX = matMul(Xt, Xw);
  const XtXinv = invMatrix(XtX);
  const se = XtXinv ? XtXinv.map((row, i) => Math.sqrt(Math.max(0, row[i]))) : new Array(p).fill(NaN);
  
  // Build output
  const fixedEffects = [];
  let idx = 0;
  fixedEffects.push({ name: '(Intercept)', estimate: beta[idx], se: se[idx], t: beta[idx] / se[idx], p: 2 * (1 - normalCdf(Math.abs(beta[idx] / se[idx]))) });
  idx++;
  
  if (includeGroup) {
    for (const g of groupNames.slice(1)) {
      fixedEffects.push({ name: `group:${g}`, estimate: beta[idx], se: se[idx], t: beta[idx] / se[idx], p: 2 * (1 - normalCdf(Math.abs(beta[idx] / se[idx]))) });
      idx++;
    }
  }
  if (includeDocLen) {
    fixedEffects.push({ name: 'log(tokens)', estimate: beta[idx], se: se[idx], t: beta[idx] / se[idx], p: 2 * (1 - normalCdf(Math.abs(beta[idx] / se[idx]))) });
  }
  
  // Log-likelihood (deviance-based approximation)
  let deviance = 0;
  for (let i = 0; i < n; i++) {
    let xb = 0;
    for (let j = 0; j < p; j++) xb += X[i][j] * beta[j];
    if (modelType === 'glmm_poisson') {
      const mu = Math.exp(Math.min(20, xb));
      deviance += 2 * (y[i] > 0 ? y[i] * Math.log(y[i] / mu) : 0) - 2 * (y[i] - mu);
    } else {
      const mu = 1 / (1 + Math.exp(-xb));
      if (y[i] === 1) deviance += -2 * Math.log(mu);
      else deviance += -2 * Math.log(1 - mu);
    }
  }
  
  const logLik = -deviance / 2;
  const nParams = p + 1;
  const aic = deviance + 2 * nParams;
  const bic = deviance + Math.log(n) * nParams;
  
  return {
    fixedEffects,
    randomVariance: sigma2_u,
    residualVariance: NaN,
    logLik,
    aic,
    bic
  };
}

function clearMixedModel() {
  document.getElementById('mixedModelStatus').textContent = '';
  document.getElementById('mixedModelResults').style.display = 'none';
  __lastMixedResult = null;
}

function exportMixedModelExcel() {
  if (!__lastMixedResult) {
    alert('No mixed model results to export. Fit a model first.');
    return;
  }
  const r = __lastMixedResult;
  let html = `<html><head><meta charset="UTF-8"></head><body>
    <h3>Mixed Effects Model Results</h3>
    <p>AIC: ${r.aic?.toFixed(2) || 'NA'}, BIC: ${r.bic?.toFixed(2) || 'NA'}, Log-lik: ${r.logLik?.toFixed(2) || 'NA'}</p>
    <h4>Fixed Effects</h4>
    <table border="1"><tr><th>Effect</th><th>Estimate</th><th>SE</th><th>t/z</th><th>p</th></tr>`;
  for (const fe of r.fixedEffects || []) {
    html += `<tr><td>${escapeHtml(fe.name)}</td><td>${fe.estimate?.toFixed(4) || 'NA'}</td><td>${fe.se?.toFixed(4) || 'NA'}</td><td>${fe.t?.toFixed(3) || 'NA'}</td><td>${fe.p?.toExponential(3) || 'NA'}</td></tr>`;
  }
  html += '</table>';
  html += `<h4>Random Effects</h4><p>Random intercept variance: ${r.randomVariance?.toFixed(4) || 'NA'}</p>`;
  if (r.residualVariance) {
    html += `<p>Residual variance: ${r.residualVariance?.toFixed(4) || 'NA'}</p>`;
  }
  html += '</body></html>';
  
  const blob = new Blob([html], { type: 'application/vnd.ms-excel' });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = 'mixed_model_results.xls';
  a.click();
  URL.revokeObjectURL(url);
}

function exportMixedModelPng() {
  const canvas = document.getElementById('mixedCanvas');
  if (!canvas) {
    alert('No mixed model visualization to export.');
    return;
  }
  const url = canvas.toDataURL('image/png');
  const a = document.createElement('a');
  a.href = url;
  a.download = 'mixed_model_forest.png';
  a.click();
}

function drawMixedForest(fixedEffects) {
  const canvas = document.getElementById('mixedCanvas');
  if (!canvas || !fixedEffects || fixedEffects.length === 0) return;
  
  const ctx = canvas.getContext('2d');
  const W = canvas.width;
  const H = canvas.height;
  ctx.clearRect(0, 0, W, H);
  
  // Filter out intercept for forest plot
  const effects = fixedEffects.filter(e => e.name !== '(Intercept)');
  if (effects.length === 0) {
    ctx.fillStyle = '#666';
    ctx.font = '12px sans-serif';
    ctx.textAlign = 'center';
    ctx.fillText('No fixed effects to plot (only intercept).', W / 2, H / 2);
    return;
  }
  
  const margin = { top: 30, right: 50, bottom: 40, left: 150 };
  const plotW = W - margin.left - margin.right;
  const plotH = H - margin.top - margin.bottom;
  
  const rowHeight = Math.min(25, plotH / effects.length);
  const rowGap = (plotH - rowHeight * effects.length) / (effects.length + 1);
  
  // Determine x-axis range
  let minX = 0, maxX = 0;
  effects.forEach(e => {
    const ci95 = 1.96 * (e.se || 0);
    minX = Math.min(minX, e.estimate - ci95);
    maxX = Math.max(maxX, e.estimate + ci95);
  });
  const range = Math.max(Math.abs(minX), Math.abs(maxX)) * 1.2;
  minX = -range;
  maxX = range;
  
  const scaleX = v => margin.left + ((v - minX) / (maxX - minX)) * plotW;
  
  // Draw zero line
  const zeroX = scaleX(0);
  ctx.strokeStyle = '#999';
  ctx.lineWidth = 1;
  ctx.setLineDash([4, 4]);
  ctx.beginPath();
  ctx.moveTo(zeroX, margin.top);
  ctx.lineTo(zeroX, H - margin.bottom);
  ctx.stroke();
  ctx.setLineDash([]);
  
  // Draw x-axis
  ctx.strokeStyle = '#333';
  ctx.beginPath();
  ctx.moveTo(margin.left, H - margin.bottom);
  ctx.lineTo(W - margin.right, H - margin.bottom);
  ctx.stroke();
  
  // X-axis labels
  ctx.fillStyle = '#333';
  ctx.font = '10px sans-serif';
  ctx.textAlign = 'center';
  for (let i = 0; i <= 4; i++) {
    const val = minX + (maxX - minX) * i / 4;
    const x = margin.left + plotW * i / 4;
    ctx.fillText(val.toFixed(2), x, H - margin.bottom + 15);
  }
  ctx.fillText('Estimate (β)', W / 2, H - 5);
  
  // Draw effects
  effects.forEach((e, i) => {
    const y = margin.top + rowGap * (i + 1) + rowHeight * i + rowHeight / 2;
    const x = scaleX(e.estimate);
    const ci95 = 1.96 * (e.se || 0);
    const xLo = scaleX(e.estimate - ci95);
    const xHi = scaleX(e.estimate + ci95);
    
    // CI line
    ctx.strokeStyle = e.p < 0.05 ? '#3b82f6' : '#94a3b8';
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(xLo, y);
    ctx.lineTo(xHi, y);
    ctx.stroke();
    
    // Point estimate
    ctx.fillStyle = e.p < 0.05 ? '#3b82f6' : '#94a3b8';
    ctx.beginPath();
    ctx.arc(x, y, 5, 0, Math.PI * 2);
    ctx.fill();
    
    // Label
    ctx.fillStyle = '#333';
    ctx.font = '11px sans-serif';
    ctx.textAlign = 'right';
    const label = e.name.length > 18 ? e.name.substring(0, 16) + '...' : e.name;
    ctx.fillText(label, margin.left - 5, y + 4);
  });
  
  // Title
  ctx.fillStyle = '#333';
  ctx.font = 'bold 12px sans-serif';
  ctx.textAlign = 'center';
  ctx.fillText('Fixed Effects Forest Plot (95% CI)', W / 2, 15);
}

// Dunn's test (pairwise) based on rank sums; Holm correction
function dunnPosthoc(groups) {
  const names = Object.keys(groups);
  const all = [];
  for (const g of names) for (const v of groups[g]) all.push({ v, g });
  const N = all.length;
  all.sort((a, b) => a.v - b.v);

  // ranks with average ties + tie correction term for variance
  const ranks = new Array(N);
  let i = 0;
  let tieSum = 0;
  while (i < N) {
    let j = i;
    while (j + 1 < N && all[j + 1].v === all[i].v) j++;
    const avgRank = (i + 1 + j + 1) / 2;
    for (let t = i; t <= j; t++) ranks[t] = avgRank;
    const tieSize = j - i + 1;
    if (tieSize > 1) tieSum += (tieSize * tieSize * tieSize - tieSize);
    i = j + 1;
  }

  const R = {};
  const n = {};
  for (const g of names) { R[g] = 0; n[g] = 0; }
  for (let idx = 0; idx < N; idx++) {
    const g = all[idx].g;
    R[g] += ranks[idx];
    n[g] += 1;
  }
  const meanRank = (N + 1) / 2;
  const varRank = (N * (N + 1) / 12) - (tieSum / (12 * (N - 1)));

  const comps = [];
  for (let a = 0; a < names.length; a++) {
    for (let b = a + 1; b < names.length; b++) {
      const g1 = names[a], g2 = names[b];
      if (n[g1] === 0 || n[g2] === 0) continue;
      const z = (R[g1] / n[g1] - R[g2] / n[g2]) / Math.sqrt(varRank * (1 / n[g1] + 1 / n[g2]));
      const p = normalPValueTwoSided(z);
      comps.push({ a: g1, b: g2, stat: z, p });
    }
  }
  const adj = holmAdjust(comps.map(x => x.p));
  comps.forEach((x, i) => x.pAdj = adj[i]);
  return comps.sort((x, y) => x.pAdj - y.pAdj);
}

// ANOVA-style pairwise comparisons (t-based approximation), Holm correction
function anovaPosthocApprox(groups, msw) {
  const names = Object.keys(groups);
  const comps = [];
  for (let a = 0; a < names.length; a++) {
    for (let b = a + 1; b < names.length; b++) {
      const g1 = names[a], g2 = names[b];
      const x1 = groups[g1], x2 = groups[g2];
      if (!x1.length || !x2.length) continue;
      const m1 = _mean(x1), m2 = _mean(x2);
      const se = Math.sqrt((msw || 0) * (1 / x1.length + 1 / x2.length));
      const t = se > 0 ? (m1 - m2) / se : 0;
      // Approximate p using normal (conservative when df is large; acceptable for quick screening)
      const p = normalPValueTwoSided(t);
      comps.push({ a: g1, b: g2, stat: t, p });
    }
  }
  const adj = holmAdjust(comps.map(x => x.p));
  comps.forEach((x, i) => x.pAdj = adj[i]);
  return comps.sort((x, y) => x.pAdj - y.pAdj);
}

// Draw boxplot
function drawBoxplot(canvas, groups) {
  if (!canvas) return;
  const ctx = canvas.getContext('2d');
  const w = canvas.width;
  const h = canvas.height;
  ctx.clearRect(0, 0, w, h);

  const names = Object.keys(groups);
  if (!names.length) return;

  // compute global min/max
  let globalMin = Infinity, globalMax = -Infinity;
  const stats = {};
  for (const g of names) {
    const arr = groups[g].slice().sort((a, b) => a - b);
    if (!arr.length) continue;
    const q1 = _quantile(arr, 0.25);
    const q2 = _quantile(arr, 0.5);
    const q3 = _quantile(arr, 0.75);
    const iqr = q3 - q1;
    const low = q1 - 1.5 * iqr;
    const high = q3 + 1.5 * iqr;
    let whiskLow = arr.find(v => v >= low);
    let whiskHigh = [...arr].reverse().find(v => v <= high);
    if (whiskLow === undefined) whiskLow = arr[0];
    if (whiskHigh === undefined) whiskHigh = arr[arr.length - 1];
    const outliers = arr.filter(v => v < whiskLow || v > whiskHigh);
    stats[g] = { q1, q2, q3, whiskLow, whiskHigh, outliers };
    globalMin = Math.min(globalMin, whiskLow, ...outliers);
    globalMax = Math.max(globalMax, whiskHigh, ...outliers);
  }
  if (globalMin === Infinity) return;
  if (globalMin === globalMax) { globalMin -= 1; globalMax += 1; }

  // padding and scale
  const padL = 60, padR = 20, padT = 20, padB = 40;
  const plotW = w - padL - padR;
  const plotH = h - padT - padB;
  const yScale = (val) => padT + (globalMax - val) * (plotH / (globalMax - globalMin));

  // axes
  ctx.strokeStyle = '#9ca3af';
  ctx.lineWidth = 1;
  ctx.beginPath();
  ctx.moveTo(padL, padT);
  ctx.lineTo(padL, padT + plotH);
  ctx.lineTo(padL + plotW, padT + plotH);
  ctx.stroke();

  // y-axis ticks
  ctx.fillStyle = '#374151';
  ctx.font = '12px system-ui, -apple-system, Segoe UI, sans-serif';
  const ticks = 4;
  for (let i = 0; i <= ticks; i++) {
    const val = globalMin + (globalMax - globalMin) * (i / ticks);
    const y = yScale(val);
    ctx.strokeStyle = '#e5e7eb';
    ctx.beginPath();
    ctx.moveTo(padL, y);
    ctx.lineTo(padL + plotW, y);
    ctx.stroke();
    ctx.fillStyle = '#374151';
    ctx.fillText(val.toFixed(2), 5, y + 4);
  }

  // boxes
  const step = plotW / names.length;
  const boxW = Math.max(18, Math.min(46, step * 0.5));
  for (let i = 0; i < names.length; i++) {
    const g = names[i];
    const s = stats[g];
    if (!s) continue;
    const cx = padL + step * (i + 0.5);

    const yQ1 = yScale(s.q1);
    const yQ2 = yScale(s.q2);
    const yQ3 = yScale(s.q3);
    const yWL = yScale(s.whiskLow);
    const yWH = yScale(s.whiskHigh);

    // whisker line
    ctx.strokeStyle = '#111827';
    ctx.beginPath();
    ctx.moveTo(cx, yWH);
    ctx.lineTo(cx, yWL);
    ctx.stroke();

    // whisker caps
    ctx.beginPath();
    ctx.moveTo(cx - boxW * 0.35, yWH);
    ctx.lineTo(cx + boxW * 0.35, yWH);
    ctx.moveTo(cx - boxW * 0.35, yWL);
    ctx.lineTo(cx + boxW * 0.35, yWL);
    ctx.stroke();

    // box
    ctx.fillStyle = 'rgba(59,130,246,0.12)';
    ctx.strokeStyle = '#2563eb';
    ctx.lineWidth = 1.5;
    ctx.beginPath();
    ctx.rect(cx - boxW / 2, yQ3, boxW, Math.max(1, yQ1 - yQ3));
    ctx.fill();
    ctx.stroke();

    // median
    ctx.strokeStyle = '#dc2626';
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(cx - boxW / 2, yQ2);
    ctx.lineTo(cx + boxW / 2, yQ2);
    ctx.stroke();

    // outliers
    ctx.fillStyle = '#111827';
    for (const o of s.outliers) {
      const y = yScale(o);
      ctx.beginPath();
      ctx.arc(cx, y, 2, 0, Math.PI * 2);
      ctx.fill();
    }

    // label
    ctx.fillStyle = '#111827';
    ctx.font = '12px system-ui, -apple-system, Segoe UI, sans-serif';
    const label = String(g);
    ctx.save();
    ctx.translate(cx, padT + plotH + 18);
    ctx.rotate(-Math.PI / 10);
    ctx.textAlign = 'center';
    ctx.fillText(label.length > 16 ? label.slice(0, 16) + '…' : label, 0, 0);
    ctx.restore();
  }
}

function populateDistTestFeatureList() {
  const sel = document.getElementById('distTestFeatureSelect');
  if (!sel) return;

  sel.innerHTML = '';
  
  // Use effective data (respects filters and deletions from 9-a)
  const effectiveData = getEffectiveFreqTableData();
  if (!effectiveData || !effectiveData.features || !effectiveData.features.length) {
    const opt = document.createElement('option');
    opt.value = '';
    opt.textContent = '(compute 9-a Frequency Table first)';
    sel.appendChild(opt);
    return;
  }

  for (const f of effectiveData.features) {
    const opt = document.createElement('option');
    opt.value = f;
    opt.textContent = f;
    sel.appendChild(opt);
  }

  if (typeof populateAdv11bFeatureList === 'function') { try { populateAdv11bFeatureList(); } catch(e){} }
}

function runDistTestFileLevel() {
  const status = document.getElementById('distTestStatus');
  const summary = document.getElementById('distTestSummary');
  const posthocWrap = document.getElementById('distTestPosthocWrapper');
  const posthocBody = document.getElementById('distTestPosthocBody');
  const box = document.getElementById('distTestBoxplot');

  status.textContent = 'Computing...';
  summary.style.display = 'none';
  posthocWrap.style.display = 'none';
  posthocBody.innerHTML = '<tr><td colspan="5" class="text-xs">No post-hoc results.</td></tr>';

  if (!corpus || !corpus.files || Object.keys(corpus.files).length === 0) {
    status.textContent = 'Please load a corpus first.';
    return;
  }
  
  // Use effective data (respects filters and deletions from 9-a)
  const effectiveData = getEffectiveFreqTableData();
  if (!effectiveData || !effectiveData.features || !effectiveData.features.length) {
    status.textContent = 'Please compute 9-a) Frequency Table first (so features are defined).';
    return;
  }

  const feature = document.getElementById('distTestFeatureSelect')?.value || '';
  if (!feature) {
    status.textContent = 'Please select a feature.';
    return;
  }

  const data = getFileLevelValuesForFeature(feature);
  if (!data) {
    status.textContent = 'Cannot compute file-level values for this feature (check Tagged mode requirements).';
    return;
  }

  let { groups: baseGroups, groupNames: baseGroupNames, nFiles } = data;

  // Apply folder selection / grouping spec (9-c UI, optionally shared with 9-b)
  const spec = getDistTestGroupingSpec();
  let groups = {};
  let groupNames = [];

  function filterToFolders(folders) {
    const keep = new Set((folders || []).filter(Boolean));
    const names = baseGroupNames.filter(g => keep.size === 0 ? true : keep.has(g));
    const out = {};
    for (const g of names) out[g] = Array.isArray(baseGroups[g]) ? baseGroups[g].slice() : [];
    return { out, names };
  }

  if (spec.mode === 'customGroups') {
    const custom = (spec.groups || []).filter(g => g && Array.isArray(g.folders) && g.folders.length);
    if (custom.length >= 2) {
      // validate duplicates across groups
      const used = new Set();
      for (const g of custom) {
        for (const f of g.folders) {
          if (used.has(f)) {
            status.textContent = `Folder "${f}" is assigned to multiple groups. Please fix Custom groups.`;
            drawBoxplot(box, {});
            return;
          }
          used.add(f);
        }
      }
      for (const g of custom) {
        const vals = [];
        for (const f of g.folders) {
          if (Array.isArray(baseGroups[f])) vals.push(...baseGroups[f]);
        }
        groups[g.name] = vals;
      }
      groupNames = Object.keys(groups);
    } else {
      status.textContent = 'Need at least 2 custom groups (with folders selected).';
      drawBoxplot(box, {});
      return;
    }
  } else if (spec.mode === 'oneVsRest') {
    const focus = spec.focus || '';
    const selFolders = (spec.folders && spec.folders.length) ? spec.folders : baseGroupNames;
    if (!focus) {
      status.textContent = 'Please choose a Focus folder for One-vs-Rest.';
      drawBoxplot(box, {});
      return;
    }
    const { out, names } = filterToFolders(selFolders);
    if (!names.includes(focus)) {
      status.textContent = 'Focus folder must be included in the selected folders.';
      drawBoxplot(box, {});
      return;
    }
    const restVals = [];
    for (const n of names) {
      if (n === focus) continue;
      restVals.push(...(out[n] || []));
    }
    groups[focus] = (out[focus] || []);
    groups['Rest'] = restVals;
    groupNames = [focus, 'Rest'];
  } else if (spec.mode === 'pairwise') {
    const folders = (spec.folders || []).filter(Boolean);
    const unique = Array.from(new Set(folders));
    if (unique.length !== 2) {
      status.textContent = 'Pairwise mode requires exactly 2 folders selected.';
      drawBoxplot(box, {});
      return;
    }
    const { out } = filterToFolders(unique);
    groups = out;
    groupNames = unique;
  } else {
    // perFolder
    const folders = (spec.folders && spec.folders.length) ? spec.folders : baseGroupNames;
    const { out, names } = filterToFolders(folders);
    groups = out;
    groupNames = names;
  }

  // Apply min-n filter if folderMeta is available and mode is perFolder/pairwise/oneVsRest
  const minN = parseInt(document.getElementById('distTestMinFiles')?.value, 10) || 1;
  const meta = (freqTableData && freqTableData.folderMeta) ? freqTableData.folderMeta : ((typeof metaSource !== 'undefined') ? metaSource : null);
  if (meta && (spec.mode !== 'customGroups')) {
    const filtered = {};
    const filteredNames = [];
    for (const g of groupNames) {
      // Rest has no folderMeta
      if (g === 'Rest') { filtered[g] = groups[g]; filteredNames.push(g); continue; }
      const nf = meta[g] && typeof meta[g].nFiles === 'number' ? meta[g].nFiles : null;
      if (nf !== null && nf < minN) continue;
      filtered[g] = groups[g];
      filteredNames.push(g);
    }
    groups = filtered;
    groupNames = filteredNames;
  }

  const k = groupNames.length;

  // require at least 2 groups
  if (k < 2) {
    status.textContent = 'Please select at least two folders (groups) in 3) Target/Reference or choose Scope=All.';
    drawBoxplot(box, {});
    return;
  }

  // run test
  const method = document.getElementById('distTestMethod')?.value || 'kw';
  let result;
  if (method === 'anova') {
    result = oneWayAnova(groups);
    document.getElementById('distTestDf').textContent = `${result.df1}, ${result.df2}`;
  } else if (method === 'welch') {
    result = welchAnova(groups);
    document.getElementById('distTestDf').textContent = `${result.df1.toFixed(0)}, ${result.df2.toFixed(2)}`;
  } else {
    result = kruskalWallis(groups);
    document.getElementById('distTestDf').textContent = `${result.df}`;
  }

  // output
  document.getElementById('distTestStat').textContent = `${result.stat.toFixed(4)}` + (method === 'kw' ? ' (H)' : ' (F)');
  document.getElementById('distTestP').textContent = `${result.p.toExponential(3)}${result.p < 0.05 ? ' *' : ''}`;
  document.getElementById('distTestEffect').textContent = `${result.effectLabel}: ${result.effect.toFixed(4)}`;
  document.getElementById('distTestN').textContent = `${nFiles}`;
  document.getElementById('distTestK').textContent = `${k}`;
  summary.style.display = 'block';

  // boxplot
  drawBoxplot(box, groups);

  
  // posthoc
  const doPosthoc = document.getElementById('distTestPosthoc')?.checked ?? true;
  const alpha = parseFloat(document.getElementById('distTestAlpha')?.value || '0.05') || 0.05;
  if (doPosthoc) {
    let comps = [];
    if (method === 'kw') {
      comps = dunnPosthoc(groups).map(x => ({ ...x, statLabel: 'z', pAdjLabel: 'Holm' }));
    } else if (method === 'anova') {
      const msw = result.msw || 0;
      comps = tukeyHSD(groups, msw, result.df2).map(x => ({ ...x, statLabel: 'q', pAdjLabel: 'Tukey' }));
    } else {
      comps = gamesHowell(groups).map(x => ({ ...x, statLabel: 'q', pAdjLabel: 'Games-Howell' }));
    }

    if (comps.length) {
      posthocBody.innerHTML = '';
      for (const c of comps) {
        const tr = document.createElement('tr');
        tr.innerHTML = `
          <td>${escapeHtml(c.a)}</td>
          <td>${escapeHtml(c.b)}</td>
          <td>${c.statLabel}: ${Number(c.stat).toFixed(4)}</td>
          <td>${Number(c.p).toExponential(3)}</td>
          <td>${Number(c.pAdj).toExponential(3)} <span class="text-xs" style="color:#6b7280;">(${escapeHtml(c.pAdjLabel)})</span></td>
        `;
        posthocBody.appendChild(tr);
      }
      posthocWrap.style.display = 'block';
    }
  }

  status.textContent = `Done. (Feature="${feature}")`;

}

function clearDistTestFileLevel() {
  const status = document.getElementById('distTestStatus');
  const summary = document.getElementById('distTestSummary');
  const posthocWrap = document.getElementById('distTestPosthocWrapper');
  const posthocBody = document.getElementById('distTestPosthocBody');
  const box = document.getElementById('distTestBoxplot');
  status.textContent = '';
  summary.style.display = 'none';
  posthocWrap.style.display = 'none';
  posthocBody.innerHTML = '<tr><td colspan="5" class="text-xs">No post-hoc results.</td></tr>';
  if (box) {
    const ctx = box.getContext('2d');
    ctx.clearRect(0, 0, box.width, box.height);
  }
}
// ---- Research Mode: GLM (Poisson/NB/ZIP/ZINB) on per-file outcomes ----

// Build model dataset for selected feature (counts + exposure)
function getFileLevelModelDataForFeature(feature, outcomeMode) {
  if (!corpus || !corpus.files) return null;

  const featureType = document.getElementById('freqTableFeatureType')?.value || 'word';
  const n = parseInt(document.getElementById('freqTableN')?.value, 10) || 4;
  const caseInsensitive = document.getElementById('freqTableCaseInsensitive')?.checked ?? true;
  const respectBoundary = document.getElementById('respectSentenceBoundary')?.checked ?? true;

  const scopeEl = document.querySelector('input[name="freqTableScope"]:checked');
  const scope = scopeEl ? scopeEl.value : 'target';

  const allowedFolders = new Set();
  if (scope === 'all') {
    for (const f of Object.keys(corpus.folders || {})) allowedFolders.add(f);
  } else if (scope === 'target') {
    for (const f of targetFolders) allowedFolders.add(f);
  } else if (scope === 'reference') {
    for (const f of referenceFolders) allowedFolders.add(f);
  } else if (scope === 'all') {
    for (const f of targetFolders) allowedFolders.add(f);
    for (const f of referenceFolders) allowedFolders.add(f);
  } else {
    for (const f of Object.keys(corpus.folders || {})) allowedFolders.add(f);
  }

  const featureLower = caseInsensitive ? String(feature).toLowerCase() : String(feature);
  const rows = [];
  const fileNames = Object.keys(corpus.files);

  function isIgnorableToken(tok) {
    if (!tok) return true;
    if (tok.isSpace) return true;
    if (tok.isPunct) return true;
    if (tok.poss === 'SPACE' || tok.posd === 'SPACE') return true;
    return false;
  }
  function tokWord(tok) {
    const w = tok.word ?? tok.surface ?? tok.form ?? '';
    return caseInsensitive ? String(w).toLowerCase() : String(w);
  }
  function tokLemma(tok) {
    const w = tok.lemma ?? tok.word ?? tok.surface ?? tok.form ?? '';
    return caseInsensitive ? String(w).toLowerCase() : String(w);
  }

  for (const fileName of fileNames) {
    const file = corpus.files[fileName];
    if (!file) continue;
    const folder = file.folder || 'Ungrouped';
    if (!allowedFolders.has(folder)) continue;

    const tokens = file.tokens || [];
    let totalTokens = 0;
    let count = 0;

    if (featureType === 'word') {
      for (const tok of tokens) {
        if (isIgnorableToken(tok)) continue;
        totalTokens++;
        if (tokWord(tok) === featureLower) count++;
      }
    } else if (featureType === 'lemma') {
      for (const tok of tokens) {
        if (isIgnorableToken(tok)) continue;
        totalTokens++;
        if (tokLemma(tok) === featureLower) count++;
      }
    } else if (featureType === 'pos_simple') {
      if (corpus.mode !== 'tagged' && corpus.mode !== 'csv') return null;
      for (const tok of tokens) {
        if (isIgnorableToken(tok)) continue;
        totalTokens++;
        if (String(tok.poss || '') === String(feature)) count++;
      }
    } else if (featureType === 'pos_detailed') {
      if (corpus.mode !== 'tagged' && corpus.mode !== 'csv') return null;
      for (const tok of tokens) {
        if (isIgnorableToken(tok)) continue;
        totalTokens++;
        if (String(tok.posd || '') === String(feature)) count++;
      }
    } else {
      // fallback: use same per-file value extractor, but convert NF/DF to count by scanning grams
      const sents = file.sentences || [{ tokenStart: 0, tokenEnd: tokens.length }];
      const segments = [];
      for (const sent of sents) {
        let subSegs;
        if (typeof getSentenceSegments === 'function' && respectBoundary) {
          subSegs = getSentenceSegments(tokens, sent.tokenStart, sent.tokenEnd);
        } else {
          subSegs = [{ tokens: tokens.slice(sent.tokenStart, sent.tokenEnd) }];
        }
        for (const sub of subSegs) segments.push(sub.tokens);
      }

      const buildArr = (segTokens) => {
        const arr = [];
        if (featureType.startsWith('posgram')) {
          if (corpus.mode !== 'tagged' && corpus.mode !== 'csv') return arr;
          const posField = featureType.includes('detailed') ? 'posd' : 'poss';
          for (const tok of segTokens) {
            if (isIgnorableToken(tok)) continue;
            totalTokens++;
            const p = tok[posField];
            if (!p) continue;
            arr.push(String(p));
          }
        } else if (featureType.startsWith('ngrampos')) {
          if (corpus.mode !== 'tagged' && corpus.mode !== 'csv') return arr;
          const wordField = featureType.includes('lemma') ? 'lemma' : 'word';
          const posField = featureType.includes('detailed') ? 'posd' : 'poss';
          for (const tok of segTokens) {
            if (isIgnorableToken(tok)) continue;
            totalTokens++;
            let w = tok[wordField];
            if (!w) continue;
            w = caseInsensitive ? String(w).toLowerCase() : String(w);
            const p = tok[posField];
            if (!p) continue;
            arr.push(`${w}_${p}`);
          }
        } else {
          const wordField = featureType.includes('lemma') ? 'lemma' : 'word';
          for (const tok of segTokens) {
            if (isIgnorableToken(tok)) continue;
            totalTokens++;
            let w = tok[wordField];
            if (!w) continue;
            w = caseInsensitive ? String(w).toLowerCase() : String(w);
            arr.push(String(w));
          }
        }
        return arr;
      };

      const targetStr = caseInsensitive ? String(feature).toLowerCase() : String(feature);

      for (const segTokens of segments) {
        const arr = buildArr(segTokens);
        if (arr.length < n) continue;
        for (let i = 0; i <= arr.length - n; i++) {
          const key = arr.slice(i, i + n).join(' ');
          if (key === targetStr) count++;
        }
      }
    }

    const y = (outcomeMode === 'df') ? (count > 0 ? 1 : 0) : count;
    const offset = totalTokens > 0 ? Math.log(totalTokens) : 0;
    rows.push({ file: fileName, group: folder, y, offset, totalTokens });
  }

  return rows;
}

// Linear solver (Gaussian elimination) for small systems
function solveLinearSystem(A, b) {
  const n = A.length;
  const M = A.map((row, i) => row.slice().concat([b[i]]));
  for (let i = 0; i < n; i++) {
    // pivot
    let maxRow = i;
    for (let r = i + 1; r < n; r++) if (Math.abs(M[r][i]) > Math.abs(M[maxRow][i])) maxRow = r;
    const tmp = M[i]; M[i] = M[maxRow]; M[maxRow] = tmp;
    const piv = M[i][i];
    if (Math.abs(piv) < 1e-12) return null;
    for (let j = i; j <= n; j++) M[i][j] /= piv;
    for (let r = 0; r < n; r++) {
      if (r === i) continue;
      const f = M[r][i];
      for (let j = i; j <= n; j++) M[r][j] -= f * M[i][j];
    }
  }
  return M.map(row => row[n]);
}

function invertMatrix(A) {
  const n = A.length;
  const M = A.map((row, i) => row.slice().concat(Array.from({length:n}, (_,j)=> (i===j?1:0))));
  for (let i=0;i<n;i++){
    let maxRow=i;
    for (let r=i+1;r<n;r++) if (Math.abs(M[r][i])>Math.abs(M[maxRow][i])) maxRow=r;
    const tmp=M[i]; M[i]=M[maxRow]; M[maxRow]=tmp;
    const piv=M[i][i];
    if (Math.abs(piv)<1e-12) return null;
    for (let j=i;j<2*n;j++) M[i][j]/=piv;
    for (let r=0;r<n;r++){
      if(r===i) continue;
      const f=M[r][i];
      for (let j=i;j<2*n;j++) M[r][j]-=f*M[i][j];
    }
  }
  return M.map(row => row.slice(n));
}

// IRLS for Poisson/NB/logistic (with optional weights and offset)
function irlsFit(X, y, offset, family, thetaInit, weightsObs) {
  const n = y.length;
  const p = X[0].length;
  let beta = Array(p).fill(0);
  let theta = thetaInit || 10;

  const maxIter = 50;
  for (let it = 0; it < maxIter; it++) {
    const eta = new Array(n);
    const mu = new Array(n);
    const w = new Array(n);
    const z = new Array(n);

    for (let i = 0; i < n; i++) {
      let xb = 0;
      for (let j = 0; j < p; j++) xb += X[i][j] * beta[j];
      const off = offset ? offset[i] : 0;
      eta[i] = xb + off;

      if (family === 'logit') {
        const m = 1 / (1 + Math.exp(-eta[i]));
        mu[i] = Math.min(1 - 1e-8, Math.max(1e-8, m));
        const varMu = mu[i] * (1 - mu[i]);
        const wi = varMu > 0 ? varMu : 1e-8;
        w[i] = wi * (weightsObs ? weightsObs[i] : 1);
        z[i] = eta[i] + (y[i] - mu[i]) / (varMu || 1e-8);
      } else {
        const m = Math.exp(eta[i]);
        mu[i] = Math.max(1e-12, m);
        let varY = mu[i];
        if (family === 'negbin') varY = mu[i] + (mu[i] * mu[i]) / Math.max(1e-8, theta);
        const wi = (mu[i] * mu[i]) / Math.max(1e-12, varY);
        w[i] = wi * (weightsObs ? weightsObs[i] : 1);
        z[i] = eta[i] + (y[i] - mu[i]) / Math.max(1e-12, mu[i]);
      }
    }

    // Build XtWX and XtWz
    const XtWX = Array.from({ length: p }, () => Array(p).fill(0));
    const XtWz = Array(p).fill(0);

    for (let i = 0; i < n; i++) {
      for (let a = 0; a < p; a++) {
        const xia = X[i][a];
        const wx = w[i] * xia;
        XtWz[a] += wx * z[i];
        for (let b = 0; b < p; b++) XtWX[a][b] += wx * X[i][b];
      }
    }

    const betaNew = solveLinearSystem(XtWX, XtWz);
    if (!betaNew) break;

    // Update theta for NB using a moment-based dispersion estimate
    if (family === 'negbin') {
      let num = 0;
      let den = 0;
      for (let i = 0; i < n; i++) {
        const r = y[i] - mu[i];
        num += (r * r - y[i]);
        den += (mu[i] * mu[i]);
      }
      const disp = den > 0 ? Math.max(0, num / den) : 0;
      if (disp > 1e-10) theta = 1 / disp;
    }

    // Convergence
    let diff = 0;
    for (let j = 0; j < p; j++) diff += Math.abs(betaNew[j] - beta[j]);
    beta = betaNew;
    if (diff < 1e-6) break;
  }

  // Final information matrix for SE
  const n2 = y.length;
  const p2 = X[0].length;
  const eta = new Array(n2);
  const mu = new Array(n2);
  const w = new Array(n2);
  for (let i = 0; i < n2; i++) {
    let xb = 0;
    for (let j = 0; j < p2; j++) xb += X[i][j] * beta[j];
    const off = offset ? offset[i] : 0;
    eta[i] = xb + off;

    if (family === 'logit') {
      const m = 1 / (1 + Math.exp(-eta[i]));
      mu[i] = Math.min(1 - 1e-8, Math.max(1e-8, m));
      const varMu = mu[i] * (1 - mu[i]);
      w[i] = (varMu || 1e-8) * (weightsObs ? weightsObs[i] : 1);
    } else {
      const m = Math.exp(eta[i]);
      mu[i] = Math.max(1e-12, m);
      let varY = mu[i];
      if (family === 'negbin') varY = mu[i] + (mu[i] * mu[i]) / Math.max(1e-8, theta);
      const wi = (mu[i] * mu[i]) / Math.max(1e-12, varY);
      w[i] = wi * (weightsObs ? weightsObs[i] : 1);
    }
  }
  const XtWX = Array.from({ length: p2 }, () => Array(p2).fill(0));
  for (let i = 0; i < n2; i++) {
    for (let a = 0; a < p2; a++) {
      const xia = X[i][a];
      const wx = w[i] * xia;
      for (let b = 0; b < p2; b++) XtWX[a][b] += wx * X[i][b];
    }
  }
  const inv = invertMatrix(XtWX);
  const se = inv ? inv.map((row, i) => Math.sqrt(Math.max(0, row[i]))) : Array(p2).fill(NaN);
  return { beta, se, theta };
}

// Zero-inflated model with intercept-only inflation (EM), count model with covariates
function fitZeroInflated(rows, X, y, offset, baseFamily) {
  const n = y.length;
  let pi = 0.2; // inflation prob
  let theta = 10;
  let wObs = Array(n).fill(1);

  for (let it = 0; it < 30; it++) {
    // Fit count model on weighted observations
    const family = (baseFamily === 'negbin') ? 'negbin' : 'poisson';
    const fit = irlsFit(X, y, offset, family, theta, wObs);
    theta = fit.theta || theta;

    // Compute mu and tau for zeros
    let sumTau = 0;
    for (let i = 0; i < n; i++) {
      // linear predictor
      let xb = 0;
      for (let j = 0; j < X[i].length; j++) xb += X[i][j] * fit.beta[j];
      const mu = Math.exp(xb + (offset ? offset[i] : 0));

      let p0 = Math.exp(-mu);
      if (family === 'negbin') {
        const th = Math.max(1e-8, theta);
        p0 = Math.pow(th / (th + mu), th);
      }

      let tau = 0;
      if (y[i] === 0) {
        const denom = pi + (1 - pi) * p0;
        tau = denom > 0 ? (pi / denom) : 0;
      }
      wObs[i] = 1 - tau; // weight for count component
      sumTau += tau;
    }

    const piNew = Math.max(1e-6, Math.min(0.99, sumTau / n));
    if (Math.abs(piNew - pi) < 1e-5) { pi = piNew; return { fit, pi, theta, baseFamily: family }; }
    pi = piNew;
  }
  const family = (baseFamily === 'negbin') ? 'negbin' : 'poisson';
  const fit = irlsFit(X, y, offset, family, theta, wObs);
  return { fit, pi, theta: fit.theta || theta, baseFamily: family };
}

function fitDistModel() {
  const status = document.getElementById('distModelStatus');
  const body = document.getElementById('distModelBody');
  const resWrap = document.getElementById('distModelResults');

  status.textContent = 'Fitting...';
  resWrap.style.display = 'none';
  body.innerHTML = '<tr><td colspan="6" class="text-xs">No model fitted.</td></tr>';

  const feature = document.getElementById('distTestFeatureSelect')?.value || '';
  if (!feature) { status.textContent = 'Select a feature first.'; return; }

  const outcome = document.getElementById('distModelOutcome')?.value || 'count';
  const familySel = document.getElementById('distModelFamily')?.value || 'poisson';
  const baseline = document.getElementById('distModelBaseline')?.value || '';

  const rows = getFileLevelModelDataForFeature(feature, outcome === 'df' ? 'df' : 'count');
  if (!rows || !rows.length) { status.textContent = 'No model data available (check corpus/scope/tagged requirements).'; return; }

  const groups = Array.from(new Set(rows.map(r => r.group))).sort();
  if (!groups.length) { status.textContent = 'No groups found.'; return; }
  const base = baseline && groups.includes(baseline) ? baseline : groups[0];

  // Build design matrix (intercept + dummies excluding baseline)
  const termNames = ['(Intercept)'].concat(groups.filter(g => g !== base).map(g => `Group:${g}`));
  const p = termNames.length;
  const X = [];
  const y = [];
  const offset = [];
  for (const r of rows) {
    const row = Array(p).fill(0);
    row[0] = 1;
    let col = 1;
    for (const g of groups) {
      if (g === base) continue;
      row[col] = (r.group === g) ? 1 : 0;
      col++;
    }
    X.push(row);
    y.push(r.y);
    offset.push(r.offset);
  }

  let fit, zi = null;
  if (outcome === 'df') {
    // Logistic regression (binomial)
    fit = irlsFit(X, y, null, 'logit', 10, null);
  } else if (familySel === 'poisson') {
    fit = irlsFit(X, y, offset, 'poisson', 10, null);
  } else if (familySel === 'negbin') {
    fit = irlsFit(X, y, offset, 'negbin', 10, null);
  } else if (familySel === 'zip') {
    zi = fitZeroInflated(rows, X, y, offset, 'poisson');
    fit = zi.fit;
  } else {
    zi = fitZeroInflated(rows, X, y, offset, 'negbin');
    fit = zi.fit;
  }

  // Render results
  body.innerHTML = '';
  for (let j = 0; j < p; j++) {
    const beta = fit.beta[j];
    const se = fit.se[j];
    const z = (isFinite(se) && se > 0) ? beta / se : 0;
    const pval = normalPValueTwoSided(z);
    const rr = Math.exp(beta);
    const lo = Math.exp(beta - 1.96 * (se || 0));
    const hi = Math.exp(beta + 1.96 * (se || 0));
    const tr = document.createElement('tr');
    tr.innerHTML = `
      <td>${escapeHtml(termNames[j])}</td>
      <td>${isFinite(beta) ? beta.toFixed(4) : '-'}</td>
      <td>${isFinite(se) ? se.toFixed(4) : '-'}</td>
      <td>${isFinite(rr) ? rr.toFixed(4) : '-'}</td>
      <td>${isFinite(lo) && isFinite(hi) ? `[${lo.toFixed(4)}, ${hi.toFixed(4)}]` : '-'}</td>
      <td>${pval.toExponential(3)}${pval < 0.05 ? ' *' : ''}</td>
    `;
    body.appendChild(tr);
  }

  const extra = [];
  if (outcome !== 'df' && (familySel === 'negbin' || familySel === 'zinb')) extra.push(`theta≈${(fit.theta || 0).toFixed(3)}`);
  if (zi) extra.push(`pi≈${(zi.pi || 0).toFixed(3)} (zero-inflation, intercept-only)`);
  status.textContent = `Done. Baseline="${base}". ${extra.join(' | ')}`;
  
  // Store results for export
  window.__lastDistModelResult = {
    feature,
    outcome,
    family: familySel,
    baseline: base,
    groups,
    termNames,
    fit,
    zi,
    n: rows.length
  };
  
  // Draw forest plot
  drawDistModelForest(termNames, fit);
  
  resWrap.style.display = 'block';
}

function clearDistModel() {
  const status = document.getElementById('distModelStatus');
  const body = document.getElementById('distModelBody');
  const resWrap = document.getElementById('distModelResults');
  status.textContent = '';
  resWrap.style.display = 'none';
  body.innerHTML = '<tr><td colspan="6" class="text-xs">No model fitted.</td></tr>';
  window.__lastDistModelResult = null;
  const canvas = document.getElementById('distModelCanvas');
  if (canvas) {
    const ctx = canvas.getContext('2d');
    ctx.clearRect(0, 0, canvas.width, canvas.height);
  }
}

function exportDistModelExcel() {
  const r = window.__lastDistModelResult;
  if (!r) {
    alert('No GLM/GLMM results to export. Fit a model first.');
    return;
  }
  
  let html = `<html><head><meta charset="UTF-8"></head><body>
    <h3>GLM/GLMM Model Results</h3>
    <p>Feature: ${escapeHtml(r.feature)}</p>
    <p>Outcome: ${r.outcome}, Family: ${r.family}, Baseline: ${escapeHtml(r.baseline)}, n=${r.n}</p>
    <table border="1"><tr><th>Term</th><th>Estimate (β)</th><th>SE</th><th>IRR/OR</th><th>95% CI</th><th>p</th></tr>`;
  
  for (let j = 0; j < r.termNames.length; j++) {
    const beta = r.fit.beta[j];
    const se = r.fit.se[j];
    const rr = Math.exp(beta);
    const lo = Math.exp(beta - 1.96 * (se || 0));
    const hi = Math.exp(beta + 1.96 * (se || 0));
    const z = (isFinite(se) && se > 0) ? beta / se : 0;
    const pval = 2 * (1 - normalCdf(Math.abs(z)));
    html += `<tr><td>${escapeHtml(r.termNames[j])}</td><td>${beta?.toFixed(4) || 'NA'}</td><td>${se?.toFixed(4) || 'NA'}</td><td>${rr?.toFixed(4) || 'NA'}</td><td>[${lo?.toFixed(4) || 'NA'}, ${hi?.toFixed(4) || 'NA'}]</td><td>${pval?.toExponential(3) || 'NA'}</td></tr>`;
  }
  html += '</table>';
  if (r.fit.theta) html += `<p>Theta (dispersion): ${r.fit.theta.toFixed(4)}</p>`;
  if (r.zi) html += `<p>Zero-inflation (π): ${r.zi.pi?.toFixed(4) || 'NA'}</p>`;
  html += '</body></html>';
  
  const blob = new Blob([html], { type: 'application/vnd.ms-excel' });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = 'glm_results.xls';
  a.click();
  URL.revokeObjectURL(url);
}

function exportDistModelPng() {
  const canvas = document.getElementById('distModelCanvas');
  if (!canvas) {
    alert('No GLM visualization to export.');
    return;
  }
  const url = canvas.toDataURL('image/png');
  const a = document.createElement('a');
  a.href = url;
  a.download = 'glm_forest_plot.png';
  a.click();
}

function drawDistModelForest(termNames, fit) {
  const canvas = document.getElementById('distModelCanvas');
  if (!canvas || !fit || !fit.beta) return;
  
  const ctx = canvas.getContext('2d');
  const W = canvas.width;
  const H = canvas.height;
  ctx.clearRect(0, 0, W, H);
  
  // Filter out intercept
  const effects = [];
  for (let j = 0; j < termNames.length; j++) {
    if (termNames[j] === '(Intercept)') continue;
    const beta = fit.beta[j];
    const se = fit.se[j];
    const z = (isFinite(se) && se > 0) ? beta / se : 0;
    const p = 2 * (1 - normalCdf(Math.abs(z)));
    effects.push({ name: termNames[j], estimate: beta, se, p });
  }
  
  if (effects.length === 0) {
    ctx.fillStyle = '#666';
    ctx.font = '12px sans-serif';
    ctx.textAlign = 'center';
    ctx.fillText('No effects to plot (only intercept).', W / 2, H / 2);
    return;
  }
  
  const margin = { top: 30, right: 50, bottom: 40, left: 150 };
  const plotW = W - margin.left - margin.right;
  const plotH = H - margin.top - margin.bottom;
  
  const rowHeight = Math.min(25, plotH / effects.length);
  const rowGap = (plotH - rowHeight * effects.length) / (effects.length + 1);
  
  // Determine x-axis range (for IRR/OR, use log scale centered at 1)
  let minX = 0, maxX = 0;
  effects.forEach(e => {
    const ci95 = 1.96 * (e.se || 0);
    minX = Math.min(minX, e.estimate - ci95);
    maxX = Math.max(maxX, e.estimate + ci95);
  });
  const range = Math.max(Math.abs(minX), Math.abs(maxX)) * 1.2;
  minX = -range;
  maxX = range;
  
  const scaleX = v => margin.left + ((v - minX) / (maxX - minX)) * plotW;
  
  // Draw zero line (no effect)
  const zeroX = scaleX(0);
  ctx.strokeStyle = '#999';
  ctx.lineWidth = 1;
  ctx.setLineDash([4, 4]);
  ctx.beginPath();
  ctx.moveTo(zeroX, margin.top);
  ctx.lineTo(zeroX, H - margin.bottom);
  ctx.stroke();
  ctx.setLineDash([]);
  
  // Draw x-axis
  ctx.strokeStyle = '#333';
  ctx.beginPath();
  ctx.moveTo(margin.left, H - margin.bottom);
  ctx.lineTo(W - margin.right, H - margin.bottom);
  ctx.stroke();
  
  // X-axis labels
  ctx.fillStyle = '#333';
  ctx.font = '10px sans-serif';
  ctx.textAlign = 'center';
  for (let i = 0; i <= 4; i++) {
    const val = minX + (maxX - minX) * i / 4;
    const x = margin.left + plotW * i / 4;
    ctx.fillText(val.toFixed(2), x, H - margin.bottom + 15);
  }
  ctx.fillText('Log(IRR/OR)', W / 2, H - 5);
  
  // Draw effects
  effects.forEach((e, i) => {
    const y = margin.top + rowGap * (i + 1) + rowHeight * i + rowHeight / 2;
    const x = scaleX(e.estimate);
    const ci95 = 1.96 * (e.se || 0);
    const xLo = scaleX(e.estimate - ci95);
    const xHi = scaleX(e.estimate + ci95);
    
    // CI line
    ctx.strokeStyle = e.p < 0.05 ? '#dc2626' : '#94a3b8';
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(xLo, y);
    ctx.lineTo(xHi, y);
    ctx.stroke();
    
    // Point estimate
    ctx.fillStyle = e.p < 0.05 ? '#dc2626' : '#94a3b8';
    ctx.beginPath();
    ctx.arc(x, y, 5, 0, Math.PI * 2);
    ctx.fill();
    
    // Label
    ctx.fillStyle = '#333';
    ctx.font = '11px sans-serif';
    ctx.textAlign = 'right';
    const label = e.name.length > 18 ? e.name.substring(0, 16) + '...' : e.name;
    ctx.fillText(label, margin.left - 5, y + 4);
  });
  
  // Title
  ctx.fillStyle = '#333';
  ctx.font = 'bold 12px sans-serif';
  ctx.textAlign = 'center';
  ctx.fillText('Coefficient Forest Plot (95% CI)', W / 2, 15);
}

function populateDistModelBaselineOptions() {
  const sel = document.getElementById('distModelBaseline');
  if (!sel || !corpus || !corpus.files) return;
  const scopeEl = document.querySelector('input[name="freqTableScope"]:checked');
  const scope = scopeEl ? scopeEl.value : 'target';

  const allowedFolders = new Set();
  if (scope === 'all') {
    for (const f of Object.keys(corpus.folders || {})) allowedFolders.add(f);
  } else if (scope === 'target') {
    for (const f of targetFolders) allowedFolders.add(f);
  } else if (scope === 'reference') {
    for (const f of referenceFolders) allowedFolders.add(f);
  } else if (scope === 'all') {
    for (const f of targetFolders) allowedFolders.add(f);
    for (const f of referenceFolders) allowedFolders.add(f);
  } else {
    for (const f of Object.keys(corpus.folders || {})) allowedFolders.add(f);
  }

  const names = Array.from(allowedFolders).sort();
  sel.innerHTML = '';
  for (const n of names) {
    const opt = document.createElement('option');
    opt.value = n;
    opt.textContent = n;
    sel.appendChild(opt);
  }
}



// ===== Init =====
window.addEventListener('DOMContentLoaded', () => {
  document.getElementById('analyzeBtn').addEventListener('click', handleAnalyzeClick);
  document.getElementById('keynessBtn').addEventListener('click', computeKeyness);
  const keyCancelBtn = document.getElementById('keyCancelBtn');
  if (keyCancelBtn) keyCancelBtn.addEventListener('click', cancelKeynessComputation);
  const hfBtn = document.getElementById('hfComputeBtn');
  if (hfBtn) hfBtn.addEventListener('click', computeHF);
  const exportHfButton = document.getElementById('exportHfBtn');
  if (exportHfButton) exportHfButton.addEventListener('click', exportHfToExcel);
  
  // Data type radio change - show/hide CSV options
  const dataTypeRadios = document.querySelectorAll('input[name="dataType"]');
  dataTypeRadios.forEach(radio => {
    radio.addEventListener('change', () => {
      const csvOptions = document.getElementById('csvOptions');
      const plainTextOptions = document.getElementById('plainTextOptions');
      if (radio.value === 'csv' && radio.checked) {
        if (csvOptions) csvOptions.style.display = 'block';
        if (plainTextOptions) plainTextOptions.style.display = 'none';
      } else if (radio.checked) {
        if (csvOptions) csvOptions.style.display = 'none';
        if (plainTextOptions) plainTextOptions.style.display = 'block';
      }
    });
  });
  
  // HF Filter event listeners
  const hfFilterApplyBtn = document.getElementById('hfFilterApplyBtn');
  if (hfFilterApplyBtn) hfFilterApplyBtn.addEventListener('click', applyHfFilter);
  const hfFilterClearBtn = document.getElementById('hfFilterClearBtn');
  if (hfFilterClearBtn) hfFilterClearBtn.addEventListener('click', clearHfFilter);
  const hfFilterInput = document.getElementById('hfFilterInput');
  if (hfFilterInput) {
    hfFilterInput.addEventListener('keypress', (e) => {
      if (e.key === 'Enter') applyHfFilter();
    });
  }
  
  // Use MTK checkbox - enable/disable Weighted pooled SD and sync with 12a)
  const useMTKCheckbox = document.getElementById('keyUseMTK');
  const weightedSDCheckbox = document.getElementById('keyWeightedPooledSD');
  const advancedStatsCheckbox = document.getElementById('keyAdvancedStats');
  const depUseMTKCheckbox = document.getElementById('depUseMTK');
  const depWeightedSDCheckbox = document.getElementById('depWeightedPooledSD');
  const depAdvancedStatsCheckbox = document.getElementById('depAdvancedStats');
  
  // Function to sync all checkboxes
  function syncCheckboxes(source, target) {
    if (target) target.checked = source.checked;
  }
  
  // Function to update Weighted pooled SD enabled state
  function updateWeightedSDState() {
    const mtkEnabled = useMTKCheckbox?.checked || false;
    if (weightedSDCheckbox) {
      weightedSDCheckbox.disabled = !mtkEnabled;
      if (!mtkEnabled) weightedSDCheckbox.checked = false;
    }
    if (depWeightedSDCheckbox) {
      depWeightedSDCheckbox.disabled = !mtkEnabled;
      if (!mtkEnabled) depWeightedSDCheckbox.checked = false;
    }
  }
  
  // 8) Use MTK change
  if (useMTKCheckbox) {
    useMTKCheckbox.addEventListener('change', () => {
      syncCheckboxes(useMTKCheckbox, depUseMTKCheckbox);
      updateWeightedSDState();
    });
  }
  
  // 8) Weighted pooled SD change
  if (weightedSDCheckbox) {
    weightedSDCheckbox.addEventListener('change', () => {
      syncCheckboxes(weightedSDCheckbox, depWeightedSDCheckbox);
    });
  }
  
  // 8) Advanced Statistics change
  if (advancedStatsCheckbox) {
    advancedStatsCheckbox.addEventListener('change', () => {
      syncCheckboxes(advancedStatsCheckbox, depAdvancedStatsCheckbox);
    });
  }
  
  // 12a) Use MTK change
  if (depUseMTKCheckbox) {
    depUseMTKCheckbox.addEventListener('change', () => {
      syncCheckboxes(depUseMTKCheckbox, useMTKCheckbox);
      updateWeightedSDState();
    });
  }
  
  // 12a) Weighted pooled SD change
  if (depWeightedSDCheckbox) {
    depWeightedSDCheckbox.addEventListener('change', () => {
      syncCheckboxes(depWeightedSDCheckbox, weightedSDCheckbox);
    });
  }
  
  // 12a) Advanced Statistics change
  if (depAdvancedStatsCheckbox) {
    depAdvancedStatsCheckbox.addEventListener('change', () => {
      syncCheckboxes(depAdvancedStatsCheckbox, advancedStatsCheckbox);
    });
  }

  document.getElementById('folderInput').addEventListener('change', updateSelectedFilesInfo);
  document.getElementById('fileInput').addEventListener('change', updateSelectedFilesInfo);
  
  // CSV input change - auto-select CSV mode
  const csvInput = document.getElementById('csvInput');
  if (csvInput) {
    csvInput.addEventListener('change', () => {
      if (csvInput.files && csvInput.files.length > 0) {
        // Auto-select CSV mode
        const csvRadio = document.querySelector('input[name="dataType"][value="csv"]');
        if (csvRadio) {
          csvRadio.checked = true;
          csvRadio.dispatchEvent(new Event('change'));
        }
        const selectedInfo = document.getElementById('selectedFilesInfo');
        const csvFileList = document.getElementById('csvFileList');
        
        if (csvInput.files.length === 1) {
          if (selectedInfo) {
            selectedInfo.textContent = `CSV: ${csvInput.files[0].name}`;
          }
          if (csvFileList) {
            csvFileList.textContent = '';
          }
        } else {
          // 複数ファイルの場合
          const fileNames = Array.from(csvInput.files).map(f => f.name);
          if (selectedInfo) {
            selectedInfo.textContent = `CSV: ${csvInput.files.length} files selected`;
          }
          if (csvFileList) {
            csvFileList.innerHTML = '<strong>Files:</strong> ' + fileNames.map(n => `<span style="background:#dbeafe;padding:1px 4px;border-radius:2px;margin-right:4px;">${n}</span>`).join('');
          }
        }
      }
    });
  }
  
  document.getElementById('kwicRecomputeBtn').addEventListener('click', () => {
    currentCollocateWord = null; // Clear collocate highlight for manual KWIC

    // Clear file/folder filters for manual KWIC
    currentKwicFileFilter = null;
    currentKwicFolderFilter = null;

    // Sync KWIC input to Collocate and Plot
    const kwicFeature = document.getElementById('kwicFeatureInput')?.value || '';
    const kwicType = document.getElementById('kwicFeatureTypeSelect')?.value || 'word';
    
    const collocateInput = document.getElementById('collocateNodeInput');
    const collocateType = document.getElementById('collocateFeatureTypeSelect');
    if (collocateInput) collocateInput.value = kwicFeature;
    if (collocateType) collocateType.value = kwicType;
    
    const plotInput = document.getElementById('plotFeatureInput');
    const plotType = document.getElementById('plotFeatureTypeSelect');
    if (plotInput) plotInput.value = kwicFeature;
    if (plotType) plotType.value = kwicType;
    
    computeKwic();
  });
  
  // Sort button for KWIC
  const kwicSortBtn = document.getElementById('kwicSortBtn');
  if (kwicSortBtn) {
    kwicSortBtn.addEventListener('click', () => {
      const colSelect = document.getElementById('kwicSortColumn');
      const dirSelect = document.getElementById('kwicSortDir');
      if (colSelect && dirSelect) {
        const col = parseInt(colSelect.value, 10);
        const dir = dirSelect.value;
        lastKwicSort = { col, dir };
        renderKwicRows();
      }
    });
  }
  
  // KWIC Scope radio button change handlers
  const kwicScopeRadios = document.querySelectorAll('input[name="kwicScope"]');
  kwicScopeRadios.forEach(radio => {
    radio.addEventListener('change', handleKwicScopeChange);
  });
  
  // KWIC Folder selector button
  const kwicFolderBtn = document.getElementById('kwicFolderBtn');
  if (kwicFolderBtn) {
    kwicFolderBtn.addEventListener('click', toggleKwicFolderDropdown);
  }
  
  // KWIC Biber Tag selector button
  const kwicBiberTagBtn = document.getElementById('kwicBiberTagBtn');
  if (kwicBiberTagBtn) {
    kwicBiberTagBtn.addEventListener('click', toggleKwicBiberDropdown);
  }
  
  // Close folder dropdown when clicking outside
  document.addEventListener('click', function(e) {
    const dropdown = document.getElementById('kwicFolderDropdown');
    const btn = document.getElementById('kwicFolderBtn');
    if (dropdown && dropdown.style.display === 'block' && !dropdown.contains(e.target) && e.target !== btn && !btn.contains(e.target)) {
      dropdown.style.display = 'none';
    }
    
    // Close Biber tag dropdown when clicking outside
    const biberDropdown = document.getElementById('kwicBiberTagDropdown');
    const biberBtn = document.getElementById('kwicBiberTagBtn');
    if (biberDropdown && biberDropdown.style.display === 'block' && !biberDropdown.contains(e.target) && e.target !== biberBtn && !biberBtn.contains(e.target)) {
      biberDropdown.style.display = 'none';
    }
  });
  
  document.getElementById('exportKeynessBtn').addEventListener('click', exportKeynessToExcel);
  document.getElementById('exportKwicBtn').addEventListener('click', exportKwicToExcel);
  
  // Advanced mode toggle
  const advancedModeToggle = document.getElementById('kwicAdvancedModeToggle');
  if (advancedModeToggle) {
    advancedModeToggle.addEventListener('change', function() {
      // Check if corpus is tagged when enabling Advanced mode
      if (this.checked && corpus && corpus.mode !== 'tagged' && corpus.mode !== 'csv') {
        alert('Advanced mode requires a Tagged corpus. Please load a Tagged corpus file (surface_POSd_POSs_lemma format).');
        this.checked = false;
        return;
      }
      
      document.getElementById('kwicSimpleMode').style.display = this.checked ? 'none' : 'block';
      document.getElementById('kwicAdvancedMode').style.display = this.checked ? 'block' : 'none';
      if (this.checked) {
        // Initialize with one token if empty
        const container = document.getElementById('kwicAdvancedInputs');
        if (container && container.querySelectorAll('.kwic-adv-token').length === 0) {
          initAdvancedKwicTokens();
        }
        // Sync to other Advanced modes
        syncAllAdvancedModes();
      }
      // Sync Plot and Collocate Advanced mode toggles (prevent infinite loop)
      if (!_syncingAdvancedModes) {
        _syncingAdvancedModes = true;
        const plotToggle = document.getElementById('plotAdvancedModeToggle');
        const collocateToggle = document.getElementById('collocateAdvancedModeToggle');
        if (this.checked) {
          if (plotToggle && !plotToggle.checked) {
            plotToggle.checked = true;
            document.getElementById('plotSimpleMode').style.display = 'none';
            document.getElementById('plotAdvancedMode').style.display = 'block';
            syncPlotAdvancedFromKwic();
          }
          if (collocateToggle && !collocateToggle.checked) {
            collocateToggle.checked = true;
            document.getElementById('collocateSimpleMode').style.display = 'none';
            document.getElementById('collocateAdvancedMode').style.display = 'block';
            syncCollocateAdvancedFromKwic();
          }
        } else {
          if (plotToggle && plotToggle.checked) {
            plotToggle.checked = false;
            document.getElementById('plotSimpleMode').style.display = 'block';
            document.getElementById('plotAdvancedMode').style.display = 'none';
          }
          if (collocateToggle && collocateToggle.checked) {
            collocateToggle.checked = false;
            document.getElementById('collocateSimpleMode').style.display = 'block';
            document.getElementById('collocateAdvancedMode').style.display = 'none';
          }
        }
        _syncingAdvancedModes = false;
      }
    });
  }
  
  // Advanced mode recompute button
  const advancedRecompute = document.getElementById('kwicAdvancedRecomputeBtn');
  if (advancedRecompute) {
    advancedRecompute.addEventListener('click', () => {
      currentCollocateWord = null;
      currentKwicFileFilter = null;
      currentKwicFolderFilter = null;
      computeAdvancedKwic();
    });
  }
  
  // Advanced mode clear button - clear ALL KWIC section
  const advancedClear = document.getElementById('kwicAdvancedClearBtn');
  if (advancedClear) {
    advancedClear.addEventListener('click', () => {
      clearAllKwicState();
    });
  }

  // Feature type change handlers for 7) HF and 8) Keyness
  const keyFeatureTypeSel = document.getElementById('featureTypeSelect');
  const hfFeatureTypeSel = document.getElementById('hfFeatureTypeSelect');
  const freqTableFeatureTypeSel = document.getElementById('freqTableFeatureType');
  
  if (keyFeatureTypeSel) {
    keyFeatureTypeSel.addEventListener('change', () => {
      updateClusterUI('key');
      syncFeatureTypeSelects('key');
    });
  }
  if (hfFeatureTypeSel) {
    hfFeatureTypeSel.addEventListener('change', () => {
      updateClusterUI('hf');
      syncFeatureTypeSelects('hf');
    });
  }
  if (freqTableFeatureTypeSel) {
    freqTableFeatureTypeSel.addEventListener('change', () => {
      updateFreqTableBiberPlusVisibility();
    });
  }
  
  // Sync n values between 7) and 8)
  const keyNInput = document.getElementById('nInput');
  const hfNInput = document.getElementById('hfNInput');
  if (keyNInput) {
    keyNInput.addEventListener('change', () => {
      if (hfNInput) hfNInput.value = keyNInput.value;
    });
  }
  if (hfNInput) {
    hfNInput.addEventListener('change', () => {
      if (keyNInput) keyNInput.value = hfNInput.value;
    });
  }
  
  // Sync cluster inputs
  const keyClusterWord = document.getElementById('keyClusterWord');
  const hfClusterWord = document.getElementById('hfClusterWord');
  const keyClusterPos = document.getElementById('keyClusterPosition');
  const hfClusterPos = document.getElementById('hfClusterPosition');
  
  if (keyClusterWord) {
    keyClusterWord.addEventListener('input', () => syncClusterInputs('key'));
  }
  if (hfClusterWord) {
    hfClusterWord.addEventListener('input', () => syncClusterInputs('hf'));
  }
  if (keyClusterPos) {
    keyClusterPos.addEventListener('change', () => syncClusterInputs('key'));
  }
  if (hfClusterPos) {
    hfClusterPos.addEventListener('change', () => syncClusterInputs('hf'));
  }
  
  // Concordance Plot
  const plotComputeBtn = document.getElementById('plotComputeBtn');
  if (plotComputeBtn) plotComputeBtn.addEventListener('click', computePlot);
  const plotClearBtn = document.getElementById('plotClearBtn');
  if (plotClearBtn) plotClearBtn.addEventListener('click', clearPlot);
  const plotDownloadBtn = document.getElementById('plotDownloadBtn');
  if (plotDownloadBtn) plotDownloadBtn.addEventListener('click', downloadPlotAsJpeg);
  
  // KWIC View mode change - re-render without recompute
  const kwicViewRadios = document.querySelectorAll('input[name="kwicView"]');
  kwicViewRadios.forEach(radio => {
    radio.addEventListener('change', () => {
      // Re-render KWIC table if we have results
      if (lastKwicRows && lastKwicRows.length > 0) {
        renderKwicRows();
      }
    });
  });
  
  // Plot Advanced mode buttons
  const plotComputeAdvBtn = document.getElementById('plotComputeAdvBtn');
  if (plotComputeAdvBtn) plotComputeAdvBtn.addEventListener('click', computePlotAdvanced);
  const plotClearAdvBtn = document.getElementById('plotClearAdvBtn');
  if (plotClearAdvBtn) plotClearAdvBtn.addEventListener('click', clearPlot);
  const plotDownloadAdvBtn = document.getElementById('plotDownloadAdvBtn');
  if (plotDownloadAdvBtn) plotDownloadAdvBtn.addEventListener('click', downloadPlotAsJpeg);
  
  // Re-render plot when group by changes
  const plotGroupBy = document.getElementById('plotGroupBy');
  if (plotGroupBy) {
    plotGroupBy.addEventListener('change', () => {
      if (plotData.length > 0) {
        renderPlot(plotGroupBy.value);
      }
    });
  }
  
  // Advanced mode group by change handler
  const plotGroupByAdv = document.getElementById('plotGroupByAdv');
  if (plotGroupByAdv) {
    plotGroupByAdv.addEventListener('change', () => {
      if (plotData.length > 0) {
        renderPlot(plotGroupByAdv.value);
      }
    });
  }
  
  // HideZero checkbox change handlers (re-render plot)
  const plotHideZeroGroups = document.getElementById('plotHideZeroGroups');
  if (plotHideZeroGroups) {
    plotHideZeroGroups.addEventListener('change', () => {
      if (plotData.length > 0) {
        const groupBy = document.getElementById('plotGroupBy')?.value || 'file';
        renderPlot(groupBy);
      }
    });
  }
  const plotHideZeroGroupsAdv = document.getElementById('plotHideZeroGroupsAdv');
  if (plotHideZeroGroupsAdv) {
    plotHideZeroGroupsAdv.addEventListener('change', () => {
      if (plotData.length > 0) {
        const groupBy = document.getElementById('plotGroupByAdv')?.value || 'file';
        renderPlot(groupBy);
      }
    });
  }
  
  // Sync Plot feature input with other sections
  const plotFeatureInput = document.getElementById('plotFeatureInput');
  const plotFeatureTypeSel = document.getElementById('plotFeatureTypeSelect');
  if (plotFeatureInput) {
    plotFeatureInput.addEventListener('input', syncPlotFeatureToOthers);
  }
  if (plotFeatureTypeSel) {
    plotFeatureTypeSel.addEventListener('change', syncPlotFeatureToOthers);
  }
  
  // Clear Original Text button
  const clearOriginalBtn = document.getElementById('clearOriginalBtn');
  if (clearOriginalBtn) {
    clearOriginalBtn.addEventListener('click', () => {
      const originalText = document.getElementById('originalText');
      if (originalText) {
        originalText.innerHTML = 'No text selected.';
      }
      lastOriginalIndex = null;
    });
  }

  const keyTable = document.getElementById('keyTable');
  keyTable.querySelectorAll('thead th.sortable').forEach(th => {
    const col = parseInt(th.getAttribute('data-col'), 10);
    th.addEventListener('click', () => sortKeynessBy(col));
  });

  initKeyTableResize();
  initKwicTableResize();
  initHfTableResize();

  // Advanced Statistics checkbox: re-render table when toggled
  const advStatsCheckbox = document.getElementById('keyAdvancedStats');
  if (advStatsCheckbox) {
    advStatsCheckbox.addEventListener('change', () => {
      if (allKeynessRows && allKeynessRows.length > 0) {
        const advStats = advStatsCheckbox.checked;
        
        // Check if we need to re-compute (switching to advanced but no dispersion data)
        if (advStats && allKeynessRows[0].rangeT === null) {
          const keyStatus = document.getElementById('keyStatus');
          if (keyStatus) {
            keyStatus.textContent = 'To enable Advanced Statistics, please re-run Compute Keyness.';
            keyStatus.style.color = '#c55';
          }
          // Still render in basic mode visually but with advanced header
          lastSort = { col: 14, dir: 'desc' };
          renderKeynessRows();
          return;
        }
        
        // Reset sort column based on new mode
        // Freq-LL is col 8 in basic, col 14 in advanced
        lastSort = { col: advStats ? 14 : 8, dir: 'desc' };
        const keyStatus = document.getElementById('keyStatus');
        if (keyStatus) keyStatus.style.color = '';
        renderKeynessRows();
      }
    });
  }

  const kwicTable = document.getElementById('kwicTable');
  kwicTable.querySelectorAll('thead th.sortable').forEach(th => {
    const col = parseInt(th.getAttribute('data-col'), 10);
    th.addEventListener('click', () => sortKwicBy(col));
  });

  document.getElementById('kwicLeftWidth').addEventListener('change', () => {
    if (currentKwicFeature) computeKwic();
  });
  document.getElementById('kwicRightWidth').addEventListener('change', () => {
    if (currentKwicFeature) computeKwic();
  });

  ['bluePosSelect','redPosSelect','greenPosSelect'].forEach(id => {
    const el = document.getElementById(id);
    if (el) {
      el.addEventListener('change', () => {
        if (lastKwicRows.length > 0) {
          renderKwicRows();
          if (lastOriginalIndex != null) {
            showOriginalFromKwic(lastOriginalIndex);
          }
        }
      });
    }
  });
  
  // KWIC View (Surface/Tagged) radio button change
  document.querySelectorAll('input[name="kwicView"]').forEach(radio => {
    radio.addEventListener('change', () => {
      if (lastKwicRows && lastKwicRows.length > 0) {
        // If collocate filter is active, just re-render without recomputing
        if (currentCollocateInfo) {
          renderKwicRows();
        } else if (currentKwicFeature) {
          computeKwic();
        }
      }
    });
  });
  
  // Original Text View (Surface/Tagged) radio button change
  document.querySelectorAll('input[name="originalView"]').forEach(radio => {
    radio.addEventListener('change', () => {
      if (lastOriginalIndex != null && lastKwicRows && lastKwicRows.length > 0) {
        showOriginalFromKwic(lastOriginalIndex);
      }
    });
  });
  
  // KWIC Scope radio button change
  document.querySelectorAll('input[name="kwicScope"]').forEach(radio => {
    radio.addEventListener('change', () => {
      // Clear collocate filter when manually changing scope
      currentCollocateWord = null;
      currentCollocateInfo = null;
      if (currentKwicFeature) {
        computeKwic();
      }
    });
  });

  const nodeFilter = document.getElementById('kwicNodeFilter');
  if (nodeFilter) {
    nodeFilter.addEventListener('change', applyKwicFilter);
    nodeFilter.addEventListener('keyup', (ev) => {
      if (ev.key === 'Enter') applyKwicFilter();
    });
  }
  
  // KWIC feature input Enter key handler
  const kwicFeatureInput = document.getElementById('kwicFeatureInput');
  if (kwicFeatureInput) {
    kwicFeatureInput.addEventListener('keyup', (ev) => {
      if (ev.key === 'Enter') {
        currentCollocateWord = null; // Clear collocate highlight for manual KWIC
        // Clear file/folder filters for manual KWIC
        currentKwicFileFilter = null;
        currentKwicFolderFilter = null;
        computeKwic();
      }
    });
  }
  
  ['kwicLeftFilterMode', 'kwicNodeFilterMode', 'kwicRightFilterMode'].forEach(id => {
    const m = document.getElementById(id);
    if (m) {
      m.addEventListener('change', applyKwicFilter);
    }
  });

  const keyFilter = document.getElementById('keyFeatureFilter');
  if (keyFilter) {
    keyFilter.addEventListener('change', applyKeynessFilter);
    keyFilter.addEventListener('keyup', (ev) => {
      if (ev.key === 'Enter') applyKeynessFilter();
    });
  }
  const keyModeSel = document.getElementById('keyFilterMode');
  if (keyModeSel) {
    keyModeSel.addEventListener('change', applyKeynessFilter);
  }

  // Collocate event listeners
  const collocateComputeBtn = document.getElementById('collocateComputeBtn');
  if (collocateComputeBtn) {
    collocateComputeBtn.addEventListener('click', computeCollocatesManual);
  }
  
  // Collocate Advanced mode buttons
  const collocateComputeAdvBtn = document.getElementById('collocateComputeAdvBtn');
  if (collocateComputeAdvBtn) {
    collocateComputeAdvBtn.addEventListener('click', computeCollocatesAdvanced);
  }
  const collocateClearAdvBtn = document.getElementById('collocateClearAdvBtn');
  if (collocateClearAdvBtn) {
    collocateClearAdvBtn.addEventListener('click', () => {
      collocateData = null;
      clearCollocateTables();
      const status = document.getElementById('collocateStatus');
      if (status) status.textContent = '';
    });
  }
  
  const collocateNodeInput = document.getElementById('collocateNodeInput');
  if (collocateNodeInput) {
    collocateNodeInput.addEventListener('keyup', (ev) => {
      if (ev.key === 'Enter') computeCollocatesManual();
    });
  }
  
  // Auto re-compute on settings change
  ['collocateSpanL', 'collocateSpanR', 'collocateTopN'].forEach(id => {
    const el = document.getElementById(id);
    if (el) {
      el.addEventListener('change', () => {
        if (collocateData) {
          computeCollocatesManual();
        }
      });
    }
  });
  
  // Advanced mode settings change
  ['collocateSpanLAdv', 'collocateSpanRAdv', 'collocateTopNAdv'].forEach(id => {
    const el = document.getElementById(id);
    if (el) {
      el.addEventListener('change', () => {
        if (collocateData && collocateData.featureType === 'advanced') {
          computeCollocatesAdvanced();
        }
      });
    }
  });
  
  // Statistic change triggers re-render (not full re-compute)
  const statSelect = document.getElementById('collocateStatSelect');
  if (statSelect) {
    statSelect.addEventListener('change', () => {
      if (collocateData) {
        collocateData.statType = statSelect.value;
        renderAllCollocateTables();
      }
    });
  }
  
  // Advanced mode stat change
  const statSelectAdv = document.getElementById('collocateStatSelectAdv');
  if (statSelectAdv) {
    statSelectAdv.addEventListener('change', () => {
      if (collocateData) {
        collocateData.statType = statSelectAdv.value;
        renderAllCollocateTables();
      }
    });
  }
  
  // Feature Type synchronization between KWIC and Collocate
  const kwicFeatureTypeSelect = document.getElementById('kwicFeatureTypeSelect');
  const collocateFeatureTypeSelect = document.getElementById('collocateFeatureTypeSelect');
  
  if (kwicFeatureTypeSelect) {
    kwicFeatureTypeSelect.addEventListener('change', () => {
      const val = kwicFeatureTypeSelect.value;
      
      // DEPタイプが選択されたら12)にリダイレクト
      if (val === 'dep') {
        alert('Dependency Grammar features use section 12). Redirecting to 12a) Pattern Search...');
        redirectToDepSection();
        // Reset to word
        kwicFeatureTypeSelect.value = 'word';
        return;
      }
      
      // Sync to Collocate (only if compatible option)
      if (collocateFeatureTypeSelect) {
        // Only sync word/lemma/ngram/pframe types (not POS types)
        if (!val.startsWith('pos')) {
          collocateFeatureTypeSelect.value = val;
        }
      }
    });
  }
  
  if (collocateFeatureTypeSelect) {
    collocateFeatureTypeSelect.addEventListener('change', () => {
      // Sync to KWIC
      if (kwicFeatureTypeSelect) {
        kwicFeatureTypeSelect.value = collocateFeatureTypeSelect.value;
      }
      // Re-compute collocates if data exists
      if (collocateData) {
        computeCollocatesManual();
      }
    });
  }
  
  const exportCollocateBtn = document.getElementById('exportCollocateBtn');
  if (exportCollocateBtn) {
    exportCollocateBtn.addEventListener('click', exportCollocatesToExcel);
  }
  
  // Advanced mode export button (same function)
  const exportCollocateAdvBtn = document.getElementById('exportCollocateAdvBtn');
  if (exportCollocateAdvBtn) {
    exportCollocateAdvBtn.addEventListener('click', exportCollocatesToExcel);
  }

  // ===== Clear Buttons =====
  // 1) Corpus Clear
  document.getElementById('corpusClearBtn')?.addEventListener('click', () => {
    corpus = null;
    targetFolders.clear();
    referenceFolders.clear();
    document.getElementById('folderInput').value = '';
    document.getElementById('fileInput').value = '';
    document.getElementById('statusMessage').textContent = '';
    document.getElementById('selectedFilesInfo').textContent = '';
    document.getElementById('modeBadge').textContent = '-';
    document.getElementById('summaryFileCount').textContent = '0';
    document.getElementById('summaryTokenCount').textContent = '0';
    document.getElementById('summaryTableBody').innerHTML = '<tr><td colspan="4" class="text-xs">No files yet.</td></tr>';
    document.getElementById('folderSelectionArea').innerHTML = 'Folder list will appear here after loading a corpus.';
    refreshFeatureTypeOptions();
    refreshKwicFeatureTypeOptions();
    refreshHfFeatureTypeOptions();
    refreshFreqTableFeatureTypeOptions();
    updateKwicViewOptions();
    updateOriginalViewOptions();
    clearFrequencyTable();
  });
  
  // 2) Summary Clear (same as corpus clear for display)
  document.getElementById('summaryClearBtn')?.addEventListener('click', () => {
    document.getElementById('modeBadge').textContent = '-';
    document.getElementById('summaryFileCount').textContent = '0';
    document.getElementById('summaryTokenCount').textContent = '0';
    document.getElementById('summaryTableBody').innerHTML = '<tr><td colspan="4" class="text-xs">No files yet.</td></tr>';
  });
  
  // 3) Folder Clear
  document.getElementById('folderClearBtn')?.addEventListener('click', () => {
    targetFolders.clear();
    referenceFolders.clear();
    document.querySelectorAll('.folder-target-cb, .folder-ref-cb').forEach(cb => cb.checked = false);
    renderFolderStats();
  });
  
  // 4) HF Clear
  document.getElementById('hfClearBtn')?.addEventListener('click', () => {
    allHfRows = [];
    hfFilteredRows = null;
    const hfFilterInput = document.getElementById('hfFilterInput');
    const hfFilterExclude = document.getElementById('hfFilterExclude');
    if (hfFilterInput) hfFilterInput.value = '';
    if (hfFilterExclude) hfFilterExclude.checked = false;
    document.getElementById('hfTableBody').innerHTML = '<tr><td colspan="10" class="text-xs">No high-frequency features yet.</td></tr>';
    document.getElementById('hfStatus').textContent = '';
  });
  
  // 8) Keyness Clear
  document.getElementById('keyClearBtn')?.addEventListener('click', () => {
    allKeynessRows = [];
    document.getElementById('keyTableBody').innerHTML = '<tr><td colspan="13" class="text-xs">Compute Keyness first.</td></tr>';
    document.getElementById('keyStatus').textContent = '';
  });
  
  // 4) KWIC Clear
  document.getElementById('kwicClearBtn')?.addEventListener('click', () => {
    allKwicRows = [];
    lastKwicRows = [];
    currentKwicFeature = null;
    currentKwicFeatureType = null;
    currentCollocateWord = null;
    currentCollocateInfo = null;
    lastWildcardMatchCounts = {};
    lastKwicAllCount = 0;
    window.lastKwicFilterState = {};
    document.getElementById('kwicTableBody').innerHTML = '<tr><td colspan="6" class="text-xs">No KWIC yet.</td></tr>';
    document.getElementById('kwicStatus').textContent = '';
    document.getElementById('kwicFeatureInput').value = '';
    document.getElementById('originalText').textContent = 'No text selected.';
    // Clear filter fields
    const leftFilter = document.getElementById('kwicLeftFilter');
    const nodeFilter = document.getElementById('kwicNodeFilter');
    const rightFilter = document.getElementById('kwicRightFilter');
    if (leftFilter) leftFilter.value = '';
    if (nodeFilter) nodeFilter.value = '';
    if (rightFilter) rightFilter.value = '';
    // Clear status bar
    const statusBar = document.getElementById('kwicFilterStatusBar');
    if (statusBar) {
      statusBar.innerHTML = '';
      statusBar.classList.remove('active');
    }
    const wildcardArea = document.getElementById('kwicWildcardMatches');
    if (wildcardArea) wildcardArea.style.display = 'none';
  });
  
  // 8) Collocate Clear
  document.getElementById('collocateClearBtn')?.addEventListener('click', () => {
    collocateData = null;
    collocateTableData = {};
    currentCollocateWord = null;
    currentCollocateInfo = null;
    clearCollocateTables();
    document.getElementById('collocateNodeInput').value = '';
    document.getElementById('collocateStatus').textContent = '';
  });

  // ===== 9) Frequency Table Event Listeners =====
  const freqTableComputeBtn = document.getElementById('freqTableComputeBtn');
  if (freqTableComputeBtn) {
    freqTableComputeBtn.addEventListener('click', () => { 
      computeFrequencyTable(); 
      setTimeout(() => {
        populateDistTestFeatureList(); 
        if (typeof refreshManovaDVs === 'function') refreshManovaDVs();
        if (typeof refreshRegPredictors === 'function') refreshRegPredictors();
      }, 0); 
    });
  }
  
  const freqTableClearBtn = document.getElementById('freqTableClearBtn');
  if (freqTableClearBtn) {
    freqTableClearBtn.addEventListener('click', clearFrequencyTable);
  }
  
  const exportFreqTableBtn = document.getElementById('exportFreqTableBtn');
  if (exportFreqTableBtn) {
    exportFreqTableBtn.addEventListener('click', exportFrequencyTableToExcel);
  }
  
  // 9-b) Chi-square Distribution Test event listeners
  const chiSquareRunBtn = document.getElementById('chiSquareRunBtn');
  if (chiSquareRunBtn) {
    chiSquareRunBtn.addEventListener('click', runChiSquareTest);
  }
  
  const chiSquareExportBtn = document.getElementById('chiSquareExportBtn');
  if (chiSquareExportBtn) {
    chiSquareExportBtn.addEventListener('click', exportChiSquareResults);
  }
  
  const chiSquareClearBtn = document.getElementById('chiSquareClearBtn');
  if (chiSquareClearBtn) {
    chiSquareClearBtn.addEventListener('click', clearChiSquareResults);
  }
  
  // Chi-square folder dropdown
  const chiSquareFolderBtn = document.getElementById('chiSquareFolderBtn');
  if (chiSquareFolderBtn) {
    chiSquareFolderBtn.addEventListener('click', toggleChiSquareFolderDropdown);
  }
  
  // Click outside to close Chi-square folder dropdown
  document.addEventListener('click', (e) => {
    const dropdown = document.getElementById('chiSquareFolderDropdown');
    const btn = document.getElementById('chiSquareFolderBtn');
    if (dropdown && btn && !dropdown.contains(e.target) && !btn.contains(e.target)) {
      dropdown.style.display = 'none';
    }
  });
  
  // Feature type change
  const freqTableFeatureType = document.getElementById('freqTableFeatureType');
  if (freqTableFeatureType) {
    freqTableFeatureType.addEventListener('change', updateFreqTableClusterUI);
  }
  
  // Value type change - show/hide options
  const freqTableValueType = document.getElementById('freqTableValueType');
  if (freqTableValueType) {
    freqTableValueType.addEventListener('change', () => {
      const normOpts = document.getElementById('freqTableNormOptions');
      const tfidfOpts = document.getElementById('freqTableTfidfOptions');
      const val = freqTableValueType.value;
      
      if (normOpts) normOpts.style.display = val === 'normalized' ? 'flex' : 'none';
      if (tfidfOpts) tfidfOpts.style.display = val === 'tfidf' ? 'flex' : 'none';
    });
  }
  
  // TF type change - show/hide per dropdown for TF-IDF
  const freqTableTfType = document.getElementById('freqTableTfType');
  if (freqTableTfType) {
    freqTableTfType.addEventListener('change', () => {
      const tfNormOpts = document.getElementById('freqTableTfNormOptions');
      if (tfNormOpts) {
        tfNormOpts.style.display = freqTableTfType.value === 'norm' ? 'flex' : 'none';
      }
    });
  }
  
  // Display mode change - re-render (TF-IDF only)
  const freqTableDisplayMode = document.getElementById('freqTableDisplayMode');
  if (freqTableDisplayMode) {
    freqTableDisplayMode.addEventListener('change', () => {
      if (freqTableData) {
        renderFrequencyTable();
      }
    });
  }

  // ===== Case-insensitive checkbox synchronization =====
  const caseInsensitiveCheckboxes = ['hfCaseInsensitive', 'keyCaseInsensitive', 'kwicCaseInsensitive', 'collocateCaseInsensitive', 'freqTableCaseInsensitive'];
  caseInsensitiveCheckboxes.forEach(id => {
    const cb = document.getElementById(id);
    if (cb) {
      cb.addEventListener('change', () => {
        const isChecked = cb.checked;
        caseInsensitiveCheckboxes.forEach(otherId => {
          const otherCb = document.getElementById(otherId);
          if (otherCb) otherCb.checked = isChecked;
        });
      });
    }
  });

  // ===== Visualization event listeners =====
  const vizComputeBtn = document.getElementById('vizComputeBtn');
  if (vizComputeBtn) {
    vizComputeBtn.addEventListener('click', computeVisualization);
  }
  
  const vizClearBtn = document.getElementById('vizClearBtn');
  if (vizClearBtn) {
    vizClearBtn.addEventListener('click', () => {
      const canvas = document.getElementById('vizCanvas');
      const ctx = canvas.getContext('2d');
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      document.getElementById('vizOutput').style.display = 'none';
      document.getElementById('vizStats').style.display = 'none';
      document.getElementById('vizStatus').textContent = '';
      vizData = null;
      vizResults = null;
    });
  }
  
  const vizDownloadJpegBtn = document.getElementById('vizDownloadJpegBtn');
  if (vizDownloadJpegBtn) {
    vizDownloadJpegBtn.addEventListener('click', downloadVisualizationJpeg);
  }
  
  const vizDownloadExcelBtn = document.getElementById('vizDownloadExcelBtn');
  if (vizDownloadExcelBtn) {
    vizDownloadExcelBtn.addEventListener('click', downloadVisualizationExcel);
  }
  
  // Show/hide method-specific options
  const vizMethodSelect = document.getElementById('vizMethod');
  if (vizMethodSelect) {
    const updateVizOptions = () => {
      const method = vizMethodSelect.value;
      document.getElementById('vizClusterOptions').style.display = method === 'cluster' ? 'block' : 'none';
      document.getElementById('vizPcaOptions').style.display = method === 'pca' ? 'flex' : 'none';
      document.getElementById('vizCorrespondenceOptions').style.display = method === 'correspondence' ? 'block' : 'none';
      document.getElementById('vizMdsOptions').style.display = method === 'mds' ? 'block' : 'none';
      document.getElementById('vizHeatmapOptions').style.display = method === 'heatmap' ? 'block' : 'none';
      document.getElementById('vizNetworkOptions').style.display = method === 'network' ? 'block' : 'none';
      document.getElementById('vizEfaOptions').style.display = method === 'efa' ? 'block' : 'none';
      document.getElementById('vizRfOptions').style.display = method === 'randomforest' ? 'block' : 'none';
      document.getElementById('vizTsneOptions').style.display = method === 'tsne' ? 'block' : 'none';
      document.getElementById('vizUmapOptions').style.display = method === 'umap' ? 'block' : 'none';
      // Hide Top N columns for Network (uses Collocate Tables instead)
      const topNContainer = document.getElementById('vizTopNContainer');
      if (topNContainer) topNContainer.style.display = method === 'network' ? 'none' : 'inline';
    };
    vizMethodSelect.addEventListener('change', updateVizOptions);
    updateVizOptions();
    
    // Cluster method toggle (Hierarchical vs K-means)
    const clusterMethodSelect = document.getElementById('vizClusterMethod');
    if (clusterMethodSelect) {
      clusterMethodSelect.addEventListener('change', function() {
        const method = this.value;
        document.getElementById('vizClusterHierOptions').style.display = method === 'hierarchical' ? 'inline' : 'none';
        document.getElementById('vizClusterKmeansOptions').style.display = method === 'kmeans' ? 'inline' : 'none';
        document.getElementById('vizClusterTreeOptions').style.display = method === 'hierarchical' ? 'inline' : 'none';
        document.getElementById('vizClusterNumOptions').style.display = method === 'hierarchical' ? 'inline' : 'none';
      });
    }
    
    // Network co-occurrence level toggle
    const networkCoocLevel = document.getElementById('vizNetworkCoocLevel');
    if (networkCoocLevel) {
      networkCoocLevel.addEventListener('change', function() {
        const level = this.value;
        document.getElementById('vizNetworkWindowSpan').style.display = level === 'window' ? 'inline' : 'none';
      });
    }
    
    // Network: Sync Collocation button
    const syncCollocBtn = document.getElementById('vizNetworkSyncCollocBtn');
    if (syncCollocBtn) {
      syncCollocBtn.addEventListener('click', function() {
        const centerInput = document.getElementById('vizNetworkCenterNode');
        const statsDisplay = document.getElementById('vizNetworkStatsDisplay');
        if (collocateData && collocateData.node) {
          if (centerInput) centerInput.value = collocateData.node;
          if (statsDisplay) {
            statsDisplay.textContent = `T:${collocateData.totalTargetHits || 0} / R:${collocateData.totalRefHits || 0}`;
          }
        } else {
          if (statsDisplay) statsDisplay.textContent = '(No Collocation data)';
        }
      });
    }
    
    // Network: Export PNG
    const exportPngBtn = document.getElementById('vizNetworkExportPngBtn');
    if (exportPngBtn) {
      exportPngBtn.addEventListener('click', function() {
        const canvas = document.getElementById('vizCanvas');
        if (!canvas || !currentNetworkData) return;
        
        const link = document.createElement('a');
        link.download = `network_${currentNetworkData.centerWord || 'graph'}.png`;
        link.href = canvas.toDataURL('image/png');
        link.click();
      });
    }
    
    // Network: Export SVG
    const exportSvgBtn = document.getElementById('vizNetworkExportSvgBtn');
    if (exportSvgBtn) {
      exportSvgBtn.addEventListener('click', function() {
        if (!currentNetworkData) return;
        
        const svg = exportNetworkToSvg(currentNetworkData, 900, 700, {
          nodeSizeBy: document.getElementById('vizNetworkNodeSize').value,
          showLabels: document.getElementById('vizNetworkShowLabels').checked
        });
        
        const blob = new Blob([svg], { type: 'image/svg+xml' });
        const url = URL.createObjectURL(blob);
        const link = document.createElement('a');
        link.download = `network_${currentNetworkData.centerWord || 'graph'}.svg`;
        link.href = url;
        link.click();
        URL.revokeObjectURL(url);
      });
    }
    
    // Network: Export Excel
    const exportCsvBtn = document.getElementById('vizNetworkExportCsvBtn');
    if (exportCsvBtn) {
      exportCsvBtn.addEventListener('click', function() {
        if (!currentNetworkData) return;
        
        // Convert network to Excel format
        const data = [['Source', 'Target', 'Weight', 'Frequency', 'Similarity']];
        const { nodes, edges } = currentNetworkData;
        for (const edge of edges) {
          data.push([
            nodes[edge.source].label,
            nodes[edge.target].label,
            edge.weight,
            edge.freq || 0,
            edge.similarity || ''
          ]);
        }
        downloadExcel(data, `network_${currentNetworkData.centerWord || 'graph'}.xls`, 'Network');
      });
    }
    
    // Network: Canvas tooltip and click
    const vizCanvas = document.getElementById('vizCanvas');
    if (vizCanvas) {
      // Create tooltip element
      let tooltip = document.getElementById('networkTooltip');
      if (!tooltip) {
        tooltip = document.createElement('div');
        tooltip.id = 'networkTooltip';
        tooltip.style.cssText = 'position:fixed; background:#333; color:#fff; padding:8px 12px; border-radius:4px; font-size:12px; pointer-events:none; z-index:1000; display:none; max-width:250px; box-shadow:0 2px 8px rgba(0,0,0,0.3);';
        document.body.appendChild(tooltip);
      }
      
      vizCanvas.addEventListener('mousemove', function(e) {
        if (!currentNetworkData || !document.getElementById('vizNetworkShowTooltip')?.checked) {
          tooltip.style.display = 'none';
          return;
        }
        
        const rect = vizCanvas.getBoundingClientRect();
        const x = e.clientX - rect.left;
        const y = e.clientY - rect.top;
        
        // Find node under cursor
        let hoveredNode = null;
        for (const node of currentNetworkData.nodes) {
          const dx = x - node.x;
          const dy = y - node.y;
          const dist = Math.sqrt(dx * dx + dy * dy);
          if (dist <= (node.size || 10) + 5) {
            hoveredNode = node;
            break;
          }
        }
        
        if (hoveredNode) {
          let html = `<strong>${hoveredNode.label}</strong><br>`;
          html += `Frequency: ${hoveredNode.freq}`;
          if (hoveredNode.freqT && hoveredNode.freqR) {
            html += ` (T:${hoveredNode.freqT}, R:${hoveredNode.freqR})`;
          }
          html += `<br>`;
          if (!hoveredNode.isCenter) {
            html += `${currentNetworkData.edgeWeight}: ${hoveredNode.weight.toFixed(2)}<br>`;
            html += `Position: ${hoveredNode.position}`;
            if (hoveredNode.positions && Object.keys(hoveredNode.positions).length > 0) {
              const posStr = Object.entries(hoveredNode.positions)
                .sort((a, b) => {
                  const aNum = parseInt(a[0].substring(1));
                  const bNum = parseInt(b[0].substring(1));
                  if (a[0].startsWith('L') && b[0].startsWith('R')) return -1;
                  if (a[0].startsWith('R') && b[0].startsWith('L')) return 1;
                  return aNum - bNum;
                })
                .map(([p, n]) => `${p}:${n}`)
                .join(', ');
              html += ` (${posStr})`;
            }
            html += `<br>Source: ${hoveredNode.source}`;
          }
          
          tooltip.innerHTML = html;
          tooltip.style.display = 'block';
          tooltip.style.left = (e.clientX + 15) + 'px';
          tooltip.style.top = (e.clientY + 15) + 'px';
        } else {
          tooltip.style.display = 'none';
        }
      });
      
      vizCanvas.addEventListener('mouseleave', function() {
        tooltip.style.display = 'none';
      });
      
      vizCanvas.addEventListener('click', function(e) {
        if (!currentNetworkData) return;
        
        const rect = vizCanvas.getBoundingClientRect();
        const x = e.clientX - rect.left;
        const y = e.clientY - rect.top;
        
        // Find clicked node
        for (const node of currentNetworkData.nodes) {
          const dx = x - node.x;
          const dy = y - node.y;
          const dist = Math.sqrt(dx * dx + dy * dy);
          if (dist <= (node.size || 10) + 5 && !node.isCenter) {
            networkNodeClick(node.label);
            break;
          }
        }
      });
    }
  }
  
  // Network node click handler - filter KWIC by collocate
  window.networkNodeClick = function(collocate) {
    if (!allKwicRows || allKwicRows.length === 0) return;
    if (!currentNetworkData) return;
    
    const spanL = parseInt(document.getElementById('vizNetworkSpanL').value) || 5;
    const spanR = parseInt(document.getElementById('vizNetworkSpanR').value) || 5;
    const lowercase = document.getElementById('vizNetworkLowercase').checked;
    const col = lowercase ? collocate.toLowerCase() : collocate;
    
    // Filter KWIC rows that contain this collocate
    const filteredIndices = [];
    
    for (let i = 0; i < allKwicRows.length; i++) {
      const row = allKwicRows[i];
      const file = corpus.files[row.fileId];
      if (!file || !file.tokens) continue;
      
      const tokens = file.tokens;
      const nodeStart = row.matchStart;
      const nodeEnd = row.matchEnd;
      
      // Validate indices
      if (nodeStart === undefined || nodeEnd === undefined) continue;
      
      // Check left context
      let found = false;
      for (let p = 1; p <= spanL && !found; p++) {
        const idx = nodeStart - p;
        if (idx < 0) continue;
        const tok = tokens[idx];
        if (!tok || !tok.word) continue;
        let word = tok.word;
        if (lowercase) word = word.toLowerCase();
        if (word === col) {
          filteredIndices.push(i);
          found = true;
        }
      }
      
      if (found) continue;
      
      // Check right context
      for (let p = 1; p <= spanR; p++) {
        const idx = nodeEnd + p - 1;
        if (idx >= tokens.length) continue;
        const tok = tokens[idx];
        if (!tok || !tok.word) continue;
        let word = tok.word;
        if (lowercase) word = word.toLowerCase();
        if (word === col) {
          filteredIndices.push(i);
          break;
        }
      }
    }
    
    // Update KWIC display
    if (filteredIndices.length > 0) {
      // Switch to KWIC tab
      const kwicTab = document.querySelector('[data-tab="kwic"]');
      if (kwicTab) kwicTab.click();
      
      // Highlight filtered rows
      const kwicBody = document.getElementById('kwicTableBody');
      if (kwicBody) {
        const rows = kwicBody.querySelectorAll('tr');
        rows.forEach((tr, idx) => {
          if (filteredIndices.includes(idx)) {
            tr.style.backgroundColor = '#e8f0ff';
          } else {
            tr.style.backgroundColor = '';
          }
        });
      }
      
      // Show status
      const status = document.getElementById('kwicStatus');
      if (status) {
        status.textContent = `Filtered: ${filteredIndices.length} rows containing "${collocate}"`;
      }
    }
  };

  // ===== Topic Modeling Event Handlers =====
  const topicComputeBtn = document.getElementById('topicComputeBtn');
  if (topicComputeBtn) {
    topicComputeBtn.addEventListener('click', computeTopicModel);
  }
  
  const topicClearBtn = document.getElementById('topicClearBtn');
  if (topicClearBtn) {
    topicClearBtn.addEventListener('click', function() {
      topicModelResults = null;
      topicSuggestKResults = null;
      topicColumnWidths = {};
      topicDiagSortCol = null;
      topicDiagSortDir = 'asc';
      document.getElementById('topicResultsArea').style.display = 'none';
      document.getElementById('topicSuggestKResults').style.display = 'none';
      document.getElementById('topicSuggestKOptions').style.display = 'none';
      document.getElementById('topicStatus').textContent = '';
      const canvas = document.getElementById('topicCanvas');
      if (canvas) {
        const ctx = canvas.getContext('2d');
        ctx.clearRect(0, 0, canvas.width, canvas.height);
      }
      document.getElementById('topicWordsTable').innerHTML = '';
      document.getElementById('topicDiagTable').innerHTML = '';
      document.getElementById('topicStatsArea').innerHTML = '';
    });
  }
  
  // POS Filter mode change handler
  const topicPosFilterMode = document.getElementById('topicPosFilterMode');
  if (topicPosFilterMode) {
    topicPosFilterMode.addEventListener('change', function() {
      const mode = this.value;
      const simpleOptions = document.getElementById('topicPosSimpleOptions');
      const detailOptions = document.getElementById('topicPosDetailOptions');
      const simpleBtns = document.getElementById('topicPosSimpleBtns');
      const detailBtns = document.getElementById('topicPosDetailBtns');
      
      if (simpleOptions) simpleOptions.style.display = mode === 'simple' ? 'block' : 'none';
      if (detailOptions) detailOptions.style.display = mode === 'detail' ? 'block' : 'none';
      if (simpleBtns) simpleBtns.style.display = mode === 'simple' ? 'inline-flex' : 'none';
      if (detailBtns) detailBtns.style.display = mode === 'detail' ? 'inline-flex' : 'none';
    });
  }
  
  // POS Detail dropdown toggle
  const topicPosDetailBtn = document.getElementById('topicPosDetailBtn');
  const topicPosDetailDropdown = document.getElementById('topicPosDetailDropdown');
  if (topicPosDetailBtn && topicPosDetailDropdown) {
    topicPosDetailBtn.addEventListener('click', function(e) {
      e.stopPropagation();
      topicPosDetailDropdown.style.display = topicPosDetailDropdown.style.display === 'none' ? 'block' : 'none';
    });
    
    // Close dropdown when clicking outside
    document.addEventListener('click', function(e) {
      if (!topicPosDetailDropdown.contains(e.target) && e.target !== topicPosDetailBtn) {
        topicPosDetailDropdown.style.display = 'none';
      }
    });
    
    // Update button text when checkboxes change
    topicPosDetailDropdown.addEventListener('change', function() {
      updatePosDetailButtonText();
    });
  }
  
  // POS Detail Select All/None buttons
  const topicPosSelectAll = document.getElementById('topicPosSelectAll');
  if (topicPosSelectAll) {
    topicPosSelectAll.addEventListener('click', function() {
      const checkboxes = document.querySelectorAll('.topicPosDetailCheckbox');
      checkboxes.forEach(cb => cb.checked = true);
      updatePosDetailButtonText();
    });
  }
  
  const topicPosSelectNone = document.getElementById('topicPosSelectNone');
  if (topicPosSelectNone) {
    topicPosSelectNone.addEventListener('click', function() {
      const checkboxes = document.querySelectorAll('.topicPosDetailCheckbox');
      checkboxes.forEach(cb => cb.checked = false);
      updatePosDetailButtonText();
    });
  }
  
  // POS Simple dropdown toggle
  const topicPosSimpleBtn = document.getElementById('topicPosSimpleBtn');
  const topicPosSimpleDropdown = document.getElementById('topicPosSimpleDropdown');
  if (topicPosSimpleBtn && topicPosSimpleDropdown) {
    topicPosSimpleBtn.addEventListener('click', function(e) {
      e.stopPropagation();
      topicPosSimpleDropdown.style.display = topicPosSimpleDropdown.style.display === 'none' ? 'block' : 'none';
    });
    
    // Close dropdown when clicking outside
    document.addEventListener('click', function(e) {
      if (!topicPosSimpleDropdown.contains(e.target) && e.target !== topicPosSimpleBtn) {
        topicPosSimpleDropdown.style.display = 'none';
      }
    });
    
    // Update button text when checkboxes change
    topicPosSimpleDropdown.addEventListener('change', function() {
      updatePosSimpleButtonText();
    });
  }
  
  // POS Simple Select All/None buttons
  const topicPosSimpleSelectAll = document.getElementById('topicPosSimpleSelectAll');
  if (topicPosSimpleSelectAll) {
    topicPosSimpleSelectAll.addEventListener('click', function() {
      const checkboxes = document.querySelectorAll('.topicPosSimpleCheckbox');
      checkboxes.forEach(cb => cb.checked = true);
      updatePosSimpleButtonText();
    });
  }
  
  const topicPosSimpleSelectNone = document.getElementById('topicPosSimpleSelectNone');
  if (topicPosSimpleSelectNone) {
    topicPosSimpleSelectNone.addEventListener('click', function() {
      const checkboxes = document.querySelectorAll('.topicPosSimpleCheckbox');
      checkboxes.forEach(cb => cb.checked = false);
      updatePosSimpleButtonText();
    });
  }
  
  const topicRefreshVizBtn = document.getElementById('topicRefreshVizBtn');
  if (topicRefreshVizBtn) {
    topicRefreshVizBtn.addEventListener('click', function() {
      if (topicModelResults) {
        // Check if per-folder mode - verify data structure matches mode
        if (topicModelResults.analysisMode === 'perFolder' && topicModelResults.folderResults) {
          displayPerFolderTopicResults(topicModelResults, topicModelResults.topWordsN || 10);
        } else if (topicModelResults.analysisMode !== 'perFolder' && topicModelResults.topWords) {
          displayTopicResults(topicModelResults, topicModelResults.topWordsN || 10);
        } else {
          console.warn('Topic model results structure mismatch');
        }
      }
    });
  }
  
  // Folder selector for per-folder mode
  const topicFolderSelect = document.getElementById('topicFolderSelect');
  if (topicFolderSelect) {
    topicFolderSelect.addEventListener('change', function() {
      if (topicModelResults && topicModelResults.analysisMode === 'perFolder') {
        displayPerFolderTopicResults(topicModelResults, topicModelResults.topWordsN || 10);
      }
    });
  }
  
  const topicExportTopicsBtn = document.getElementById('topicExportTopicsBtn');
  if (topicExportTopicsBtn) {
    topicExportTopicsBtn.addEventListener('click', exportTopicsToCSV);
  }
  
  const topicExportDocTopicBtn = document.getElementById('topicExportDocTopicBtn');
  if (topicExportDocTopicBtn) {
    topicExportDocTopicBtn.addEventListener('click', exportDocTopicToCSV);
  }
  
  const topicExportPngBtn = document.getElementById('topicExportPngBtn');
  if (topicExportPngBtn) {
    topicExportPngBtn.addEventListener('click', exportTopicPNG);
  }
  
  // Topic label set button
  const topicLabelSetBtn = document.getElementById('topicLabelSetBtn');
  if (topicLabelSetBtn) {
    topicLabelSetBtn.addEventListener('click', function() {
      const select = document.getElementById('topicLabelSelect');
      const input = document.getElementById('topicLabelInput');
      const status = document.getElementById('topicLabelStatus');
      
      if (!topicModelResults) {
        status.textContent = 'No topic model computed.';
        return;
      }
      
      const k = parseInt(select.value);
      const label = input.value.trim();
      
      if (label) {
        topicLabels[k] = label;
        status.textContent = `Label set for Topic ${k + 1}: "${label}"`;
        // Update select option text
        select.options[k].textContent = `T${k + 1}: ${label}`;
        // Refresh visualization if results exist
        if (topicModelResults) {
          if (topicModelResults.analysisMode === 'perFolder' && topicModelResults.folderResults) {
            displayPerFolderTopicResults(topicModelResults, topicModelResults.topWordsN || 10);
          } else if (topicModelResults.topWords) {
            displayTopicResults(topicModelResults, topicModelResults.topWordsN || 10);
          }
        }
      } else {
        delete topicLabels[k];
        status.textContent = `Label cleared for Topic ${k + 1}`;
        select.options[k].textContent = `Topic ${k + 1}`;
        if (topicModelResults) {
          if (topicModelResults.analysisMode === 'perFolder' && topicModelResults.folderResults) {
            displayPerFolderTopicResults(topicModelResults, topicModelResults.topWordsN || 10);
          } else if (topicModelResults.topWords) {
            displayTopicResults(topicModelResults, topicModelResults.topWordsN || 10);
          }
        }
      }
      input.value = '';
    });
  }
  
  // Folder-topic export button
  const topicExportFolderTopicBtn = document.getElementById('topicExportFolderTopicBtn');
  if (topicExportFolderTopicBtn) {
    topicExportFolderTopicBtn.addEventListener('click', exportFolderTopicToCSV);
  }
  
  // Show/hide LDA-specific options
  const topicMethodSelect = document.getElementById('topicMethod');
  if (topicMethodSelect) {
    topicMethodSelect.addEventListener('change', function() {
      const ldaOptions = document.getElementById('topicLdaOptions');
      if (ldaOptions) {
        ldaOptions.style.display = this.value === 'lda' ? 'flex' : 'none';
      }
    });
  }
  
  // Clear results when switching between Global and Per-folder mode
  const topicAnalysisModeSelect = document.getElementById('topicAnalysisMode');
  if (topicAnalysisModeSelect) {
    topicAnalysisModeSelect.addEventListener('change', function() {
      // Clear previous results to avoid structure mismatch errors
      topicModelResults = null;
      topicSuggestKResults = null;
      topicColumnWidths = {};
      topicDiagSortCol = null;
      topicDiagSortDir = 'asc';
      document.getElementById('topicResultsArea').style.display = 'none';
      document.getElementById('topicSuggestKResults').style.display = 'none';
      document.getElementById('topicSuggestKOptions').style.display = 'none';
      document.getElementById('topicStatus').textContent = '';
      const canvas = document.getElementById('topicCanvas');
      if (canvas) {
        const ctx = canvas.getContext('2d');
        ctx.clearRect(0, 0, canvas.width, canvas.height);
      }
      document.getElementById('topicWordsTable').innerHTML = '';
      document.getElementById('topicDiagTable').innerHTML = '';
      document.getElementById('topicStatsArea').innerHTML = '';
      
      // Show/hide folder selector based on mode
      const folderSelectorContainer = document.getElementById('topicFolderSelectorContainer');
      if (folderSelectorContainer) {
        folderSelectorContainer.style.display = this.value === 'perFolder' ? 'flex' : 'none';
      }
    });
  }
  
  // Suggest K button - show options
  const topicSuggestKBtn = document.getElementById('topicSuggestKBtn');
  if (topicSuggestKBtn) {
    topicSuggestKBtn.addEventListener('click', function() {
      document.getElementById('topicSuggestKOptions').style.display = 'flex';
    });
  }
  
  // Cancel Suggest K
  const topicCancelSuggestKBtn = document.getElementById('topicCancelSuggestKBtn');
  if (topicCancelSuggestKBtn) {
    topicCancelSuggestKBtn.addEventListener('click', function() {
      document.getElementById('topicSuggestKOptions').style.display = 'none';
      document.getElementById('topicSuggestKResults').style.display = 'none';
    });
  }
  
  // Run Suggest K analysis
  const topicRunSuggestKBtn = document.getElementById('topicRunSuggestKBtn');
  if (topicRunSuggestKBtn) {
    topicRunSuggestKBtn.addEventListener('click', suggestOptimalK);
  }
  
  // Apply suggested K
  const topicApplySuggestKBtn = document.getElementById('topicApplySuggestKBtn');
  if (topicApplySuggestKBtn) {
    topicApplySuggestKBtn.addEventListener('click', function() {
      if (topicSuggestKResults && topicSuggestKResults.bestK) {
        document.getElementById('topicNumTopics').value = topicSuggestKResults.bestK;
        document.getElementById('topicSuggestKOptions').style.display = 'none';
      }
    });
  }
  
  // Export Suggest K results to Excel
  const topicSuggestKExportBtn = document.getElementById('topicSuggestKExportBtn');
  if (topicSuggestKExportBtn) {
    topicSuggestKExportBtn.addEventListener('click', function() {
      if (!topicSuggestKResults || !topicSuggestKResults.rawResults) {
        alert('No K suggestion results to export.');
        return;
      }
      const results = topicSuggestKResults.rawResults;
      const data = [['K', 'Coherence', 'Perplexity', 'CaoJuan2009', 'Arun2010', 'Deveaud2014']];
      for (const r of results) {
        data.push([r.K, r.coherence || '', r.perplexity || '', r.caojuan || '', r.arun || '', r.deveaud || '']);
      }
      downloadExcel(data, 'suggest_k_results.xls', 'SuggestK');
    });
  }
  
  // Export diagnostics CSV
  const topicExportDiagBtn = document.getElementById('topicExportDiagBtn');
  if (topicExportDiagBtn) {
    topicExportDiagBtn.addEventListener('click', exportDiagnosticsToCSV);
  }
  
  // Diagnostics scatter options change handlers
  const topicDiagX = document.getElementById('topicDiagX');
  const topicDiagY = document.getElementById('topicDiagY');
  const topicDiagSizeByTokens = document.getElementById('topicDiagSizeByTokens');
  
  [topicDiagX, topicDiagY, topicDiagSizeByTokens].forEach(el => {
    if (el) {
      el.addEventListener('change', function() {
        if (topicModelResults) {
          const canvas = document.getElementById('topicCanvas');
          const ctx = canvas.getContext('2d');
          drawDiagnosticsScatter(ctx, topicModelResults, canvas.width, canvas.height);
        }
      });
    }
  });
  
  // Visualization type change - show/hide diagnostics options
  const topicVizType = document.getElementById('topicVizType');
  if (topicVizType) {
    topicVizType.addEventListener('change', function() {
      document.getElementById('topicDiagOptions').style.display = this.value === 'diagnostics' ? 'flex' : 'none';
    });
  }

  refreshFeatureTypeOptions();
  refreshKwicFeatureTypeOptions();
  refreshHfFeatureTypeOptions();
  refreshFreqTableFeatureTypeOptions();
  updateKwicViewOptions();
  updateOriginalViewOptions();
  updateCollocatePosOptions();

  // 9-c) Distribution Test (File-level)
  populateDistTestFeatureList();
  populateDistModelBaselineOptions();
  // 9-c folder selection / grouping UI
  populateDistTestFolderCheckboxes();
  toggleDistTestCompareMode();
  const distFolderBtn = document.getElementById('distTestFolderBtn');
  if (distFolderBtn) distFolderBtn.addEventListener('click', (e) => { e.preventDefault(); e.stopPropagation(); toggleDistTestFolderDropdown(e); });
  document.addEventListener('click', (e) => {
    const dd = document.getElementById('distTestFolderDropdown');
    const btn = document.getElementById('distTestFolderBtn');
    if (!dd || !btn) return;
    if (dd.style.display === 'block' && !dd.contains(e.target) && e.target !== btn && !btn.contains(e.target)) {
      dd.style.display = 'none';
    }
  });
  const distShare = document.getElementById('distTestShareWith9b');
  if (distShare) distShare.addEventListener('change', () => { updateDistTestFolderLabel(); });
  const distModeSel = document.getElementById('distTestCompareMode');
  if (distModeSel) distModeSel.addEventListener('change', () => { toggleDistTestCompareMode(); });

  const distRunBtn = document.getElementById('distTestRunBtn');
  if (distRunBtn) distRunBtn.addEventListener('click', runDistTestFileLevel);
  const distClearBtn = document.getElementById('distTestClearBtn');
  if (distClearBtn) distClearBtn.addEventListener('click', clearDistTestFileLevel);
  const distFeatureSel = document.getElementById('distTestFeatureSelect');
  const distModelFitBtn = document.getElementById('distModelFitBtn');
  if (distModelFitBtn) distModelFitBtn.addEventListener('click', fitDistModel);
  const distModelClearBtn = document.getElementById('distModelClearBtn');
  if (distModelClearBtn) distModelClearBtn.addEventListener('click', clearDistModel);
  const distModelBaselineSel = document.getElementById('distModelBaseline');
  if (distModelBaselineSel) distModelBaselineSel.addEventListener('change', () => {});

  if (distFeatureSel) distFeatureSel.addEventListener('change', () => { /* keep plot/results until user runs */ });

});
</script>


<script>
/* === 9-b/9-c Contrast Label ↔ GLM/GLMM Full Linkage (Research Mode) === */
(function () {
  function _sanitizeLabel(s) {
    return String(s || '')
      .trim()
      .replace(/\s+/g, '_')
      .replace(/[^A-Za-z0-9_\-:.]/g, '_')
      .replace(/_+/g, '_')
      .replace(/^_+|_+$/g, '');
  }

  function computeDistContrastLabel(spec) {
    try {
      if (!spec) return '';
      const mode = spec.mode || 'perFolder';

      if (mode === 'pairwise') {
        const f = (spec.folders || []).slice(0, 2);
        if (f.length === 2) return _sanitizeLabel(`${f[0]}_vs_${f[1]}`);
        return '';
      }
      if (mode === 'oneVsRest') {
        const focus = spec.focus || '';
        if (!focus) return '';
        return _sanitizeLabel(`${focus}_vs_Rest`);
      }
      if (mode === 'customGroups') {
        const names = (spec.groups || []).map(g => g.name || '').filter(Boolean);
        if (names.length === 2) return _sanitizeLabel(`${names[0]}_vs_${names[1]}`);
        if (names.length > 2) return _sanitizeLabel(`Custom_${names.join('_')}`);
        return '';
      }

      // perFolder
      const k = (spec.folders || []).length;
      return _sanitizeLabel(`PerFolder_${k}groups`);
    } catch (e) {
      return '';
    }
  }

  function updateDistContrastLabel() {
    const spec = (typeof window.getDistTestGroupingSpec === 'function')
      ? window.getDistTestGroupingSpec()
      : null;

    const label = computeDistContrastLabel(spec);
    window.__wbcaDistContrastLabel = label;

    const box = document.getElementById('distContrastLabel');
    if (box) box.value = label || '';

    const sp = document.getElementById('distModelContrastLabel');
    if (sp) sp.textContent = label || '(not set)';
  }

  function copyDistContrastLabel() {
    const label = window.__wbcaDistContrastLabel || document.getElementById('distContrastLabel')?.value || '';
    if (!label) return;
    if (navigator.clipboard && navigator.clipboard.writeText) {
      navigator.clipboard.writeText(label).catch(() => {});
    } else {
      const ta = document.createElement('textarea');
      ta.value = label;
      document.body.appendChild(ta);
      ta.select();
      try { document.execCommand('copy'); } catch (e) {}
      ta.remove();
    }
  }

  // expose
  window.updateDistContrastLabel = updateDistContrastLabel;
  window.copyDistContrastLabel = copyDistContrastLabel;

  // --- Ensure label updates when 9-b/9-c grouping UI changes ---
  function _wrap(fnName) {
    const orig = window[fnName];
    if (typeof orig !== 'function' || orig.__wbcaWrapped) return;
    const wrapped = function () {
      const r = orig.apply(this, arguments);
      try { updateDistContrastLabel(); } catch (e) {}
      return r;
    };
    wrapped.__wbcaWrapped = true;
    window[fnName] = wrapped;
  }
  _wrap('updateDistTestFolderLabel');
  _wrap('updateDistTestGroupLabels');
  _wrap('updateChiSquareFolderLabel');
  _wrap('updateChiSquareCustomGroupLabels');

  // --- Apply the SAME grouping spec to GLM/GLMM model data (complete linkage) ---
  const __origGetRows = window.getFileLevelModelDataForFeature;
  function applyGroupingSpecToRows(rows, spec) {
    if (!rows || !rows.length || !spec) return rows;

    const mode = spec.mode || 'perFolder';

    // Helper: filter to selected folders when provided
    const selectedFolders = (spec.folders && spec.folders.length) ? new Set(spec.folders) : null;

    if (mode === 'perFolder' || mode === 'pairwise') {
      if (!selectedFolders) return rows;
      return rows.filter(r => selectedFolders.has(r.folder || r.group));
    }

    if (mode === 'oneVsRest') {
      const focus = spec.focus || '';
      if (!focus) return rows;
      const keep = selectedFolders ? (r => selectedFolders.has(r.folder || r.group)) : (() => true);
      return rows.filter(keep).map(r => {
        const folder = r.folder || r.group;
        return Object.assign({}, r, { group: (folder === focus ? focus : 'Rest'), folder });
      });
    }

    if (mode === 'customGroups') {
      const map = new Map();
      (spec.groups || []).forEach(g => {
        (g.folders || []).forEach(f => map.set(f, g.name));
      });
      return rows
        .filter(r => map.has(r.folder || r.group))
        .map(r => {
          const folder = r.folder || r.group;
          return Object.assign({}, r, { group: map.get(folder), folder });
        });
    }

    return rows;
  }

  if (typeof __origGetRows === 'function') {
    window.getFileLevelModelDataForFeature = function (feature, outcomeMode) {
      const rows = __origGetRows.call(this, feature, outcomeMode);
      const spec = (typeof window.getDistTestGroupingSpec === 'function')
        ? window.getDistTestGroupingSpec()
        : null;
      return applyGroupingSpecToRows(rows, spec);
    };
  }

  // --- Patch fitDistModel to stamp contrast into status + keep label fresh ---
  const __origFit = window.fitDistModel;
  if (typeof __origFit === 'function') {
    window.fitDistModel = function () {
      try { updateDistContrastLabel(); } catch (e) {}
      const label = window.__wbcaDistContrastLabel || '';
      const status = document.getElementById('distModelStatus');
      if (status && label) status.dataset.contrast = label;
      return __origFit.apply(this, arguments);
    };
  }

  // Initial
  document.addEventListener('DOMContentLoaded', function () {
    setTimeout(function () {
      try { updateDistContrastLabel(); } catch (e) {}
    }, 0);
  });
})();

// ===========================
// 11-b) Advanced Research Extensions (Permutation/Bootstrap & JSD)
// ===========================
function populateAdv11bFeatureList() {
  const sel = document.getElementById('adv11bFeatureSelect');
  if (!sel) return;
  sel.innerHTML = '';
  
  // Use effective data (respects filters and deletions from 9-a)
  const effectiveData = getEffectiveFreqTableData();
  if (!effectiveData || !Array.isArray(effectiveData.features) || !effectiveData.features.length) {
    const opt = document.createElement('option');
    opt.value = '';
    opt.textContent = '(compute 9-a Frequency Table first)';
    sel.appendChild(opt);
  }
  // Prefer the same feature list as 9-c (derived from 9-a)
  if (typeof populateDistTestFeatureList === 'function') {
    // Ensure 9-c list is up-to-date, then clone options
    populateDistTestFeatureList();
    const srcSel = document.getElementById('distTestFeatureSelect');
    if (srcSel && srcSel.options && srcSel.options.length) {
      for (const opt of Array.from(srcSel.options)) {
        const o = document.createElement('option');
        o.value = opt.value;
        o.textContent = opt.textContent;
        sel.appendChild(o);
      }
      return;
    }
  }
  if (effectiveData && Array.isArray(effectiveData.features)) {
    effectiveData.features.forEach(f => {
      const o = document.createElement('option');
      o.value = String(f);
      o.textContent = String(f);
      sel.appendChild(o);
    });
  }
}

function syncAdv11bFeatureFrom9c() {
  const src = document.getElementById('distTestFeatureSelect');
  const dst = document.getElementById('adv11bFeatureSelect');
  if (src && dst) {
    dst.value = src.value || dst.value;
  }
}

function getAdv11bContrastLabel() {
  // Prefer the shared contrast label used in 9-c grouping UI.
  const el = document.getElementById('distContrastLabel') || document.getElementById('distModelContrastLabel');
  const v = el?.value?.trim();
  if (v) return v;
  // Fallback: regenerate from grouping spec
  if (typeof updateDistTestContrastLabel === 'function') {
    try { updateDistTestContrastLabel(); } catch(e){}
    const v2 = (document.getElementById('distContrastLabel') || document.getElementById('distModelContrastLabel'))?.value?.trim();
    if (v2) return v2;
  }
  return '(auto)';
}

function updateAdv11bContrastView() {
  const span = document.getElementById('adv11bContrastView');
  if (!span) return;
  span.textContent = getAdv11bContrastLabel();
}

function copyAdv11bContrast() {
  const v = getAdv11bContrastLabel();
  if (!v) return;
  try { navigator.clipboard.writeText(v); } catch(e) {}
}

function clearAdv11b() {
  const st = document.getElementById('adv11bStatus');
  const sum = document.getElementById('adv11bSummary');
  const tbl = document.getElementById('adv11bJsdTable');
  if (st) st.textContent = '';
  if (sum) { sum.style.display = 'none'; sum.innerHTML = ''; }
  if (tbl) tbl.innerHTML = '';
  const c = document.getElementById('adv11bCanvas');
  if (c) { const ctx = c.getContext('2d'); ctx.clearRect(0,0,c.width,c.height); }
  const h = document.getElementById('adv11bJsdHeat');
  if (h) { const ctx = h.getContext('2d'); ctx.clearRect(0,0,h.width,h.height); }
}

function _adv11bBuildGroupsFromSpec(folderGroups, groupingSpec) {
  // folderGroups: { folderName: [values...] }
  // returns { groups: {groupName: [values...]}, groupNames: [...] }
  const out = {};
  const mode = groupingSpec?.mode || 'perFolder';

  if (mode === 'customGroups') {
    const gs = groupingSpec.groups || [];
    for (const g of gs) {
      const name = (g.name || '').trim() || 'Group';
      out[name] = [];
      (g.folders || []).forEach(f => {
        if (folderGroups[f]) out[name].push(...folderGroups[f]);
      });
    }
  } else if (mode === 'oneVsRest') {
    const focus = groupingSpec.focusFolder;
    const folders = groupingSpec.folders || [];
    out['Focus'] = folderGroups[focus] ? [...folderGroups[focus]] : [];
    out['Rest'] = [];
    folders.forEach(f => {
      if (f === focus) return;
      if (folderGroups[f]) out['Rest'].push(...folderGroups[f]);
    });
  } else {
    // perFolder or pairwise
    const folders = groupingSpec.folders || Object.keys(folderGroups);
    for (const f of folders) out[f] = folderGroups[f] ? [...folderGroups[f]] : [];
  }

  const groupNames = Object.keys(out).filter(g => Array.isArray(out[g]) && out[g].length > 0);
  return { groups: out, groupNames };
}

function _adv11bApplyMinFiles(groupsObj) {
  const minN = parseInt(document.getElementById('distTestMinFiles')?.value, 10) || 10;
  const groups = {};
  const kept = [];
  const dropped = [];
  for (const [g, arr] of Object.entries(groupsObj)) {
    if (!Array.isArray(arr)) continue;
    if (arr.length >= minN) { groups[g] = arr; kept.push(g); }
    else dropped.push({ group:g, n: arr.length });
  }
  return { groups, kept, dropped, minN };
}

function _adv11bMean(a) {
  let s=0, n=0;
  for (const x of a) { if (Number.isFinite(x)) { s+=x; n++; } }
  return n? s/n : NaN;
}
function _adv11bMedian(a) {
  const b=a.filter(Number.isFinite).slice().sort((x,y)=>x-y);
  if (!b.length) return NaN;
  const m=Math.floor(b.length/2);
  return (b.length%2)? b[m] : (b[m-1]+b[m])/2;
}
function _adv11bKW(groups, names) {
  // Kruskal–Wallis H
  const data = [];
  names.forEach((g,i)=>{ groups[g].forEach(v=>{ if (Number.isFinite(v)) data.push({v, g}); }); });
  const N=data.length;
  if (N < 2) return NaN;

  // rank with ties
  data.sort((a,b)=>a.v-b.v);
  let ranks=new Array(N);
  let i=0;
  while(i<N){
    let j=i;
    while(j+1<N && data[j+1].v===data[i].v) j++;
    const avgRank=(i+1 + j+1)/2; // 1-based
    for (let k=i;k<=j;k++) ranks[k]=avgRank;
    i=j+1;
  }
  const sumRanks={};
  const nBy={};
  for (let k=0;k<N;k++){
    const g=data[k].g;
    sumRanks[g]=(sumRanks[g]||0)+ranks[k];
    nBy[g]=(nBy[g]||0)+1;
  }
  const k=names.length;
  let H=0;
  for (const g of names){
    const n=nBy[g]||0;
    if (!n) continue;
    const R=sumRanks[g]||0;
    H += (R*R)/n;
  }
  H = (12/(N*(N+1))) * H - 3*(N+1);

  // tie correction
  let tieSum=0;
  i=0;
  while(i<N){
    let j=i;
    while(j+1<N && data[j+1].v===data[i].v) j++;
    const t=j-i+1;
    if (t>1) tieSum += (t*t*t - t);
    i=j+1;
  }
  if (tieSum>0){
    const c = 1 - tieSum/(N*N*N - N);
    if (c>0) H = H / c;
  }
  return H;
}

function _adv11bStatObserved(groups, groupNames, statMode) {
  if (statMode === 'meanDiff' || statMode === 'medianDiff') {
    if (groupNames.length !== 2) return NaN;
    const a=groups[groupNames[0]]||[];
    const b=groups[groupNames[1]]||[];
    const f = (statMode==='meanDiff') ? _adv11bMean : _adv11bMedian;
    return f(a) - f(b);
  }
  return _adv11bKW(groups, groupNames);
}

function _adv11bDrawHistogram(canvasId, values, observed) {
  const c=document.getElementById(canvasId);
  if (!c) return;
  const ctx=c.getContext('2d');
  ctx.clearRect(0,0,c.width,c.height);

  if (!values || !values.length || !Number.isFinite(observed)) {
    ctx.fillStyle='#6b7280';
    ctx.font='12px Arial';
    ctx.fillText('No histogram to display.', 10, 20);
    return;
  }
  const pad=30;
  const w=c.width-pad*2, h=c.height-pad*2;
  const v=values.filter(Number.isFinite);
  const min=Math.min(...v, observed);
  const max=Math.max(...v, observed);
  const bins=30;
  const counts=new Array(bins).fill(0);
  const span=(max-min)||1;
  for (const x of v){
    const bi=Math.min(bins-1, Math.max(0, Math.floor((x-min)/span*bins)));
    counts[bi]++;
  }
  const maxC=Math.max(...counts)||1;

  // axes
  ctx.strokeStyle='#e5e7eb';
  ctx.beginPath(); ctx.moveTo(pad, pad); ctx.lineTo(pad, pad+h); ctx.lineTo(pad+w, pad+h); ctx.stroke();

  // bars
  for (let i=0;i<bins;i++){
    const bh = counts[i]/maxC*h;
    const x0 = pad + (i/bins)*w;
    const bw = (w/bins)*0.9;
    const y0 = pad + h - bh;
    ctx.fillStyle = '#93c5fd';
    ctx.fillRect(x0, y0, bw, bh);
  }

  // observed line
  const ox = pad + ((observed-min)/span)*w;
  ctx.strokeStyle='#ef4444';
  ctx.beginPath(); ctx.moveTo(ox, pad); ctx.lineTo(ox, pad+h); ctx.stroke();

  ctx.fillStyle='#111827';
  ctx.font='12px Arial';
  ctx.fillText('Observed', Math.min(ox+6, c.width-70), pad+12);
}

function runAdv11b() {
  const status = document.getElementById('adv11bStatus');
  const summary = document.getElementById('adv11bSummary');
  const method = document.getElementById('adv11bMethod')?.value || 'perm';
  const statMode = document.getElementById('adv11bStat')?.value || 'kw';
  const iters = Math.max(200, parseInt(document.getElementById('adv11bIter')?.value, 10) || 5000);
  const ci = parseFloat(document.getElementById('adv11bCI')?.value || '0.95');
  const alpha = Math.max(0, parseFloat(document.getElementById('adv11bJsdAlpha')?.value || '0.5'));

  updateAdv11bContrastView();
  if (status) status.textContent = 'Computing...';
  if (summary) { summary.style.display='none'; summary.innerHTML=''; }

  if (!corpus || !corpus.files || Object.keys(corpus.files).length===0) {
    if (status) status.textContent = 'Please load a corpus first.';
    return;
  }
  
  // Use effective data (respects filters and deletions from 9-a)
  const effectiveData = getEffectiveFreqTableData();
  if (!effectiveData || !effectiveData.features || !effectiveData.features.length) {
    if (status) status.textContent = 'Please compute 9-a) Frequency Table first.';
    return;
  }

  if (method === 'jsd') {
    const res = adv11bComputeJSD(alpha);
    if (!res) return;
    adv11bRenderJSD(res);
    _adv11bDrawHistogram('adv11bCanvas', [], NaN);
    if (status) status.textContent = `JSD computed for ${res.groupNames.length} groups.`;
    if (summary) {
      summary.style.display='block';
      summary.innerHTML = `<div><strong>JSD</strong> computed from 9-a raw frequencies with smoothing α=${alpha}.</div>` +
                          `<div class="text-xs" style="color:#6b7280;">Contrast: ${escapeHtml(getAdv11bContrastLabel())}</div>`;
    }
    return;
  }

  const feature = document.getElementById('adv11bFeatureSelect')?.value || '';
  if (!feature) {
    if (status) status.textContent = 'Please select a feature.';
    return;
  }

  // File-level values by folder, then regroup by 9-c grouping spec
  const fileData = getFileLevelValuesForFeature(feature);
  if (!fileData || !fileData.groups) {
    if (status) status.textContent = 'Cannot compute file-level values for this feature with the current settings.';
    return;
  }

  const groupingSpec = getDistTestGroupingSpec();
  const built = _adv11bBuildGroupsFromSpec(fileData.groups, groupingSpec);
  const filtered = _adv11bApplyMinFiles(built.groups);
  const groupNames = filtered.kept;

  if (groupNames.length < 2) {
    if (status) status.textContent = `Need 2+ groups with at least n≥${filtered.minN} files each. Dropped: ` +
      (filtered.dropped.length ? filtered.dropped.map(d=>`${d.group}(n=${d.n})`).join(', ') : 'none');
    _adv11bDrawHistogram('adv11bCanvas', [], NaN);
    return;
  }

  // If user chose mean/median diff but not 2 groups, fall back to KW
  let statMode2 = statMode;
  if ((statMode==='meanDiff' || statMode==='medianDiff') && groupNames.length !== 2) statMode2 = 'kw';

  const obs = _adv11bStatObserved(filtered.groups, groupNames, statMode2);
  if (!Number.isFinite(obs)) {
    if (status) status.textContent = 'Observed statistic is not computable (insufficient data).';
    return;
  }

  // Build pooled values and labels
  const pooled = [];
  const labels = [];
  groupNames.forEach((g, gi) => {
    const arr = filtered.groups[g].filter(Number.isFinite);
    arr.forEach(v => { pooled.push(v); labels.push(gi); });
  });

  // Resampling
  const resampled = [];
  const n = pooled.length;

  if (method === 'perm') {
    // permutation test
    for (let b=0;b<iters;b++){
      // shuffle labels
      const perm = labels.slice();
      for (let i=n-1;i>0;i--){
        const j = (Math.random()*(i+1))|0;
        const tmp=perm[i]; perm[i]=perm[j]; perm[j]=tmp;
      }
      const gObj = {};
      groupNames.forEach(g => gObj[g]=[]);
      for (let i=0;i<n;i++){
        const gi = perm[i];
        const gName = groupNames[gi];
        gObj[gName].push(pooled[i]);
      }
      const s = _adv11bStatObserved(gObj, groupNames, statMode2);
      if (Number.isFinite(s)) resampled.push(s);
    }
    // p-value (two-sided for diffs, right-tail for KW)
    let p=1;
    if (statMode2==='meanDiff' || statMode2==='medianDiff') {
      const absObs=Math.abs(obs);
      const ge=resampled.filter(x=>Math.abs(x) >= absObs).length;
      p = (ge+1)/(resampled.length+1);
    } else {
      const ge=resampled.filter(x=>x >= obs).length;
      p = (ge+1)/(resampled.length+1);
    }

    _adv11bDrawHistogram('adv11bCanvas', resampled, obs);
    if (status) status.textContent = `Permutation test completed (${resampled.length} permutations).`;

    if (summary) {
      summary.style.display='block';
      const droppedTxt = filtered.dropped.length ? `<div class="text-xs" style="color:#6b7280;">Dropped (n&lt;${filtered.minN}): ${filtered.dropped.map(d=>`${escapeHtml(d.group)}(n=${d.n})`).join(', ')}</div>` : '';
      summary.innerHTML =
        `<div><strong>Permutation test</strong> on file-level values (feature: <span class="mono">${escapeHtml(feature)}</span>)</div>` +
        `<div>Statistic: <strong>${escapeHtml(statMode2)}</strong> | Observed: <strong>${obs.toFixed(4)}</strong> | Empirical p: <strong>${p.toFixed(4)}</strong></div>` +
        `<div class="text-xs" style="color:#6b7280;">Groups: ${groupNames.map(g=>`${escapeHtml(g)}(n=${filtered.groups[g].length})`).join(', ')} | Contrast: ${escapeHtml(getAdv11bContrastLabel())}</div>` +
        droppedTxt;
    }
  } else {
    // bootstrap CI for the statistic
    for (let b=0;b<iters;b++){
      const gObj = {};
      groupNames.forEach(g => gObj[g]=[]);
      // sample within each group with replacement
      groupNames.forEach((g)=>{
        const arr = filtered.groups[g].filter(Number.isFinite);
        const m = arr.length;
        for (let i=0;i<m;i++){
          const j = (Math.random()*m)|0;
          gObj[g].push(arr[j]);
        }
      });
      const s = _adv11bStatObserved(gObj, groupNames, statMode2);
      if (Number.isFinite(s)) resampled.push(s);
    }
    resampled.sort((a,b)=>a-b);
    const lo = (1-ci)/2;
    const hi = 1-lo;
    const q = (p) => {
      if (!resampled.length) return NaN;
      const idx = Math.min(resampled.length-1, Math.max(0, Math.floor(p*(resampled.length-1))));
      return resampled[idx];
    };
    const ciLo = q(lo);
    const ciHi = q(hi);

    _adv11bDrawHistogram('adv11bCanvas', resampled, obs);
    if (status) status.textContent = `Bootstrap completed (${resampled.length} replicates).`;

    if (summary) {
      summary.style.display='block';
      const droppedTxt = filtered.dropped.length ? `<div class="text-xs" style="color:#6b7280;">Dropped (n&lt;${filtered.minN}): ${filtered.dropped.map(d=>`${escapeHtml(d.group)}(n=${d.n})`).join(', ')}</div>` : '';
      summary.innerHTML =
        `<div><strong>Bootstrap CI</strong> on file-level values (feature: <span class="mono">${escapeHtml(feature)}</span>)</div>` +
        `<div>Statistic: <strong>${escapeHtml(statMode2)}</strong> | Observed: <strong>${obs.toFixed(4)}</strong> | CI(${(ci*100).toFixed(0)}%): <strong>[${ciLo.toFixed(4)}, ${ciHi.toFixed(4)}]</strong></div>` +
        `<div class="text-xs" style="color:#6b7280;">Groups: ${groupNames.map(g=>`${escapeHtml(g)}(n=${filtered.groups[g].length})`).join(', ')} | Contrast: ${escapeHtml(getAdv11bContrastLabel())}</div>` +
        droppedTxt;
    }
  }
}

function adv11bComputeJSD(alpha) {
  // Use effective data (respects filters and deletions from 9-a)
  const effectiveData = getEffectiveFreqTableData();
  if (!effectiveData || !freqTableData || !freqTableData.rawData || !effectiveData.features) {
    const status = document.getElementById('adv11bStatus');
    if (status) status.textContent = 'Please compute 9-a) Frequency Table first (raw frequencies required).';
    return null;
  }

  // Build per-group count vectors from rawData
  const groupingSpec = getDistTestGroupingSpec();
  const rawByFolder = freqTableData.rawData; // folder -> {feature: count}
  const features = effectiveData.features.map(String);

  // Aggregate folder distributions into analysis groups
  const folderKeys = Object.keys(rawByFolder || {});
  const folderDist = {};
  folderKeys.forEach(f => { folderDist[f] = rawByFolder[f] || {}; });

  // Helper to get aggregated distribution object
  const agg = {};
  if (groupingSpec.mode === 'customGroups') {
    (groupingSpec.groups || []).forEach(g => {
      const name = (g.name || '').trim() || 'Group';
      agg[name] = {};
      (g.folders || []).forEach(f => {
        const d = folderDist[f] || {};
        for (const feat of features) {
          const c = d[feat] || 0;
          if (c) agg[name][feat] = (agg[name][feat] || 0) + c;
        }
      });
    });
  } else if (groupingSpec.mode === 'oneVsRest') {
    const focus = groupingSpec.focusFolder;
    const folders = groupingSpec.folders || [];
    agg['Focus'] = {};
    agg['Rest'] = {};
    folders.forEach(f => {
      const d = folderDist[f] || {};
      const tgt = (f === focus) ? agg['Focus'] : agg['Rest'];
      for (const feat of features) {
        const c = d[feat] || 0;
        if (c) tgt[feat] = (tgt[feat] || 0) + c;
      }
    });
  } else {
    const folders = groupingSpec.folders || folderKeys;
    folders.forEach(f => {
      agg[f] = {};
      const d = folderDist[f] || {};
      for (const feat of features) {
        const c = d[feat] || 0;
        if (c) agg[f][feat] = c;
      }
    });
  }

  // Convert to probability vectors with smoothing alpha
  const groupNames = Object.keys(agg).filter(g => agg[g] && Object.keys(agg[g]).length > 0);
  if (groupNames.length < 2) {
    const status = document.getElementById('adv11bStatus');
    if (status) status.textContent = 'Need 2+ groups to compute JSD (check folder/group selection).';
    return null;
  }

  const vecs = {};
  groupNames.forEach(g => {
    const counts = features.map(feat => (agg[g][feat] || 0));
    const smoothed = counts.map(c => c + alpha);
    const total = smoothed.reduce((s,x)=>s+x,0) || 1;
    vecs[g] = smoothed.map(x => x/total);
  });

  // JSD
  const jsd = (p,q) => {
    const m = p.map((x,i)=>(x+q[i])/2);
    const kl = (a,b) => {
      let s=0;
      for (let i=0;i<a.length;i++){
        const ai=a[i], bi=b[i];
        if (ai<=0 || bi<=0) continue;
        s += ai * Math.log2(ai/bi);
      }
      return s;
    };
    const v = 0.5*kl(p,m) + 0.5*kl(q,m);
    return Math.sqrt(Math.max(0,v)); // distance (sqrt JSD)
  };

  const matrix = [];
  for (let i=0;i<groupNames.length;i++){
    const row=[];
    for (let j=0;j<groupNames.length;j++){
      row.push(jsd(vecs[groupNames[i]], vecs[groupNames[j]]));
    }
    matrix.push(row);
  }
  return { groupNames, matrix, alpha };
}

function adv11bRenderJSD(res) {
  const tbl = document.getElementById('adv11bJsdTable');
  const heat = document.getElementById('adv11bJsdHeat');
  if (!tbl || !heat) return;

  // Allow optional ordering (e.g., hierarchical clustering)
  const _names0 = res.groupNames.slice();
  const _M0 = res.matrix.map(r=>r.slice());
  let order = (res.order && Array.isArray(res.order) && res.order.length===_names0.length) ? res.order.slice() : null;
  const names = order ? order.map(i=>_names0[i]) : _names0;
  const M = order ? order.map(i=>order.map(j=>_M0[i][j])) : _M0;

  // Summary (mean distance, closest/farthest pairs)
  const sumDiv = document.getElementById('adv11bJsdSummary');
  if (sumDiv) {
    const k = names.length;
    let s=0, c=0;
    let minV=Infinity, minI=-1, minJ=-1;
    let maxV=-Infinity, maxI=-1, maxJ=-1;
    for (let i=0;i<k;i++){
      for (let j=i+1;j<k;j++){
        const v = M[i][j];
        if (!isFinite(v)) continue;
        s += v; c += 1;
        if (v < minV){ minV=v; minI=i; minJ=j; }
        if (v > maxV){ maxV=v; maxI=i; maxJ=j; }
      }
    }
    const mean = c ? (s/c) : 0;
    let htmlS = `<strong>Distance summary:</strong> mean √JSD = ${mean.toFixed(4)} (k=${k}).`;
    if (minI>=0) htmlS += ` Closest: <code>${escapeHtml(names[minI])} ↔ ${escapeHtml(names[minJ])}</code> (${minV.toFixed(4)}).`;
    if (maxI>=0) htmlS += ` Farthest: <code>${escapeHtml(names[maxI])} ↔ ${escapeHtml(names[maxJ])}</code> (${maxV.toFixed(4)}).`;
    sumDiv.innerHTML = htmlS;
  }

  // Table
  let html = '<table style="border-collapse:collapse; width:100%;">';
  html += '<thead><tr><th style="position:sticky; top:0; background:#f9fafb; border:1px solid #e5e7eb; padding:4px 6px; text-align:left;">Group</th>';
  names.forEach(n => {
    html += `<th style="position:sticky; top:0; background:#f9fafb; border:1px solid #e5e7eb; padding:4px 6px; text-align:right;">${escapeHtml(n)}</th>`;
  });
  html += '</tr></thead><tbody>';
  for (let i=0;i<names.length;i++){
    html += `<tr><td style="border:1px solid #e5e7eb; padding:4px 6px;">${escapeHtml(names[i])}</td>`;
    for (let j=0;j<names.length;j++){
      html += `<td style="border:1px solid #e5e7eb; padding:4px 6px; text-align:right;">${M[i][j].toFixed(4)}</td>`;
    }
    html += '</tr>';
  }
  html += '</tbody></table>';
  tbl.innerHTML = html;

  // Heatmap (grayscale; no fixed palette)
  const ctx = heat.getContext('2d');
  ctx.clearRect(0,0,heat.width,heat.height);
  const padL = 80;
  const padT = 20;
  const size = Math.min(heat.width-padL-10, heat.height-padT-10);
  const cell = size / names.length;

  // find max off-diagonal
  let maxV = 0;
  for (let i=0;i<names.length;i++){
    for (let j=0;j<names.length;j++){
      if (i===j) continue;
      maxV = Math.max(maxV, M[i][j]);
    }
  }
  maxV = maxV || 1;

  // labels
  ctx.fillStyle = '#111827';
  ctx.font = '11px Arial';
  for (let i=0;i<names.length;i++){
    ctx.fillText(names[i].slice(0,10), 2, padT + i*cell + cell*0.65);
    ctx.save();
    ctx.translate(padL + i*cell + cell*0.5, 12);
    ctx.rotate(-Math.PI/4);
    ctx.fillText(names[i].slice(0,10), 0, 0);
    ctx.restore();
  }

  // cells
  for (let i=0;i<names.length;i++){
    for (let j=0;j<names.length;j++){
      const v = M[i][j];
      const t = Math.min(1, v/maxV);
      const shade = Math.floor(255 - t*180); // 255=white, lower=darker
      ctx.fillStyle = `rgb(${shade},${shade},${shade})`;
      ctx.fillRect(padL + j*cell, padT + i*cell, cell, cell);
      ctx.strokeStyle = '#e5e7eb';
      ctx.strokeRect(padL + j*cell, padT + i*cell, cell, cell);
    }
  }
}
// --- 11-b JSD hierarchical clustering (average linkage) ---
function adv11bClusterAndReorderJSD() {
  try {
    const res = window.__adv11bLastJsdRes;
    if (!res || !res.groupNames || !res.matrix) return;
    const order = adv11bHierarchicalOrderAverage(res.matrix);
    res.order = order;
    window.__adv11bLastJsdRes = res;
    adv11bRenderJSD(res);
  } catch (e) {
    console.error(e);
    const sumDiv = document.getElementById('adv11bJsdSummary');
    if (sumDiv) sumDiv.innerHTML = '<span style="color:#b91c1c;">Clustering failed.</span>';
  }
}

function adv11bResetJSDOrder() {
  const res = window.__adv11bLastJsdRes;
  if (!res) return;
  delete res.order;
  window.__adv11bLastJsdRes = res;
  adv11bRenderJSD(res);
}

function exportJsdExcel() {
  const res = window.__adv11bLastJsdRes;
  if (!res || !res.names || !res.matrix) {
    alert('No JSD results to export. Run JSD analysis first.');
    return;
  }
  const names = res.order ? res.order.map(i => res.names[i]) : res.names;
  const M = res.matrix;
  const order = res.order || res.names.map((_, i) => i);
  
  let html = `<html><head><meta charset="UTF-8"></head><body>
    <h3>Jensen-Shannon Distance Matrix</h3>
    <table border="1" style="border-collapse:collapse;">
      <tr><th></th>`;
  for (const n of names) html += `<th>${escapeHtml(n)}</th>`;
  html += '</tr>';
  
  for (let i = 0; i < names.length; i++) {
    html += `<tr><th>${escapeHtml(names[i])}</th>`;
    for (let j = 0; j < names.length; j++) {
      const val = M[order[i]][order[j]];
      html += `<td style="text-align:center;">${isFinite(val) ? val.toFixed(4) : '-'}</td>`;
    }
    html += '</tr>';
  }
  html += '</table></body></html>';
  
  const blob = new Blob([html], { type: 'application/vnd.ms-excel' });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = 'jsd_matrix.xls';
  a.click();
  URL.revokeObjectURL(url);
}

function exportJsdPng() {
  const canvas = document.getElementById('adv11bJsdHeat');
  if (!canvas) {
    alert('No JSD heatmap to export.');
    return;
  }
  const url = canvas.toDataURL('image/png');
  const a = document.createElement('a');
  a.href = url;
  a.download = 'jsd_heatmap.png';
  a.click();
}

// Average-linkage hierarchical clustering; returns a leaf order (indices)
function adv11bHierarchicalOrderAverage(M) {
  const n = M.length;
  let nodes = [];
  for (let i=0;i<n;i++) nodes.push({ left:null, right:null, leaves:[i] });

  const distClusters = (a,b) => {
    let s=0, c=0;
    for (let i=0;i<a.length;i++){
      for (let j=0;j<b.length;j++){
        const v = M[a[i]][b[j]];
        if (!isFinite(v)) continue;
        s += v; c += 1;
      }
    }
    return c ? (s/c) : Infinity;
  };

  while (nodes.length > 1) {
    let bestI=0, bestJ=1, bestD=Infinity;
    for (let i=0;i<nodes.length;i++){
      for (let j=i+1;j<nodes.length;j++){
        const d = distClusters(nodes[i].leaves, nodes[j].leaves);
        if (d < bestD) { bestD=d; bestI=i; bestJ=j; }
      }
    }
    const A = nodes[bestI], B = nodes[bestJ];
    const merged = { left:A, right:B, leaves: A.leaves.concat(B.leaves) };
    nodes.splice(bestJ,1);
    nodes.splice(bestI,1);
    nodes.push(merged);
  }

  const orderNode = (node) => {
    if (!node.left && !node.right) return node.leaves.slice();
    const L = orderNode(node.left);
    const R = orderNode(node.right);
    const dLR = M[L[L.length-1]][R[0]];
    const dRL = M[R[R.length-1]][L[0]];
    if (isFinite(dLR) && isFinite(dRL) && dRL < dLR) return R.concat(L);
    return L.concat(R);
  };

  return orderNode(nodes[0]);
}


// Hook feature list and contrast updates
(function initAdv11b() {
  try { populateAdv11bFeatureList(); } catch(e) {}
  try { updateAdv11bContrastView(); } catch(e) {}

  // Keep contrast label in sync when 9-c settings change
  const ids = [
    'distTestCompareMode','distTestShareWith9b','distTestMinFiles','distTestDataMode','distTestNormBase',
    'distTestFolderCheckboxes','distTestFocusFolder','distTestGroupsContainer','distContrastLabel'
  ];
  ids.forEach(id=>{
    const el = document.getElementById(id);
    if (el) {
      el.addEventListener('change', ()=>{ updateAdv11bContrastView(); });
      el.addEventListener('input',  ()=>{ updateAdv11bContrastView(); });
    }
  });
})();


// --- Bayesian Modeling (Gamma–Poisson / Beta–Binomial) ---
function runBayesianDistModel() {
  const out = document.getElementById('bayesOutput');
  if (out) out.innerHTML = '';
  try {
    if (!corpus || !corpus.files || Object.keys(corpus.files).length===0) {
      if (out) out.innerHTML = '<span style="color:#b91c1c;">Please load a corpus first.</span>';
      return;
    }
    const fSel = document.getElementById('distTestFeature') || document.getElementById('distFeatureSelect') || document.getElementById('adv11bFeatureSelect');
    const feature = fSel ? fSel.value : '';
    if (!feature) {
      if (out) out.innerHTML = '<span style="color:#b91c1c;">Please select a feature first (9-c).</span>';
      return;
    }

    const modelType = document.getElementById('bayesModelType')?.value || 'gammaPoisson';
    const a0 = Math.max(1e-6, parseFloat(document.getElementById('bayesPriorA')?.value || '1'));
    const b0 = Math.max(1e-6, parseFloat(document.getElementById('bayesPriorB')?.value || '1'));
    const S = Math.max(500, parseInt(document.getElementById('bayesSamples')?.value || '5000', 10));

    const fileData = getFileLevelValuesForFeature(feature);
    if (!fileData || !fileData.groups) {
      if (out) out.innerHTML = '<span style="color:#b91c1c;">Cannot compute file-level values for this feature.</span>';
      return;
    }

    const groupingSpec = getDistTestGroupingSpec();
    const built = _adv11bBuildGroupsFromSpec(fileData.groups, groupingSpec);
    const filtered = _adv11bApplyMinFiles(built.groups);
    const groups = filtered.groups;
    const names = filtered.kept;

    if (names.length < 2) {
      if (out) out.innerHTML = `<span style="color:#b91c1c;">Need 2+ groups with at least n≥${filtered.minN} files each.</span>`;
      return;
    }

    const agg = {};
    for (const g of names) {
      const arr = groups[g] || [];
      let y=0, t=0, s=0, n=0;
      for (const it of arr) {
        if (it && isFinite(it.tokens)) t += Math.max(0, it.tokens);
        if (it && isFinite(it.count)) y += Math.max(0, it.count);
        if (it && isFinite(it.df)) s += (it.df ? 1 : 0);
        n += 1;
      }
      agg[g] = { y, t, s, n };
    }

    const randn = () => {
      let u=0,v=0;
      while(u===0) u=Math.random();
      while(v===0) v=Math.random();
      return Math.sqrt(-2*Math.log(u))*Math.cos(2*Math.PI*v);
    };
    const rgamma = (shape, rate) => {
      if (shape < 1) {
        const u = Math.random();
        return rgamma(shape+1, rate) * Math.pow(u, 1/shape);
      }
      const d = shape - 1/3;
      const c = 1/Math.sqrt(9*d);
      while(true){
        let x = randn();
        let v = 1 + c*x;
        if (v <= 0) continue;
        v = v*v*v;
        const u = Math.random();
        if (u < 1 - 0.0331*(x*x)*(x*x)) return (d*v)/rate;
        if (Math.log(u) < 0.5*x*x + d*(1 - v + Math.log(v))) return (d*v)/rate;
      }
    };
    const rbeta = (a,b) => {
      const x = rgamma(a, 1);
      const y = rgamma(b, 1);
      return x/(x+y);
    };
    const quantile = (arr, q) => {
      const a = arr.slice().sort((x,y)=>x-y);
      const pos = (a.length-1)*q;
      const lo = Math.floor(pos), hi = Math.ceil(pos);
      if (lo===hi) return a[lo];
      return a[lo] + (a[hi]-a[lo])*(pos-lo);
    };

    const post = {};
    if (modelType === 'gammaPoisson') {
      for (const g of names) {
        const y = agg[g].y;
        const t = Math.max(1e-9, agg[g].t);
        const shape = a0 + y;
        const rate = b0 + t;
        const draws = new Array(S);
        for (let i=0;i<S;i++) draws[i] = rgamma(shape, rate);
        post[g] = draws;
      }
    } else {
      for (const g of names) {
        const s = agg[g].s;
        const n = agg[g].n;
        const A = a0 + s;
        const B = b0 + (n - s);
        const draws = new Array(S);
        for (let i=0;i<S;i++) draws[i] = rbeta(A,B);
        post[g] = draws;
      }
    }

    let htmlOut = `<div style="padding:0.4rem 0.6rem; background:#f9fafb; border:1px solid #e5e7eb; border-radius:6px;">
      <div><strong>Contrast:</strong> <code>${escapeHtml(document.getElementById('distModelContrastLabel')?.textContent || '(not set)')}</code></div>
      <div><strong>Feature:</strong> <code>${escapeHtml(feature)}</code> &nbsp; <strong>Model:</strong> ${escapeHtml(modelType==='gammaPoisson'?'Gamma–Poisson':'Beta–Binomial')}</div>
      <div><strong>Groups:</strong> ${names.map(g=>`${escapeHtml(g)} (n=${agg[g].n})`).join(', ')}</div>
    </div>`;

    htmlOut += `<div class="mt-05"><strong>Posterior summaries</strong> (median [95% CrI])</div>`;
    htmlOut += `<div style="max-height:220px; overflow:auto; border:1px solid #e5e7eb; border-radius:6px;">
      <table style="border-collapse:collapse; width:100%; font-size:0.85rem;">
        <thead><tr style="background:#f3f4f6;">
          <th style="border:1px solid #e5e7eb; padding:4px 6px; text-align:left;">Group</th>
          <th style="border:1px solid #e5e7eb; padding:4px 6px; text-align:right;">Median</th>
          <th style="border:1px solid #e5e7eb; padding:4px 6px; text-align:right;">2.5%</th>
          <th style="border:1px solid #e5e7eb; padding:4px 6px; text-align:right;">97.5%</th>
        </tr></thead><tbody>`;
    for (const g of names) {
      const d = post[g];
      const med = quantile(d,0.5), lo = quantile(d,0.025), hi = quantile(d,0.975);
      htmlOut += `<tr>
        <td style="border:1px solid #e5e7eb; padding:4px 6px;">${escapeHtml(g)}</td>
        <td style="border:1px solid #e5e7eb; padding:4px 6px; text-align:right;">${med.toFixed(6)}</td>
        <td style="border:1px solid #e5e7eb; padding:4px 6px; text-align:right;">${lo.toFixed(6)}</td>
        <td style="border:1px solid #e5e7eb; padding:4px 6px; text-align:right;">${hi.toFixed(6)}</td>
      </tr>`;
    }
    htmlOut += `</tbody></table></div>`;

    if (names.length === 2) {
      const A = names[0], B = names[1];
      const r = new Array(S);
      let gt=0;
      for (let i=0;i<S;i++){
        r[i] = post[A][i] / Math.max(1e-12, post[B][i]);
        if (r[i] > 1) gt++;
      }
      const med = quantile(r,0.5), lo = quantile(r,0.025), hi = quantile(r,0.975);
      const pgt = gt / S;
      const label = (modelType==='gammaPoisson') ? 'Rate ratio (IRR)' : 'Probability ratio';
      htmlOut += `<div class="mt-05" style="padding:0.5rem; border:1px solid #e5e7eb; border-radius:6px; background:#fff;">
        <strong>${escapeHtml(label)}:</strong> <code>${escapeHtml(A)} / ${escapeHtml(B)}</code>
        = ${med.toFixed(4)} [${lo.toFixed(4)}, ${hi.toFixed(4)}]; P(ratio &gt; 1) = ${pgt.toFixed(3)}
      </div>`;
    } else {
      htmlOut += `<div class="help-text mt-05">Tip: For pairwise ratios, switch Grouping mode to Pairwise or One-vs-Rest.</div>`;
    }

    if (out) out.innerHTML = htmlOut;
  } catch (e) {
    console.error(e);
    if (out) out.innerHTML = '<span style="color:#b91c1c;">Bayesian modeling failed.</span>';
  }
}



// ===============================
// 11-c) Association & Explanatory Modeling (Correlation & Regression)
// ===============================
let __last11cCorr = null; // { xFeature, yFeature, method, stat, ci, p, n, points: [{x,y,g}] }
let __last11cReg = null;  // { outcomeFeature, outcomeType, model, rows, coefTable, aic, overdisp, n }

function toggle11cExportMenu(menuId) {
  const el = document.getElementById(menuId);
  if (!el) return;
  const isOpen = el.style.display === 'block';
  // close all 11c menus
  const menus = ['11cCorrExportMenu', '11cRegExportMenu'];
  menus.forEach(id => {
    const m = document.getElementById(id);
    if (m) m.style.display = 'none';
  });
  el.style.display = isOpen ? 'none' : 'block';
}

document.addEventListener('click', (e) => {
  const t = e.target;
  if (!t) return;
  // close export menus when clicking outside
  if (!t.closest || !t.closest('.dropdown')) {
    ['11cCorrExportMenu','11cRegExportMenu'].forEach(id => {
      const el = document.getElementById(id);
      if (el) el.style.display = 'none';
    });
  }
});

function populate11cFeatureSelectors() {
  // Copy options from distTestFeatureSelect (authoritative) if available.
  const src = document.getElementById('distTestFeatureSelect');
  const xSel = document.getElementById('assocXFeature');
  const ySel = document.getElementById('assocYFeature');
  const outSel = document.getElementById('assocRegOutcomeFeature');

  if (!xSel || !ySel || !outSel) return;

  const copyOptions = (target) => {
    const prev = target.value;
    target.innerHTML = '';
    if (src && src.options && src.options.length) {
      for (const opt of Array.from(src.options)) {
        const o = document.createElement('option');
        o.value = opt.value;
        o.textContent = opt.textContent;
        target.appendChild(o);
      }
    } else {
      // fallback: populate via feature list builder
      try { populateDistTestFeatureList(); } catch (e) {}
      const src2 = document.getElementById('distTestFeatureSelect');
      if (src2 && src2.options && src2.options.length) {
        for (const opt of Array.from(src2.options)) {
          const o = document.createElement('option');
          o.value = opt.value;
          o.textContent = opt.textContent;
          target.appendChild(o);
        }
      }
    }
    // restore best-effort previous selection
    if (prev) target.value = prev;
  };

  copyOptions(xSel);
  copyOptions(ySel);
  copyOptions(outSel);

  // default pairing: x = current distTest feature, y = next (or same)
  try {
    const cur = src ? src.value : xSel.value;
    if (cur) xSel.value = cur;
    if (ySel.options.length > 1) {
      const i = Math.max(0, Array.from(ySel.options).findIndex(o => o.value === xSel.value));
      ySel.selectedIndex = Math.min(ySel.options.length - 1, i + 1);
    }
    outSel.value = ySel.value || xSel.value;
  } catch (e) {}
  
  // Also refresh regression predictor list
  if (typeof refreshRegPredictors === 'function') {
    try { refreshRegPredictors(); } catch (e) {}
  }
}

function update11cContext() {
  const groupsEl = document.getElementById('assocCtxGroups');
  const modeEl = document.getElementById('assocCtxMode');
  const baseEl = document.getElementById('assocCtxBaseline');
  const ctrEl = document.getElementById('assocCtxContrast');
  const minEl = document.getElementById('assocCtxMinN');

  if (!groupsEl || !modeEl || !baseEl || !ctrEl || !minEl) return;

  const spec = getDistTestGroupingSpec ? getDistTestGroupingSpec() : { mode: 'perFolder', folders: [] };
  const minFiles = parseInt(document.getElementById('distTestMinFiles')?.value, 10) || 10;
  const baseline = document.getElementById('distBaselineGroup')?.value || '(not set)';
  const contrast = document.getElementById('distTestContrastLabel')?.value || '(not set)';

  modeEl.textContent = spec.mode || 'perFolder';
  baseEl.textContent = baseline || '(not set)';
  ctrEl.textContent = contrast || '(not set)';
  minEl.textContent = String(minFiles);

  // show group labels computed from current X feature (best effort)
  const xSel = document.getElementById('assocXFeature');
  const xFeature = xSel ? xSel.value : '';
  if (xFeature) {
    const ds = getAligned11cDataset(xFeature, xFeature); // to enumerate groups
    if (ds && ds.groupNames) {
      const parts = ds.groupNames.map(g => `${g} (n=${ds.groupCounts[g]||0})`);
      groupsEl.textContent = parts.join(', ');
    } else {
      groupsEl.textContent = '(not set)';
    }
  } else {
    groupsEl.textContent = '(not set)';
  }
}

function resolve11cGroupLabel(folder, spec) {
  if (!spec || !spec.mode) return { ok: true, label: folder };

  const mode = spec.mode;
  if (mode === 'customGroups') {
    const custom = (spec.groups || []).filter(g => g && Array.isArray(g.folders) && g.folders.length);
    for (const g of custom) {
      if (g.folders.includes(folder)) return { ok: true, label: g.name || 'Group' };
    }
    return { ok: false, label: null };
  }

  const selected = new Set((spec.folders || []).filter(Boolean));
  if (mode === 'pairwise') {
    if (selected.size && !selected.has(folder)) return { ok: false, label: null };
    return { ok: true, label: folder };
  }

  if (mode === 'oneVsRest') {
    if (selected.size && !selected.has(folder)) return { ok: false, label: null };
    const focus = spec.focus || '';
    return { ok: true, label: (folder === focus ? focus : 'Rest') };
  }

  // perFolder (default): filter to selected folders if any
  if (selected.size && !selected.has(folder)) return { ok: false, label: null };
  return { ok: true, label: folder };
}

function getAligned11cDataset(xFeature, yFeature) {
  if (!corpus || !corpus.files) return null;
  if (!xFeature || !yFeature) return null;

  const spec = getDistTestGroupingSpec ? getDistTestGroupingSpec() : { mode: 'perFolder', folders: [] };
  const minFiles = parseInt(document.getElementById('distTestMinFiles')?.value, 10) || 10;

  const xData = getFileLevelValuesForFeature(xFeature);
  const yData = getFileLevelValuesForFeature(yFeature);
  if (!xData || !yData || !xData.fileMap || !yData.fileMap) return null;

  const xf = xData.fileMap;
  const yf = yData.fileMap;

  const rows = [];
  for (const fileName in xf) {
    if (!Object.prototype.hasOwnProperty.call(xf, fileName)) continue;
    if (!yf[fileName]) continue;
    const folder = xf[fileName].folder;
    if (folder !== yf[fileName].folder) continue; // safety
    const res = resolve11cGroupLabel(folder, spec);
    if (!res.ok) continue;
    rows.push({
      file: fileName,
      folder,
      group: res.label,
      x: xf[fileName].value,
      y: yf[fileName].value,
      xCount: xf[fileName].count,
      yCount: yf[fileName].count,
      xDF: xf[fileName].count > 0 ? 1 : 0,
      yDF: yf[fileName].count > 0 ? 1 : 0,
      tokens: xf[fileName].totalTokens || 0
    });
  }

  // enforce min files per group
  const groupCounts = {};
  rows.forEach(r => { groupCounts[r.group] = (groupCounts[r.group] || 0) + 1; });
  const keepGroups = new Set(Object.keys(groupCounts).filter(g => groupCounts[g] >= minFiles));
  const filtered = rows.filter(r => keepGroups.has(r.group));

  const groupNames = Array.from(keepGroups).sort();
  const groupCounts2 = {};
  filtered.forEach(r => { groupCounts2[r.group] = (groupCounts2[r.group] || 0) + 1; });

  return { rows: filtered, groupNames, groupCounts: groupCounts2, spec, minFiles };
}

// ---------- Correlation helpers ----------
function rankWithTies(arr) {
  const indexed = arr.map((v, i) => ({ v, i })).sort((a, b) => (a.v < b.v ? -1 : a.v > b.v ? 1 : 0));
  const ranks = Array(arr.length);
  let i = 0;
  while (i < indexed.length) {
    let j = i;
    while (j + 1 < indexed.length && indexed[j + 1].v === indexed[i].v) j++;
    const avgRank = (i + j + 2) / 2; // ranks start at 1
    for (let k = i; k <= j; k++) ranks[indexed[k].i] = avgRank;
    i = j + 1;
  }
  return ranks;
}

function pearsonCorr(x, y) {
  const n = x.length;
  if (n < 3) return NaN;
  let mx = 0, my = 0;
  for (let i = 0; i < n; i++) { mx += x[i]; my += y[i]; }
  mx /= n; my /= n;
  let num = 0, dx = 0, dy = 0;
  for (let i = 0; i < n; i++) {
    const a = x[i] - mx;
    const b = y[i] - my;
    num += a * b;
    dx += a * a;
    dy += b * b;
  }
  const den = Math.sqrt(dx * dy);
  return den === 0 ? NaN : num / den;
}

function spearmanRho(x, y) {
  return pearsonCorr(rankWithTies(x), rankWithTies(y));
}

function kendallTau(x, y) {
  const n = x.length;
  if (n < 3) return NaN;
  let concord = 0, discord = 0, tieX = 0, tieY = 0;
  for (let i = 0; i < n - 1; i++) {
    for (let j = i + 1; j < n; j++) {
      const dx = x[i] - x[j];
      const dy = y[i] - y[j];
      if (dx === 0 && dy === 0) continue;
      if (dx === 0) { tieX++; continue; }
      if (dy === 0) { tieY++; continue; }
      const s = dx * dy;
      if (s > 0) concord++;
      else if (s < 0) discord++;
    }
  }
  const denom = Math.sqrt((concord + discord + tieX) * (concord + discord + tieY));
  return denom === 0 ? NaN : (concord - discord) / denom;
}

function approxPForCorr(stat, n, method) {
  if (!isFinite(stat) || n < 3) return NaN;
  // crude approximations (sufficient for exploratory reporting; bootstrap/permutation recommended in Methods)
  if (method === 'kendall') {
    const z = 3 * stat * Math.sqrt(n * (n - 1) / (2 * (2 * n + 5)));
    const p = 2 * (1 - normalCdf(Math.abs(z)));
    return p;
  }
  // Pearson and Spearman: t = r * sqrt((n-2)/(1-r²))
  const t = stat * Math.sqrt((n - 2) / Math.max(1e-12, 1 - stat * stat));
  const p = 2 * (1 - studentTCdf(Math.abs(t), n - 2));
  return p;
}

// normal CDF approximation
function normalCdf(x) {
  // Abramowitz & Stegun approximation
  const t = 1 / (1 + 0.2316419 * x);
  const d = 0.3989423 * Math.exp(-x * x / 2);
  let prob = d * t * (0.3193815 + t * (-0.3565638 + t * (1.781478 + t * (-1.821256 + t * 1.330274))));
  if (x > 0) prob = 1 - prob;
  return prob;
}

// Student-t CDF approximation via regularized incomplete beta (simple)
function studentTCdf(t, df) {
  // for our usage: df >= 1, t >= 0
  if (df <= 0) return NaN;
  const x = df / (df + t * t);
  const a = df / 2;
  const b = 0.5;
  const ib = regIncompleteBeta(x, a, b);
  // for t >= 0: CDF = 1 - 0.5 * I_{x}(a,b)
  return 1 - 0.5 * ib;
}

// Regularized incomplete beta using continued fraction (Numerical Recipes)
function regIncompleteBeta(x, a, b) {
  if (x <= 0) return 0;
  if (x >= 1) return 1;
  const bt = Math.exp(logGamma(a + b) - logGamma(a) - logGamma(b) + a * Math.log(x) + b * Math.log(1 - x));
  if (x < (a + 1) / (a + b + 2)) {
    return bt * betacf(x, a, b) / a;
  } else {
    return 1 - bt * betacf(1 - x, b, a) / b;
  }
}
function betacf(x, a, b) {
  const MAXIT = 200;
  const EPS = 3e-7;
  const FPMIN = 1e-30;
  let qab = a + b;
  let qap = a + 1;
  let qam = a - 1;
  let c = 1;
  let d = 1 - qab * x / qap;
  if (Math.abs(d) < FPMIN) d = FPMIN;
  d = 1 / d;
  let h = d;
  for (let m = 1; m <= MAXIT; m++) {
    const m2 = 2 * m;
    let aa = m * (b - m) * x / ((qam + m2) * (a + m2));
    d = 1 + aa * d;
    if (Math.abs(d) < FPMIN) d = FPMIN;
    c = 1 + aa / c;
    if (Math.abs(c) < FPMIN) c = FPMIN;
    d = 1 / d;
    h *= d * c;
    aa = -(a + m) * (qab + m) * x / ((a + m2) * (qap + m2));
    d = 1 + aa * d;
    if (Math.abs(d) < FPMIN) d = FPMIN;
    c = 1 + aa / c;
    if (Math.abs(c) < FPMIN) c = FPMIN;
    d = 1 / d;
    const del = d * c;
    h *= del;
    if (Math.abs(del - 1) < EPS) break;
  }
  return h;
}
function logGamma(z) {
  // Lanczos approximation
  const g = 7;
  const p = [
    0.99999999999980993,
    676.5203681218851,
    -1259.1392167224028,
    771.32342877765313,
    -176.61502916214059,
    12.507343278686905,
    -0.13857109526572012,
    9.9843695780195716e-6,
    1.5056327351493116e-7
  ];
  if (z < 0.5) return Math.log(Math.PI) - Math.log(Math.sin(Math.PI * z)) - logGamma(1 - z);
  z -= 1;
  let x = p[0];
  for (let i = 1; i < p.length; i++) x += p[i] / (z + i);
  const t = z + g + 0.5;
  return 0.5 * Math.log(2 * Math.PI) + (z + 0.5) * Math.log(t) - t + Math.log(x);
}

// ---------- Drawing ----------
function draw11cScatter(canvas, points, xLabel, yLabel) {
  if (!canvas) return;
  const ctx = canvas.getContext('2d');
  const W = canvas.width, H = canvas.height;
  ctx.clearRect(0, 0, W, H);

  // margins
  const ml = 55, mr = 15, mt = 20, mb = 45;
  const pw = W - ml - mr, ph = H - mt - mb;

  // background
  ctx.fillStyle = '#ffffff';
  ctx.fillRect(0, 0, W, H);

  if (!points || points.length === 0) {
    ctx.fillStyle = '#6b7280';
    ctx.font = '14px Arial';
    ctx.fillText('No data to plot (check grouping/min-n and feature selections).', ml, mt + 20);
    return;
  }

  const xs = points.map(p => p.x);
  const ys = points.map(p => p.y);
  let xmin = Math.min(...xs), xmax = Math.max(...xs);
  let ymin = Math.min(...ys), ymax = Math.max(...ys);
  if (xmin === xmax) { xmin -= 1; xmax += 1; }
  if (ymin === ymax) { ymin -= 1; ymax += 1; }

  const x2px = (x) => ml + (x - xmin) / (xmax - xmin) * pw;
  const y2py = (y) => mt + (1 - (y - ymin) / (ymax - ymin)) * ph;

  // axes
  ctx.strokeStyle = '#111827';
  ctx.lineWidth = 1;
  ctx.beginPath();
  ctx.moveTo(ml, mt);
  ctx.lineTo(ml, mt + ph);
  ctx.lineTo(ml + pw, mt + ph);
  ctx.stroke();

  // ticks
  ctx.fillStyle = '#111827';
  ctx.font = '12px Arial';
  const ticks = 5;
  for (let i = 0; i <= ticks; i++) {
    const tx = xmin + (xmax - xmin) * i / ticks;
    const px = x2px(tx);
    ctx.strokeStyle = '#e5e7eb';
    ctx.beginPath();
    ctx.moveTo(px, mt);
    ctx.lineTo(px, mt + ph);
    ctx.stroke();
    ctx.fillStyle = '#111827';
    ctx.fillText(tx.toFixed(2), px - 12, mt + ph + 15);
  }
  for (let i = 0; i <= ticks; i++) {
    const ty = ymin + (ymax - ymin) * i / ticks;
    const py = y2py(ty);
    ctx.strokeStyle = '#e5e7eb';
    ctx.beginPath();
    ctx.moveTo(ml, py);
    ctx.lineTo(ml + pw, py);
    ctx.stroke();
    ctx.fillStyle = '#111827';
    ctx.fillText(ty.toFixed(2), 5, py + 4);
  }

  // Trend line (linear regression)
  if (points.length >= 3) {
    const n = points.length;
    let mx = 0, my = 0;
    for (let i = 0; i < n; i++) { mx += xs[i]; my += ys[i]; }
    mx /= n; my /= n;
    let num = 0, den = 0;
    for (let i = 0; i < n; i++) {
      num += (xs[i] - mx) * (ys[i] - my);
      den += (xs[i] - mx) * (xs[i] - mx);
    }
    const slope = den > 0 ? num / den : 0;
    const intercept = my - slope * mx;
    
    // Draw trend line
    const y1 = slope * xmin + intercept;
    const y2 = slope * xmax + intercept;
    ctx.strokeStyle = 'rgba(220, 38, 38, 0.6)';
    ctx.lineWidth = 2;
    ctx.setLineDash([5, 3]);
    ctx.beginPath();
    ctx.moveTo(x2px(xmin), y2py(y1));
    ctx.lineTo(x2px(xmax), y2py(y2));
    ctx.stroke();
    ctx.setLineDash([]);
  }

  // points
  ctx.fillStyle = 'rgba(37,99,235,0.65)';
  for (const p of points) {
    const px = x2px(p.x);
    const py = y2py(p.y);
    ctx.beginPath();
    ctx.arc(px, py, 3.2, 0, Math.PI * 2);
    ctx.fill();
  }

  // labels
  ctx.fillStyle = '#111827';
  ctx.font = '13px Arial';
  ctx.fillText(xLabel || 'X', ml + pw / 2 - 40, H - 10);
  ctx.save();
  ctx.translate(15, mt + ph / 2 + 40);
  ctx.rotate(-Math.PI / 2);
  ctx.fillText(yLabel || 'Y', 0, 0);
  ctx.restore();
}

function draw11cForest(canvas, coefRows) {
  if (!canvas) return;
  const ctx = canvas.getContext('2d');
  const W = canvas.width, H = canvas.height;
  ctx.clearRect(0, 0, W, H);
  ctx.fillStyle = '#fff';
  ctx.fillRect(0, 0, W, H);

  const ml = 160, mr = 20, mt = 20, mb = 20;
  const pw = W - ml - mr, ph = H - mt - mb;

  if (!coefRows || coefRows.length === 0) {
    ctx.fillStyle = '#6b7280';
    ctx.font = '14px Arial';
    ctx.fillText('No coefficients to plot.', ml, mt + 20);
    return;
  }

  // Use OR/IRR scale; ensure >0
  const vals = coefRows.map(r => r.ratio).filter(v => isFinite(v) && v > 0);
  const lows = coefRows.map(r => r.ciLow).filter(v => isFinite(v) && v > 0);
  const highs = coefRows.map(r => r.ciHigh).filter(v => isFinite(v) && v > 0);
  let vmin = Math.min(...vals, ...lows);
  let vmax = Math.max(...vals, ...highs);
  if (!isFinite(vmin) || !isFinite(vmax) || vmin <= 0 || vmax <= 0) {
    ctx.fillStyle = '#6b7280';
    ctx.font = '14px Arial';
    ctx.fillText('Forest plot unavailable (non-positive ratios).', ml, mt + 20);
    return;
  }
  // log scale
  const lmin = Math.log(vmin), lmax = Math.log(vmax);
  const x2px = (v) => ml + (Math.log(v) - lmin) / (lmax - lmin) * pw;

  // reference line at 1
  ctx.strokeStyle = '#9ca3af';
  ctx.lineWidth = 1;
  const xRef = x2px(1);
  ctx.beginPath();
  ctx.moveTo(xRef, mt);
  ctx.lineTo(xRef, mt + ph);
  ctx.stroke();

  // rows
  const rowH = Math.max(18, ph / Math.max(1, coefRows.length));
  ctx.font = '12px Arial';
  for (let i = 0; i < coefRows.length; i++) {
    const r = coefRows[i];
    const y = mt + i * rowH + rowH / 2;

    // label
    ctx.fillStyle = '#111827';
    ctx.fillText(r.name, 10, y + 4);

    if (!(isFinite(r.ratio) && r.ratio > 0)) continue;

    // CI line
    ctx.strokeStyle = '#2563eb';
    ctx.lineWidth = 2;
    const xl = x2px(Math.max(r.ciLow, vmin));
    const xh = x2px(Math.min(r.ciHigh, vmax));
    ctx.beginPath();
    ctx.moveTo(xl, y);
    ctx.lineTo(xh, y);
    ctx.stroke();

    // point
    ctx.fillStyle = '#dc2626';
    ctx.beginPath();
    ctx.arc(x2px(r.ratio), y, 3.2, 0, Math.PI * 2);
    ctx.fill();
  }

  // x-axis ticks
  const ticks = 5;
  ctx.strokeStyle = '#e5e7eb';
  ctx.fillStyle = '#111827';
  for (let i = 0; i <= ticks; i++) {
    const lv = lmin + (lmax - lmin) * i / ticks;
    const v = Math.exp(lv);
    const x = x2px(v);
    ctx.beginPath();
    ctx.moveTo(x, mt + ph);
    ctx.lineTo(x, mt + ph + 5);
    ctx.stroke();
    ctx.fillText(v.toFixed(2), x - 12, mt + ph + 18);
  }
}


// ---------- 11-c helpers (partial correlation, BH-FDR, robust SE) ----------
window.__wbca11c_corrHistory = window.__wbca11c_corrHistory || [];

function bhFdrQ(pvals) {
  const m = pvals.length;
  const idx = pvals.map((p,i)=>[p,i]).sort((a,b)=>a[0]-b[0]);
  const q = Array(m).fill(NaN);
  for (let k=0;k<m;k++) {
    const p = idx[k][0];
    const i = k+1;
    q[idx[k][1]] = p * m / i;
  }
  // monotone
  for (let k=m-2;k>=0;k--) {
    const ii = idx[k][1], jj = idx[k+1][1];
    q[ii] = Math.min(q[ii], q[jj]);
  }
  // cap
  for (let i=0;i<m;i++) q[i]=Math.min(1, Math.max(0, q[i]));
  return q;
}

function rankArray(arr) {
  // average ranks for ties
  const n = arr.length;
  const idx = arr.map((v,i)=>[v,i]).sort((a,b)=>a[0]-b[0]);
  const ranks = Array(n).fill(NaN);
  let i=0;
  while (i<n) {
    let j=i;
    while (j+1<n && idx[j+1][0]===idx[i][0]) j++;
    const r = (i + j + 2) / 2; // 1-based average
    for (let k=i;k<=j;k++) ranks[idx[k][1]] = r;
    i = j+1;
  }
  return ranks;
}

function pearsonCorr(a,b) {
  const n=a.length;
  let ma=0, mb=0;
  for (let i=0;i<n;i++){ma+=a[i]; mb+=b[i];}
  ma/=n; mb/=n;
  let num=0, da=0, db=0;
  for (let i=0;i<n;i++){
    const xa=a[i]-ma, xb=b[i]-mb;
    num += xa*xb; da += xa*xa; db += xb*xb;
  }
  const den = Math.sqrt(da*db);
  return den>0 ? num/den : NaN;
}

function residualize(a, z) {
  // a ~ 1 + z
  const n=a.length;
  let ma=0, mz=0;
  for (let i=0;i<n;i++){ma+=a[i]; mz+=z[i];}
  ma/=n; mz/=n;
  let cov=0, vz=0;
  for (let i=0;i<n;i++){
    cov += (a[i]-ma)*(z[i]-mz);
    vz  += (z[i]-mz)*(z[i]-mz);
  }
  const b = vz>0 ? cov/vz : 0;
  const res = new Array(n);
  for (let i=0;i<n;i++) res[i] = a[i] - (ma + b*(z[i]-mz));
  return res;
}

function partialSpearman(xs, ys, zs) {
  const rx = rankArray(xs);
  const ry = rankArray(ys);
  const rz = rankArray(zs);
  const ex = residualize(rx, rz);
  const ey = residualize(ry, rz);
  return pearsonCorr(ex, ey);
}

function partialPearson(xs, ys, zs) {
  const ex = residualize(xs, zs);
  const ey = residualize(ys, zs);
  return pearsonCorr(ex, ey);
}

// ---------- Correlation Matrix ----------
let __last11cCorrMatrix = null;

function run11cCorrMatrix() {
  const status = document.getElementById('corrMatrixStatus');
  const tableDiv = document.getElementById('corrMatrixTable');
  const canvas = document.getElementById('corrMatrixHeatmap');
  
  if (status) status.textContent = 'Computing...';
  if (tableDiv) tableDiv.innerHTML = '';
  
  if (!corpus || !corpus.files) {
    if (status) status.textContent = 'Please load a corpus first.';
    return;
  }
  
  // Use effective data (respects filters and deletions from 9-a)
  const effectiveData = getEffectiveFreqTableData();
  if (!effectiveData || !effectiveData.features || !effectiveData.features.length) {
    if (status) status.textContent = 'Please compute 9-a) Frequency Table first.';
    return;
  }
  
  const topN = Math.max(3, Math.min(50, parseInt(document.getElementById('corrMatrixTopN')?.value, 10) || 10));
  const method = document.getElementById('corrMatrixMethod')?.value || 'spearman';
  
  // Get top N features from frequency table
  const features = effectiveData.features.slice(0, topN).map(String);
  if (features.length < 2) {
    if (status) status.textContent = 'Need at least 2 features.';
    return;
  }
  
  // Build file-level data for each feature
  const featureData = {};
  for (const feat of features) {
    const fd = getFileLevelValuesForFeature(feat);
    if (fd && fd.fileMap) {
      featureData[feat] = fd.fileMap;
    }
  }
  
  // Get common files across all features
  const allFiles = new Set();
  for (const feat of features) {
    if (featureData[feat]) {
      for (const f in featureData[feat]) allFiles.add(f);
    }
  }
  const commonFiles = Array.from(allFiles).filter(f => {
    return features.every(feat => featureData[feat] && featureData[feat][f] !== undefined);
  });
  
  if (commonFiles.length < 3) {
    if (status) status.textContent = 'Insufficient common files across features.';
    return;
  }
  
  // Build value arrays
  const valueArrays = {};
  for (const feat of features) {
    valueArrays[feat] = commonFiles.map(f => featureData[feat][f]?.value ?? 0);
  }
  
  // Compute correlation matrix
  const n = features.length;
  const matrix = [];
  const pMatrix = [];
  for (let i = 0; i < n; i++) {
    const row = [];
    const pRow = [];
    for (let j = 0; j < n; j++) {
      if (i === j) {
        row.push(1);
        pRow.push(0);
      } else {
        const xs = valueArrays[features[i]];
        const ys = valueArrays[features[j]];
        const r = method === 'pearson' ? pearsonCorr(xs, ys) : spearmanRho(xs, ys);
        const p = approxPForCorr(r, commonFiles.length, method);
        row.push(r);
        pRow.push(p);
      }
    }
    matrix.push(row);
    pMatrix.push(pRow);
  }
  
  __last11cCorrMatrix = { features, matrix, pMatrix, method, n: commonFiles.length };
  
  // Render table
  renderCorrMatrixTable(tableDiv, features, matrix, pMatrix);
  
  // Render heatmap
  drawCorrMatrixHeatmap(canvas, features, matrix);
  
  if (status) status.textContent = `Done. ${features.length} features × ${commonFiles.length} files. Method: ${method === 'pearson' ? "Pearson's r" : "Spearman's ρ"}`;
}

function renderCorrMatrixTable(container, features, matrix, pMatrix) {
  if (!container) return;
  
  const n = features.length;
  let html = `<table style="border-collapse:collapse; font-size:0.8rem; width:100%;">
    <thead><tr style="background:#f3f4f6;">
      <th style="border:1px solid #e5e7eb; padding:4px 6px; text-align:left; position:sticky; left:0; background:#f3f4f6; z-index:1;"></th>`;
  
  for (const f of features) {
    const label = f.length > 12 ? f.substring(0, 10) + '…' : f;
    html += `<th style="border:1px solid #e5e7eb; padding:4px 6px; text-align:center; font-weight:normal; writing-mode:vertical-rl; text-orientation:mixed; height:80px;" title="${escapeHtml(f)}">${escapeHtml(label)}</th>`;
  }
  html += '</tr></thead><tbody>';
  
  for (let i = 0; i < n; i++) {
    const label = features[i].length > 15 ? features[i].substring(0, 13) + '…' : features[i];
    html += `<tr><td style="border:1px solid #e5e7eb; padding:4px 6px; font-weight:600; position:sticky; left:0; background:#fff; z-index:1;" title="${escapeHtml(features[i])}">${escapeHtml(label)}</td>`;
    for (let j = 0; j < n; j++) {
      const r = matrix[i][j];
      const p = pMatrix[i][j];
      const bg = getCorrColor(r);
      const textColor = Math.abs(r) > 0.5 ? '#fff' : '#111';
      const sig = (i !== j && p < 0.05) ? '*' : '';
      const sig2 = (i !== j && p < 0.01) ? '*' : '';
      html += `<td style="border:1px solid #e5e7eb; padding:4px 6px; text-align:center; background:${bg}; color:${textColor};" title="r=${r.toFixed(3)}, p=${p.toExponential(2)}">${r.toFixed(2)}${sig}${sig2}</td>`;
    }
    html += '</tr>';
  }
  html += '</tbody></table>';
  container.innerHTML = html;
}

function getCorrColor(r) {
  // Blue for negative, white for zero, red for positive
  if (!isFinite(r)) return '#f3f4f6';
  const intensity = Math.min(1, Math.abs(r));
  if (r >= 0) {
    const g = Math.round(255 - intensity * 120);
    const b = Math.round(255 - intensity * 180);
    return `rgb(255,${g},${b})`;
  } else {
    const g = Math.round(255 - intensity * 120);
    const red = Math.round(255 - intensity * 180);
    return `rgb(${red},${g},255)`;
  }
}

function drawCorrMatrixHeatmap(canvas, features, matrix) {
  if (!canvas) return;
  const ctx = canvas.getContext('2d');
  const W = canvas.width, H = canvas.height;
  ctx.clearRect(0, 0, W, H);
  ctx.fillStyle = '#fff';
  ctx.fillRect(0, 0, W, H);
  
  const n = features.length;
  if (n < 2) return;
  
  const ml = 90, mt = 90, mr = 60, mb = 20;
  const pw = W - ml - mr;
  const ph = H - mt - mb;
  const cellW = pw / n;
  const cellH = ph / n;
  
  // Draw cells
  for (let i = 0; i < n; i++) {
    for (let j = 0; j < n; j++) {
      const r = matrix[i][j];
      ctx.fillStyle = getCorrColor(r);
      ctx.fillRect(ml + j * cellW, mt + i * cellH, cellW, cellH);
      ctx.strokeStyle = '#e5e7eb';
      ctx.strokeRect(ml + j * cellW, mt + i * cellH, cellW, cellH);
      
      // Draw value if cell is large enough
      if (cellW > 25 && cellH > 18) {
        ctx.fillStyle = Math.abs(r) > 0.5 ? '#fff' : '#111';
        ctx.font = '10px Arial';
        ctx.textAlign = 'center';
        ctx.fillText(r.toFixed(2), ml + j * cellW + cellW / 2, mt + i * cellH + cellH / 2 + 4);
      }
    }
  }
  
  // Draw labels
  ctx.fillStyle = '#111827';
  ctx.font = '11px Arial';
  ctx.textAlign = 'right';
  for (let i = 0; i < n; i++) {
    const label = features[i].length > 10 ? features[i].substring(0, 8) + '…' : features[i];
    ctx.fillText(label, ml - 5, mt + i * cellH + cellH / 2 + 4);
  }
  
  ctx.save();
  ctx.textAlign = 'left';
  for (let j = 0; j < n; j++) {
    const label = features[j].length > 10 ? features[j].substring(0, 8) + '…' : features[j];
    ctx.save();
    ctx.translate(ml + j * cellW + cellW / 2 + 4, mt - 5);
    ctx.rotate(-Math.PI / 2);
    ctx.fillText(label, 0, 0);
    ctx.restore();
  }
  ctx.restore();
  
  // Draw color scale
  const scaleX = W - mr + 10;
  const scaleW = 15;
  const scaleH = ph;
  for (let i = 0; i < scaleH; i++) {
    const r = 1 - (i / scaleH) * 2; // 1 to -1
    ctx.fillStyle = getCorrColor(r);
    ctx.fillRect(scaleX, mt + i, scaleW, 1);
  }
  ctx.strokeStyle = '#9ca3af';
  ctx.strokeRect(scaleX, mt, scaleW, scaleH);
  
  ctx.fillStyle = '#111827';
  ctx.font = '10px Arial';
  ctx.textAlign = 'left';
  ctx.fillText('+1', scaleX + scaleW + 3, mt + 10);
  ctx.fillText('0', scaleX + scaleW + 3, mt + scaleH / 2 + 4);
  ctx.fillText('-1', scaleX + scaleW + 3, mt + scaleH - 2);
}

function export11cCorrMatrixExcel() {
  if (!__last11cCorrMatrix) {
    alert('Please compute the correlation matrix first.');
    return;
  }
  const { features, matrix, pMatrix, method, n } = __last11cCorrMatrix;
  
  let html = `<html><head><meta charset="UTF-8"></head><body>
    <h3>Correlation Matrix (${method === 'pearson' ? "Pearson's r" : "Spearman's ρ"}, n=${n} files)</h3>
    <table border="1" style="border-collapse:collapse;">
      <tr><th></th>`;
  for (const f of features) html += `<th>${escapeHtml(f)}</th>`;
  html += '</tr>';
  
  for (let i = 0; i < features.length; i++) {
    html += `<tr><th>${escapeHtml(features[i])}</th>`;
    for (let j = 0; j < features.length; j++) {
      const r = matrix[i][j];
      const p = pMatrix[i][j];
      const sig = (i !== j && p < 0.05) ? '*' : '';
      html += `<td style="text-align:center;">${r.toFixed(4)}${sig}</td>`;
    }
    html += '</tr>';
  }
  html += '</table>';
  
  html += `<h4>P-values</h4><table border="1" style="border-collapse:collapse;">
    <tr><th></th>`;
  for (const f of features) html += `<th>${escapeHtml(f)}</th>`;
  html += '</tr>';
  
  for (let i = 0; i < features.length; i++) {
    html += `<tr><th>${escapeHtml(features[i])}</th>`;
    for (let j = 0; j < features.length; j++) {
      const p = pMatrix[i][j];
      html += `<td style="text-align:center;">${i === j ? '-' : p.toExponential(3)}</td>`;
    }
    html += '</tr>';
  }
  html += '</table></body></html>';
  
  const blob = new Blob([html], { type: 'application/vnd.ms-excel' });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = `correlation_matrix_${method}.xls`;
  a.click();
  URL.revokeObjectURL(url);
}

// Robust (HC3-style) SE for GLM (approx; suitable for research robustness checks)
function robustSE_HC3(X, y, beta, offset, family, theta) {
  const n=y.length, p=X[0].length;
  const mu=new Array(n), varY=new Array(n), dmu=new Array(n), w=new Array(n), h=new Array(n);
  for (let i=0;i<n;i++){
    let xb=0;
    for (let j=0;j<p;j++) xb += X[i][j]*beta[j];
    const off = offset ? offset[i] : 0;
    const eta = xb + off;
    if (family==='logit'){
      const m = 1/(1+Math.exp(-eta));
      mu[i]=Math.min(1-1e-8, Math.max(1e-8,m));
      varY[i]=mu[i]*(1-mu[i]);
      dmu[i]=varY[i];
      const wi = varY[i]>0?varY[i]:1e-8;
      w[i]=wi;
    } else {
      const m = Math.exp(eta);
      mu[i]=Math.max(1e-12,m);
      varY[i]=mu[i];
      if (family==='negbin') varY[i]=mu[i] + (mu[i]*mu[i])/Math.max(1e-8, theta||10);
      dmu[i]=mu[i]; // log link
      const wi = (mu[i]*mu[i]) / Math.max(1e-12, varY[i]);
      w[i]=wi;
    }
  }
  // bread = (X'WX)^-1
  const XtWX = Array.from({length:p},()=>Array(p).fill(0));
  for (let i=0;i<n;i++){
    for (let a=0;a<p;a++){
      const xia=X[i][a];
      const wx = w[i]*xia;
      for (let b=0;b<p;b++) XtWX[a][b]+= wx*X[i][b];
    }
  }
  const inv = invertMatrix(XtWX);
  if (!inv) return Array(p).fill(NaN);

  // leverage h_i = w_i * x_i' inv x_i
  for (let i=0;i<n;i++){
    let t=0;
    for (let a=0;a<p;a++){
      let s=0;
      for (let b=0;b<p;b++) s += inv[a][b]*X[i][b];
      t += X[i][a]*s;
    }
    h[i] = Math.min(0.999999, Math.max(0, w[i]*t));
  }

  // score vector per obs
  const meat = Array.from({length:p},()=>Array(p).fill(0));
  for (let i=0;i<n;i++){
    // approximate score for GLM:
    // s_i = X_i * (y-mu) * dmu/deta / Var(y)
    const resid = (y[i]-mu[i]) * (dmu[i]/Math.max(1e-12,varY[i]));
    const adj = 1/Math.max(1e-8,(1-h[i])*(1-h[i])); // HC3
    for (let a=0;a<p;a++){
      const sa = X[i][a]*resid*adj;
      for (let b=0;b<p;b++){
        meat[a][b] += sa * (X[i][b]*resid*adj);
      }
    }
  }

  // cov = inv * meat * inv
  const tmp = Array.from({length:p},()=>Array(p).fill(0));
  for (let a=0;a<p;a++){
    for (let b=0;b<p;b++){
      let s=0;
      for (let k=0;k<p;k++) s += inv[a][k]*meat[k][b];
      tmp[a][b]=s;
    }
  }
  const cov = Array.from({length:p},()=>Array(p).fill(0));
  for (let a=0;a<p;a++){
    for (let b=0;b<p;b++){
      let s=0;
      for (let k=0;k<p;k++) s += tmp[a][k]*inv[k][b];
      cov[a][b]=s;
    }
  }
  const se = new Array(p);
  for (let j=0;j<p;j++) se[j]=Math.sqrt(Math.max(0,cov[j][j]));
  return se;
}

// ---------- Clear functions for 11-c ----------
function clear11cCorrelation() {
  const status = document.getElementById('assocCorrStatus');
  const summary = document.getElementById('assocCorrSummary');
  const canvas = document.getElementById('assocCorrCanvas');
  const tableDiv = document.getElementById('corrMatrixTable');
  const heatCanvas = document.getElementById('corrMatrixHeatmap');
  const matrixStatus = document.getElementById('corrMatrixStatus');
  
  if (status) status.textContent = 'Ready.';
  if (summary) { summary.style.display = 'none'; summary.innerHTML = ''; }
  if (canvas) {
    const ctx = canvas.getContext('2d');
    ctx.clearRect(0, 0, canvas.width, canvas.height);
  }
  if (tableDiv) tableDiv.innerHTML = '';
  if (heatCanvas) {
    const ctx = heatCanvas.getContext('2d');
    ctx.clearRect(0, 0, heatCanvas.width, heatCanvas.height);
  }
  if (matrixStatus) matrixStatus.textContent = 'Ready.';
  
  __last11cCorr = null;
  __last11cCorrMatrix = null;
  window.__wbca11c_corrHistory = [];
}

function clear11cRegression() {
  const status = document.getElementById('assocRegStatus');
  const summary = document.getElementById('assocRegSummary');
  const canvas = document.getElementById('assocRegCanvas');
  const coefTable = document.getElementById('assocRegCoefTable');
  
  if (status) status.textContent = 'Ready.';
  if (summary) { summary.style.display = 'none'; summary.innerHTML = ''; }
  if (canvas) {
    const ctx = canvas.getContext('2d');
    ctx.clearRect(0, 0, canvas.width, canvas.height);
  }
  if (coefTable) coefTable.innerHTML = '';
  
  __last11cReg = null;
}

// ---------- Run correlation ----------
function run11cCorrelation() {
  const status = document.getElementById('assocCorrStatus');
  const summary = document.getElementById('assocCorrSummary');
  const canvas = document.getElementById('assocCorrCanvas');

  if (!status || !summary) return;
  status.textContent = 'Computing...';
  summary.style.display = 'none';

  if (!corpus || !corpus.files) {
    status.textContent = 'Please load a corpus first.';
    draw11cScatter(canvas, [], 'X', 'Y');
    return;
  }

  const xFeature = document.getElementById('assocXFeature')?.value || '';
  const yFeature = document.getElementById('assocYFeature')?.value || '';
  if (!xFeature || !yFeature) {
    status.textContent = 'Please select X and Y features.';
    draw11cScatter(canvas, [], 'X', 'Y');
    return;
  }

  const ds = getAligned11cDataset(xFeature, yFeature);
  if (!ds || !ds.rows || ds.rows.length < 3) {
    status.textContent = 'Insufficient data after grouping/min-n. Adjust 9-c group selection or min-n.';
    draw11cScatter(canvas, [], xFeature, yFeature);
    return;
  }

  const method = document.getElementById('assocCorrMethod')?.value || 'spearman';

  const doPartial = document.getElementById('assocCorrPartial')?.checked ?? false;
  const controlVar = document.getElementById('assocCorrControlVar')?.value || 'logTokens';
  const doFDR = document.getElementById('assocCorrFDR')?.checked ?? true;

  const xs = ds.rows.map(r => r.x);
  const ys = ds.rows.map(r => r.y);

  let stat = method === 'kendall' ? kendallTau(xs, ys) : (method === 'pearson' ? pearsonCorr(xs, ys) : spearmanRho(xs, ys));
  let usedMethod = method;
  if (doPartial) {
    const zs = ds.rows.map(r => {
      const t = r.tokens || 0;
      return controlVar === 'tokens' ? t : Math.log(Math.max(1, t));
    });
    stat = method === 'pearson' ? partialPearson(xs, ys, zs) : partialSpearman(xs, ys, zs);
    usedMethod = method === 'pearson' ? 'pearson' : 'spearman';
  }
  const n = ds.rows.length;
  const p = approxPForCorr(stat, n, usedMethod);

  // bootstrap CI
  let ciText = '(disabled)';
  const doBoot = document.getElementById('assocCorrBootstrap')?.checked ?? true;
  let ci = null;
  if (doBoot) {
    const B = Math.max(100, parseInt(document.getElementById('assocCorrB')?.value, 10) || 1000);
    const stats = [];
    for (let b = 0; b < B; b++) {
      const bx = [];
      const by = [];
      for (let i = 0; i < n; i++) {
        const j = Math.floor(Math.random() * n);
        bx.push(xs[j]);
        by.push(ys[j]);
      }
      let s;
      if (doPartial) {
        const bz = [];
        for (let i = 0; i < n; i++) {
          const j2 = Math.floor(Math.random() * n);
          const t = ds.rows[j2].tokens || 0;
          bz.push(controlVar === 'tokens' ? t : Math.log(Math.max(1, t)));
        }
        s = method === 'pearson' ? partialPearson(bx, by, bz) : partialSpearman(bx, by, bz);
      } else {
        s = method === 'kendall' ? kendallTau(bx, by) : (method === 'pearson' ? pearsonCorr(bx, by) : spearmanRho(bx, by));
      }
      if (isFinite(s)) stats.push(s);
    }
    stats.sort((a, b) => a - b);
    const lo = stats[Math.floor(0.025 * (stats.length - 1))] ?? NaN;
    const hi = stats[Math.floor(0.975 * (stats.length - 1))] ?? NaN;
    ci = [lo, hi];
    ciText = `[${lo.toFixed(3)}, ${hi.toFixed(3)}]`;
  }

  document.getElementById('assocCorrStat').textContent = `${(isFinite(stat)?stat:NaN).toFixed(4)}` + (usedMethod === 'kendall' ? ' (τ)' : (usedMethod === 'pearson' ? ' (r)' : ' (ρ)'));
  document.getElementById('assocCorrCI').textContent = ciText;
  document.getElementById('assocCorrP').textContent = isFinite(p) ? p.toExponential(3) + (p < 0.05 ? ' *' : '') : 'NA';
  document.getElementById('assocCorrN').textContent = String(n);
  let q = p;
  if (doFDR) {
    const hist = window.__wbca11c_corrHistory || [];
    const pvals = hist.map(h => h.p).concat([p]);
    const qs = bhFdrQ(pvals);
    q = qs[qs.length - 1];
  }
  const qEl = document.getElementById('assocCorrQ');
  if (qEl) qEl.textContent = isFinite(q) ? q.toExponential(3) : 'NA';

  const ctlEl = document.getElementById('assocCorrControlLabel');
  if (ctlEl) ctlEl.textContent = doPartial ? (controlVar === 'tokens' ? 'tokens' : 'log(tokens)') : 'None';

  summary.style.display = 'block';

  draw11cScatter(canvas, ds.rows.map(r => ({ x: r.x, y: r.y, g: r.group })), xFeature, yFeature);

  status.textContent = `Done. (${ds.groupNames.length} groups; min-n=${ds.minFiles})`;

  __last11cCorr = {
    xFeature, yFeature, method: usedMethod, stat, ci, p, q, n, doPartial, controlVar, fdr: doFDR,
    groups: ds.groupNames,
    groupCounts: ds.groupCounts,
    points: ds.rows.map(r => ({ file: r.file, group: r.group, x: r.x, y: r.y }))
  };

  try {
    window.__wbca11c_corrHistory = window.__wbca11c_corrHistory || [];
    window.__wbca11c_corrHistory.push({ xFeature, yFeature, p, q, doPartial, controlVar, method: usedMethod, n });
  } catch(e) {}
}


// ---------- Regression (lightweight GLM) ----------
function addIntercept(X) {
  return X.map(row => [1, ...row]);
}

function matMul(A, B) {
  const n = A.length, m = B[0].length, k = B.length;
  const out = Array.from({ length: n }, () => Array(m).fill(0));
  for (let i = 0; i < n; i++) {
    for (let j = 0; j < m; j++) {
      let s = 0;
      for (let t = 0; t < k; t++) s += A[i][t] * B[t][j];
      out[i][j] = s;
    }
  }
  return out;
}

function matVec(A, v) {
  const n = A.length, k = v.length;
  const out = Array(n).fill(0);
  for (let i = 0; i < n; i++) {
    let s = 0;
    for (let j = 0; j < k; j++) s += A[i][j] * v[j];
    out[i] = s;
  }
  return out;
}

function transpose(A) {
  const n = A.length, m = A[0].length;
  const T = Array.from({ length: m }, () => Array(n).fill(0));
  for (let i = 0; i < n; i++) for (let j = 0; j < m; j++) T[j][i] = A[i][j];
  return T;
}

function solveLinearSystem(A, b) {
  // Gaussian elimination with partial pivoting
  const n = A.length;
  const M = A.map((row, i) => row.slice().concat([b[i]]));
  for (let i = 0; i < n; i++) {
    // pivot
    let maxRow = i;
    for (let r = i + 1; r < n; r++) if (Math.abs(M[r][i]) > Math.abs(M[maxRow][i])) maxRow = r;
    const tmp = M[i]; M[i] = M[maxRow]; M[maxRow] = tmp;
    const piv = M[i][i];
    if (Math.abs(piv) < 1e-12) return null;
    for (let j = i; j <= n; j++) M[i][j] /= piv;
    for (let r = 0; r < n; r++) {
      if (r === i) continue;
      const f = M[r][i];
      for (let j = i; j <= n; j++) M[r][j] -= f * M[i][j];
    }
  }
  return M.map(row => row[n]);
}

function invMatrix(A) {
  const n = A.length;
  const I = Array.from({ length: n }, (_, i) => Array.from({ length: n }, (_, j) => (i === j ? 1 : 0)));
  const M = A.map((row, i) => row.slice().concat(I[i]));
  for (let i = 0; i < n; i++) {
    let maxRow = i;
    for (let r = i + 1; r < n; r++) if (Math.abs(M[r][i]) > Math.abs(M[maxRow][i])) maxRow = r;
    const tmp = M[i]; M[i] = M[maxRow]; M[maxRow] = tmp;
    const piv = M[i][i];
    if (Math.abs(piv) < 1e-12) return null;
    for (let j = i; j < 2 * n; j++) M[i][j] /= piv;
    for (let r = 0; r < n; r++) {
      if (r === i) continue;
      const f = M[r][i];
      for (let j = i; j < 2 * n; j++) M[r][j] -= f * M[i][j];
    }
  }
  const inv = Array.from({ length: n }, () => Array(n).fill(0));
  for (let i = 0; i < n; i++) for (let j = 0; j < n; j++) inv[i][j] = M[i][j + n];
  return inv;
}

// ---------- Linear Regression (OLS) ----------
function fitLinearOLS(X, y) {
  const n = X.length, p = X[0].length;
  
  // Compute X'X and X'y
  const Xt = transpose(X);
  const XtX = matMul(Xt, X);
  const Xty = Xt.map(row => row.reduce((s, v, i) => s + v * y[i], 0));
  
  // Solve (X'X)β = X'y
  const beta = solveLinearSystem(XtX, Xty);
  if (!beta) return null;
  
  // Compute fitted values and residuals
  const yhat = matVec(X, beta);
  const resid = y.map((yi, i) => yi - yhat[i]);
  
  // Compute residual sum of squares
  const rss = resid.reduce((s, r) => s + r * r, 0);
  
  // Compute total sum of squares
  const yMean = y.reduce((s, v) => s + v, 0) / n;
  const tss = y.reduce((s, v) => s + (v - yMean) * (v - yMean), 0);
  
  // R-squared
  const r2 = tss > 0 ? 1 - rss / tss : 0;
  const adjR2 = 1 - (1 - r2) * (n - 1) / (n - p);
  
  // Residual standard error
  const df = n - p;
  const mse = df > 0 ? rss / df : 0;
  const rse = Math.sqrt(mse);
  
  // Standard errors of coefficients
  const XtXinv = invMatrix(XtX);
  const se = XtXinv ? XtXinv.map((row, i) => Math.sqrt(Math.max(0, mse * row[i]))) : Array(p).fill(NaN);
  
  // AIC (for comparison)
  const logLik = -n / 2 * (Math.log(2 * Math.PI) + Math.log(rss / n) + 1);
  const aic = -2 * logLik + 2 * p;
  
  return {
    beta,
    se,
    r2,
    adjR2,
    rse,
    aic,
    overdisp: NaN
  };
}

function fitLogisticIRLS(X, y, maxIter=50) {
  const n = X.length, p = X[0].length;
  let beta = Array(p).fill(0);
  for (let iter = 0; iter < maxIter; iter++) {
    const eta = matVec(X, beta);
    const mu = eta.map(e => 1 / (1 + Math.exp(-Math.max(-30, Math.min(30, e)))));
    const W = mu.map(m => Math.max(1e-6, m * (1 - m)));
    const z = mu.map((m, i) => eta[i] + (y[i] - m) / W[i]);

    // X' W X and X' W z
    const Xt = transpose(X);
    const XtW = Xt.map((row, i) => row.map((v, j) => v * W[j]));
    const XtWX = matMul(XtW, X);
    const XtWz = XtW.map(row => row.reduce((s, v, j) => s + v * z[j], 0));

    const sol = solveLinearSystem(XtWX, XtWz);
    if (!sol) break;
    const diff = sol.map((b, i) => Math.abs(b - beta[i]));
    beta = sol;
    if (Math.max(...diff) < 1e-6) break;
  }

  // covariance approx
  const eta = matVec(X, beta);
  const mu = eta.map(e => 1 / (1 + Math.exp(-Math.max(-30, Math.min(30, e)))));
  const W = mu.map(m => Math.max(1e-6, m * (1 - m)));
  const Xt = transpose(X);
  const XtW = Xt.map((row, i) => row.map((v, j) => v * W[j]));
  const XtWX = matMul(XtW, X);
  const cov = invMatrix(XtWX);
  const se = cov ? cov.map((row, i) => Math.sqrt(Math.max(0, row[i]))) : Array(beta.length).fill(NaN);

  // log-likelihood
  let ll = 0;
  for (let i = 0; i < n; i++) {
    const m = Math.min(1 - 1e-12, Math.max(1e-12, mu[i]));
    ll += y[i] * Math.log(m) + (1 - y[i]) * Math.log(1 - m);
  }
  const aic = 2 * p - 2 * ll;
  return { beta, se, ll, aic };
}

function fitPoissonIRLS(X, y, offset, maxIter=60) {
  const n = X.length, p = X[0].length;
  let beta = Array(p).fill(0);
  const off = offset || Array(n).fill(0);
  for (let iter = 0; iter < maxIter; iter++) {
    const eta0 = matVec(X, beta).map((e, i) => e + off[i]);
    const mu = eta0.map(e => Math.exp(Math.max(-30, Math.min(30, e))));
    const W = mu.map(m => Math.max(1e-6, m)); // variance=mu
    const z = mu.map((m, i) => eta0[i] + (y[i] - m) / W[i]);
    // remove offset from z in IRLS step: z* = z - offset
    const zStar = z.map((v, i) => v - off[i]);

    const Xt = transpose(X);
    const XtW = Xt.map((row, i) => row.map((v, j) => v * W[j]));
    const XtWX = matMul(XtW, X);
    const XtWz = XtW.map(row => row.reduce((s, v, j) => s + v * zStar[j], 0));
    const sol = solveLinearSystem(XtWX, XtWz);
    if (!sol) break;
    const diff = sol.map((b, i) => Math.abs(b - beta[i]));
    beta = sol;
    if (Math.max(...diff) < 1e-6) break;
  }

  const eta0 = matVec(X, beta).map((e, i) => e + off[i]);
  const mu = eta0.map(e => Math.exp(Math.max(-30, Math.min(30, e))));

  // covariance
  const W = mu.map(m => Math.max(1e-6, m));
  const Xt = transpose(X);
  const XtW = Xt.map((row, i) => row.map((v, j) => v * W[j]));
  const XtWX = matMul(XtW, X);
  const cov = invMatrix(XtWX);
  const se = cov ? cov.map((row, i) => Math.sqrt(Math.max(0, row[i]))) : Array(beta.length).fill(NaN);

  // log-likelihood
  let ll = 0;
  for (let i = 0; i < n; i++) {
    const m = Math.max(1e-12, mu[i]);
    const yi = y[i];
    ll += yi * Math.log(m) - m - logFactorial(yi);
  }
  const aic = 2 * p - 2 * ll;

  // overdispersion (Pearson)
  let pearson = 0;
  for (let i = 0; i < n; i++) pearson += ((y[i] - mu[i]) * (y[i] - mu[i])) / Math.max(1e-12, mu[i]);
  const overdisp = pearson / Math.max(1, (n - p));

  return { beta, se, ll, aic, mu, overdisp };
}

function logFactorial(n) {
  if (n < 2) return 0;
  // Stirling with correction
  return n * Math.log(n) - n + 0.5 * Math.log(2 * Math.PI * n) + 1/(12*n) - 1/(360*n*n*n);
}

function fitNegBinApprox(X, y, offset) {
  // Two-stage: fit Poisson, estimate alpha, refit with variance mu + alpha*mu^2 via IRLS weights (NB2).
  const n = X.length, p = X[0].length;
  const off = offset || Array(n).fill(0);
  let fit = fitPoissonIRLS(X, y, off, 60);
  if (!fit || !fit.mu) return null;

  let alpha = 0;
  // method-of-moments alpha
  let num = 0, den = 0;
  for (let i = 0; i < n; i++) {
    const mu = Math.max(1e-12, fit.mu[i]);
    num += (y[i] - mu) * (y[i] - mu) - y[i];
    den += mu * mu;
  }
  alpha = Math.max(0, num / Math.max(1e-12, den));

  // IRLS for NB2 with fixed alpha
  let beta = fit.beta.slice();
  for (let iter = 0; iter < 60; iter++) {
    const eta0 = matVec(X, beta).map((e, i) => e + off[i]);
    const mu = eta0.map(e => Math.exp(Math.max(-30, Math.min(30, e))));
    const varr = mu.map(m => m + alpha * m * m);
    const W = mu.map((m, i) => Math.max(1e-6, m * m / varr[i])); // working weights
    const z = mu.map((m, i) => eta0[i] + (y[i] - m) / Math.max(1e-6, m));
    const zStar = z.map((v, i) => v - off[i]);

    const Xt = transpose(X);
    const XtW = Xt.map((row, i) => row.map((v, j) => v * W[j]));
    const XtWX = matMul(XtW, X);
    const XtWz = XtW.map(row => row.reduce((s, v, j) => s + v * zStar[j], 0));
    const sol = solveLinearSystem(XtWX, XtWz);
    if (!sol) break;
    const diff = sol.map((b, i) => Math.abs(b - beta[i]));
    beta = sol;
    if (Math.max(...diff) < 1e-6) break;
  }

  // covariance (approx)
  const eta0 = matVec(X, beta).map((e, i) => e + off[i]);
  const mu = eta0.map(e => Math.exp(Math.max(-30, Math.min(30, e))));
  const varr = mu.map(m => m + alpha * m * m);
  const W = mu.map((m, i) => Math.max(1e-6, m * m / varr[i]));
  const Xt = transpose(X);
  const XtW = Xt.map((row, i) => row.map((v, j) => v * W[j]));
  const XtWX = matMul(XtW, X);
  const cov = invMatrix(XtWX);
  const se = cov ? cov.map((row, i) => Math.sqrt(Math.max(0, row[i]))) : Array(beta.length).fill(NaN);

  // quasi log-likelihood not computed; use AIC from Poisson as placeholder
  return { beta, se, alpha, overdisp: fit.overdisp, aic: fit.aic, ll: fit.ll };
}

function buildDesignMatrix(rows, baselineGroup, includeGroup, includeX, includeDocLen) {
  const groups = Array.from(new Set(rows.map(r => r.group))).sort();
  const base = baselineGroup && groups.includes(baselineGroup) ? baselineGroup : groups[0];
  const groupCols = groups.filter(g => g !== base);
  const X = [];
  const names = ['Intercept'];
  if (includeGroup) {
    groupCols.forEach(g => names.push(`Group: ${g}`));
  }
  if (includeX) names.push('X (feature value)');
  if (includeDocLen) names.push('log(tokens)');

  for (const r of rows) {
    const row = [];
    if (includeGroup) {
      groupCols.forEach(g => row.push(r.group === g ? 1 : 0));
    }
    if (includeX) row.push(r.x);
    if (includeDocLen) row.push(Math.log(Math.max(1, r.tokens)));
    X.push([1, ...row]);
  }
  return { X, names, baseGroup: base, groupCols };
}

// ---------- Regression UI helper functions ----------
function updateRegModelOptions() {
  const outcomeType = document.getElementById('assocRegOutcomeType')?.value || 'nf';
  const modelSel = document.getElementById('assocRegModel');
  if (!modelSel) return;
  
  const currentVal = modelSel.value;
  modelSel.innerHTML = '';
  
  if (outcomeType === 'nf') {
    modelSel.innerHTML = `
      <option value="linear" selected>Linear regression (OLS)</option>
    `;
  } else if (outcomeType === 'df') {
    modelSel.innerHTML = `
      <option value="logit" selected>Logistic regression (DF)</option>
    `;
  } else {
    modelSel.innerHTML = `
      <option value="poisson" selected>Poisson GLM (count, offset)</option>
      <option value="nb">Negative Binomial GLM (count, offset)</option>
    `;
  }
}

function refreshRegPredictors() {
  const container = document.getElementById('assocRegPredictorList');
  if (!container) return;
  
  // Use effective data (respects filters and deletions from 9-a)
  const effectiveData = getEffectiveFreqTableData();
  if (!effectiveData || !effectiveData.features || !effectiveData.features.length) {
    container.innerHTML = '<div class="text-xs" style="color:#6b7280;">Compute 9-a) Frequency Table first</div>';
    return;
  }
  
  const features = effectiveData.features.slice(0, 50).map(String); // limit to 50
  const outcomeFeature = document.getElementById('assocRegOutcomeFeature')?.value || '';
  
  container.innerHTML = features.map((f, i) => {
    const isOutcome = f === outcomeFeature;
    return `
      <label style="display:block; margin:0.15rem 0; cursor:pointer;${isOutcome ? ' opacity:0.5;' : ''}">
        <input type="checkbox" class="reg-predictor-checkbox" value="${escapeHtml(f)}" ${i < 3 && !isOutcome ? 'checked' : ''} ${isOutcome ? 'disabled' : ''}>
        <span class="text-xs">${escapeHtml(f.length > 30 ? f.substring(0, 28) + '...' : f)}</span>
        ${isOutcome ? '<span class="text-xs" style="color:#666;">(outcome)</span>' : ''}
      </label>
    `;
  }).join('');
}

function selectAllRegPredictors() {
  const checkboxes = document.querySelectorAll('.reg-predictor-checkbox:not(:disabled)');
  checkboxes.forEach(cb => cb.checked = true);
}

function clearAllRegPredictors() {
  const checkboxes = document.querySelectorAll('.reg-predictor-checkbox');
  checkboxes.forEach(cb => cb.checked = false);
}

function getSelectedRegPredictors() {
  const checkboxes = document.querySelectorAll('.reg-predictor-checkbox:checked');
  return Array.from(checkboxes).map(cb => cb.value);
}

// ---------- Updated buildDesignMatrix for multiple predictors ----------
function buildDesignMatrixMulti(rows, baseline, predictorFeatures, includeGroup, includeDocLen) {
  const groupNames = [...new Set(rows.map(r => r.group))].sort();
  const base = baseline && groupNames.includes(baseline) ? baseline : groupNames[0];
  const dummyGroups = groupNames.filter(g => g !== base);
  
  const names = ['(Intercept)'];
  if (includeGroup) dummyGroups.forEach(g => names.push(`group:${g}`));
  predictorFeatures.forEach(f => names.push(`x:${f}`));
  if (includeDocLen) names.push('log(tokens)');
  
  const groupCols = includeGroup ? dummyGroups.length : 0;
  
  // Build data for predictor features
  const predictorData = {};
  for (const feat of predictorFeatures) {
    const fd = getFileLevelValuesForFeature(feat);
    if (fd && fd.fileMap) {
      predictorData[feat] = fd.fileMap;
    }
  }
  
  const X = [];
  for (const r of rows) {
    const row = [];
    if (includeGroup) {
      for (const g of dummyGroups) row.push(r.group === g ? 1 : 0);
    }
    for (const feat of predictorFeatures) {
      const val = predictorData[feat]?.[r.file]?.value ?? 0;
      row.push(val);
    }
    if (includeDocLen) row.push(Math.log(Math.max(1, r.tokens)));
    X.push([1, ...row]);
  }
  return { X, names, baseGroup: base, groupCols, predictorFeatures };
}

function run11cRegression() {
  const status = document.getElementById('assocRegStatus');
  const body = document.getElementById('assocRegCoefBody');
  const summary = document.getElementById('assocRegSummary');
  const canvas = document.getElementById('assocRegCanvas');
  if (!status || !body || !summary) return;

  status.textContent = 'Computing...';
  summary.style.display = 'none';
  body.innerHTML = '<tr><td colspan="7" class="text-xs">Computing...</td></tr>';

  if (!corpus || !corpus.files) {
    status.textContent = 'Please load a corpus first.';
    body.innerHTML = '<tr><td colspan="7" class="text-xs">No corpus loaded.</td></tr>';
    draw11cForest(canvas, []);
    return;
  }

  const yFeature = document.getElementById('assocRegOutcomeFeature')?.value || '';
  if (!yFeature) {
    status.textContent = 'Please select an outcome feature.';
    body.innerHTML = '<tr><td colspan="7" class="text-xs">No outcome selected.</td></tr>';
    draw11cForest(canvas, []);
    return;
  }

  // Get selected predictor features
  const predictorFeatures = getSelectedRegPredictors().filter(f => f !== yFeature);
  
  const ds = getAligned11cDataset(yFeature, yFeature);
  if (!ds || !ds.rows || ds.rows.length < 10) {
    status.textContent = 'Insufficient data after grouping/min-n. Adjust 9-c settings.';
    body.innerHTML = '<tr><td colspan="7" class="text-xs">Insufficient data.</td></tr>';
    draw11cForest(canvas, []);
    return;
  }

  const outcomeType = document.getElementById('assocRegOutcomeType')?.value || 'nf';
  const model = document.getElementById('assocRegModel')?.value || 'linear';

  const includeGroup = document.getElementById('assocRegIncludeGroup')?.checked ?? true;
  const includeDocLen = document.getElementById('assocRegIncludeDocLen')?.checked ?? true;
  const useRobustSE = document.getElementById('assocRegRobustSE')?.checked ?? true;

  const baseline = document.getElementById('distBaselineGroup')?.value || '';

  const rows = ds.rows;
  
  // Check if we have any predictors
  const hasPredictors = predictorFeatures.length > 0 || includeGroup || includeDocLen;
  if (!hasPredictors) {
    status.textContent = 'Please select at least one predictor (features, group, or doc length).';
    body.innerHTML = '<tr><td colspan="7" class="text-xs">No predictors selected.</td></tr>';
    draw11cForest(canvas, []);
    return;
  }
  
  const { X, names } = buildDesignMatrixMulti(rows, baseline, predictorFeatures, includeGroup, includeDocLen);
  
  // Check for collinearity/variation issues
  const p = X[0]?.length || 0;
  if (p < 2) {
    status.textContent = 'Design matrix too small. Add more predictors.';
    body.innerHTML = '<tr><td colspan="7" class="text-xs">Insufficient predictors.</td></tr>';
    draw11cForest(canvas, []);
    return;
  }
  
  // Check if any column has zero variance
  for (let j = 1; j < p; j++) {
    const col = X.map(row => row[j]);
    const mean = col.reduce((s, v) => s + v, 0) / col.length;
    const variance = col.reduce((s, v) => s + (v - mean) * (v - mean), 0) / col.length;
    if (variance < 1e-10) {
      status.textContent = `Predictor "${names[j]}" has no variation. Remove or check data.`;
      body.innerHTML = `<tr><td colspan="7" class="text-xs">No variation in: ${names[j]}</td></tr>`;
      draw11cForest(canvas, []);
      return;
    }
  }

  let y;
  let offset = null;

  if (outcomeType === 'nf') {
    y = rows.map(r => r.y); // normalized frequency
  } else if (outcomeType === 'count') {
    y = rows.map(r => r.yCount);
    offset = rows.map(r => Math.log(Math.max(1, r.tokens)));
  } else {
    y = rows.map(r => r.yDF);
  }

  // Fit model
  let fit = null;
  let modelLabel = '';
  
  if (model === 'linear') {
    fit = fitLinearOLS(X, y);
    modelLabel = 'Linear (OLS)';
  } else if (model === 'logit') {
    fit = fitLogisticIRLS(X, y, 60);
    modelLabel = 'Logistic';
  } else if (model === 'nb') {
    fit = fitNegBinApprox(X, y, offset);
    modelLabel = 'Negative Binomial';
  } else {
    fit = fitPoissonIRLS(X, y, offset, 80);
    modelLabel = 'Poisson';
  }

  if (!fit) {
    status.textContent = 'Model fitting failed (possibly collinearity or insufficient variation).';
    body.innerHTML = '<tr><td colspan="7" class="text-xs">Model fitting failed.</td></tr>';
    draw11cForest(canvas, []);
    return;
  }

  const beta = fit.beta;
  const se = fit.se || Array(beta.length).fill(NaN);
  let seUsed = se;
  if (useRobustSE && model !== 'linear') {
    const fam = (model === 'logit') ? 'logit' : (model === 'nb' ? 'negbin' : 'poisson');
    const rse = robustSE_HC3(X, y, beta, offset, fam, fit.theta);
    if (rse && rse.length === beta.length) seUsed = rse;
  }

  const coefRows = [];
  const zCrit = 1.96;
  const isLinear = model === 'linear';
  
  for (let j = 0; j < beta.length; j++) {
    const est = beta[j];
    const s = seUsed[j];
    const ratio = isLinear ? est : Math.exp(est);
    const ciLow = isLinear ? (est - zCrit * s) : Math.exp(est - zCrit * s);
    const ciHigh = isLinear ? (est + zCrit * s) : Math.exp(est + zCrit * s);
    const t = s > 0 ? est / s : NaN;
    const df = isLinear ? (rows.length - beta.length) : Infinity;
    const p = isFinite(t) ? (isLinear ? 2 * (1 - studentTCdf(Math.abs(t), df)) : 2 * (1 - normalCdf(Math.abs(t)))) : NaN;
    coefRows.push({
      name: names[j] || `β${j}`,
      estimate: est,
      ratio,
      ciLow,
      ciHigh,
      se: s,
      t,
      p
    });
  }

  // render table
  body.innerHTML = '';
  for (const r of coefRows) {
    const tr = document.createElement('tr');
    const td1 = document.createElement('td'); td1.textContent = r.name;
    const td2 = document.createElement('td'); td2.className = 'text-right'; td2.textContent = isFinite(r.estimate) ? r.estimate.toFixed(4) : 'NA';
    const td3 = document.createElement('td'); td3.className = 'text-right'; td3.textContent = isFinite(r.ratio) ? r.ratio.toFixed(4) : 'NA';
    const td4 = document.createElement('td'); td4.className = 'text-right'; td4.textContent = (isFinite(r.ciLow) && isFinite(r.ciHigh)) ? `[${r.ciLow.toFixed(4)}, ${r.ciHigh.toFixed(4)}]` : 'NA';
    const td5 = document.createElement('td'); td5.className = 'text-right'; td5.textContent = isFinite(r.se) ? r.se.toFixed(4) : 'NA';
    const td6 = document.createElement('td'); td6.className = 'text-right'; td6.textContent = isFinite(r.t) ? r.t.toFixed(3) : 'NA';
    const td7 = document.createElement('td'); td7.className = 'text-right'; td7.textContent = isFinite(r.p) ? r.p.toExponential(2) + (r.p < 0.05 ? ' *' : '') : 'NA';
    tr.appendChild(td1); tr.appendChild(td2); tr.appendChild(td3); tr.appendChild(td4); tr.appendChild(td5); tr.appendChild(td6); tr.appendChild(td7);
    body.appendChild(tr);
  }

  // summary
  const modelLabelEl = document.getElementById('assocRegModelLabel');
  if (modelLabelEl) modelLabelEl.textContent = modelLabel;
  
  const r2El = document.getElementById('assocRegR2');
  const adjR2El = document.getElementById('assocRegAdjR2');
  if (r2El) r2El.textContent = isFinite(fit.r2) ? fit.r2.toFixed(4) : '-';
  if (adjR2El) adjR2El.textContent = isFinite(fit.adjR2) ? fit.adjR2.toFixed(4) : '-';
  
  document.getElementById('assocRegAIC').textContent = isFinite(fit.aic) ? fit.aic.toFixed(2) : '-';
  document.getElementById('assocRegOverdisp').textContent = isFinite(fit.overdisp) ? fit.overdisp.toFixed(3) : (fit.alpha !== undefined ? `α=${fit.alpha.toFixed(4)}` : '-');
  document.getElementById('assocRegN').textContent = String(rows.length);
  summary.style.display = 'block';

  draw11cForest(canvas, coefRows.filter(r => r.name !== '(Intercept)'));

  status.textContent = 'Done.';

  __last11cReg = {
    outcomeFeature: yFeature, predictorFeatures, outcomeType, model: modelLabel,
    n: rows.length,
    coefRows,
    r2: fit.r2,
    adjR2: fit.adjR2,
    aic: fit.aic,
    overdisp: fit.overdisp,
    groups: ds.groupNames,
    groupCounts: ds.groupCounts
  };
}

// ---------- Export ----------
function export11cCorrelationExcel() {
  if (!__last11cCorr) {
    alert('No correlation results to export. Run correlation first.');
    return;
  }
  const contrast = document.getElementById('distTestContrastLabel')?.value || 'contrast';
  const fname = `11c_correlation_${sanitizeFilename(contrast)}.xls`;

  const log = build11cAnalysisLog();
  const summary = [
    ['Metric', __last11cCorr.method === 'kendall' ? 'Kendall tau' : 'Spearman rho'],
    ['X feature', __last11cCorr.xFeature],
    ['Y feature', __last11cCorr.yFeature],
    ['Statistic', __last11cCorr.stat],
    ['p', __last11cCorr.p],
    ['q (BH)', __last11cCorr.q],
    ['Partial', __last11cCorr.doPartial ? 'Yes' : 'No'],
    ['Control', __last11cCorr.doPartial ? (__last11cCorr.controlVar === 'tokens' ? 'tokens' : 'log(tokens)') : 'None'],
    ['n files', __last11cCorr.n],
    ['95% CI', __last11cCorr.ci ? `${__last11cCorr.ci[0]} to ${__last11cCorr.ci[1]}` : 'NA']
  ];
  const points = [['file','group','x','y']].concat(__last11cCorr.points.map(p => [p.file, p.group, p.x, p.y]));
  downloadExcelMultiSheet([
    { name: 'Summary', data: summary },
    { name: 'Points', data: points },
    { name: 'Analysis_Log', data: log }
  ], fname);
}

function export11cCorrelationPNG() {
  const canvas = document.getElementById('assocCorrCanvas');
  if (!canvas) return;
  const contrast = document.getElementById('distTestContrastLabel')?.value || 'contrast';
  const fname = `11c_correlation_scatter_${sanitizeFilename(contrast)}.png`;
  downloadCanvasPNG(canvas, fname);
}

function export11cRegressionExcel() {
  if (!__last11cReg) {
    alert('No regression results to export. Run regression first.');
    return;
  }
  const contrast = document.getElementById('distTestContrastLabel')?.value || 'contrast';
  const fname = `11c_regression_${sanitizeFilename(contrast)}.xls`;
  const log = build11cAnalysisLog();
  const summary = [
    ['Outcome feature', __last11cReg.outcomeFeature],
    ['Outcome type', __last11cReg.outcomeType],
    ['Model', __last11cReg.model],
    ['X feature', __last11cReg.xFeature || '(none)'],
    ['AIC', __last11cReg.aic],
    ['Overdispersion', __last11cReg.overdisp],
    ['n files', __last11cReg.n]
  ];
  const coef = [['Predictor','Estimate','OR/IRR','CI_low','CI_high','p']].concat(
    __last11cReg.coefRows.map(r => [r.name, r.estimate, r.ratio, r.ciLow, r.ciHigh, r.p])
  );
  downloadExcelMultiSheet([
    { name: 'Summary', data: summary },
    { name: 'Coefficients', data: coef },
    { name: 'Analysis_Log', data: log }
  ], fname);
}

function export11cRegressionPNG() {
  const canvas = document.getElementById('assocRegCanvas');
  if (!canvas) return;
  const contrast = document.getElementById('distTestContrastLabel')?.value || 'contrast';
  const fname = `11c_regression_forest_${sanitizeFilename(contrast)}.png`;
  downloadCanvasPNG(canvas, fname);
}

function build11cAnalysisLog() {
  const spec = getDistTestGroupingSpec ? getDistTestGroupingSpec() : { mode: 'perFolder', folders: [] };
  const minFiles = parseInt(document.getElementById('distTestMinFiles')?.value, 10) || 10;
  const baseline = document.getElementById('distBaselineGroup')?.value || '';
  const contrast = document.getElementById('distTestContrastLabel')?.value || '';
  const dataMode = document.getElementById('distTestDataMode')?.value || '';
  const normBase = document.getElementById('distTestNormBase')?.value || '';
  const scope = document.querySelector('input[name="freqTableScope"]:checked')?.value || '';
  return [
    ['timestamp', new Date().toISOString()],
    ['spec.mode', spec.mode || 'perFolder'],
    ['spec.focus', spec.focus || ''],
    ['spec.folders', (spec.folders || []).join(', ')],
    ['spec.customGroups', spec.mode === 'customGroups' ? JSON.stringify(spec.groups || []) : ''],
    ['minFiles', minFiles],
    ['baseline', baseline],
    ['contrast', contrast],
    ['dataMode (9-c)', dataMode],
    ['normBase (9-c)', normBase],
    ['scope (9-a)', scope]
  ];
}

function sanitizeFilename(s) {
  return String(s || '').replace(/[\\\/\?\*\[\]\:]/g, '_').replace(/\s+/g, '_').slice(0, 80) || 'output';
}

function downloadCanvasPNG(canvas, filename) {
  try {
    const link = document.createElement('a');
    link.download = filename;
    link.href = canvas.toDataURL('image/png');
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
  } catch (e) {
    alert('PNG export failed (browser security restriction). Try a different browser or download via screenshot.');
  }
}

// Try to initialize 11-c when UI is present.
window.addEventListener('load', () => {
  try {
    populate11cFeatureSelectors();
    update11cContext();
    // draw empty canvases
    draw11cScatter(document.getElementById('assocCorrCanvas'), [], 'X', 'Y');
    draw11cForest(document.getElementById('assocRegCanvas'), []);
  } catch (e) {}
});

// ============================================================
// 11) Dependency Grammar Functions
// ============================================================

// Initialize dependency grammar UI
function initDepGrammarUI() {
  // Check if corpus has dependency data
  depHasDependencyData = checkDepDataAvailable();
  
  // Show/hide warning
  const warning = document.getElementById('depGrammarNotAvailable');
  const patternCard = document.getElementById('depPatternSearchCard');
  const concCard = document.getElementById('depConcordanceSection');
  
  if (!depHasDependencyData) {
    if (warning) warning.style.display = 'block';
    if (patternCard) patternCard.style.opacity = '0.5';
    if (concCard) concCard.style.opacity = '0.5';
  } else {
    if (warning) warning.style.display = 'none';
    if (patternCard) patternCard.style.opacity = '1';
    if (concCard) concCard.style.opacity = '1';
  }
  
  // Populate dropdowns
  populateDepRelationDropdowns();
  populateDepPosDropdowns();
  updateDepPresetList();
  
  // Setup element checkbox listeners
  setupDepElementCheckboxes();
  
  // Initialize preset settings (default: Sensitive OFF = no POS restriction)
  const presetKey = document.getElementById('depPresetPattern')?.value;
  if (presetKey && DEP_PRESETS[presetKey]) {
    const sensitive = document.getElementById('depApplyPreset')?.checked || false;
    applyDepPresetToCustom(sensitive);
    showDepPresetDescription();
  }
}

// Check if corpus has dependency columns
function checkDepDataAvailable() {
  if (!corpus || Object.keys(corpus.files).length === 0) return false;
  if (corpus.mode !== 'csv') return false;
  
  const files = Object.values(corpus.files);
  const firstFile = files[0];
  if (!firstFile.tokens || firstFile.tokens.length === 0) {
    return false;
  }
  
  const firstToken = firstFile.tokens[0];
  return firstToken.hasOwnProperty('dep') && firstToken.hasOwnProperty('head_id');
}

// Populate relation dropdowns
function populateDepRelationDropdowns() {
  const options = DEP_RELATIONS.map(r => `<option value="${r}">${r || 'NA'}</option>`).join('');
  for (let i = 1; i <= 5; i++) {
    const sel = document.getElementById(`depRel${i}`);
    if (sel) sel.innerHTML = options;
  }
}

// Populate POS dropdowns
function populateDepPosDropdowns() {
  const posType = document.querySelector('input[name="depPosType"]:checked')?.value || 'universal';
  const posList = posType === 'universal' ? UNIVERSAL_POS : PENN_POS;
  const options = posList.map(p => `<option value="${p}">${p || 'NA'}</option>`).join('');
  
  for (let i = 1; i <= 5; i++) {
    const nodeSel = document.getElementById(`depNodePos${i}`);
    const modSel = document.getElementById(`depModPos${i}`);
    if (nodeSel) nodeSel.innerHTML = options;
    if (modSel) modSel.innerHTML = options;
  }
}

// Handle POS Type change
function onDepPosTypeChange() {
  // Re-populate POS dropdowns with new POS type
  populateDepPosDropdowns();
  
  // Re-apply preset if one is selected (to update POS values)
  const presetKey = document.getElementById('depPresetPattern')?.value;
  if (presetKey && DEP_PRESETS[presetKey]) {
    applyDepPresetToCustom();
  }
}

// Sync 12b) concordance scope with 12a) scope
function syncDepConcScope() {
  const scope = document.querySelector('input[name="depScope"]:checked')?.value || 'target';
  const concScope = document.getElementById('depConcScope');
  if (concScope) {
    concScope.value = scope;
    // Update concordance display if there's data
    if (currentDepInstances && currentDepInstances.length > 0) {
      updateDepConcordanceDisplay();
    }
  }
}

// Setup element checkbox enable/disable
function setupDepElementCheckboxes() {
  const radios = document.querySelectorAll('input[name="depExtractionDepth"]');
  radios.forEach(radio => {
    radio.addEventListener('change', () => {
      const isElement = radio.value === 'element' && radio.checked;
      ['S', 'V', 'O', 'C', 'Mod'].forEach(el => {
        const cb = document.getElementById(`depElement${el}`);
        if (cb) cb.disabled = !isElement;
      });
    });
  });
}

// Update preset pattern list based on category
function updateDepPresetList() {
  const cat = document.getElementById('depPresetCategory')?.value || 'all';
  const sel = document.getElementById('depPresetPattern');
  if (!sel) return;
  
  let html = '<option value="">-- Select Preset --</option>';
  
  for (const [key, preset] of Object.entries(DEP_PRESETS)) {
    if (cat === 'all' || preset.cat === cat) {
      html += `<option value="${key}">${preset.id}: ${preset.name}</option>`;
    }
  }
  
  sel.innerHTML = html;
  showDepPresetDescription();
}

// Show preset description and auto-apply to custom pattern
function showDepPresetDescription() {
  const presetKey = document.getElementById('depPresetPattern')?.value;
  const descEl = document.getElementById('depPresetDescription');
  const posFilterDiv = document.getElementById('depPositionFilterDiv');
  if (!descEl) return;
  
  if (presetKey && DEP_PRESETS[presetKey]) {
    descEl.textContent = DEP_PRESETS[presetKey].desc;
    // Auto-apply preset to custom pattern with current sensitive setting
    const sensitive = document.getElementById('depApplyPreset')?.checked;
    applyDepPresetToCustom(sensitive);
    
    // Show position filter for N07/N08
    if (posFilterDiv) {
      if (presetKey === 'N07' || presetKey === 'N08') {
        posFilterDiv.style.display = 'block';
      } else {
        posFilterDiv.style.display = 'none';
      }
    }
    
    // Show PP filter for N06
    const ppFilterDiv = document.getElementById('depPpFilterDiv');
    if (ppFilterDiv) {
      if (presetKey === 'N06') {
        ppFilterDiv.style.display = 'block';
      } else {
        ppFilterDiv.style.display = 'none';
      }
    }
    
    // Update Active Filters section
    updateActiveFiltersUI(presetKey);
    
    // Auto-enable Sensitive (restrict by POS) for Sentence patterns
    const preset = DEP_PRESETS[presetKey];
    const sensitiveCheckbox = document.getElementById('depApplyPreset');
    if (preset && preset.cat === 'sentence' && sensitiveCheckbox && !sensitiveCheckbox.checked) {
      sensitiveCheckbox.checked = true;
      applyDepPresetToCustom(true);
    }
  } else {
    descEl.textContent = '';
    if (posFilterDiv) posFilterDiv.style.display = 'none';
    const ppFilterDiv = document.getElementById('depPpFilterDiv');
    if (ppFilterDiv) ppFilterDiv.style.display = 'none';
    
    // Hide Active Filters section
    const activeFiltersBox = document.getElementById('depActiveFiltersBox');
    if (activeFiltersBox) activeFiltersBox.style.display = 'none';
  }
}

// Update Active Filters UI based on preset
function updateActiveFiltersUI(presetKey) {
  const activeFiltersBox = document.getElementById('depActiveFiltersBox');
  if (!activeFiltersBox) return;
  
  const preset = DEP_PRESETS[presetKey];
  if (!preset) {
    activeFiltersBox.style.display = 'none';
    return;
  }
  
  // Check if any filters are active
  const hasVerbFormFilter = preset.verbFormFilter;
  const hasToInfFilter = preset.toInfFilter;
  const hasCaseFilter = preset.caseFilter;
  const hasIncludeCase = preset.includeCase;
  const hasNoObjFilter = preset.noObjFilter;
  const hasPpFilter = preset.ppFilter && preset.ppFilter !== 'include';
  
  const hasAnyFilter = hasVerbFormFilter || hasToInfFilter || hasCaseFilter || hasIncludeCase || hasNoObjFilter || hasPpFilter;
  
  if (!hasAnyFilter) {
    activeFiltersBox.style.display = 'none';
    return;
  }
  
  activeFiltersBox.style.display = 'block';
  
  // Verb Form Filter
  const verbFormLabel = document.getElementById('depFilterVerbFormLabel');
  const verbFormSelect = document.getElementById('depFilterVerbForm');
  if (verbFormLabel && verbFormSelect) {
    if (hasVerbFormFilter) {
      verbFormLabel.style.display = 'inline-flex';
      verbFormSelect.value = preset.verbFormFilter;
    } else {
      verbFormLabel.style.display = 'none';
    }
  }
  
  // To-Infinitive Filter
  const toInfLabel = document.getElementById('depFilterToInfLabel');
  const toInfCheckbox = document.getElementById('depFilterToInf');
  if (toInfLabel && toInfCheckbox) {
    if (hasToInfFilter) {
      toInfLabel.style.display = 'inline-flex';
      toInfCheckbox.checked = preset.toInfFilter;
    } else {
      toInfLabel.style.display = 'none';
    }
  }
  
  // Case Filter
  const caseLabel = document.getElementById('depFilterCaseLabel');
  const caseInput = document.getElementById('depFilterCase');
  if (caseLabel && caseInput) {
    if (hasCaseFilter) {
      caseLabel.style.display = 'inline-flex';
      caseInput.value = preset.caseFilter;
    } else {
      caseLabel.style.display = 'none';
    }
  }
  
  // Include Case Filter
  const includeCaseLabel = document.getElementById('depFilterIncludeCaseLabel');
  const includeCaseCheckbox = document.getElementById('depFilterIncludeCase');
  if (includeCaseLabel && includeCaseCheckbox) {
    if (hasIncludeCase) {
      includeCaseLabel.style.display = 'inline-flex';
      includeCaseCheckbox.checked = preset.includeCase;
    } else {
      includeCaseLabel.style.display = 'none';
    }
  }
  
  // No Object Filter
  const noObjLabel = document.getElementById('depFilterNoObjLabel');
  const noObjCheckbox = document.getElementById('depFilterNoObj');
  if (noObjLabel && noObjCheckbox) {
    if (hasNoObjFilter) {
      noObjLabel.style.display = 'inline-flex';
      noObjCheckbox.checked = preset.noObjFilter;
    } else {
      noObjLabel.style.display = 'none';
    }
  }
}

// Toggle preset mode
function toggleDepPresetMode() {
  const sensitive = document.getElementById('depApplyPreset')?.checked;
  const customBox = document.getElementById('depCustomPatternBox');
  
  // Apply preset with or without POS restrictions based on sensitive mode
  applyDepPresetToCustom(sensitive);
  
  // Visual feedback - dim custom box if not in sensitive mode to indicate using defaults
  if (customBox) {
    customBox.style.opacity = '1';
    customBox.style.pointerEvents = 'auto';
  }
}

// Apply preset settings to custom pattern
// sensitive: if true, apply POS restrictions; if false, only apply relation
function applyDepPresetToCustom(sensitive = false) {
  const presetKey = document.getElementById('depPresetPattern')?.value;
  if (!presetKey || !DEP_PRESETS[presetKey]) return;
  
  const preset = DEP_PRESETS[presetKey];
  
  // Set mode
  const modeRadio = document.querySelector(`input[name="depPatternMode"][value="${preset.mode}"]`);
  if (modeRadio) modeRadio.checked = true;
  
  // Clear all relations
  for (let i = 1; i <= 5; i++) {
    const relSel = document.getElementById(`depRel${i}`);
    const nodeWord = document.getElementById(`depNodeWord${i}`);
    const nodeSel = document.getElementById(`depNodePos${i}`);
    const modSel = document.getElementById(`depModPos${i}`);
    if (relSel) relSel.value = '';
    if (nodeWord) nodeWord.value = '';
    if (nodeSel) nodeSel.value = '';
    if (modSel) modSel.value = '';
  }
  
  // Set preset relations
  preset.rels.forEach((rel, idx) => {
    if (idx >= 5) return;
    const relSel = document.getElementById(`depRel${idx + 1}`);
    const nodeSel = document.getElementById(`depNodePos${idx + 1}`);
    const modSel = document.getElementById(`depModPos${idx + 1}`);
    if (relSel) relSel.value = rel.rel || '';
    // Only set POS if sensitive mode is enabled
    if (sensitive) {
      if (nodeSel) nodeSel.value = rel.nodePos || '';
      if (modSel) modSel.value = rel.modPos || '';
    }
    // If not sensitive, POS remains NA (empty)
  });
}

// Get current pattern configuration (always reads from UI)
function getDepPatternConfig() {
  // Get custom pattern from UI (which may have been set by preset)
  const mode = document.querySelector('input[name="depPatternMode"]:checked')?.value || 'chain';
  const rels = [];
  
  for (let i = 1; i <= 5; i++) {
    const rel = document.getElementById(`depRel${i}`)?.value;
    const nodeWord = document.getElementById(`depNodeWord${i}`)?.value?.trim() || '';
    const nodePos = document.getElementById(`depNodePos${i}`)?.value;
    const modPos = document.getElementById(`depModPos${i}`)?.value;
    
    if (rel || nodePos || modPos || nodeWord) {
      rels.push({ rel, nodeWord, nodePos, modPos });
    }
  }
  
  const presetKey = document.getElementById('depPresetPattern')?.value;
  
  // Get additional filters from preset if selected
  let caseFilter = null;
  let verbFormFilter = null;
  let includeCase = false;
  let toInfFilter = false;
  let positionFilter = 'both';
  let ppFilter = 'include';
  let noObjFilter = false;
  
  if (presetKey && DEP_PRESETS[presetKey]) {
    const preset = DEP_PRESETS[presetKey];
    
    // Get filter values from UI if available, otherwise use preset defaults
    const verbFormSelect = document.getElementById('depFilterVerbForm');
    const toInfCheckbox = document.getElementById('depFilterToInf');
    const caseInput = document.getElementById('depFilterCase');
    const includeCaseCheckbox = document.getElementById('depFilterIncludeCase');
    const noObjCheckbox = document.getElementById('depFilterNoObj');
    
    // Use UI values if the filter UI is visible
    if (preset.verbFormFilter && verbFormSelect && verbFormSelect.parentElement.style.display !== 'none') {
      verbFormFilter = verbFormSelect.value || null;
    } else {
      verbFormFilter = preset.verbFormFilter || null;
    }
    
    if (preset.toInfFilter !== undefined && toInfCheckbox && toInfCheckbox.parentElement.style.display !== 'none') {
      toInfFilter = toInfCheckbox.checked;
    } else {
      toInfFilter = preset.toInfFilter || false;
    }
    
    if (preset.caseFilter && caseInput && caseInput.parentElement.style.display !== 'none') {
      caseFilter = caseInput.value || null;
    } else {
      caseFilter = preset.caseFilter || null;
    }
    
    if (preset.includeCase !== undefined && includeCaseCheckbox && includeCaseCheckbox.parentElement.style.display !== 'none') {
      includeCase = includeCaseCheckbox.checked;
    } else {
      includeCase = preset.includeCase || false;
    }
    
    if (preset.noObjFilter !== undefined && noObjCheckbox && noObjCheckbox.parentElement.style.display !== 'none') {
      noObjFilter = noObjCheckbox.checked;
    } else {
      noObjFilter = preset.noObjFilter || false;
    }
    
    // For N07/N08, get position filter from UI
    if (presetKey === 'N07' || presetKey === 'N08') {
      positionFilter = document.querySelector('input[name="depPositionFilter"]:checked')?.value || 'both';
    } else {
      positionFilter = preset.positionFilter || 'both';
    }
    
    // For N06, get PP filter from UI
    if (presetKey === 'N06') {
      ppFilter = document.querySelector('input[name="depPpFilter"]:checked')?.value || 'include';
    } else {
      ppFilter = preset.ppFilter || 'include';
    }
  }
  
  // Get sentence-specific options from UI
  const excludeRelClauses = document.getElementById('depExcludeRelClauses')?.checked || false;
  const rootVerbOnly = document.getElementById('depRootVerbOnly')?.checked || false;
  
  return { preset: presetKey || null, mode, rels, caseFilter, verbFormFilter, includeCase, toInfFilter, positionFilter, ppFilter, noObjFilter, excludeRelClauses, rootVerbOnly };
}

// Cancel flag for dependency computation
let depComputationCancelled = false;

// Cancel dependency computation
function cancelDepComputation() {
  depComputationCancelled = true;
}

// Main compute function
async function computeDepPattern() {
  const status = document.getElementById('depPatternStatus');
  const computeBtn = document.getElementById('depComputeBtn');
  const cancelBtn = document.getElementById('depCancelBtn');
  
  if (!corpus || Object.keys(corpus.files).length === 0) {
    status.textContent = 'Error: No corpus loaded.';
    return;
  }
  
  if (!depHasDependencyData) {
    status.textContent = 'Error: Corpus does not have dependency data.';
    return;
  }
  
  const config = getDepPatternConfig();
  if (!config.rels || config.rels.length === 0) {
    status.textContent = 'Error: No relation specified. Select a preset or configure custom pattern.';
    return;
  }
  
  // Show cancel button, hide compute button
  computeBtn.style.display = 'none';
  cancelBtn.style.display = '';
  depComputationCancelled = false;
  
  status.textContent = 'Phase 1/3: Scanning files...';
  
  try {
    await new Promise(r => setTimeout(r, 10));
    const results = await searchDepPatternsAsync(config, status);
    
    if (depComputationCancelled) {
      status.textContent = 'Computation cancelled.';
    } else {
      displayDepResults(results);
    }
  } catch (e) {
    status.textContent = 'Error: ' + e.message;
    console.error(e);
  } finally {
    // Restore buttons
    computeBtn.style.display = '';
    cancelBtn.style.display = 'none';
  }
}

// Search for dependency patterns (async with progress) - OPTIMIZED
async function searchDepPatternsAsync(config, status) {
  const scope = document.querySelector('input[name="depScope"]:checked')?.value || 'target';
  const query = document.getElementById('depQueryInput')?.value.trim() || '';
  const searchAs = document.querySelector('input[name="depSearchAs"]:checked')?.value || 'node';
  const queryType = document.getElementById('depQueryType')?.value || 'word';
  const ignoreCase = document.getElementById('depIgnoreCase')?.checked;
  const depth = document.querySelector('input[name="depExtractionDepth"]:checked')?.value || 'head';
  const minFreq = parseInt(document.getElementById('depMinFreq')?.value) || 1;
  
  // Pre-compute query for faster matching
  const queryLower = query ? query.toLowerCase() : '';
  
  // Get element config if depth is 'element'
  let elementConfig = null;
  if (depth === 'element') {
    elementConfig = {
      S: document.getElementById('depElementS')?.checked || false,
      V: document.getElementById('depElementV')?.checked || false,
      O: document.getElementById('depElementO')?.checked || false,
      C: document.getElementById('depElementC')?.checked || false,
      Mod: document.getElementById('depElementMod')?.checked || false
    };
    if (!elementConfig.S && !elementConfig.V && !elementConfig.O && !elementConfig.C && !elementConfig.Mod) {
      elementConfig = null;
    }
  }
  
  const patternMap = new Map();
  let totalTokensT = 0, totalTokensR = 0, totalTokensN = 0;
  
  // Check if MTK is enabled (use 12a's checkbox, synced with 8's)
  const useMTK = document.getElementById('depUseMTK')?.checked ?? false;
  
  // Collect file sizes for MTK calculation (only when MTK enabled)
  const targetFileSizes = useMTK ? {} : null;
  const referenceFileSizes = useMTK ? {} : null;
  
  // Get weighted pooled SD option
  const useWeightedPooledSD = document.getElementById('depWeightedPooledSD')?.checked ?? false;
  
  // Get advanced statistics option
  const advancedStats = document.getElementById('depAdvancedStats')?.checked ?? false;
  
  // Get all files to process based on scope
  const files = Object.values(corpus.files).filter(f => {
    if (corpus.mode !== 'csv' || !f.tokens) return false;
    
    // All folders: include all files
    if (scope === 'all') return true;
    
    // Target/Reference scope: include all files that are in Target OR Reference
    // (we need both sides for comparison)
    const isTarget = targetFolders.has(f.folder);
    const isReference = referenceFolders.has(f.folder);
    return isTarget || isReference;
  });
  
  const totalFiles = files.length;
  let processedFiles = 0;
  
  // Process files with progress updates
  for (const file of files) {
    if (depComputationCancelled) break;
    
    const isTarget = targetFolders.has(file.folder);
    const isReference = referenceFolders.has(file.folder);
    
    // Determine side for instances: T, R, B (both), or N (neither)
    let side = 'N';
    if (isTarget && isReference) side = 'B';
    else if (isTarget) side = 'T';
    else if (isReference) side = 'R';
    
    const tokens = file.tokens;
    
    // Count tokens excluding punctuation (for MTK normalization)
    let tokenCount = 0;
    for (const tok of tokens) {
      if (!isPunctuationOrSpaceToken(tok)) tokenCount++;
    }
    
    // Count tokens based on scope and collect file sizes
    if (scope === 'all') {
      // All folders: avoid double counting, prioritize T > R > N
      if (isTarget) {
        totalTokensT += tokenCount;
        if (targetFileSizes) targetFileSizes[file.name] = tokenCount;
      } else if (isReference) {
        totalTokensR += tokenCount;
        if (referenceFileSizes) referenceFileSizes[file.name] = tokenCount;
      } else {
        totalTokensN += tokenCount;
      }
    } else {
      // Target/Reference scope: count both for comparison
      if (isTarget) {
        totalTokensT += tokenCount;
        if (targetFileSizes) targetFileSizes[file.name] = tokenCount;
      }
      if (isReference) {
        totalTokensR += tokenCount;
        if (referenceFileSizes) referenceFileSizes[file.name] = tokenCount;
      }
    }
    
    // Build sentence index first (use original tokens.length for iteration)
    const tokensBySentence = new Map();
    for (let idx = 0; idx < tokens.length; idx++) {
      const tok = tokens[idx];
      const sentId = tok.sent_id ?? 0;
      if (!tokensBySentence.has(sentId)) tokensBySentence.set(sentId, []);
      tokensBySentence.get(sentId).push(idx);
    }
    
    // Build dependency index PER SENTENCE
    // Key: array index of head -> list of dependent array indices
    const depsByHead = new Map();
    
    for (const [sentId, sentIndices] of tokensBySentence) {
      // Build token_id to array index mapping for this sentence
      const tokenIdToArrayIdx = new Map();
      for (const idx of sentIndices) {
        const tok = tokens[idx];
        // Use token_id if available, convert to number for consistent keys
        const tokenId = tok.token_id != null ? Number(tok.token_id) : (idx - sentIndices[0]);
        tokenIdToArrayIdx.set(tokenId, idx);
      }
      
      // Build dependency index using mapped indices
      for (const idx of sentIndices) {
        const tok = tokens[idx];
        let headId = tok.head_id;
        
        // Skip if no valid head_id
        if (headId == null || headId === '' || headId === '-1') continue;
        
        // Convert to number for consistent lookup
        headId = Number(headId);
        if (isNaN(headId) || headId < 0) continue;
        
        // Get head's array index from mapping
        const headArrayIdx = tokenIdToArrayIdx.get(headId);
        
        if (headArrayIdx != null) {
          if (!depsByHead.has(headArrayIdx)) depsByHead.set(headArrayIdx, []);
          depsByHead.get(headArrayIdx).push(idx);
        }
      }
    }
    
    // Search each token as potential node
    for (let idx = 0; idx < tokenCount; idx++) {
      const tok = tokens[idx];
      
      // Check if matches query (if specified)
      if (query) {
        const tokValue = queryType === 'lemma' ? (tok.lemma || tok.word) : tok.word;
        const queryMatch = ignoreCase 
          ? tokValue.toLowerCase() === queryLower
          : tokValue === query;
        
        if (searchAs === 'node' && !queryMatch) continue;
      }
      
      // Try to match pattern starting from this token as node (OPTIMIZED)
      const matches = matchDepPatternOptimized(tok, idx, config, tokens, depsByHead, tokensBySentence, query, queryLower, searchAs, queryType, ignoreCase);
      
      for (const match of matches) {
        const feature = buildFeatureString(match, depth, elementConfig, ignoreCase, queryType);
        
        if (!patternMap.has(feature)) {
          patternMap.set(feature, {
            freqT: 0, freqR: 0, freqN: 0,
            fileFreqT: new Map(), fileFreqR: new Map(), fileFreqN: new Map(),
            instances: [],
            seenKeys: new Set() // For deduplication
          });
        }
        
        const entry = patternMap.get(feature);
        
        // Check for duplicates if dedupe is enabled
        const dedupe = document.getElementById('depDedupeInstances')?.checked ?? true;
        let isDuplicate = false;
        
        if (dedupe) {
          // Extract governor and dependent for duplicate check
          const governor = match.node?.word || '';
          const depToken = match.dependents?.[0]?.token;
          const dependent = depToken?.word || '';
          
          // Create unique key: fileId + sentId + governor + dependent
          const dedupeKey = `${file.id}|${tok.sent_id ?? ''}|${governor.toLowerCase()}|${dependent.toLowerCase()}`;
          
          if (entry.seenKeys.has(dedupeKey)) {
            isDuplicate = true;
          } else {
            entry.seenKeys.add(dedupeKey);
          }
        }
        
        // Skip frequency counting and instance recording if duplicate
        if (isDuplicate) continue;
        
        // Optimized counting based on scope
        if (scope === 'all') {
          // All folders: just count total (use freqT + freqR + freqN for total)
          if (isTarget) {
            entry.freqT++;
            entry.fileFreqT.set(file.name, (entry.fileFreqT.get(file.name) || 0) + 1);
          } else if (isReference) {
            entry.freqR++;
            entry.fileFreqR.set(file.name, (entry.fileFreqR.get(file.name) || 0) + 1);
          } else {
            entry.freqN++;
            entry.fileFreqN.set(file.name, (entry.fileFreqN.get(file.name) || 0) + 1);
          }
        } else {
          // Target or Reference scope: count both sides for comparison
          if (isTarget) {
            entry.freqT++;
            entry.fileFreqT.set(file.name, (entry.fileFreqT.get(file.name) || 0) + 1);
          }
          if (isReference) {
            entry.freqR++;
            entry.fileFreqR.set(file.name, (entry.fileFreqR.get(file.name) || 0) + 1);
          }
        }
        
        // Store instance data with governor/dependent for 12b display
        if (entry.instances.length < 5000) {
          // Extract governor (node) and all dependents
          const governor = match.node?.word || '';
          
          // Collect all dependents (up to 5)
          const allDependents = [];
          let relativePronouns = []; // For N06 (acl:relcl) - collect that, which, who, etc.
          
          if (match.dependents && match.dependents.length > 0) {
            for (let i = 0; i < Math.min(match.dependents.length, 5); i++) {
              const dep = match.dependents[i];
              const word = dep.token?.word || '';
              const rel = dep.rel || '';
              if (word) allDependents.push({ word, rel, idx: dep.idx });
              
              // For acl:relcl, find relative pronouns (mark, nsubj with relative pronouns)
              if (rel === 'acl:relcl' || (config.preset === 'N06')) {
                const depIdx = dep.idx;
                if (depIdx !== undefined && depsByHead) {
                  const verbDeps = depsByHead.get(depIdx) || [];
                  for (const childIdx of verbDeps) {
                    const childTok = tokens[childIdx];
                    const childDep = childTok?.dep || childTok?.deprel || '';
                    const childWord = (childTok?.word || '').toLowerCase();
                    // Collect relative pronouns
                    if (childDep === 'mark' || childDep === 'nsubj' || childDep === 'ref') {
                      if (['that', 'which', 'who', 'whom', 'whose', 'where', 'when', 'what'].includes(childWord)) {
                        relativePronouns.push(childTok.word);
                      }
                    }
                  }
                }
              }
            }
          }
          
          // Add caseWord (e.g., "of") to dependents for highlighting
          if (match.caseWord && match.caseWord.token) {
            const word = match.caseWord.token.word || '';
            if (word) allDependents.push({ word, rel: 'case', idx: match.caseWord.idx });
          }
          
          // Add toWord (e.g., "to") to dependents for highlighting
          if (match.toWord && match.toWord.token) {
            const word = match.toWord.token.word || '';
            if (word) allDependents.push({ word, rel: 'mark', idx: match.toWord.idx });
          }
          
          const dependent = allDependents.length > 0 ? allDependents[0].word : '';
          
          entry.instances.push({
            fileId: file.id,
            fileName: file.name,
            folder: file.folder,
            side,
            sentId: tok.sent_id,
            sentText: tok.sent_text || '',
            governor,
            dependent,
            allDependents,
            relativePronouns,
            nodeIdx: match.nodeIdx,
            match // Keep full match for related word extraction
          });
        }
      }
    }
    
    // Update progress every 100 files (reduced frequency for performance)
    processedFiles++;
    if (processedFiles % 100 === 0 || processedFiles === totalFiles) {
      status.textContent = `Phase 1/3: Scanning files... ${processedFiles}/${totalFiles}`;
      await new Promise(r => setTimeout(r, 0));
    }
  }
  
  if (depComputationCancelled) {
    return { rows: [], totalTokensT: 0, totalTokensR: 0, scope };
  }
  
  status.textContent = 'Phase 2/3: Computing statistics...';
  await new Promise(r => setTimeout(r, 0));
  
  // Get file counts for dispersion calculation
  const targetFileCount = getTargetFileCount();
  const refFileCount = getReferenceFileCount();
  
  // Convert to array and calculate statistics
  const results = [];
  
  patternMap.forEach((data, feature) => {
    // Filter by minFreq based on scope
    // Target: only include if freqT >= minFreq
    // Reference: only include if freqR >= minFreq  
    // All folders: include if total freq (T + R + N) >= minFreq
    if (scope === 'target' && data.freqT < minFreq) return;
    if (scope === 'reference' && data.freqR < minFreq) return;
    if (scope === 'all' && (data.freqT + data.freqR + data.freqN) < minFreq) return;
    
    const normT = totalTokensT > 0 ? (data.freqT / totalTokensT) * 1000000 : 0;
    const normR = totalTokensR > 0 ? (data.freqR / totalTokensR) * 1000000 : 0;
    
    // Calculate keyness statistics based on scope
    // Target: Target vs Reference (positive LL = more frequent in Target)
    // Reference: Reference vs Target (positive LL = more frequent in Reference)
    // Both: No keyness calculation
    let ll = 0, textLL = 0, cohensD = null;
    if (scope === 'target') {
      ll = computeLL(data.freqT, data.freqR, totalTokensT, totalTokensR);
      textLL = computeLL(data.fileFreqT.size, data.fileFreqR.size, targetFileCount, refFileCount);
      if (useMTK && targetFileSizes && referenceFileSizes) {
        cohensD = computeMeanTextKeynessFromMaps(
          data.fileFreqT, data.fileFreqR,
          targetFileSizes, referenceFileSizes,
          targetFileCount, refFileCount,
          useWeightedPooledSD
        );
      }
    } else if (scope === 'reference') {
      ll = computeLL(data.freqR, data.freqT, totalTokensR, totalTokensT);
      textLL = computeLL(data.fileFreqR.size, data.fileFreqT.size, refFileCount, targetFileCount);
      if (useMTK && targetFileSizes && referenceFileSizes) {
        cohensD = computeMeanTextKeynessFromMaps(
          data.fileFreqR, data.fileFreqT,
          referenceFileSizes, targetFileSizes,
          refFileCount, targetFileCount,
          useWeightedPooledSD
        );
      }
    }
    // scope === 'all': ll, textLL, cohensD remain 0/null
    
    // Calculate dispersion for Target (only when Advanced Statistics enabled)
    const rangeT = data.fileFreqT.size;
    let juillandT = 0, dpT = 0;
    if (advancedStats && targetFileCount > 0 && data.freqT > 0) {
      const freqsT = Array.from(data.fileFreqT.values());
      const dispT = computeDepDispersion(freqsT, data.freqT, targetFileCount);
      juillandT = dispT.juilland;
      dpT = dispT.dp;
    }
    
    // Calculate dispersion for Reference (only when Advanced Statistics enabled)
    const rangeR = data.fileFreqR.size;
    let juillandR = 0, dpR = 0;
    if (advancedStats && refFileCount > 0 && data.freqR > 0) {
      const freqsR = Array.from(data.fileFreqR.values());
      const dispR = computeDepDispersion(freqsR, data.freqR, refFileCount);
      juillandR = dispR.juilland;
      dpR = dispR.dp;
    }
    
    // Calculate total norm for All folders
    const totalTokensAll = totalTokensT + totalTokensR + totalTokensN;
    const totalFreq = data.freqT + data.freqR + data.freqN;
    const totalNorm = totalTokensAll > 0 ? (totalFreq / totalTokensAll) * 1000000 : 0;
    
    results.push({
      feature,
      freqT: data.freqT,
      freqR: data.freqR,
      freqN: data.freqN,
      normT,
      normR,
      totalNorm,
      rangeT,
      juillandT,
      dpT,
      rangeR,
      juillandR,
      dpR,
      ll,
      textLL,
      cohensD,
      filesT: data.fileFreqT.size,
      filesR: data.fileFreqR.size,
      filesN: data.fileFreqN ? data.fileFreqN.size : 0,
      instances: data.instances
    });
  });
  
  status.textContent = 'Phase 3/3: Sorting and rendering...';
  await new Promise(r => setTimeout(r, 0));
  
  return {
    rows: results,
    totalTokensT,
    totalTokensR,
    scope
  };
}

// Calculate dispersion measures for dependency patterns
function computeDepDispersion(fileFreqs, totalFreq, numFiles) {
  if (numFiles === 0 || totalFreq === 0) {
    return { juilland: 0, dp: 0 };
  }
  
  // Pad with zeros for files without the feature
  const allFreqs = [...fileFreqs];
  while (allFreqs.length < numFiles) {
    allFreqs.push(0);
  }
  
  const n = allFreqs.length;
  
  // Juilland's D
  const mean = totalFreq / n;
  let sumSqDiff = 0;
  for (const f of allFreqs) {
    sumSqDiff += (f - mean) ** 2;
  }
  const sd = Math.sqrt(sumSqDiff / n);
  const cv = mean > 0 ? sd / mean : 0;
  const juilland = cv > 0 ? 1 - cv / Math.sqrt(n - 1) : 1;
  
  // DP (Deviation of Proportions)
  const expectedProp = 1 / n;
  let sumAbsDiff = 0;
  for (const f of allFreqs) {
    const observedProp = totalFreq > 0 ? f / totalFreq : 0;
    sumAbsDiff += Math.abs(observedProp - expectedProp);
  }
  const dp = sumAbsDiff / 2;
  
  return { 
    juilland: Math.max(0, Math.min(1, juilland)), 
    dp: Math.max(0, Math.min(1, dp)) 
  };
}

// Match dependency pattern
function matchDepPattern(nodeTok, nodeIdx, config, tokenById, tokensBySentence, file, query, searchAs, queryType, ignoreCase) {
  const matches = [];
  const { mode, rels } = config;
  
  if (!rels || rels.length === 0) return matches;
  
  // Check first relation's nodeWord against nodeTok (if specified)
  const firstRel = rels[0];
  if (firstRel.nodeWord) {
    const nodeValue = queryType === 'lemma' ? (nodeTok.lemma || nodeTok.word) : nodeTok.word;
    const nodeWordMatch = ignoreCase 
      ? nodeValue.toLowerCase() === firstRel.nodeWord.toLowerCase()
      : nodeValue === firstRel.nodeWord;
    if (!nodeWordMatch) return matches;
  }
  
  if (mode === 'or') {
    // OR mode: any relation matches
    rels.forEach(relConfig => {
      const relMatches = findDependentsForRel(nodeTok, nodeIdx, relConfig, tokenById, file);
      relMatches.forEach(depTok => {
        // Check modifier query match if searching as modifier
        if (searchAs === 'modifier' && query) {
          const depValue = queryType === 'lemma' ? (depTok.lemma || depTok.word) : depTok.word;
          const queryMatch = ignoreCase 
            ? depValue.toLowerCase() === query.toLowerCase()
            : depValue === query;
          if (!queryMatch) return;
        }
        
        matches.push({
          node: nodeTok,
          nodeIdx,
          dependents: [{ token: depTok, rel: relConfig.rel }],
          sentTokens: tokensBySentence.get(nodeTok.sent_id ?? 0) || []
        });
      });
    });
  } else {
    // Chain mode: all relations must match in sequence
    const chainMatch = matchChainPattern(nodeTok, nodeIdx, rels, tokenById, tokensBySentence, file, query, searchAs, queryType, ignoreCase);
    if (chainMatch) {
      matches.push(chainMatch);
    }
  }
  
  return matches;
}

// OPTIMIZED version using depsByHead index
function matchDepPatternOptimized(nodeTok, nodeIdx, config, tokens, depsByHead, tokensBySentence, query, queryLower, searchAs, queryType, ignoreCase) {
  const matches = [];
  const { mode, rels } = config;
  
  if (!rels || rels.length === 0) return matches;
  
  // Get POS type
  const posType = document.querySelector('input[name="depPosType"]:checked')?.value || 'universal';
  const posField = posType === 'universal' ? 'poss' : 'posd';
  
  // Check first relation's nodeWord against nodeTok (if specified)
  const firstRel = rels[0];
  if (firstRel.nodeWord) {
    const nodeValue = queryType === 'lemma' ? (nodeTok.lemma || nodeTok.word) : nodeTok.word;
    const nodeWordMatch = ignoreCase 
      ? nodeValue.toLowerCase() === firstRel.nodeWord.toLowerCase()
      : nodeValue === firstRel.nodeWord;
    if (!nodeWordMatch) return matches;
  }
  
  // Check node POS for first relation
  if (firstRel.nodePos && nodeTok[posField] !== firstRel.nodePos) {
    return matches;
  }
  
  // Get dependents from pre-built index (keyed by array index)
  const depIndices = depsByHead.get(nodeIdx) || [];
  
  if (mode === 'or') {
    // OR mode: any relation matches (used for N07/N08 with positionFilter)
    const positionFilter = config.positionFilter || 'both';
    const verbFormFilter = config.verbFormFilter || null;
    
    for (const relConfig of rels) {
      // Apply positionFilter for N07/N08
      // 'before' = amod only (modifier before noun)
      // 'after' = acl only (modifier after noun)
      // 'both' = both amod and acl
      if (positionFilter === 'before' && relConfig.rel === 'acl') continue;
      if (positionFilter === 'after' && relConfig.rel === 'amod') continue;
      
      for (const depIdx of depIndices) {
        const depTok = tokens[depIdx];
        const dep = depTok.dep || depTok.deprel || '';
        
        // Check relation match
        // If relConfig.rel contains ':', require exact match
        // If relConfig.rel doesn't contain ':', match base relation only (exclude subtypes like nmod:poss)
        let relMatch = false;
        if (!relConfig.rel) {
          relMatch = true; // No relation specified, match all
        } else if (relConfig.rel.includes(':')) {
          // Exact match for specific subtypes (e.g., acl:relcl)
          relMatch = relConfig.rel === dep;
        } else {
          // Base relation match - exact match only, exclude subtypes
          // e.g., "nmod" matches "nmod" but NOT "nmod:poss"
          // But for acl, also exclude acl:relcl
          if (relConfig.rel === 'acl') {
            relMatch = dep === 'acl'; // Exact match, exclude acl:relcl
          } else {
            relMatch = relConfig.rel === dep;
          }
        }
        
        if (!relMatch) continue;
        
        // Check modifier POS
        if (relConfig.modPos && depTok[posField] !== relConfig.modPos) continue;
        
        // Apply verbFormFilter for N07/N08
        if (verbFormFilter) {
          const word = (depTok.word || '').toLowerCase();
          const posd = (depTok.posd || '').toUpperCase();
          let matches = false;
          if (verbFormFilter === 'ing') {
            matches = word.endsWith('ing') || posd === 'VBG';
          } else if (verbFormFilter === 'ed') {
            matches = word.endsWith('ed') || posd === 'VBN' || posd === 'VBD';
          } else if (verbFormFilter === 'both') {
            matches = word.endsWith('ing') || word.endsWith('ed') || posd === 'VBG' || posd === 'VBN' || posd === 'VBD';
          }
          if (!matches) continue;
        }
        
        // Check modifier query match if searching as modifier
        if (searchAs === 'modifier' && query) {
          const depValue = queryType === 'lemma' ? (depTok.lemma || depTok.word) : depTok.word;
          const queryMatch = ignoreCase 
            ? depValue.toLowerCase() === queryLower
            : depValue === query;
          if (!queryMatch) continue;
        }
        
        // Store minimal match data - no sentTokens for performance
        matches.push({
          node: nodeTok,
          nodeIdx,
          dependents: [{ token: depTok, rel: dep, idx: depIdx }]
        });
      }
    }
  } else {
    // Chain mode: all relations must match in sequence - returns array of matches
    const chainMatches = matchChainPatternOptimized(nodeTok, nodeIdx, rels, tokens, depsByHead, tokensBySentence, query, queryLower, searchAs, queryType, ignoreCase, posField, config.caseFilter, config.verbFormFilter, config.includeCase, config.toInfFilter, config.ppFilter, config.noObjFilter, config.excludeRelClauses, config.rootVerbOnly);
    matches.push(...chainMatches);
  }
  
  return matches;
}

// OPTIMIZED chain pattern matching - returns ALL matches, not just first
function matchChainPatternOptimized(nodeTok, nodeIdx, rels, tokens, depsByHead, tokensBySentence, query, queryLower, searchAs, queryType, ignoreCase, posField, caseFilter, verbFormFilter, includeCase, toInfFilter, ppFilter, noObjFilter, excludeRelClauses, rootVerbOnly) {
  if (!rels || rels.length === 0) return [];
  
  // Apply rootVerbOnly filter - only match verbs that are ROOT
  if (rootVerbOnly) {
    const nodeDep = nodeTok.dep || nodeTok.deprel || '';
    if (nodeDep !== 'ROOT' && nodeDep !== 'root') {
      return []; // Not a root verb, skip
    }
  }
  
  // Apply excludeRelClauses filter - exclude if this is a relative clause verb
  // Check if verb has a subject that is a relative pronoun (which, that, who, etc.)
  if (excludeRelClauses) {
    const nodeDepIndices = depsByHead.get(nodeIdx) || [];
    for (const depIdx of nodeDepIndices) {
      const depTok = tokens[depIdx];
      const dep = depTok.dep || depTok.deprel || '';
      const word = (depTok.word || '').toLowerCase();
      // If subject is a relative pronoun, this is a relative clause
      if ((dep === 'nsubj' || dep === 'nsubj:pass') && 
          ['which', 'that', 'who', 'whom', 'whose', 'where', 'when'].includes(word)) {
        return []; // This is a relative clause, skip
      }
    }
    // Also check if the verb itself is in an acl:relcl relation (is a relative clause verb)
    const verbDep = nodeTok.dep || nodeTok.deprel || '';
    if (verbDep === 'acl:relcl' || verbDep === 'acl' || verbDep === 'relcl') {
      return []; // This verb is a relative clause modifier, skip
    }
  }
  
  // Apply noObjFilter for S01 (intransitive verbs only)
  // Check if verb has obj or xcomp relation - if so, skip (not first sentence pattern)
  if (noObjFilter) {
    const nodeDepIndices = depsByHead.get(nodeIdx) || [];
    for (const depIdx of nodeDepIndices) {
      const depTok = tokens[depIdx];
      const dep = depTok.dep || depTok.deprel || '';
      // Exclude if has object (obj, dobj) or complement (xcomp, ccomp)
      if (dep === 'obj' || dep === 'dobj' || dep === 'xcomp' || dep === 'ccomp' || dep === 'iobj') {
        return []; // Has object or complement, not simple SV pattern
      }
    }
  }
  
  // Apply ppFilter for N06 (NOUN + REL.CLAUSE)
  // Check if NOUN has nmod relation (PP attached)
  if (ppFilter && ppFilter !== 'include') {
    const nodeDepIndices = depsByHead.get(nodeIdx) || [];
    let hasNmod = false;
    for (const depIdx of nodeDepIndices) {
      const depTok = tokens[depIdx];
      const dep = depTok.dep || depTok.deprel || '';
      if (dep === 'nmod' || dep.startsWith('nmod:')) {
        hasNmod = true;
        break;
      }
    }
    
    if (ppFilter === 'exclude' && hasNmod) {
      return []; // Exclude NOUN + PP + REL.CLAUSE
    }
    if (ppFilter === 'only' && !hasNmod) {
      return []; // Only NOUN + PP + REL.CLAUSE
    }
  }
  
  // Get dependents from pre-built index (keyed by array index)
  const depIndices = depsByHead.get(nodeIdx) || [];
  
  const firstRel = rels[0];
  let firstDeps = [];
  
  for (const depIdx of depIndices) {
    const depTok = tokens[depIdx];
    const dep = depTok.dep || depTok.deprel || '';
    
    // Check relation match - exact match only (exclude subtypes)
    let relMatch = false;
    if (!firstRel.rel) {
      relMatch = true;
    } else if (firstRel.rel.includes(':')) {
      relMatch = firstRel.rel === dep;
    } else {
      relMatch = firstRel.rel === dep;
    }
    
    if (!relMatch) continue;
    
    // Check modifier POS
    if (firstRel.modPos && depTok[posField] !== firstRel.modPos) continue;
    
    // Apply caseFilter: check if dependent has a 'case' child with matching word (e.g., "of")
    if (caseFilter) {
      const depDepIndices = depsByHead.get(depIdx) || [];
      let hasCase = false;
      for (const childIdx of depDepIndices) {
        const childTok = tokens[childIdx];
        const childDep = childTok.dep || childTok.deprel || '';
        if (childDep === 'case' && childTok.word && childTok.word.toLowerCase() === caseFilter.toLowerCase()) {
          hasCase = true;
          break;
        }
      }
      if (!hasCase) continue;
    }
    
    // Apply toInfFilter: check if verb has "to" marker (mark relation)
    if (toInfFilter) {
      const depDepIndices = depsByHead.get(depIdx) || [];
      let hasTo = false;
      for (const childIdx of depDepIndices) {
        const childTok = tokens[childIdx];
        const childDep = childTok.dep || childTok.deprel || '';
        if (childDep === 'mark' && childTok.word && childTok.word.toLowerCase() === 'to') {
          hasTo = true;
          break;
        }
      }
      if (!hasTo) continue;
    }
    
    // Apply verbFormFilter: check word ending or POS tag
    if (verbFormFilter && verbFormFilter !== 'both') {
      const word = (depTok.word || '').toLowerCase();
      const posd = (depTok.posd || '').toUpperCase();
      let matches = false;
      if (verbFormFilter === 'ing') {
        matches = word.endsWith('ing') || posd === 'VBG';
      } else if (verbFormFilter === 'ed') {
        matches = word.endsWith('ed') || posd === 'VBN' || posd === 'VBD';
      }
      if (!matches) continue;
    }
    
    // Collect case word (e.g., "of") for includeCase
    let caseWord = null;
    if (includeCase && caseFilter) {
      const depDepIndices = depsByHead.get(depIdx) || [];
      for (const childIdx of depDepIndices) {
        const childTok = tokens[childIdx];
        const childDep = childTok.dep || childTok.deprel || '';
        if (childDep === 'case' && childTok.word && childTok.word.toLowerCase() === caseFilter.toLowerCase()) {
          caseWord = { token: childTok, idx: childIdx };
          break;
        }
      }
    }
    
    // Collect "to" word for toInfFilter
    let toWord = null;
    if (toInfFilter) {
      const depDepIndices = depsByHead.get(depIdx) || [];
      for (const childIdx of depDepIndices) {
        const childTok = tokens[childIdx];
        const childDep = childTok.dep || childTok.deprel || '';
        if (childDep === 'mark' && childTok.word && childTok.word.toLowerCase() === 'to') {
          toWord = { token: childTok, idx: childIdx };
          break;
        }
      }
    }
    
    firstDeps.push({ token: depTok, idx: depIdx, rel: dep, caseWord, toWord });
  }
  
  if (firstDeps.length === 0) return [];
  
  const allMatches = [];
  
  // For single relation pattern - return ALL matches
  if (rels.length === 1) {
    for (const dep of firstDeps) {
      // Check modifier query match if searching as modifier
      if (searchAs === 'modifier' && query) {
        const depValue = queryType === 'lemma' ? (dep.token.lemma || dep.token.word) : dep.token.word;
        const queryMatch = ignoreCase 
          ? depValue.toLowerCase() === queryLower
          : depValue === query;
        if (!queryMatch) continue;
      }
      
      allMatches.push({
        node: nodeTok,
        nodeIdx,
        dependents: [{ token: dep.token, rel: dep.rel, idx: dep.idx }],
        caseWord: dep.caseWord,
        toWord: dep.toWord
      });
    }
    return allMatches;
  }
  
  // For multi-relation pattern, continue chain for each first dependent
  for (const firstDep of firstDeps) {
    const chainResults = continueChainOptimizedAll(firstDep.token, firstDep.idx, rels.slice(1), tokens, depsByHead, tokensBySentence, query, queryLower, searchAs, queryType, ignoreCase, posField);
    
    for (const chainResult of chainResults) {
      // Check modifier query match on last dependent if searching as modifier
      if (searchAs === 'modifier' && query) {
        const lastDep = chainResult[chainResult.length - 1].token;
        const depValue = queryType === 'lemma' ? (lastDep.lemma || lastDep.word) : lastDep.word;
        const queryMatch = ignoreCase 
          ? depValue.toLowerCase() === queryLower
          : depValue === query;
        if (!queryMatch) continue;
      }
      
      allMatches.push({
        node: nodeTok,
        nodeIdx,
        dependents: [{ token: firstDep.token, rel: firstDep.rel, idx: firstDep.idx }, ...chainResult],
        caseWord: firstDep.caseWord,
        toWord: firstDep.toWord
      });
    }
  }
  
  return allMatches;
}

// OPTIMIZED continue chain - returns ALL possible chains
function continueChainOptimizedAll(currentTok, currentIdx, remainingRels, tokens, depsByHead, tokensBySentence, query, queryLower, searchAs, queryType, ignoreCase, posField) {
  if (!remainingRels || remainingRels.length === 0) return [[]];
  
  // Get dependents from pre-built index (keyed by array index)
  const depIndices = depsByHead.get(currentIdx) || [];
  
  const nextRel = remainingRels[0];
  let nextDeps = [];
  
  for (const depIdx of depIndices) {
    const depTok = tokens[depIdx];
    const dep = depTok.dep || depTok.deprel || '';
    
    // Check relation match - exact match only (exclude subtypes)
    let relMatch = false;
    if (!nextRel.rel) {
      relMatch = true;
    } else if (nextRel.rel.includes(':')) {
      relMatch = nextRel.rel === dep;
    } else {
      relMatch = nextRel.rel === dep;
    }
    
    if (!relMatch) continue;
    
    // Check modifier POS
    if (nextRel.modPos && depTok[posField] !== nextRel.modPos) continue;
    
    nextDeps.push({ token: depTok, idx: depIdx, rel: dep });
  }
  
  if (nextDeps.length === 0) return [];
  
  const allChains = [];
  
  if (remainingRels.length === 1) {
    // Return all matches at this level
    for (const dep of nextDeps) {
      allChains.push([{ token: dep.token, rel: dep.rel, idx: dep.idx }]);
    }
    return allChains;
  }
  
  // Continue chain for each match
  for (const nextDep of nextDeps) {
    const furtherChains = continueChainOptimizedAll(nextDep.token, nextDep.idx, remainingRels.slice(1), tokens, depsByHead, tokensBySentence, query, queryLower, searchAs, queryType, ignoreCase, posField);
    for (const further of furtherChains) {
      allChains.push([{ token: nextDep.token, rel: nextDep.rel, idx: nextDep.idx }, ...further]);
    }
  }
  
  return allChains;
}

// Find dependents for a relation
function findDependentsForRel(nodeTok, nodeIdx, relConfig, tokenById, file) {
  const results = [];
  const nodeTokenId = nodeTok.token_id ?? nodeIdx;
  
  // Get POS type (universal uses poss, penn uses posd)
  const posType = document.querySelector('input[name="depPosType"]:checked')?.value || 'universal';
  const posField = posType === 'universal' ? 'poss' : 'posd';
  
  // Check node POS
  if (relConfig.nodePos && nodeTok[posField] !== relConfig.nodePos) {
    return results;
  }
  
  // Find tokens that have this node as head with matching relation
  file.tokens.forEach((tok, idx) => {
    const headId = tok.head_id;
    const dep = tok.dep || '';
    
    // Check if this token's head is our node (compare as numbers for type consistency)
    const headIdNum = parseInt(headId);
    const nodeTokenIdNum = parseInt(nodeTokenId);
    const nodeIdxNum = parseInt(nodeIdx);
    
    const isHeadMatch = (!isNaN(headIdNum) && !isNaN(nodeTokenIdNum) && headIdNum === nodeTokenIdNum) ||
                        (!isNaN(headIdNum) && headIdNum === nodeIdxNum) ||
                        (headId === nodeTokenId) || (headId === nodeIdx);
    
    if (isHeadMatch) {
      // Check relation match (handle subtypes like acl:relcl)
      const relMatch = relConfig.rel === dep || 
        dep.startsWith(relConfig.rel + ':') ||
        relConfig.rel.includes(':') && dep === relConfig.rel.split(':')[0];
      
      if (relMatch || !relConfig.rel) {
        // Check modifier POS
        if (!relConfig.modPos || tok[posField] === relConfig.modPos) {
          results.push({ ...tok, arrayIndex: idx });
        }
      }
    }
  });
  
  return results;
}

// Match chain pattern (Rel1 → Rel2 → ...)
function matchChainPattern(nodeTok, nodeIdx, rels, tokenById, tokensBySentence, file, query, searchAs, queryType, ignoreCase) {
  if (!rels || rels.length === 0) return null;
  
  const firstRel = rels[0];
  const firstDeps = findDependentsForRel(nodeTok, nodeIdx, firstRel, tokenById, file);
  
  if (firstDeps.length === 0) return null;
  
  // For single relation pattern
  if (rels.length === 1) {
    const dep = firstDeps[0];
    
    // Check modifier query match if searching as modifier
    if (searchAs === 'modifier' && query) {
      const depValue = queryType === 'lemma' ? (dep.lemma || dep.word) : dep.word;
      const queryMatch = ignoreCase 
        ? depValue.toLowerCase() === query.toLowerCase()
        : depValue === query;
      if (!queryMatch) return null;
    }
    
    return {
      node: nodeTok,
      nodeIdx,
      dependents: [{ token: dep, rel: firstRel.rel }],
      sentTokens: tokensBySentence.get(nodeTok.sent_id ?? 0) || []
    };
  }
  
  // For multi-relation chain, continue from first dependent
  for (const firstDep of firstDeps) {
    const remainingRels = rels.slice(1);
    const chainResult = continueChain(firstDep, firstDep.arrayIndex, remainingRels, tokenById, tokensBySentence, file);
    
    if (chainResult) {
      // Check modifier query match on last dependent if searching as modifier
      if (searchAs === 'modifier' && query) {
        const lastDep = chainResult[chainResult.length - 1].token;
        const depValue = queryType === 'lemma' ? (lastDep.lemma || lastDep.word) : lastDep.word;
        const queryMatch = ignoreCase 
          ? depValue.toLowerCase() === query.toLowerCase()
          : depValue === query;
        if (!queryMatch) continue;
      }
      
      return {
        node: nodeTok,
        nodeIdx,
        dependents: [{ token: firstDep, rel: firstRel.rel }, ...chainResult],
        sentTokens: tokensBySentence.get(nodeTok.sent_id ?? 0) || []
      };
    }
  }
  
  return null;
}

// Continue chain matching
function continueChain(currentTok, currentIdx, remainingRels, tokenById, tokensBySentence, file) {
  if (!remainingRels || remainingRels.length === 0) return [];
  
  const nextRel = remainingRels[0];
  const nextDeps = findDependentsForRel(currentTok, currentIdx, nextRel, tokenById, file);
  
  if (nextDeps.length === 0) return null;
  
  if (remainingRels.length === 1) {
    return [{ token: nextDeps[0], rel: nextRel.rel }];
  }
  
  for (const nextDep of nextDeps) {
    const further = continueChain(nextDep, nextDep.arrayIndex, remainingRels.slice(1), tokenById, tokensBySentence, file);
    if (further) {
      return [{ token: nextDep, rel: nextRel.rel }, ...further];
    }
  }
  
  return null;
}

// Build feature string from match (in text order)
function buildFeatureString(match, depth, elementConfig, ignoreCase, queryType) {
  const tokens = [];
  
  // Use token_id for sorting within sentence (not array index)
  // Ensure token_id is parsed correctly - handle both string and number types
  const nodeTokenIdRaw = match.node.token_id;
  const nodeTokenId = typeof nodeTokenIdRaw === 'number' ? nodeTokenIdRaw : parseInt(nodeTokenIdRaw, 10);
  const nodePos = (!isNaN(nodeTokenId) && nodeTokenId >= 0) ? nodeTokenId : (match.nodeIdx || 0);
  const nodeWord = queryType === 'lemma' ? (match.node.lemma || match.node.word) : match.node.word;
  const nodeText = ignoreCase ? nodeWord.toLowerCase() : nodeWord;
  tokens.push({ pos: nodePos, text: nodeText, type: 'node', tok: match.node });
  
  match.dependents.forEach((dep, i) => {
    const depTokenIdRaw = dep.token.token_id;
    const depTokenId = typeof depTokenIdRaw === 'number' ? depTokenIdRaw : parseInt(depTokenIdRaw, 10);
    const depPos = (!isNaN(depTokenId) && depTokenId >= 0) ? depTokenId : (dep.idx || 0);
    const depWord = queryType === 'lemma' ? (dep.token.lemma || dep.token.word) : dep.token.word;
    const depText = ignoreCase ? depWord.toLowerCase() : depWord;
    tokens.push({ pos: depPos, text: depText, type: `dep${i + 1}`, rel: dep.rel, tok: dep.token });
  });
  
  // Include caseWord (e.g., "of") if present
  if (match.caseWord && match.caseWord.token) {
    const caseTokenIdRaw = match.caseWord.token.token_id;
    const caseTokenId = typeof caseTokenIdRaw === 'number' ? caseTokenIdRaw : parseInt(caseTokenIdRaw, 10);
    const casePos = (!isNaN(caseTokenId) && caseTokenId >= 0) ? caseTokenId : (match.caseWord.idx || 0);
    const caseWord = match.caseWord.token.word || '';
    const caseText = ignoreCase ? caseWord.toLowerCase() : caseWord;
    tokens.push({ pos: casePos, text: caseText, type: 'case', tok: match.caseWord.token });
  }
  
  // Include toWord (e.g., "to") if present
  if (match.toWord && match.toWord.token) {
    const toTokenIdRaw = match.toWord.token.token_id;
    const toTokenId = typeof toTokenIdRaw === 'number' ? toTokenIdRaw : parseInt(toTokenIdRaw, 10);
    const toPos = (!isNaN(toTokenId) && toTokenId >= 0) ? toTokenId : (match.toWord.idx || 0);
    const toWord = match.toWord.token.word || '';
    const toText = ignoreCase ? toWord.toLowerCase() : toWord;
    tokens.push({ pos: toPos, text: toText, type: 'to', tok: match.toWord.token });
  }
  
  // Sort by token_id (position within sentence) - ascending order
  tokens.sort((a, b) => {
    const posA = Number(a.pos);
    const posB = Number(b.pos);
    return posA - posB;
  });
  
  // Build feature string based on depth
  if (depth === 'head') {
    return tokens.map(t => t.text).join(' ');
  } else if (depth === 'element' && elementConfig) {
    // Filter tokens based on selected elements
    const filtered = tokens.filter(t => {
      if (t.type === 'node') {
        if (elementConfig.V && isVerbElement(t.tok)) return true;
        if (elementConfig.S && isSubjectHead(t.tok)) return true;
        return false;
      } else {
        if (elementConfig.S && isSubjectRel(t.rel)) return true;
        if (elementConfig.V && isVerbRel(t.rel, t.tok)) return true;
        if (elementConfig.O && isObjectRel(t.rel)) return true;
        if (elementConfig.C && isCompRel(t.rel)) return true;
        if (elementConfig.Mod && isModifierRel(t.rel)) return true;
        return false;
      }
    });
    
    if (filtered.length === 0) {
      return tokens.map(t => t.text).join(' ');
    }
    return filtered.map(t => t.text).join(' ');
  } else {
    return tokens.map(t => t.text).join(' ');
  }
}

// Helper functions for element detection
function isSubjectRel(rel) {
  if (!rel) return false;
  return rel === 'nsubj' || rel === 'nsubj:pass' || rel === 'csubj' || rel === 'csubj:pass';
}

function isSubjectHead(tok) {
  // Check if this token has a subject dependent
  return false; // Node itself is not typically the subject
}

function isVerbElement(tok) {
  if (!tok) return false;
  const pos = tok.poss || tok.posd || '';
  return pos === 'VERB' || pos === 'VB' || pos === 'VBD' || pos === 'VBG' || pos === 'VBN' || pos === 'VBP' || pos === 'VBZ';
}

function isVerbRel(rel, tok) {
  if (!rel) return false;
  // Auxiliary verbs
  if (rel === 'aux' || rel === 'aux:pass' || rel === 'cop') return true;
  // Check POS
  return isVerbElement(tok);
}

function isObjectRel(rel) {
  if (!rel) return false;
  return rel === 'obj' || rel === 'dobj' || rel === 'iobj';
}

function isCompRel(rel) {
  if (!rel) return false;
  return rel === 'ccomp' || rel === 'xcomp' || rel === 'advcl';
}

function isModifierRel(rel) {
  if (!rel) return false;
  return rel === 'amod' || rel === 'advmod' || rel === 'nmod' || rel === 'nummod' || 
         rel === 'compound' || rel === 'det' || rel.startsWith('nmod:');
}

// Helper: get target file count
function getTargetFileCount() {
  if (!corpus) return 0;
  return Object.values(corpus.files).filter(f => targetFolders.has(f.folder)).length;
}

// Helper: get reference file count
function getReferenceFileCount() {
  if (!corpus) return 0;
  return Object.values(corpus.files).filter(f => referenceFolders.has(f.folder)).length;
}

// Store current scope for concordance filtering
let lastDepScope = 'target';

// Display results
function displayDepResults(results) {
  allDepPatternRows = results.rows;
  lastDepPatternRows = [...allDepPatternRows];
  lastDepAdvancedStats = document.getElementById('depAdvancedStats')?.checked || false;
  lastDepScope = results.scope;
  
  // Update summary based on scope
  const scope = results.scope;
  
  // Calculate instances and files based on scope
  let totalInstances = 0;
  const totalFiles = new Set();
  
  allDepPatternRows.forEach(r => {
    if (scope === 'target') {
      totalInstances += r.freqT;
      r.instances.forEach(inst => {
        // Include T and B (both) as Target files
        if (inst.side === 'T' || inst.side === 'B') totalFiles.add(inst.fileName);
      });
    } else if (scope === 'reference') {
      totalInstances += r.freqR;
      r.instances.forEach(inst => {
        // Include R and B (both) as Reference files
        if (inst.side === 'R' || inst.side === 'B') totalFiles.add(inst.fileName);
      });
    } else {
      // All folders: include T + R + N
      totalInstances += r.freqT + r.freqR + (r.freqN || 0);
      r.instances.forEach(inst => totalFiles.add(inst.fileName));
    }
  });
  
  document.getElementById('depPatternSummary').style.display = 'block';
  document.getElementById('depPatternTypes').textContent = allDepPatternRows.length.toLocaleString();
  document.getElementById('depPatternInstances').textContent = totalInstances.toLocaleString();
  document.getElementById('depPatternFiles').textContent = totalFiles.size.toLocaleString();
  
  // Update table header
  updateDepTableHeader(scope);
  
  // Sort setting based on scope
  const advanced = document.getElementById('depAdvancedStats')?.checked || false;
  if (scope === 'all') {
    // No keyness columns, sort by freqT (col 2)
    lastDepSort = { col: 2, dir: 'desc' };
  } else {
    // Has keyness columns
    // Basic: Freq-LL is col 6
    // Advanced: Freq-LL is col 12
    lastDepSort = { col: advanced ? 12 : 6, dir: 'desc' };
  }
  sortDepPatternRows();
  
  renderDepTable();
  
  // Initialize column resizers
  setTimeout(() => initDepTableResize(), 50);
  
  document.getElementById('depPatternStatus').textContent = 
    `Found ${allDepPatternRows.length.toLocaleString()} pattern types.`;
}

// Update table header based on scope
function updateDepTableHeader(scope) {
  const table = document.getElementById('depPatternTable');
  const thead = document.getElementById('depPatternThead');
  if (!thead || !table) return;
  
  const advanced = document.getElementById('depAdvancedStats')?.checked || false;
  let colIdx = 0;
  let sortIdx = 0;
  
  // Build colgroup dynamically
  let colgroupHtml = '<colgroup>';
  let headerHtml = '<tr>';
  
  // # column
  colgroupHtml += '<col style="width:40px;">';
  headerHtml += `<th style="position:relative;">#<div class="dep-col-resizer" data-col="${colIdx++}"></div></th>`;
  sortIdx++;
  
  // Feature column
  colgroupHtml += '<col style="width:160px;">';
  headerHtml += `<th class="sortable" style="position:relative;" onclick="sortDepTable(${sortIdx++})">Feature<div class="dep-col-resizer" data-col="${colIdx++}"></div></th>`;
  
  if (scope === 'all') {
    // All folders: show only freq, files, pmw
    // freq (total)
    colgroupHtml += '<col style="width:80px;">';
    headerHtml += `<th class="sortable text-right" style="position:relative;" onclick="sortDepTable(${sortIdx++})">Freq<div class="dep-col-resizer" data-col="${colIdx++}"></div></th>`;
    
    // files
    colgroupHtml += '<col style="width:80px;">';
    headerHtml += `<th class="sortable text-right" style="position:relative;" onclick="sortDepTable(${sortIdx++})">Files<div class="dep-col-resizer" data-col="${colIdx++}"></div></th>`;
    
    // pmw (per million words)
    colgroupHtml += '<col style="width:100px;">';
    headerHtml += `<th class="sortable text-right" style="position:relative;" onclick="sortDepTable(${sortIdx++})">pmw<div class="dep-col-resizer" data-col="${colIdx++}"></div></th>`;
  } else {
    // Target/Reference: show freq_T, norm_T, freq_R, norm_R, and keyness
    // freq_T
    colgroupHtml += '<col style="width:60px;">';
    headerHtml += `<th class="sortable text-right" style="position:relative;" onclick="sortDepTable(${sortIdx++})">freq_T<div class="dep-col-resizer" data-col="${colIdx++}"></div></th>`;
    
    // norm_T
    colgroupHtml += '<col style="width:80px;">';
    headerHtml += `<th class="sortable text-right" style="position:relative;" onclick="sortDepTable(${sortIdx++})">norm_T (pm)<div class="dep-col-resizer" data-col="${colIdx++}"></div></th>`;
    
    if (advanced) {
      // Range_T
      colgroupHtml += '<col style="width:60px;">';
      headerHtml += `<th class="sortable text-right" style="position:relative;" onclick="sortDepTable(${sortIdx++})">Range_T<div class="dep-col-resizer" data-col="${colIdx++}"></div></th>`;
      
      // Juilland_T
      colgroupHtml += '<col style="width:70px;">';
      headerHtml += `<th class="sortable text-right" style="position:relative;" onclick="sortDepTable(${sortIdx++})">Juilland_T<div class="dep-col-resizer" data-col="${colIdx++}"></div></th>`;
      
      // DP_T
      colgroupHtml += '<col style="width:50px;">';
      headerHtml += `<th class="sortable text-right" style="position:relative;" onclick="sortDepTable(${sortIdx++})">DP_T<div class="dep-col-resizer" data-col="${colIdx++}"></div></th>`;
    }
    
    // freq_R
    colgroupHtml += '<col style="width:60px;">';
    headerHtml += `<th class="sortable text-right" style="position:relative;" onclick="sortDepTable(${sortIdx++})">freq_R<div class="dep-col-resizer" data-col="${colIdx++}"></div></th>`;
    
    // norm_R
    colgroupHtml += '<col style="width:80px;">';
    headerHtml += `<th class="sortable text-right" style="position:relative;" onclick="sortDepTable(${sortIdx++})">norm_R (pm)<div class="dep-col-resizer" data-col="${colIdx++}"></div></th>`;
    
    if (advanced) {
      // Range_R
      colgroupHtml += '<col style="width:60px;">';
      headerHtml += `<th class="sortable text-right" style="position:relative;" onclick="sortDepTable(${sortIdx++})">Range_R<div class="dep-col-resizer" data-col="${colIdx++}"></div></th>`;
      
      // Juilland_R
      colgroupHtml += '<col style="width:70px;">';
      headerHtml += `<th class="sortable text-right" style="position:relative;" onclick="sortDepTable(${sortIdx++})">Juilland_R<div class="dep-col-resizer" data-col="${colIdx++}"></div></th>`;
      
      // DP_R
      colgroupHtml += '<col style="width:50px;">';
      headerHtml += `<th class="sortable text-right" style="position:relative;" onclick="sortDepTable(${sortIdx++})">DP_R<div class="dep-col-resizer" data-col="${colIdx++}"></div></th>`;
    }
    
    // Keyness columns (for Target or Reference scope)
    const suffix = scope === 'target' ? '(T)' : '(R)';
    
    // Freq-LL
    colgroupHtml += '<col style="width:75px;">';
    headerHtml += `<th class="sortable text-right" style="position:relative;" onclick="sortDepTable(${sortIdx++})">Freq-LL ${suffix}<div class="dep-col-resizer" data-col="${colIdx++}"></div></th>`;
    
    // Text-LL
    colgroupHtml += '<col style="width:75px;">';
    headerHtml += `<th class="sortable text-right" style="position:relative;" onclick="sortDepTable(${sortIdx++})">Text-LL ${suffix}<div class="dep-col-resizer" data-col="${colIdx++}"></div></th>`;
    
    // MTK
    colgroupHtml += '<col style="width:80px;">';
    headerHtml += `<th class="sortable text-right" style="position:relative;" onclick="sortDepTable(${sortIdx++})">MTK ${suffix}<div class="dep-col-resizer" data-col="${colIdx++}"></div></th>`;
  }
  
  colgroupHtml += '</colgroup>';
  headerHtml += '</tr>';
  
  // Update colgroup
  const existingColgroup = table.querySelector('colgroup');
  if (existingColgroup) {
    existingColgroup.outerHTML = colgroupHtml;
  } else {
    table.insertAdjacentHTML('afterbegin', colgroupHtml);
  }
  
  // Update thead
  thead.innerHTML = headerHtml;
  
  // Re-initialize column resizers after header update
  setTimeout(() => initDepTableResize(), 10);
}

// Render table based on scope
function renderDepTable() {
  const tbody = document.getElementById('depPatternTbody');
  if (!tbody) return;
  
  if (lastDepPatternRows.length === 0) {
    tbody.innerHTML = '<tr><td colspan="15" class="text-xs">No results found.</td></tr>';
    return;
  }
  
  const advanced = document.getElementById('depAdvancedStats')?.checked || false;
  const scope = lastDepScope || 'target';
  
  let html = '';
  lastDepPatternRows.forEach((row, idx) => {
    html += `<tr onclick="showDepConcordance(${idx})" style="cursor:pointer;">`;
    html += `<td>${idx + 1}</td>`;
    html += `<td>${escapeHtml(row.feature)}</td>`;
    
    if (scope === 'all') {
      // All folders: show freq, files, pmw
      const totalFreq = row.freqT + row.freqR + (row.freqN || 0);
      const filesCount = new Set(row.instances.map(i => i.fileName)).size;
      const pmw = row.totalNorm || ((row.normT * row.freqT + row.normR * row.freqR) / (row.freqT + row.freqR || 1));
      
      html += `<td class="text-right">${totalFreq.toLocaleString()}</td>`;
      html += `<td class="text-right">${filesCount.toLocaleString()}</td>`;
      html += `<td class="text-right">${pmw.toFixed(2)}</td>`;
    } else {
      // Target/Reference: show freq_T, norm_T, freq_R, norm_R, keyness
      // Target columns
      html += `<td class="text-right">${row.freqT.toLocaleString()}</td>`;
      html += `<td class="text-right">${row.normT.toFixed(1)}</td>`;
      if (advanced) {
        html += `<td class="text-right">${row.rangeT || 0}</td>`;
        html += `<td class="text-right">${(row.juillandT || 0).toFixed(3)}</td>`;
        html += `<td class="text-right">${(row.dpT || 0).toFixed(3)}</td>`;
      }
      
      // Reference columns
      html += `<td class="text-right">${row.freqR.toLocaleString()}</td>`;
      html += `<td class="text-right">${row.normR.toFixed(1)}</td>`;
      if (advanced) {
        html += `<td class="text-right">${row.rangeR || 0}</td>`;
        html += `<td class="text-right">${(row.juillandR || 0).toFixed(3)}</td>`;
        html += `<td class="text-right">${(row.dpR || 0).toFixed(3)}</td>`;
      }
      
      // Keyness columns
      html += `<td class="text-right">${formatLL(row.ll)}</td>`;
      html += `<td class="text-right">${formatLL(row.textLL)}</td>`;
      html += `<td class="text-right">${row.cohensD != null ? row.cohensD.toFixed(3) : '-'}</td>`;
    }
    
    html += '</tr>';
  });
  
  tbody.innerHTML = html;
}

// Format LL value with significance marker
function formatLL(ll) {
  if (ll === null || ll === undefined || isNaN(ll)) return '-';
  const sig = Math.abs(ll) > 3.84 ? '*' : '';
  return ll.toFixed(2) + sig;
}

// Sort table
function sortDepTable(colIdx) {
  if (lastDepSort.col === colIdx) {
    lastDepSort.dir = lastDepSort.dir === 'asc' ? 'desc' : 'asc';
  } else {
    lastDepSort.col = colIdx;
    lastDepSort.dir = 'desc';
  }
  sortDepPatternRows();
  renderDepTable();
}

// Sort rows (always use Both format columns)
function sortDepPatternRows() {
  const col = lastDepSort.col;
  const dir = lastDepSort.dir === 'asc' ? 1 : -1;
  const advanced = document.getElementById('depAdvancedStats')?.checked || false;
  
  lastDepPatternRows.sort((a, b) => {
    let va, vb;
    
    if (col === 0) { // #
      return 0; // Keep current order
    } else if (col === 1) { // Feature
      va = a.feature.toLowerCase();
      vb = b.feature.toLowerCase();
      return va < vb ? -dir : va > vb ? dir : 0;
    } else {
      // Map column to property based on advanced stats
      // Advanced OFF: #, Feature, freqT, normT, freqR, normR, ll, textLL, cohensD
      // Advanced ON:  #, Feature, freqT, normT, rangeT, juillandT, dpT, freqR, normR, rangeR, juillandR, dpR, ll, textLL, cohensD
      const colMap = advanced 
        ? [null, null, 'freqT', 'normT', 'rangeT', 'juillandT', 'dpT', 'freqR', 'normR', 'rangeR', 'juillandR', 'dpR', 'll', 'textLL', 'cohensD']
        : [null, null, 'freqT', 'normT', 'freqR', 'normR', 'll', 'textLL', 'cohensD'];
      const prop = colMap[col];
      if (prop) {
        va = a[prop] ?? 0;
        vb = b[prop] ?? 0;
        return (va - vb) * dir;
      }
    }
    return 0;
  });
}

// Apply filter
function applyDepFilter() {
  const minFreq = parseInt(document.getElementById('depFilterFreq')?.value) || 0;
  const featureSearch = (document.getElementById('depFilterFeature')?.value || '').toLowerCase().trim();
  const filterMode = document.getElementById('depFilterMode')?.value || 'partial';
  
  lastDepPatternRows = allDepPatternRows.filter(row => {
    const totalFreq = row.freqT + row.freqR;
    if (totalFreq < minFreq) return false;
    
    if (featureSearch) {
      const featureLower = row.feature.toLowerCase();
      
      if (filterMode === 'exact') {
        // Exact match: any word in the feature matches exactly
        const words = featureLower.split(/\s+/);
        if (!words.some(word => word === featureSearch)) return false;
      } else {
        // Partial match: feature contains the search string
        if (!featureLower.includes(featureSearch)) return false;
      }
    }
    
    return true;
  });
  
  sortDepPatternRows();
  renderDepTable();
  
  document.getElementById('depPatternStatus').textContent = 
    `Showing ${lastDepPatternRows.length.toLocaleString()} of ${allDepPatternRows.length.toLocaleString()} types.`;
}

// Clear filter
function clearDepFilter() {
  document.getElementById('depFilterFreq').value = '0';
  document.getElementById('depFilterFeature').value = '';
  document.getElementById('depFilterMode').value = 'partial';
  lastDepPatternRows = [...allDepPatternRows];
  sortDepPatternRows();
  renderDepTable();
  
  document.getElementById('depPatternStatus').textContent = 
    `Showing all ${allDepPatternRows.length.toLocaleString()} types.`;
}

// Show all concordance lines for filtered (or all) results
function showAllDepConcordance() {
  if (!lastDepPatternRows || lastDepPatternRows.length === 0) {
    alert('No results to show. Run Compute first.');
    return;
  }
  
  // Collect all instances from filtered results
  let allInstances = [];
  let totalInstances = 0;
  
  for (const row of lastDepPatternRows) {
    if (row.instances && row.instances.length > 0) {
      // Add feature name to each instance for reference
      const instancesWithFeature = row.instances.map(inst => ({
        ...inst,
        feature: row.feature
      }));
      allInstances.push(...instancesWithFeature);
      totalInstances += row.instances.length;
    }
  }
  
  // Limit to prevent browser freeze
  const MAX_INSTANCES = 10000;
  if (allInstances.length > MAX_INSTANCES) {
    allInstances = allInstances.slice(0, MAX_INSTANCES);
    alert(`Showing first ${MAX_INSTANCES.toLocaleString()} concordance lines (total: ${totalInstances.toLocaleString()})`);
  }
  
  // Set current instances for display
  currentDepInstances = allInstances;
  currentDepFeature = `[All ${lastDepPatternRows.length} filtered types]`;
  
  // Update current feature display
  document.getElementById('depConcordanceFeature').textContent = currentDepFeature;
  document.getElementById('depConcordanceCount').textContent = allInstances.length.toLocaleString();
  
  // Expand 12b) section if collapsed
  const section12bContent = document.getElementById('section12b-content');
  const section12bArrow = document.getElementById('section12b-arrow');
  if (section12bContent && section12bContent.style.display === 'none') {
    section12bContent.style.display = 'block';
    if (section12bArrow) section12bArrow.textContent = '▼';
  }
  
  // Scroll to 12b) section
  const depConcSection = document.getElementById('depConcordanceSection');
  if (depConcSection) {
    depConcSection.scrollIntoView({ behavior: 'smooth', block: 'start' });
  }
  
  // Update display
  updateDepConcordanceDisplay();
}

// Clear all
function clearDepPattern() {
  allDepPatternRows = [];
  lastDepPatternRows = [];
  currentDepFeature = null;
  currentDepInstances = [];
  
  // Clear Node Word inputs
  for (let i = 1; i <= 5; i++) {
    const nodeWord = document.getElementById(`depNodeWord${i}`);
    if (nodeWord) nodeWord.value = '';
  }
  
  document.getElementById('depPatternTbody').innerHTML = 
    '<tr><td colspan="15" class="text-xs">No results yet. Configure pattern and click Compute.</td></tr>';
  document.getElementById('depPatternSummary').style.display = 'none';
  document.getElementById('depPatternStatus').textContent = 'Cleared. Ready for new search.';
  
  // Clear concordance
  document.getElementById('depConcordanceTbody').innerHTML = 
    '<tr><td colspan="3" class="text-xs">No concordance data. Click a row in 12a) to view.</td></tr>';
  document.getElementById('depConcordanceFeature').textContent = '-';
  document.getElementById('depConcordanceCount').textContent = '0';
}

// Show concordance for selected row
function showDepConcordance(rowIdx) {
  // Use lastDepPatternRows (currently displayed rows in 12a)
  if (rowIdx < 0 || rowIdx >= lastDepPatternRows.length) return;
  
  const row = lastDepPatternRows[rowIdx];
  currentDepFeature = row.feature;
  currentDepInstances = row.instances;
  
  // Sync concordance scope with 12a) scope
  const concScope = document.getElementById('depConcScope');
  if (concScope && lastDepScope) {
    concScope.value = lastDepScope;
  }
  
  // Update UI
  document.getElementById('depConcordanceFeature').textContent = row.feature;
  
  // Count instances based on scope filter (B = both, include in Target and Reference)
  const scope = concScope?.value || 'all';
  let filteredCount = currentDepInstances.length;
  if (scope === 'target') {
    filteredCount = currentDepInstances.filter(i => i.side === 'T' || i.side === 'B').length;
  } else if (scope === 'reference') {
    filteredCount = currentDepInstances.filter(i => i.side === 'R' || i.side === 'B').length;
  }
  document.getElementById('depConcordanceCount').textContent = filteredCount.toLocaleString();
  
  // Expand concordance section
  const content = document.getElementById('section12b-content');
  const arrow = document.getElementById('section12b-arrow');
  if (content && content.style.display === 'none') {
    content.style.display = 'block';
    if (arrow) arrow.textContent = '▼';
  }
  
  updateDepConcordanceDisplay();
  
  // Scroll to 12b) with a slight delay
  setTimeout(() => {
    const section12b = document.getElementById('section12b-header');
    if (section12b) {
      section12b.scrollIntoView({ behavior: 'smooth', block: 'start' });
    }
  }, 100);
}

// Update concordance display
function updateDepConcordanceDisplay() {
  const table = document.getElementById('depConcordanceTable');
  const tbody = document.getElementById('depConcordanceTbody');
  const thead = document.getElementById('depConcordanceThead');
  if (!tbody || !table || !currentDepInstances || currentDepInstances.length === 0) {
    if (tbody) tbody.innerHTML = '<tr><td colspan="5" class="text-xs">No concordance data.</td></tr>';
    return;
  }
  
  const maxRows = parseInt(document.getElementById('depConcMax')?.value) || 500;
  const scope = document.getElementById('depConcScope')?.value || 'all';
  
  // Filter instances by scope (B = both, so include in Target and Reference)
  let filteredInstances = currentDepInstances;
  if (scope === 'target') {
    filteredInstances = currentDepInstances.filter(i => i.side === 'T' || i.side === 'B');
  } else if (scope === 'reference') {
    filteredInstances = currentDepInstances.filter(i => i.side === 'R' || i.side === 'B');
  }
  
  // Remove duplicates if checkbox is checked
  const dedupe = document.getElementById('depConcDedupe')?.checked || false;
  if (dedupe) {
    const seen = new Set();
    filteredInstances = filteredInstances.filter(inst => {
      // Create unique key: fileName + sentId + governor + dependent
      const gov = inst.governor || (inst.match?.node?.word) || '';
      const dep = inst.dependent || (inst.match?.dependents?.[0]?.token?.word) || '';
      const key = `${inst.fileName}|${inst.sentId ?? ''}|${gov.toLowerCase()}|${dep.toLowerCase()}`;
      if (seen.has(key)) {
        return false;
      }
      seen.add(key);
      return true;
    });
  }
  
  // Update count display
  document.getElementById('depConcordanceCount').textContent = filteredInstances.length.toLocaleString();
  
  // Sort instances based on depConcSortCol and depConcSortDir
  let sortedInstances = [...filteredInstances];
  const sortMultiplier = depConcSortDir === 'asc' ? 1 : -1;
  
  if (depConcSortCol === 'governor') {
    sortedInstances.sort((a, b) => sortMultiplier * (a.governor || '').localeCompare(b.governor || ''));
  } else if (depConcSortCol === 'dependent') {
    sortedInstances.sort((a, b) => sortMultiplier * (a.dependent || '').localeCompare(b.dependent || ''));
  } else if (depConcSortCol === 'file') {
    sortedInstances.sort((a, b) => sortMultiplier * a.fileName.localeCompare(b.fileName));
  } else if (depConcSortCol === 'side') {
    sortedInstances.sort((a, b) => sortMultiplier * a.side.localeCompare(b.side));
  } else if (depConcSortCol === 'concordance') {
    sortedInstances.sort((a, b) => sortMultiplier * (a.sentText || '').localeCompare(b.sentText || ''));
  }
  // 'position' keeps original order
  
  // Check if instances have feature property (from showAllDepConcordance)
  const showFeatureColumn = filteredInstances.length > 0 && filteredInstances[0].feature;
  
  // Check if columns should be swapped
  const swapColumns = document.getElementById('depConcSwapColumns')?.checked || false;
  
  // Add feature sort option
  if (depConcSortCol === 'feature' && showFeatureColumn) {
    sortedInstances.sort((a, b) => sortMultiplier * (a.feature || '').localeCompare(b.feature || ''));
  }
  
  // Limit
  sortedInstances = sortedInstances.slice(0, maxRows);
  
  // Build colgroup and header (with Governor, Dependent columns) - clickable for sorting
  const colgroupHtml = showFeatureColumn ? `<colgroup>
    <col style="width:150px;">
    <col style="width:100px;">
    <col style="width:100px;">
    <col style="width:150px;">
    <col style="width:40px;">
    <col style="width:auto;">
  </colgroup>` : `<colgroup>
    <col style="width:100px;">
    <col style="width:100px;">
    <col style="width:180px;">
    <col style="width:40px;">
    <col style="width:auto;">
  </colgroup>`;
  
  const getSortIndicator = (col) => {
    if (depConcSortCol === col) {
      return depConcSortDir === 'asc' ? ' ↑' : ' ↓';
    }
    return '';
  };
  
  // Column labels based on swap setting
  const col1Label = swapColumns ? 'Dependent' : 'Governor';
  const col2Label = swapColumns ? 'Governor' : 'Dependent';
  const col1Sort = swapColumns ? 'dependent' : 'governor';
  const col2Sort = swapColumns ? 'governor' : 'dependent';
  
  const headerHtml = showFeatureColumn ? `<tr>
    <th class="sortable" style="position:relative; cursor:pointer;" onclick="sortDepConcordance('feature')">Feature${getSortIndicator('feature')}<div class="dep-conc-resizer" data-col="0"></div></th>
    <th class="sortable" style="position:relative; cursor:pointer;" onclick="sortDepConcordance('${col1Sort}')">${col1Label}${getSortIndicator(col1Sort)}<div class="dep-conc-resizer" data-col="1"></div></th>
    <th class="sortable" style="position:relative; cursor:pointer;" onclick="sortDepConcordance('${col2Sort}')">${col2Label}${getSortIndicator(col2Sort)}<div class="dep-conc-resizer" data-col="2"></div></th>
    <th class="sortable" style="position:relative; cursor:pointer;" onclick="sortDepConcordance('file')">File${getSortIndicator('file')}<div class="dep-conc-resizer" data-col="3"></div></th>
    <th class="sortable" style="position:relative; cursor:pointer;" onclick="sortDepConcordance('side')">Side${getSortIndicator('side')}<div class="dep-conc-resizer" data-col="4"></div></th>
    <th class="sortable" style="position:relative; cursor:pointer;" onclick="sortDepConcordance('concordance')">Concordance${getSortIndicator('concordance')}<div class="dep-conc-resizer" data-col="5"></div></th>
  </tr>` : `<tr>
    <th class="sortable" style="position:relative; cursor:pointer;" onclick="sortDepConcordance('${col1Sort}')">${col1Label}${getSortIndicator(col1Sort)}<div class="dep-conc-resizer" data-col="0"></div></th>
    <th class="sortable" style="position:relative; cursor:pointer;" onclick="sortDepConcordance('${col2Sort}')">${col2Label}${getSortIndicator(col2Sort)}<div class="dep-conc-resizer" data-col="1"></div></th>
    <th class="sortable" style="position:relative; cursor:pointer;" onclick="sortDepConcordance('file')">File${getSortIndicator('file')}<div class="dep-conc-resizer" data-col="2"></div></th>
    <th class="sortable" style="position:relative; cursor:pointer;" onclick="sortDepConcordance('side')">Side${getSortIndicator('side')}<div class="dep-conc-resizer" data-col="3"></div></th>
    <th class="sortable" style="position:relative; cursor:pointer;" onclick="sortDepConcordance('concordance')">Concordance${getSortIndicator('concordance')}<div class="dep-conc-resizer" data-col="4"></div></th>
  </tr>`;
  
  // Update colgroup
  const existingColgroup = table.querySelector('colgroup');
  if (existingColgroup) {
    existingColgroup.outerHTML = colgroupHtml;
  } else {
    table.insertAdjacentHTML('afterbegin', colgroupHtml);
  }
  
  // Update thead
  thead.innerHTML = headerHtml;
  
  // Build rows
  let html = '';
  sortedInstances.forEach(inst => {
    // Get governor and dependent (from DEP calc or extract from pattern match)
    let governor = inst.governor || '';
    let dependent = inst.dependent || '';
    let sentText = inst.sentText || '';
    
    // If no governor/dependent, try to extract from match (12a pattern search)
    if ((!governor || !dependent) && inst.match) {
      const match = inst.match;
      if (match.node) {
        // Node is the governor (head)
        governor = match.node.word || '';
      }
      if (match.dependents && match.dependents.length > 0) {
        // First dependent (dependents[i] could be {token: ...} or just the token)
        const dep = match.dependents[0];
        dependent = dep.token ? (dep.token.word || '') : (dep.word || '');
      }
      
      // If no sentText, reconstruct from sentTokens
      if (!sentText && match.sentTokens && match.sentTokens.length > 0) {
        sentText = match.sentTokens.map(t => t.word || '').join(' ');
      }
    }
    
    // Highlight governor and dependent in sentence
    let concordance = escapeHtml(sentText);
    
    // Define colors for highlighting (Governor: blue, Dependents: various colors)
    const depColors = ['#ea580c', '#16a34a', '#9333ea', '#db2777', '#0891b2']; // orange, green, purple, pink, cyan
    const relPronounColor = '#6b7280'; // gray for relative pronouns
    
    // Get all dependents from instance
    const allDeps = inst.allDependents || [];
    const relPronouns = inst.relativePronouns || [];
    
    // Create list of words to highlight with their colors
    const highlightWords = [];
    if (governor) highlightWords.push({ word: governor, color: '#2563eb', label: 'gov' });
    allDeps.forEach((dep, i) => {
      if (dep.word && !highlightWords.some(h => h.word.toLowerCase() === dep.word.toLowerCase())) {
        highlightWords.push({ word: dep.word, color: depColors[i % depColors.length], label: `dep${i+1}` });
      }
    });
    // Add relative pronouns (with underline)
    relPronouns.forEach(rp => {
      if (rp && !highlightWords.some(h => h.word.toLowerCase() === rp.toLowerCase())) {
        highlightWords.push({ word: rp, color: relPronounColor, label: 'relPron', underline: true });
      }
    });
    
    // Apply highlights (longer words first to avoid partial matches)
    highlightWords.sort((a, b) => b.word.length - a.word.length);
    highlightWords.forEach(h => {
      const regex = new RegExp(`\\b(${escapeRegexChars(h.word)})\\b`, 'gi');
      const style = h.underline 
        ? `color:${h.color}; font-weight:600; text-decoration:underline;`
        : `color:${h.color}; font-weight:600;`;
      concordance = concordance.replace(regex, `<span style="${style}">$1</span>`);
    });
    
    // Build dependent column (show first dependent or list all for multi-chain)
    let depDisplay = '';
    if (allDeps.length > 1) {
      depDisplay = allDeps.map((d, i) => `<span style="color:${depColors[i % depColors.length]};">${escapeHtml(d.word)}</span>`).join(' ');
    } else {
      depDisplay = `<span style="color:#ea580c;">${escapeHtml(dependent)}</span>`;
    }
    
    // Build governor column
    const govDisplay = `<span style="color:#2563eb; font-weight:600;">${escapeHtml(governor)}</span>`;
    
    html += `<tr>`;
    if (showFeatureColumn) {
      html += `<td class="text-xs" style="max-width:150px; overflow:hidden; text-overflow:ellipsis; white-space:nowrap;" title="${escapeHtml(inst.feature || '')}">${escapeHtml(inst.feature || '')}</td>`;
    }
    // Swap columns if checkbox is checked
    if (swapColumns) {
      html += `<td class="text-xs" style="font-weight:600;">${depDisplay}</td>`;
      html += `<td class="text-xs">${govDisplay}</td>`;
    } else {
      html += `<td class="text-xs">${govDisplay}</td>`;
      html += `<td class="text-xs" style="font-weight:600;">${depDisplay}</td>`;
    }
    html += `<td class="text-xs">${escapeHtml(inst.fileName)}</td>`;
    html += `<td class="text-xs">${inst.side}</td>`;
    html += `<td class="text-xs">${concordance}</td>`;
    html += `</tr>`;
  });
  
  const colSpan = showFeatureColumn ? 6 : 5;
  tbody.innerHTML = html || `<tr><td colspan="${colSpan}" class="text-xs">No concordance data.</td></tr>`;
  
  // Re-initialize column resizers
  setTimeout(() => initDepConcTableResize(), 10);
}

// Sort 12b) Concordance by clicking column header
function sortDepConcordance(col) {
  if (depConcSortCol === col) {
    // Toggle direction
    depConcSortDir = depConcSortDir === 'asc' ? 'desc' : 'asc';
  } else {
    // New column, default to ascending
    depConcSortCol = col;
    depConcSortDir = 'asc';
  }
  
  // Sync dropdown
  const dropdown = document.getElementById('depConcSort');
  if (dropdown) {
    dropdown.value = col;
  }
  
  updateDepConcordanceDisplay();
}

// Escape regex special characters
function escapeRegexChars(str) {
  return str.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
}

// Build concordance display
function buildDepConcordance(inst, depth, view) {
  const match = inst.match;
  const sentTokens = match.sentTokens || [];
  const sentText = inst.sentText || '';
  
  // Get positions of matched tokens
  const nodePos = match.node.token_id ?? match.nodeIdx;
  const depPositions = match.dependents.map(d => d.token.token_id ?? d.token.arrayIndex);
  const allMatchPos = new Set([nodePos, ...depPositions]);
  
  // Find min and max positions
  const positions = [nodePos, ...depPositions];
  const minPos = Math.min(...positions);
  const maxPos = Math.max(...positions);
  
  // Build context
  const contextSize = 10;
  
  if (view === 'compact') {
    // Build single concordance string with highlighting
    let result = '';
    
    if (sentTokens.length > 0) {
      // Use sentence tokens
      sentTokens.forEach((tok, idx) => {
        const tokPos = tok.token_id ?? idx;
        const tokText = tok.word || '';
        
        if (tokPos === nodePos) {
          result += `<span style="color:#2563eb; font-weight:600;">${escapeHtml(tokText)}</span> `;
        } else if (depPositions.includes(tokPos)) {
          const depIdx = depPositions.indexOf(tokPos);
          const colors = ['#ea580c', '#ca8a04', '#16a34a'];
          const color = colors[depIdx % colors.length];
          result += `<span style="color:${color}; font-weight:600;">${escapeHtml(tokText)}</span> `;
        } else {
          result += escapeHtml(tokText) + ' ';
        }
      });
    } else if (sentText) {
      // Use sentence text with simple highlighting
      result = escapeHtml(sentText);
      // Highlight feature
      const feature = currentDepFeature;
      if (feature) {
        const regex = new RegExp(`(${escapeRegex(feature)})`, 'gi');
        result = result.replace(regex, '<span style="color:#2563eb; font-weight:600;">$1</span>');
      }
    }
    
    return result.trim();
  } else {
    // Detailed view: left, match, right
    let left = '', matchText = '', right = '';
    
    if (sentTokens.length > 0) {
      sentTokens.forEach((tok, idx) => {
        const tokPos = tok.token_id ?? idx;
        const tokText = tok.word || '';
        
        if (tokPos < minPos) {
          left += tokText + ' ';
        } else if (tokPos > maxPos) {
          right += tokText + ' ';
        } else {
          if (tokPos === nodePos) {
            matchText += `<span style="color:#2563eb; font-weight:600;">${escapeHtml(tokText)}</span> `;
          } else if (depPositions.includes(tokPos)) {
            const depIdx = depPositions.indexOf(tokPos);
            const colors = ['#ea580c', '#ca8a04', '#16a34a'];
            const color = colors[depIdx % colors.length];
            matchText += `<span style="color:${color}; font-weight:600;">${escapeHtml(tokText)}</span> `;
          } else {
            matchText += escapeHtml(tokText) + ' ';
          }
        }
      });
      
      // Trim context (only add ... if there's actual content)
      const leftWords = left.trim().split(/\s+/).filter(w => w);
      const rightWords = right.trim().split(/\s+/).filter(w => w);
      left = leftWords.length > 0 ? (leftWords.length > contextSize ? '...' : '') + leftWords.slice(-contextSize).join(' ') : '';
      right = rightWords.length > 0 ? rightWords.slice(0, contextSize).join(' ') + (rightWords.length > contextSize ? '...' : '') : '';
    } else if (sentText) {
      // Fallback: use sentence text when sentTokens is empty
      const feature = currentDepFeature || '';
      const featureWords = feature.split(/\s+/);
      
      // Try to find feature in sentence text
      const featureIndex = sentText.toLowerCase().indexOf(feature.toLowerCase());
      if (featureIndex >= 0) {
        left = sentText.substring(0, featureIndex).trim();
        const afterFeature = featureIndex + feature.length;
        right = sentText.substring(afterFeature).trim();
        
        // Highlight the match
        matchText = `<span style="color:#2563eb; font-weight:600;">${escapeHtml(feature)}</span>`;
        
        // Trim context
        const leftWords = left.split(/\s+/).filter(w => w);
        const rightWords = right.split(/\s+/).filter(w => w);
        left = leftWords.length > contextSize ? '...' + leftWords.slice(-contextSize).join(' ') : left;
        right = rightWords.length > contextSize ? rightWords.slice(0, contextSize).join(' ') + '...' : right;
      } else {
        // Feature not found, show whole sentence
        matchText = escapeHtml(sentText);
      }
    }
    
    return { left: left, match: matchText.trim(), right: right };
  }
}

// Escape regex special chars
function escapeRegex(str) {
  return str.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
}

// Back to pattern search
function backToDepPatternSearch() {
  // Collapse concordance, expand pattern search
  const content12a = document.getElementById('section12a-content');
  const arrow12a = document.getElementById('section12a-arrow');
  if (content12a && content12a.style.display === 'none') {
    content12a.style.display = 'block';
    if (arrow12a) arrow12a.textContent = '▼';
  }
}

// Clear 12b) Concordance
function clearDepConcordance() {
  currentDepFeature = null;
  currentDepInstances = [];
  
  document.getElementById('depConcordanceFeature').textContent = '-';
  document.getElementById('depConcordanceCount').textContent = '0';
  
  const tbody = document.getElementById('depConcordanceTbody');
  if (tbody) {
    tbody.innerHTML = '<tr><td colspan="5" class="text-xs">No concordance data. Click a row in 12a) to view.</td></tr>';
  }
}

// Export functions
function exportDepPatternExcel() {
  if (lastDepPatternRows.length === 0) {
    alert('No data to export.');
    return;
  }
  
  const advanced = document.getElementById('depAdvancedStats')?.checked || false;
  const scope = lastDepScope || 'target';
  
  // Build header
  let header = ['#', 'Feature', 'freq_T', 'norm_T (pm)'];
  if (advanced) header.push('Range_T', 'Juilland_T', 'DP_T');
  header.push('freq_R', 'norm_R (pm)');
  if (advanced) header.push('Range_R', 'Juilland_R', 'DP_R');
  
  // Add keyness columns only for Target or Reference scope
  if (scope === 'target' || scope === 'reference') {
    const suffix = scope === 'target' ? '(T)' : '(R)';
    header.push(`Freq-LL ${suffix}`, `Text-LL ${suffix}`, `MTK ${suffix}`);
  }
  
  // Build rows
  const rows = [header];
  lastDepPatternRows.forEach((row, idx) => {
    const r = [idx + 1, row.feature, row.freqT, row.normT.toFixed(2)];
    if (advanced) {
      r.push(row.rangeT || 0, (row.juillandT || 0).toFixed(3), (row.dpT || 0).toFixed(3));
    }
    r.push(row.freqR, row.normR.toFixed(2));
    if (advanced) {
      r.push(row.rangeR || 0, (row.juillandR || 0).toFixed(3), (row.dpR || 0).toFixed(3));
    }
    
    // Add keyness values only for Target or Reference scope
    if (scope === 'target' || scope === 'reference') {
      r.push(row.ll?.toFixed(3) || '', row.textLL?.toFixed(3) || '', row.cohensD?.toFixed(3) || '');
    }
    rows.push(r);
  });
  
  downloadExcel(rows, 'dependency_patterns.xls');
}

function exportDepConcordanceExcel() {
  if (!currentDepInstances || currentDepInstances.length === 0) {
    alert('No concordance data to export.');
    return;
  }
  
  // Check if columns should be swapped
  const swapColumns = document.getElementById('depConcSwapColumns')?.checked || false;
  
  // Header based on swap setting
  const header = swapColumns 
    ? ['Dependent', 'Governor', 'File', 'Side', 'Sentence', 'Feature']
    : ['Governor', 'Dependent', 'File', 'Side', 'Sentence', 'Feature'];
  
  const rows = [header];
  currentDepInstances.forEach(inst => {
    // Get governor and dependent (from DEP calc or extract from pattern match)
    let governor = inst.governor || '';
    let dependent = inst.dependent || '';
    let sentText = inst.sentText || '';
    
    // If no governor/dependent, try to extract from match (12a pattern search)
    if ((!governor || !dependent) && inst.match) {
      const match = inst.match;
      if (match.node) {
        governor = match.node.word || '';
      }
      if (match.dependents && match.dependents.length > 0) {
        const dep = match.dependents[0];
        dependent = dep.token ? (dep.token.word || '') : (dep.word || '');
      }
      if (!sentText && match.sentTokens && match.sentTokens.length > 0) {
        sentText = match.sentTokens.map(t => t.word || '').join(' ');
      }
    }
    
    // Row based on swap setting
    if (swapColumns) {
      rows.push([dependent, governor, inst.fileName, inst.side, sentText, currentDepFeature]);
    } else {
      rows.push([governor, dependent, inst.fileName, inst.side, sentText, currentDepFeature]);
    }
  });
  
  downloadExcel(rows, 'dependency_concordance.xls');
}

// Helper: download as Excel
function downloadExcel(rows, filename) {
  let html = '<html><head><meta charset="UTF-8"></head><body><table border="1">';
  rows.forEach(row => {
    html += '<tr>';
    row.forEach(cell => {
      html += `<td>${escapeHtml(String(cell ?? ''))}</td>`;
    });
    html += '</tr>';
  });
  html += '</table></body></html>';
  
  const blob = new Blob([html], { type: 'application/vnd.ms-excel' });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = filename;
  document.body.appendChild(a);
  a.click();
  document.body.removeChild(a);
  URL.revokeObjectURL(url);
}

// Link from 7) 8) 9a) to 12)
function linkToDepGrammar(feature, featureType, scope) {
  // Set query
  const queryInput = document.getElementById('depQueryInput');
  if (queryInput) queryInput.value = feature;
  
  // Set type
  const typeSelect = document.getElementById('depQueryType');
  if (typeSelect) {
    typeSelect.value = featureType.includes('lemma') ? 'lemma' : 'word';
  }
  
  // Set scope
  const scopeRadio = document.querySelector(`input[name="depScope"][value="${scope}"]`);
  if (scopeRadio) scopeRadio.checked = true;
  
  // Clear preset
  const presetCheck = document.getElementById('depApplyPreset');
  if (presetCheck) presetCheck.checked = false;
  toggleDepPresetMode();
  
  // Clear relations (search all)
  for (let i = 1; i <= 5; i++) {
    const rel = document.getElementById(`depRel${i}`);
    if (rel) rel.value = '';
  }
  
  // Expand section
  const content = document.getElementById('section12a-content');
  const arrow = document.getElementById('section12a-arrow');
  if (content && content.style.display === 'none') {
    content.style.display = 'block';
    if (arrow) arrow.textContent = '▼';
  }
  
  // Scroll to section
  document.getElementById('depPatternSearchCard')?.scrollIntoView({ behavior: 'smooth' });
  
  // Auto compute
  computeDepPattern();
}

// ===== 12a) Column Resize =====
function initDepTableResize() {
  const table = document.getElementById('depPatternTable');
  if (!table) return;
  
  const cols = table.querySelectorAll('colgroup col');
  const resizers = table.querySelectorAll('.dep-col-resizer');

  resizers.forEach((resizer) => {
    const colIndex = parseInt(resizer.dataset.col, 10);
    const col = cols[colIndex];
    if (!col) return;

    let startX = 0;
    let startWidth = 0;

    const onMouseMove = (e) => {
      const dx = e.pageX - startX;
      const newWidth = Math.max(40, startWidth + dx);
      col.style.width = newWidth + 'px';
    };

    const onMouseUp = () => {
      document.removeEventListener('mousemove', onMouseMove);
      document.removeEventListener('mouseup', onMouseUp);
    };

    resizer.addEventListener('mousedown', (e) => {
      e.preventDefault();
      e.stopPropagation();
      startX = e.pageX;
      const colStyle = window.getComputedStyle(col);
      const width = parseFloat(colStyle.width);
      startWidth = isNaN(width) ? resizer.parentElement.offsetWidth : width;
      document.addEventListener('mousemove', onMouseMove);
      document.addEventListener('mouseup', onMouseUp);
    });
  });
}

// ===== 12b) Concordance Column Resize =====
function initDepConcTableResize() {
  const table = document.getElementById('depConcordanceTable');
  if (!table) return;
  
  const cols = table.querySelectorAll('colgroup col');
  const resizers = table.querySelectorAll('.dep-conc-resizer');

  resizers.forEach((resizer) => {
    const colIndex = parseInt(resizer.dataset.col, 10);
    const col = cols[colIndex];
    if (!col) return;

    let startX = 0;
    let startWidth = 0;

    const onMouseMove = (e) => {
      const dx = e.pageX - startX;
      const newWidth = Math.max(40, startWidth + dx);
      col.style.width = newWidth + 'px';
    };

    const onMouseUp = () => {
      document.removeEventListener('mousemove', onMouseMove);
      document.removeEventListener('mouseup', onMouseUp);
    };

    resizer.addEventListener('mousedown', (e) => {
      e.preventDefault();
      e.stopPropagation();
      startX = e.pageX;
      const colStyle = window.getComputedStyle(col);
      const width = parseFloat(colStyle.width);
      startWidth = isNaN(width) ? resizer.parentElement.offsetWidth : width;
      document.addEventListener('mousemove', onMouseMove);
      document.addEventListener('mouseup', onMouseUp);
    });
  });
}

// ===== 12) Constituent (Phrase Structure) Functions =====

// Constituent Pattern Presets
// ============================================
// 12) CONSTITUENT PATTERN SEARCH - REDESIGNED
// ============================================

// Unified Presets with search criteria
const CONST_ALL_PRESETS = {
  // Phrase Types
  PH_NP: { id: 'PH_NP', cat: 'phrase', name: 'NP (Noun Phrase)', desc: 'All noun phrases', chunk: 'NP', path: '', pos: '', seq: '' },
  PH_VP: { id: 'PH_VP', cat: 'phrase', name: 'VP (Verb Phrase)', desc: 'All verb phrases', chunk: 'VP', path: '', pos: '', seq: '' },
  PH_PP: { id: 'PH_PP', cat: 'phrase', name: 'PP (Prepositional)', desc: 'All prepositional phrases', chunk: 'PP', path: '', pos: '', seq: '' },
  PH_ADJP: { id: 'PH_ADJP', cat: 'phrase', name: 'ADJP (Adjective)', desc: 'Adjective phrases', chunk: 'ADJP', path: '', pos: '', seq: '' },
  PH_ADVP: { id: 'PH_ADVP', cat: 'phrase', name: 'ADVP (Adverb)', desc: 'Adverb phrases', chunk: 'ADVP', path: '', pos: '', seq: '' },
  
  // Clause Types (search via cpath)
  CL_S: { id: 'CL_S', cat: 'clause', name: 'S (Main clause)', desc: 'Tokens in main/declarative clause (S node)', chunk: '', path: '>S>', pos: '', seq: '' },
  CL_SBAR: { id: 'CL_SBAR', cat: 'clause', name: 'SBAR (Subordinate)', desc: 'Tokens in subordinate clause (that/which/because...)', chunk: '', path: '>SBAR>', pos: '', seq: '' },
  CL_SINV: { id: 'CL_SINV', cat: 'clause', name: 'SINV (Inverted)', desc: 'Tokens in inverted declarative (subject-aux inversion)', chunk: '', path: '>SINV>', pos: '', seq: '' },
  CL_SQ: { id: 'CL_SQ', cat: 'clause', name: 'SQ (Yes/No Q)', desc: 'Tokens in yes/no question clause', chunk: '', path: '>SQ>', pos: '', seq: '' },
  CL_SBARQ: { id: 'CL_SBARQ', cat: 'clause', name: 'SBARQ (Wh-Q)', desc: 'Tokens in wh-question clause', chunk: '', path: '>SBARQ>', pos: '', seq: '' },
  CL_VP_IN_SBAR: { id: 'CL_VP_IN_SBAR', cat: 'clause', name: 'VP in SBAR', desc: 'Verb phrases in subordinate clauses', chunk: 'VP', path: '>SBAR>', pos: '', seq: '' },
  CL_NP_IN_SBAR: { id: 'CL_NP_IN_SBAR', cat: 'clause', name: 'NP in SBAR', desc: 'Noun phrases in subordinate clauses', chunk: 'NP', path: '>SBAR>', pos: '', seq: '' },
  
  // Noun Patterns
  N01: { id: 'N01', cat: 'noun', name: 'ADJ + NOUN', desc: 'JJ + NN: "important role"', chunk: 'NP', path: '', pos: '', seq: 'JJ+NN' },
  N02: { id: 'N02', cat: 'noun', name: 'NOUN + NOUN', desc: 'NN + NN: "stem cells"', chunk: 'NP', path: '', pos: '', seq: 'NN+NN' },
  N03: { id: 'N03', cat: 'noun', name: 'NOUN + of + NOUN', desc: 'NN of NN: "analysis of data"', chunk: 'NP', path: '', pos: '', seq: 'NN+of+NN' },
  N04: { id: 'N04', cat: 'noun', name: 'DET + NOUN', desc: 'DT + NN: "the study"', chunk: 'NP', path: '', pos: '', seq: 'DT+NN' },
  N05: { id: 'N05', cat: 'noun', name: 'ADV + ADJ + NOUN', desc: 'RB + JJ + NN: "very high level"', chunk: 'NP', path: '', pos: '', seq: 'RB+JJ+NN' },
  N06: { id: 'N06', cat: 'noun', name: 'NP in SBAR', desc: 'NP in relative clause', chunk: 'NP', path: '>SBAR>', pos: '', seq: '' },
  N07: { id: 'N07', cat: 'noun', name: '-ing + NOUN', desc: 'VBG + NN / NN + VBG (position selectable)', chunk: 'NP', path: '', pos: '', seq: '', showIngEdOptions: true, ingEdType: 'ing' },
  N08: { id: 'N08', cat: 'noun', name: '-ed + NOUN', desc: 'VBN + NN / NN + VBN (position selectable)', chunk: 'NP', path: '', pos: '', seq: '', showIngEdOptions: true, ingEdType: 'ed' },
  N09: { id: 'N09', cat: 'noun', name: 'Multiple ADJ + NOUN', desc: 'JJ + JJ + NN', chunk: 'NP', path: '', pos: '', seq: 'JJ+JJ+NN' },
  N10: { id: 'N10', cat: 'noun', name: 'NP in PP', desc: 'NP inside PP', chunk: 'NP', path: '>PP>', pos: '', seq: '' },
  N11: { id: 'N11', cat: 'noun', name: 'Proper Nouns', desc: 'NNP/NNPS only', chunk: 'NP', path: '', pos: 'NNP,NNPS', seq: '' },
  
  // Verb Patterns
  V01: { id: 'V01', cat: 'verb', name: 'Past Tense', desc: 'VBD verbs', chunk: 'VP', path: '', pos: 'VBD', seq: '' },
  V02: { id: 'V02', cat: 'verb', name: 'Past Participle', desc: 'VBN verbs', chunk: 'VP', path: '', pos: 'VBN', seq: '' },
  V03: { id: 'V03', cat: 'verb', name: 'Present Participle', desc: 'VBG verbs', chunk: 'VP', path: '', pos: 'VBG', seq: '' },
  V04: { id: 'V04', cat: 'verb', name: 'Modal + Verb', desc: 'MD + VB: "can be"', chunk: 'VP', path: '', pos: '', seq: 'MD+VB' },
  V05: { id: 'V05', cat: 'verb', name: 'Passive (be+VBN)', desc: 'be + VBN: "was examined"', chunk: '', path: '', pos: '', seq: 'be+VBN' },
  V06: { id: 'V06', cat: 'verb', name: 'To-infinitive', desc: 'TO + VB: "to examine"', chunk: 'VP', path: '', pos: '', seq: 'TO+VB' },
  V07: { id: 'V07', cat: 'verb', name: 'Negation', desc: 'not + VB: "not show"', chunk: 'VP', path: '', pos: '', seq: 'not+VB' },
  V08: { id: 'V08', cat: 'verb', name: 'VP in SBAR', desc: 'Verbs in subordinate clause', chunk: 'VP', path: '>SBAR>', pos: '', seq: '' },
  V09: { id: 'V09', cat: 'verb', name: 'Have + VBN (Perfect)', desc: 'have/has/had + VBN: "have shown"', chunk: '', path: '', pos: '', seq: 'have+VBN' },
  V10: { id: 'V10', cat: 'verb', name: 'Be + VBG (Progressive)', desc: 'be + VBG: "is showing"', chunk: '', path: '', pos: '', seq: 'be+VBG' },
  
  // Sentence Patterns (sequence-based detection)
  S01: { id: 'S01', cat: 'sentence', name: 'PASSIVE (be + Vpp)', desc: 'be + VBN: "was examined", "is shown"', chunk: '', path: '', pos: '', seq: 'be+VBN' },
  S02: { id: 'S02', cat: 'sentence', name: 'THERE + BE + NP', desc: 'there + be: "there is/are/was evidence"', chunk: '', path: '', pos: '', seq: 'there+be' },
  S03: { id: 'S03', cat: 'sentence', name: 'IT + BE + ADJ', desc: 'it + be + ADJ: "it is important/clear/possible"', chunk: '', path: '', pos: '', seq: 'it+be+JJ' },
  S04: { id: 'S04', cat: 'sentence', name: 'IT + BE + ADJ + to', desc: 'it + be + ADJ + to: "it is important to"', chunk: '', path: '', pos: '', seq: 'it+be+JJ+to' },
  S05: { id: 'S05', cat: 'sentence', name: 'NP + BE + ADJ', desc: 'Copula: NN + be + JJ: "results are significant"', chunk: '', path: '', pos: '', seq: 'NN+be+JJ' },
  S06: { id: 'S06', cat: 'sentence', name: 'NP + BE + NP', desc: 'Copula: NN + be + NN: "X is a method"', chunk: '', path: '', pos: '', seq: 'NN+be+DT' },
  S07: { id: 'S07', cat: 'sentence', name: 'That-clause intro', desc: 'that + VB: verbs in that-clause', chunk: '', path: '', pos: '', seq: 'that+VB' },
  S08: { id: 'S08', cat: 'sentence', name: 'Perfect aspect', desc: 'have + VBN: "have shown", "has been"', chunk: '', path: '', pos: '', seq: 'have+VBN' },
  S09: { id: 'S09', cat: 'sentence', name: 'Progressive aspect', desc: 'be + VBG: "is showing", "are increasing"', chunk: '', path: '', pos: '', seq: 'be+VBG' }
};

// State variables
let constPatternRows = [];
let lastConstPatternRows = [];
let currentConstInstances = [];
let constSortCol = 'feature';
let constSortDir = 'asc';
let constConcSortCol = 'position';
let constConcSortDir = 'asc';
let constComputationCancelled = false;

// Sentence Pattern detection state
let constSentPatternCounts = {};

// Helper: Set all Sentence Pattern checkboxes
function setAllConstSentPatterns(checked) {
  document.querySelectorAll('.constSentPatternCb').forEach(cb => cb.checked = checked);
  applyConstSentPatternFilter();
}

// Apply Sentence Pattern filter to display results
function applyConstSentPatternFilter() {
  if (!constPatternRows || constPatternRows.length === 0) return;
  
  const selectedPatterns = getSelectedConstSentPatterns();
  const svcType = document.querySelector('input[name="constSVCType"]:checked')?.value || 'both';
  const svocType = document.querySelector('input[name="constSVOCType"]:checked')?.value || 'both';
  
  // If no patterns selected, show nothing (or show all?)
  // For user convenience, show nothing when nothing is selected
  if (selectedPatterns.size === 0) {
    lastConstPatternRows = [];
    displayConstPatternResults();
    return;
  }
  
  // Filter rows based on instances' sentence patterns
  const filteredRows = [];
  
  for (const row of constPatternRows) {
    // Check if any instance matches the selected patterns
    let hasMatchingInstance = false;
    let matchingInstanceCount = 0;
    
    for (const inst of row.instances || []) {
      const pattern = inst.sentPattern || 'Other';
      
      // Handle SVC/SVOC type filtering
      if (pattern === 'SVC_adj' && svcType === 'noun') continue;
      if (pattern === 'SVC_noun' && svcType === 'adj') continue;
      if (pattern === 'SVOC_adj' && svocType === 'noun') continue;
      if (pattern === 'SVOC_noun' && svocType === 'adj') continue;
      
      if (selectedPatterns.has(pattern)) {
        hasMatchingInstance = true;
        matchingInstanceCount++;
      }
    }
    
    if (hasMatchingInstance) {
      // Clone row and update freq based on matching instances
      const filteredRow = { ...row };
      // For now, keep original freq - could adjust based on matchingInstanceCount
      filteredRows.push(filteredRow);
    }
  }
  
  lastConstPatternRows = filteredRows;
  displayConstPatternResults();
  
  // Update status
  const status = document.getElementById('constPatternStatus');
  if (status) {
    status.textContent = `Showing ${filteredRows.length} types (filtered by ${selectedPatterns.size} patterns).`;
  }
}

// Helper: Detect Sentence Pattern from dependency information
// Uses: dep, head_id, pos, and optionally cpath for clause level
// Get selected sentence patterns from checkboxes
function getSelectedConstSentPatterns() {
  const patterns = new Set();
  document.querySelectorAll('.constSentPatternCb:checked').forEach(cb => {
    patterns.add(cb.value);
  });
  return patterns;
}

// Get selected sub types from checkboxes
function getSelectedConstSubTypes() {
  const types = new Set();
  document.querySelectorAll('.constSubTypeCb:checked').forEach(cb => {
    types.add(cb.value);
  });
  return types;
}

// Build sentence pattern cache for a file's tokens
// Returns: Map<sentId, Array<{pattern, clauseType, subType, clauseDepth, subject, verb, objectComp, verbIdx}>>
function buildSentencePatternCache(tokens, options = {}) {
  const { analysisLevel = 'all', useConstituent = true } = options;
  const cache = new Map();
  
  // Group tokens by sentence
  const sentTokens = new Map();
  tokens.forEach((tok, idx) => {
    const sentId = tok.sent_id || 'unknown';
    if (!sentTokens.has(sentId)) {
      sentTokens.set(sentId, []);
    }
    sentTokens.get(sentId).push({ tok, idx });
  });
  
  // For each sentence, find verbs and detect patterns
  for (const [sentId, tokList] of sentTokens) {
    const patterns = [];
    
    // Find all verbs in the sentence
    for (const { tok, idx } of tokList) {
      const pos = (tok.pos || '').toUpperCase();
      const xpos = (tok.xpos || tok.posd || '').toUpperCase();
      const dep = (tok.dep || '').toLowerCase();
      
      // Check if this is a main verb (not auxiliary)
      const isVerb = pos === 'VERB' || xpos.startsWith('VB');
      const isAux = dep === 'aux' || dep === 'aux:pass' || dep === 'cop';
      
      if (isVerb && !isAux) {
        // Detect sentence pattern for this verb
        const patternInfo = detectSentencePatternForVerb(tokens, idx, { analysisLevel, useConstituent });
        if (patternInfo) {
          patterns.push(patternInfo);
        }
      }
    }
    
    // If no patterns found, add 'Other' as default
    if (patterns.length === 0) {
      patterns.push({
        pattern: 'Other',
        clauseType: 'Main',
        subType: '-',
        clauseDepth: 0,
        subject: '',
        verb: '',
        objectComp: '',
        verbIdx: -1
      });
    }
    
    cache.set(sentId, patterns);
  }
  
  return cache;
}

// Detect sentence pattern for a specific verb
function detectSentencePatternForVerb(tokens, verbIdx, options = {}) {
  const { useConstituent = true, analysisLevel = 'all' } = options;
  
  const verb = tokens[verbIdx];
  if (!verb) return null;
  
  const verbPos = (verb.pos || '').toUpperCase();
  const verbXpos = (verb.xpos || verb.posd || '').toUpperCase();
  
  // Must be a verb
  if (verbPos !== 'VERB' && !verbXpos.startsWith('VB')) return null;
  
  // Find dependents of this verb
  const deps = {};
  for (let i = 0; i < tokens.length; i++) {
    const tok = tokens[i];
    const headId = parseInt(tok.head_id);
    // Check both 1-indexed and 0-indexed
    if (headId === verbIdx + 1 || headId === verbIdx) {
      const rel = (tok.dep || '').toLowerCase();
      if (!deps[rel]) deps[rel] = [];
      deps[rel].push({ idx: i, tok });
    }
  }
  
  // Check verb's own dep relation to determine clause type
  const verbDep = (verb.dep || '').toLowerCase();
  const cpath = verb.cpath_norm || verb.cpath || '';
  
  let clauseType = 'Main';
  let subType = '-';
  let clauseDepth = 0;
  
  // Determine clause type from cpath
  if (useConstituent && cpath) {
    clauseDepth = (cpath.match(/>/g) || []).length;
    if (cpath.includes('>SBAR>')) {
      clauseType = 'Sub';
    }
  }
  
  // Check dep relation for subordinate clause type
  if (verbDep === 'ccomp') {
    clauseType = 'Sub';
    subType = 'that';
  } else if (verbDep === 'xcomp') {
    clauseType = 'Sub';
    const verbWord = (verb.word || '').toLowerCase();
    if (verbXpos === 'VBG' || verbWord.endsWith('ing')) {
      subType = '-ing';
    } else {
      subType = 'to-inf';
    }
  } else if (verbDep === 'advcl') {
    clauseType = 'Sub';
    subType = 'adv';
  } else if (verbDep === 'acl' || verbDep === 'acl:relcl') {
    clauseType = 'Sub';
    subType = 'wh';
  } else if (verbDep === 'csubj') {
    clauseType = 'Sub';
    subType = 'that';
  }
  
  // Check for markers (if, that, when, etc.)
  if (deps['mark']) {
    for (const d of deps['mark']) {
      const markWord = (d.tok.word || '').toLowerCase();
      if (markWord === 'if' || markWord === 'whether') {
        clauseType = 'Sub';
        subType = 'if';
      } else if (markWord === 'that') {
        clauseType = 'Sub';
        subType = 'that';
      } else if (['when', 'while', 'because', 'although', 'unless', 'before', 'after', 'since', 'as'].includes(markWord)) {
        clauseType = 'Sub';
        subType = 'adv';
      }
    }
  }
  
  // Skip subordinate clauses if analysisLevel is 'main'
  if (analysisLevel === 'main' && clauseType === 'Sub') {
    return null;
  }
  
  // Detect sentence pattern
  const hasSubj = deps['nsubj'] || deps['nsubj:pass'] || deps['csubj'];
  const hasObj = deps['obj'] || deps['dobj'];
  const hasIobj = deps['iobj'];
  const hasCcomp = deps['ccomp'];
  const hasXcomp = deps['xcomp'];
  const hasAcomp = deps['acomp'];
  const hasAttr = deps['attr'];
  const hasOprd = deps['oprd'];
  
  // Get complement type (adj/noun/verb)
  let compType = null;
  const compArr = hasXcomp || hasAcomp || hasOprd || hasAttr;
  if (compArr) {
    const compTok = compArr[0].tok;
    const compPos = (compTok.pos || '').toUpperCase();
    const compXpos = (compTok.xpos || compTok.posd || '').toUpperCase();
    if (compPos === 'ADJ' || compXpos.startsWith('JJ')) {
      compType = 'adj';
    } else if (compPos === 'NOUN' || compXpos.startsWith('NN')) {
      compType = 'noun';
    } else if (compPos === 'VERB') {
      compType = 'verb';
    }
  }
  
  // Determine pattern
  let pattern = 'Other';
  
  if (hasSubj) {
    if (hasCcomp && !hasObj) {
      pattern = 'SV_that';
    } else if (hasCcomp && hasObj) {
      pattern = 'SVO_that';
    } else if (hasObj && hasXcomp && compType === 'verb') {
      pattern = 'SVO_toV';
    } else if (hasObj && hasIobj) {
      pattern = 'SVOO';
    } else if (hasObj && (hasXcomp || hasOprd)) {
      pattern = compType === 'adj' ? 'SVOC_adj' : (compType === 'noun' ? 'SVOC_noun' : 'SVOC_adj');
    } else if (hasObj) {
      pattern = 'SVO';
    } else if (hasXcomp || hasAcomp || hasAttr) {
      pattern = compType === 'adj' ? 'SVC_adj' : (compType === 'noun' ? 'SVC_noun' : 'SVC_adj');
    } else {
      pattern = 'SV';
    }
  }
  
  // Extract S, V, O/C text
  let subject = '';
  let verbText = verb.word || '';
  let objectComp = '';
  
  if (hasSubj) {
    const subjArr = deps['nsubj'] || deps['nsubj:pass'] || deps['csubj'];
    subject = subjArr[0].tok.word || '';
  }
  if (hasObj) {
    const objArr = deps['obj'] || deps['dobj'];
    objectComp = objArr[0].tok.word || '';
  } else if (compArr) {
    objectComp = compArr[0].tok.word || '';
  }
  
  return {
    pattern,
    clauseType,
    subType,
    clauseDepth,
    subject,
    verb: verbText,
    objectComp,
    verbIdx
  };
}

// Update sentence pattern counts in UI
function updateConstSentPatternCounts(counts) {
  constSentPatternCounts = counts;
  const patterns = ['SV', 'SVC_adj', 'SVC_noun', 'SVO', 'SVOO', 'SVOC_adj', 'SVOC_noun', 'SV_that', 'SVO_that', 'SVO_toV', 'Other'];
  let total = 0;
  
  document.querySelectorAll('.constSentPatternCb').forEach(cb => {
    const p = cb.value;
    const count = counts[p] || 0;
    total += count;
    const span = cb.parentElement.querySelector('span');
    if (span) span.textContent = `(${count})`;
  });
  
  const countEl = document.getElementById('constSentPatternCount');
  if (countEl) {
    countEl.textContent = `(${total} hits / ${patterns.filter(p => counts[p] > 0).length} types)`;
  }
}

// Update preset dropdown list
function updateConstPresetList() {
  const cat = document.getElementById('constPresetCategory')?.value || 'custom';
  const sel = document.getElementById('constPresetSelect');
  if (!sel) return;
  
  let html = '<option value="">-- Select or use custom --</option>';
  
  if (cat !== 'custom') {
    for (const [key, preset] of Object.entries(CONST_ALL_PRESETS)) {
      if (preset.cat === cat) {
        html += `<option value="${key}">${preset.id}: ${preset.name}</option>`;
      }
    }
  }
  
  sel.innerHTML = html;
  
  const descEl = document.getElementById('constPresetDescription');
  if (descEl) {
    descEl.style.display = 'none';
  }
}

// Apply preset to search criteria fields
function applyConstPreset() {
  const presetKey = document.getElementById('constPresetSelect')?.value;
  const descEl = document.getElementById('constPresetDescription');
  
  if (!presetKey || !CONST_ALL_PRESETS[presetKey]) {
    if (descEl) descEl.style.display = 'none';
    // Hide -ing/-ed options
    const ingEdDiv = document.getElementById('constIngEdOptions');
    if (ingEdDiv) ingEdDiv.style.display = 'none';
    return;
  }
  
  const preset = CONST_ALL_PRESETS[presetKey];
  
  // Show description
  if (descEl) {
    descEl.innerHTML = `<strong>${preset.name}:</strong> ${preset.desc}`;
    descEl.style.display = 'block';
  }
  
  // Show/hide -ing/-ed options
  const ingEdDiv = document.getElementById('constIngEdOptions');
  if (ingEdDiv) {
    if (preset.showIngEdOptions) {
      ingEdDiv.style.display = 'flex';
      // Store the type for later use
      ingEdDiv.dataset.ingEdType = preset.ingEdType || '';
      // Update seq field based on position selection
      updateConstIngEdSeq();
    } else {
      ingEdDiv.style.display = 'none';
    }
  }
  
  // Apply to fields
  const chunkField = document.getElementById('constChunkFilter');
  const pathField = document.getElementById('constPathContains');
  const posField = document.getElementById('constPOSFilter');
  const seqField = document.getElementById('constSequencePattern');
  
  if (chunkField) chunkField.value = preset.chunk || '';
  if (pathField) pathField.value = preset.path || '';
  if (posField) posField.value = preset.pos || '';
  
  // For N07/N08, set seq based on position; otherwise use preset.seq
  if (!preset.showIngEdOptions && seqField) {
    seqField.value = preset.seq || '';
  }
  
  console.log('[Const] Applied preset:', preset.id);
}

// Update sequence pattern based on -ing/-ed position selection
function updateConstIngEdSeq() {
  const ingEdDiv = document.getElementById('constIngEdOptions');
  const seqField = document.getElementById('constSequencePattern');
  if (!ingEdDiv || !seqField) return;
  
  const ingEdType = ingEdDiv.dataset.ingEdType || '';
  const position = document.querySelector('input[name="constIngEdPos"]:checked')?.value || 'both';
  
  let seq = '';
  if (ingEdType === 'ing') {
    if (position === 'before') seq = 'VBG+NN';
    else if (position === 'after') seq = 'NN+VBG';
    else seq = ''; // both - handled specially in search
  } else if (ingEdType === 'ed') {
    if (position === 'before') seq = 'VBN+NN';
    else if (position === 'after') seq = 'NN+VBN';
    else seq = ''; // both - handled specially in search
  }
  
  seqField.value = seq;
  console.log('[Const] Updated -ing/-ed seq:', seq, 'type:', ingEdType, 'position:', position);
}

// Sync scope and show warning
function syncConstConcScope() {
  const scope = document.querySelector('input[name="constScope"]:checked')?.value || 'all';
  const warning = document.getElementById('constScopeWarning');
  
  // Debug: log the folder sets
  console.log('[Const syncScope] Scope:', scope);
  console.log('[Const syncScope] targetFolders:', targetFolders ? Array.from(targetFolders) : 'undefined');
  console.log('[Const syncScope] referenceFolders:', referenceFolders ? Array.from(referenceFolders) : 'undefined');
  
  if (warning) {
    // Use global Sets (defined at line 4280)
    const hasTarget = targetFolders && targetFolders.size > 0;
    const hasRef = referenceFolders && referenceFolders.size > 0;
    
    console.log('[Const syncScope] hasTarget:', hasTarget, 'hasRef:', hasRef);
    
    if ((scope === 'target' && !hasTarget) ||
        (scope === 'reference' && !hasRef)) {
      warning.style.display = 'inline';
    } else {
      warning.style.display = 'none';
    }
  }
}

// Clear pattern results
function clearConstPattern() {
  constPatternRows = [];
  lastConstPatternRows = [];
  currentConstInstances = [];
  
  const tbody = document.getElementById('constPatternTbody');
  if (tbody) tbody.innerHTML = '<tr><td colspan="14" class="text-xs">No data.</td></tr>';
  
  const status = document.getElementById('constPatternStatus');
  if (status) status.textContent = '';
  
  const summary = document.getElementById('constPatternSummary');
  if (summary) summary.style.display = 'none';
  
  // Clear fields
  ['constChunkFilter', 'constPathContains', 'constPOSFilter', 'constSequencePattern', 'constQueryInput', 'constParentFilter'].forEach(id => {
    const el = document.getElementById(id);
    if (el) el.value = '';
  });
  
  document.getElementById('constPresetSelect').value = '';
  document.getElementById('constPresetCategory').value = 'custom';
  updateConstPresetList();
}

// Cancel computation
function cancelConstComputation() {
  constComputationCancelled = true;
}

// Main compute function
async function computeConstPattern() {
  const status = document.getElementById('constPatternStatus');
  const computeBtn = document.getElementById('constComputeBtn');
  const cancelBtn = document.getElementById('constCancelBtn');
  
  if (!corpus || !corpus.files) {
    if (status) status.textContent = 'No corpus loaded.';
    return;
  }
  
  constComputationCancelled = false;
  if (computeBtn) computeBtn.disabled = true;
  if (cancelBtn) cancelBtn.style.display = 'inline';
  if (status) status.textContent = 'Computing...';
  
  try {
    const results = await computeConstPatternCore();
    constPatternRows = results.rows;
    lastConstPatternRows = [...results.rows]; // Show all initially
    
    // Update summary
    const summary = document.getElementById('constPatternSummary');
    if (summary) {
      summary.style.display = 'block';
      document.getElementById('constTypeCount').textContent = results.rows.length;
      document.getElementById('constInstanceCount').textContent = results.totalInstances;
      document.getElementById('constFileCount').textContent = results.fileCount;
    }
    
    // Update sentence pattern counts in UI
    if (results.sentPatternCounts) {
      updateConstSentPatternCounts(results.sentPatternCounts);
    }
    
    // Clear all sentence pattern checkboxes after computation
    // User can then select which patterns to view
    document.querySelectorAll('.constSentPatternCb').forEach(cb => cb.checked = false);
    
    displayConstPatternResults();
    status.textContent = `Found ${results.rows.length} types. Select patterns to filter.`;
  } catch (err) {
    status.textContent = `Error: ${err.message}`;
    console.error(err);
  } finally {
    if (cancelBtn) cancelBtn.style.display = 'none';
    if (computeBtn) computeBtn.disabled = false;
  }
}

// Core computation with new search logic
async function computeConstPatternCore() {
  const status = document.getElementById('constPatternStatus');
  
  // Get search criteria from UI fields
  const chunkFilter = (document.getElementById('constChunkFilter')?.value || '').trim();
  const pathContains = (document.getElementById('constPathContains')?.value || '').trim();
  const posFilter = (document.getElementById('constPOSFilter')?.value || '').trim();
  let seqPattern = (document.getElementById('constSequencePattern')?.value || '').trim();
  
  // Check for -ing/-ed both option
  const ingEdDiv = document.getElementById('constIngEdOptions');
  let ingEdPatterns = null;
  if (ingEdDiv && ingEdDiv.style.display !== 'none') {
    const ingEdType = ingEdDiv.dataset.ingEdType || '';
    const position = document.querySelector('input[name="constIngEdPos"]:checked')?.value || 'both';
    
    if (position === 'both' && !seqPattern) {
      // Search both patterns
      if (ingEdType === 'ing') {
        ingEdPatterns = ['VBG+NN', 'NN+VBG'];
      } else if (ingEdType === 'ed') {
        ingEdPatterns = ['VBN+NN', 'NN+VBN'];
      }
    }
  }
  
  const query = (document.getElementById('constQueryInput')?.value || '').trim();
  const searchAs = document.querySelector('input[name="constSearchAs"]:checked')?.value || 'word';
  const ignoreCase = document.getElementById('constIgnoreCase')?.checked ?? true;
  const scope = document.querySelector('input[name="constScope"]:checked')?.value || 'all';
  const minFreq = parseInt(document.getElementById('constMinFreq')?.value) || 1;
  const dedupe = document.getElementById('constDedupe')?.checked ?? true;
  
  const extractUnit = document.querySelector('input[name="constExtractUnit"]:checked')?.value || 'head';
  const depthMin = parseInt(document.getElementById('constDepthMin')?.value) || 0;
  const depthMax = parseInt(document.getElementById('constDepthMax')?.value) || 20;
  const parentFilter = (document.getElementById('constParentFilter')?.value || '').trim();
  
  // Sentence Pattern filter options
  const analysisLevel = document.querySelector('input[name="constAnalysisLevel"]:checked')?.value || 'all';
  const countMode = document.querySelector('input[name="constCountMode"]:checked')?.value || 'both';
  const selectedSentPatterns = getSelectedConstSentPatterns();
  const selectedSubTypes = getSelectedConstSubTypes();
  const svcType = document.querySelector('input[name="constSVCType"]:checked')?.value || 'both';
  const svocType = document.querySelector('input[name="constSVOCType"]:checked')?.value || 'both';
  
  // Parse filters
  const chunkTypes = chunkFilter ? chunkFilter.split(',').map(s => s.trim().toUpperCase()).filter(s => s) : [];
  const pathPatterns = pathContains ? pathContains.split(',').map(s => s.trim()).filter(s => s) : [];
  const posTags = posFilter ? posFilter.split(',').map(s => s.trim().toUpperCase()).filter(s => s) : [];
  
  // Use global targetFolders and referenceFolders Sets directly
  // These are defined at the top of the script as global Sets
  console.log('[Const] === Search Criteria ===');
  console.log('[Const] Chunks:', chunkTypes);
  console.log('[Const] Path patterns:', pathPatterns);
  console.log('[Const] POS tags:', posTags);
  console.log('[Const] Sequence:', seqPattern);
  console.log('[Const] Sentence Patterns:', Array.from(selectedSentPatterns));
  console.log('[Const] -ing/-ed Both patterns:', ingEdPatterns);
  console.log('[Const] Scope:', scope);
  console.log('[Const] Dedupe:', dedupe);
  console.log('[Const] Global targetFolders:', targetFolders ? Array.from(targetFolders) : 'undefined');
  console.log('[Const] Global referenceFolders:', referenceFolders ? Array.from(referenceFolders) : 'undefined');
  
  const patternMap = new Map();
  const files = Object.values(corpus.files);
  let totalTokensT = 0, totalTokensR = 0, totalTokensN = 0;
  let fileCount = 0, debugMatched = 0;
  
  // Log first few files for debugging
  if (files.length > 0) {
    console.log('[Const] Sample file folder:', files[0].folder);
    console.log('[Const] Is in targetFolders?', targetFolders.has(files[0].folder));
    console.log('[Const] Is in referenceFolders?', referenceFolders.has(files[0].folder));
  }
  
  for (let fi = 0; fi < files.length; fi++) {
    if (constComputationCancelled) break;
    
    const file = files[fi];
    const folder = file.folder || '';
    const isTarget = targetFolders.size > 0 && targetFolders.has(folder);
    const isReference = referenceFolders.size > 0 && referenceFolders.has(folder);
    
    // Scope filtering
    if (scope === 'target' && !isTarget) continue;
    if (scope === 'reference' && !isReference) continue;
    
    if (!file.tokens || file.tokens.length === 0) continue;
    
    const tokens = file.tokens;
    const side = isTarget && isReference ? 'B' : isTarget ? 'T' : isReference ? 'R' : 'N';
    
    // For dedupe: track seen sentence IDs per file
    const seenSentences = dedupe ? new Map() : null; // key: sentId+word, value: true
    
    // Build sentence pattern cache for this file
    const sentPatternCache = buildSentencePatternCache(tokens, { analysisLevel, useConstituent: true });
    
    // Count tokens
    let nonPunctCount = 0;
    for (const tok of tokens) {
      const isPunctVal = tok.isPunct || tok.is_punct;
      if (isPunctVal !== true && isPunctVal !== 'True' && isPunctVal !== 'true' && isPunctVal !== '1') {
        nonPunctCount++;
      }
    }
    if (isTarget) totalTokensT += nonPunctCount;
    if (isReference) totalTokensR += nonPunctCount;
    if (!isTarget && !isReference) totalTokensN += nonPunctCount;
    
    let fileHasMatch = false;
    
    // Helper: Get sentence pattern info for a token
    const getSentPatternForToken = (tok, tokenIdx) => {
      const sentId = tok.sent_id || 'unknown';
      const patterns = sentPatternCache.get(sentId) || [{ pattern: 'Other', clauseType: 'Main', subType: '-', clauseDepth: 0 }];
      // Return first matching pattern (or first pattern if only one)
      // In future, could match based on token position relative to verb
      return patterns[0];
    };
    
    // Helper: Check if pattern passes filter
    const passesPatternFilter = (patternInfo) => {
      // Check sentence pattern filter
      let pattern = patternInfo.pattern;
      
      // Handle SVC/SVOC type filtering
      if (pattern === 'SVC_adj' && svcType === 'noun') return false;
      if (pattern === 'SVC_noun' && svcType === 'adj') return false;
      if (pattern === 'SVOC_adj' && svocType === 'noun') return false;
      if (pattern === 'SVOC_noun' && svocType === 'adj') return false;
      
      // If SVC type is 'both', check if either SVC_adj or SVC_noun is selected
      if (svcType === 'both' && (pattern === 'SVC_adj' || pattern === 'SVC_noun')) {
        if (!selectedSentPatterns.has('SVC_adj') && !selectedSentPatterns.has('SVC_noun')) return false;
        if (!selectedSentPatterns.has(pattern)) return false;
      } else if (svocType === 'both' && (pattern === 'SVOC_adj' || pattern === 'SVOC_noun')) {
        if (!selectedSentPatterns.has('SVOC_adj') && !selectedSentPatterns.has('SVOC_noun')) return false;
        if (!selectedSentPatterns.has(pattern)) return false;
      } else {
        if (!selectedSentPatterns.has(pattern)) return false;
      }
      
      // Check sub type filter
      const subTypeKey = patternInfo.clauseType === 'Main' ? 'main' : patternInfo.subType;
      if (!selectedSubTypes.has(subTypeKey) && !selectedSubTypes.has('main')) {
        // If it's a subordinate clause, check if its specific subType is selected
        if (patternInfo.clauseType === 'Sub' && !selectedSubTypes.has(patternInfo.subType)) {
          return false;
        }
      }
      
      return true;
    };
    
    // Sequence pattern search (including -ing/-ed both)
    const patternsToSearch = ingEdPatterns || (seqPattern ? [seqPattern] : []);
    
    if (patternsToSearch.length > 0) {
      for (const pattern of patternsToSearch) {
        const matches = findSequenceMatches(tokens, pattern, { query, searchAs, ignoreCase, depthMin, depthMax, parentFilter });
        for (const match of matches) {
          // Get sentence pattern info
          const patternInfo = getSentPatternForToken(tokens[match.tokenIdx], match.tokenIdx);
          
          // Note: Sentence pattern filtering is NOT applied here
          // It will be applied at display time for flexibility
          
          // Dedupe check (per sentence) - fullPhrase already in lemma form if searchAs=lemma
          if (dedupe && seenSentences) {
            const dedupeKey = `${match.sentId || ''}_${(match.fullPhrase || match.word || '').toLowerCase()}`;
            if (seenSentences.has(dedupeKey)) continue;
            seenSentences.set(dedupeKey, true);
          }
          
          // Add sentence pattern info to match
          match.sentPattern = patternInfo.pattern;
          match.clauseType = patternInfo.clauseType;
          match.subType = patternInfo.subType;
          match.clauseDepth = patternInfo.clauseDepth;
          match.subject = patternInfo.subject;
          match.verb = patternInfo.verb;
          match.objectComp = patternInfo.objectComp;
          
          addConstMatch(patternMap, match, file, side, isTarget, isReference);
          debugMatched++;
          fileHasMatch = true;
        }
      }
    }
    // Regular search
    else {
      for (let idx = 0; idx < tokens.length; idx++) {
        const tok = tokens[idx];
        
        // Skip punctuation
        const isPunctVal = tok.isPunct || tok.is_punct;
        if (isPunctVal === true || isPunctVal === 'True' || isPunctVal === 'true' || isPunctVal === '1') continue;
        
        const chunk = tok.chunk || '';
        const cpath = tok.cpath_norm || tok.cpath || '';
        const xpos = tok.posd || tok.xpos || '';
        
        // Calculate depth
        const depth = cpath ? (cpath.match(/>/g) || []).length : 0;
        const pathParts = cpath.split('>');
        const parent = pathParts.length >= 2 ? pathParts[pathParts.length - 2] : '';
        
        // Apply filters
        if (depth < depthMin || depth > depthMax) continue;
        if (parentFilter && !parent.toUpperCase().includes(parentFilter.toUpperCase())) continue;
        
        // Chunk filter
        if (chunkTypes.length > 0 && !chunkTypes.includes(chunk.toUpperCase())) continue;
        
        // Path contains filter
        if (pathPatterns.length > 0) {
          let pathMatch = false;
          for (const pp of pathPatterns) {
            if (cpath.toUpperCase().includes(pp.toUpperCase())) {
              pathMatch = true;
              break;
            }
          }
          if (!pathMatch) continue;
        }
        
        // POS filter
        if (posTags.length > 0 && !posTags.includes(xpos.toUpperCase())) continue;
        
        // Head only check
        if (extractUnit === 'head') {
          const isHeadVal = tok.is_chunk_head;
          if (isHeadVal !== '1' && isHeadVal !== 1 && isHeadVal !== true && isHeadVal !== 'True') continue;
        }
        
        // Get sentence pattern info
        const patternInfo = getSentPatternForToken(tok, idx);
        
        // Note: Sentence pattern filtering is NOT applied here
        // It will be applied at display time for flexibility
        
        // Query filter (with ignore case support)
        if (query) {
          let tokenValue;
          if (searchAs === 'lemma') {
            // Use searchLemma (already lowercase) or lemma or word
            tokenValue = tok.searchLemma || tok.lemma || tok.word || '';
          } else {
            tokenValue = tok.word || '';
          }
          const q = ignoreCase ? query.toLowerCase() : query;
          const tv = ignoreCase ? tokenValue.toLowerCase() : tokenValue;
          
          if (!tv.includes(q)) continue;
        }
        
        // Dedupe check (per sentence)
        if (dedupe && seenSentences) {
          // Use lemma for dedupe key if in lemma mode
          const dedupeWord = searchAs === 'lemma' 
            ? (tok.searchLemma || tok.lemma || tok.word || '').toLowerCase()
            : (tok.word || '').toLowerCase();
          const dedupeKey = `${tok.sent_id || ''}_${dedupeWord}`;
          if (seenSentences.has(dedupeKey)) continue;
          seenSentences.set(dedupeKey, true);
        }
        
        // Matched!
        // Determine display text: use lemma if in lemma mode
        let displayWord;
        if (searchAs === 'lemma') {
          displayWord = tok.searchLemma || tok.lemma || tok.word || '';
          if (ignoreCase) displayWord = displayWord.toLowerCase();
        } else {
          displayWord = ignoreCase ? tok.word.toLowerCase() : tok.word;
        }
        
        addConstMatch(patternMap, {
          word: displayWord,
          fullPhrase: displayWord,
          chunk: chunk,
          cpath: cpath,
          depth: depth,
          parent: parent,
          tokenIdx: idx,
          sentId: tok.sent_id,
          sentText: tok.sent_text || '',
          // Sentence pattern info
          sentPattern: patternInfo.pattern,
          clauseType: patternInfo.clauseType,
          subType: patternInfo.subType,
          clauseDepth: patternInfo.clauseDepth,
          subject: patternInfo.subject,
          verb: patternInfo.verb,
          objectComp: patternInfo.objectComp
        }, file, side, isTarget, isReference);
        debugMatched++;
        fileHasMatch = true;
      }
    }
    
    if (fileHasMatch) fileCount++;
    
    if ((fi + 1) % 100 === 0) {
      status.textContent = `Processing... ${fi + 1}/${files.length}`;
      await new Promise(r => setTimeout(r, 0));
    }
  }
  
  // Convert to rows
  const rows = [];
  let totalInstances = 0;
  const totalAllTokens = totalTokensT + totalTokensR + totalTokensN;
  
  for (const [feature, data] of patternMap) {
    const totalFreq = data.freqT + data.freqR + data.freqN;
    if (totalFreq < minFreq) continue;
    
    totalInstances += data.instances.length;
    
    // Calculate statistics
    const displayFreqT = scope === 'all' ? totalFreq : data.freqT;
    const displayNormT = scope === 'all' 
      ? (totalAllTokens > 0 ? totalFreq / totalAllTokens * 1000000 : 0)
      : (totalTokensT > 0 ? data.freqT / totalTokensT * 1000000 : 0);
    const displayNormR = scope === 'all' ? 0 : (totalTokensR > 0 ? data.freqR / totalTokensR * 1000000 : 0);
    
    let freqLL = 0, textLL = 0;
    if (scope !== 'all' && totalTokensT > 0 && totalTokensR > 0) {
      freqLL = computeLL(data.freqT, data.freqR, totalTokensT, totalTokensR);
      const totalFilesT = getTargetFileCount();
      const totalFilesR = getReferenceFileCount();
      if (totalFilesT > 0 && totalFilesR > 0) {
        textLL = computeLL(data.fileFreqT.size, data.fileFreqR.size, totalFilesT, totalFilesR);
      }
    }
    
    rows.push({
      feature, word: data.word, fullPhrase: data.fullPhrase,
      chunk: data.chunk, path: data.path, depth: data.depth, parent: data.parent,
      freqT: displayFreqT, freqR: scope === 'all' ? 0 : data.freqR,
      normT: displayNormT, normR: displayNormR,
      freqLL, textLL, mtk: '-',
      instances: data.instances,
      sentPatternCounts: data.sentPatternCounts
    });
  }
  
  rows.sort((a, b) => b.freqT - a.freqT);
  
  // Aggregate sentence pattern counts across all rows
  const globalSentPatternCounts = {};
  for (const row of rows) {
    for (const [pattern, count] of Object.entries(row.sentPatternCounts || {})) {
      globalSentPatternCounts[pattern] = (globalSentPatternCounts[pattern] || 0) + count;
    }
  }
  
  console.log('[Const] Matched:', debugMatched, 'Types:', rows.length);
  console.log('[Const] Sentence Pattern counts:', globalSentPatternCounts);
  
  return { rows, totalInstances, fileCount, totalTokensT, totalTokensR, sentPatternCounts: globalSentPatternCounts };
}

// Helper: Add match to pattern map
function addConstMatch(patternMap, match, file, side, isTarget, isReference) {
  const featureKey = match.fullPhrase.toLowerCase();
  
  if (!patternMap.has(featureKey)) {
    patternMap.set(featureKey, {
      word: match.word, fullPhrase: match.fullPhrase,
      chunk: match.chunk, path: match.cpath,
      depth: match.depth, parent: match.parent,
      freqT: 0, freqR: 0, freqN: 0,
      fileFreqT: new Map(), fileFreqR: new Map(), fileFreqN: new Map(),
      instances: [],
      // Sentence Pattern counts
      sentPatternCounts: {}
    });
  }
  
  const entry = patternMap.get(featureKey);
  
  if (isTarget) {
    entry.freqT++;
    entry.fileFreqT.set(file.name, (entry.fileFreqT.get(file.name) || 0) + 1);
  }
  if (isReference) {
    entry.freqR++;
    entry.fileFreqR.set(file.name, (entry.fileFreqR.get(file.name) || 0) + 1);
  }
  if (!isTarget && !isReference) {
    entry.freqN++;
    entry.fileFreqN.set(file.name, (entry.fileFreqN.get(file.name) || 0) + 1);
  }
  
  // Count sentence patterns
  if (match.sentPattern) {
    entry.sentPatternCounts[match.sentPattern] = (entry.sentPatternCounts[match.sentPattern] || 0) + 1;
  }
  
  if (entry.instances.length < 5000) {
    entry.instances.push({
      fileId: file.id, fileName: file.name, folder: file.folder, side,
      sentId: match.sentId, sentText: match.sentText,
      word: match.word, fullPhrase: match.fullPhrase,
      chunk: match.chunk, cpath: match.cpath,
      depth: match.depth, parent: match.parent,
      tokenIdx: match.tokenIdx,
      // Sentence Pattern info
      sentPattern: match.sentPattern || 'Other',
      clauseType: match.clauseType || 'Main',
      subType: match.subType || '-',
      clauseDepth: match.clauseDepth || 0,
      subject: match.subject || '',
      verb: match.verb || '',
      objectComp: match.objectComp || ''
    });
  }
}

// Find sequence pattern matches (JJ+NN, be+VBN, etc.)
function findSequenceMatches(tokens, pattern, options) {
  const matches = [];
  const { query, searchAs, ignoreCase, depthMin, depthMax, parentFilter } = options;
  
  // Parse pattern: "JJ+NN", "be+VBN", "NN+of+NN"
  const parts = pattern.split('+').map(p => p.trim());
  if (parts.length < 2) return matches;
  
  const isPunct = (tok) => {
    const v = tok.isPunct || tok.is_punct;
    return v === true || v === 'True' || v === 'true' || v === '1';
  };
  
  const getPOS = (tok) => (tok.posd || tok.xpos || '').toUpperCase();
  const getWord = (tok) => tok.word || '';
  const getLemma = (tok) => tok.lemma || tok.word || '';
  
  // Special word matchers
  const beVerbs = ['be', 'been', 'being', 'is', 'are', 'was', 'were', 'am'];
  const haveVerbs = ['have', 'has', 'had', 'having'];
  const nounPOS = ['NN', 'NNS', 'NNP', 'NNPS'];
  const verbPOS = ['VB', 'VBD', 'VBG', 'VBN', 'VBP', 'VBZ'];
  const adjPOS = ['JJ', 'JJR', 'JJS'];
  
  // Match function for a single pattern part
  const matchPart = (tok, part) => {
    const partUpper = part.toUpperCase();
    const pos = getPOS(tok);
    const word = getWord(tok).toLowerCase();
    const lemma = getLemma(tok).toLowerCase();
    
    // POS tags
    if (partUpper === 'NN') return nounPOS.includes(pos);
    if (partUpper === 'VB') return verbPOS.includes(pos);
    if (partUpper === 'JJ') return adjPOS.includes(pos);
    if (['VBN', 'VBD', 'VBG', 'VBP', 'VBZ', 'DT', 'IN', 'TO', 'MD', 'RB', 'CC'].includes(partUpper)) {
      return pos === partUpper;
    }
    
    // Special words
    if (part.toLowerCase() === 'be') return beVerbs.includes(lemma) || beVerbs.includes(word);
    if (part.toLowerCase() === 'have') return haveVerbs.includes(lemma) || haveVerbs.includes(word);
    if (part.toLowerCase() === 'not') return word === 'not' || word === "n't";
    if (part.toLowerCase() === 'there') return word === 'there';
    if (part.toLowerCase() === 'it') return word === 'it';
    if (part.toLowerCase() === 'that') return word === 'that';
    if (part.toLowerCase() === 'of') return word === 'of';
    if (part.toLowerCase() === 'to') return word === 'to' || pos === 'TO';
    
    // Exact word match
    return word === part.toLowerCase() || lemma === part.toLowerCase();
  };
  
  // Slide through tokens
  for (let i = 0; i <= tokens.length - parts.length; i++) {
    let allMatch = true;
    const matchedTokens = [];
    
    for (let j = 0; j < parts.length; j++) {
      const tok = tokens[i + j];
      if (isPunct(tok) || !matchPart(tok, parts[j])) {
        allMatch = false;
        break;
      }
      matchedTokens.push(tok);
    }
    
    if (!allMatch) continue;
    
    // Build full phrase - use lemma if in lemma mode
    let fullPhrase;
    if (searchAs === 'lemma') {
      fullPhrase = matchedTokens.map(t => t.searchLemma || t.lemma || t.word).join(' ');
    } else {
      fullPhrase = matchedTokens.map(t => t.word).join(' ');
    }
    const headTok = matchedTokens[matchedTokens.length - 1]; // Last token as head
    const cpath = headTok.cpath_norm || headTok.cpath || '';
    const depth = cpath ? (cpath.match(/>/g) || []).length : 0;
    const pathParts = cpath.split('>');
    const parent = pathParts.length >= 2 ? pathParts[pathParts.length - 2] : '';
    
    // Apply filters
    if (depth < depthMin || depth > depthMax) continue;
    if (parentFilter && !parent.toUpperCase().includes(parentFilter.toUpperCase())) continue;
    
    // Query filter (support lemma search)
    if (query) {
      const q = ignoreCase ? query.toLowerCase() : query;
      const mt = ignoreCase ? fullPhrase.toLowerCase() : fullPhrase;
      if (!mt.includes(q)) continue;
    }
    
    // Determine display text based on ignoreCase and searchAs
    let displayPhrase = ignoreCase ? fullPhrase.toLowerCase() : fullPhrase;
    let displayWord;
    if (searchAs === 'lemma') {
      displayWord = headTok.searchLemma || headTok.lemma || headTok.word || '';
      if (ignoreCase) displayWord = displayWord.toLowerCase();
    } else {
      displayWord = ignoreCase ? headTok.word.toLowerCase() : headTok.word;
    }
    
    matches.push({
      word: displayWord,
      fullPhrase: displayPhrase,
      chunk: headTok.chunk || '',
      cpath: cpath,
      depth: depth,
      parent: parent,
      tokenIdx: i,
      sentId: headTok.sent_id,
      sentText: headTok.sent_text || ''
    });
    
    // Skip matched tokens
    i += parts.length - 1;
  }
  
  return matches;
}

// Display results
function displayConstPatternResults() {
  const tbody = document.getElementById('constPatternTbody');
  if (!tbody) return;
  
  if (constPatternRows.length === 0) {
    tbody.innerHTML = '<tr><td colspan="14" class="text-xs">No patterns found.</td></tr>';
    return;
  }
  
  let html = '';
  constPatternRows.forEach((r, idx) => {
    const fullPhraseDisplay = r.fullPhrase.length > 30 ? r.fullPhrase.substring(0, 27) + '...' : r.fullPhrase;
    const pathDisplay = r.path && r.path.length > 25 ? '...' + r.path.slice(-22) : (r.path || '-');
    
    html += `<tr onclick="selectConstPatternRow(${idx})" style="cursor:pointer;">
      <td class="text-xs">${idx + 1}</td>
      <td class="text-xs">${escapeHtml(r.feature)}</td>
      <td class="text-xs" title="${escapeHtml(r.fullPhrase)}">${escapeHtml(fullPhraseDisplay)}</td>
      <td class="text-xs">${r.chunk || '-'}</td>
      <td class="text-xs text-right">${r.depth ?? '-'}</td>
      <td class="text-xs">${r.parent || '-'}</td>
      <td class="text-xs" title="${escapeHtml(r.path || '')}">${escapeHtml(pathDisplay)}</td>
      <td class="text-xs text-right">${r.freqT}</td>
      <td class="text-xs text-right">${r.normT.toFixed(1)}</td>
      <td class="text-xs text-right">${r.freqR}</td>
      <td class="text-xs text-right">${r.normR.toFixed(1)}</td>
      <td class="text-xs text-right">${r.freqLL.toFixed(2)}</td>
      <td class="text-xs text-right">${r.textLL.toFixed(2)}</td>
      <td class="text-xs text-right">${r.mtk}</td>
    </tr>`;
  });
  
  tbody.innerHTML = html;
}

// Select row and show concordance
function selectConstPatternRow(idx) {
  if (idx < 0 || idx >= constPatternRows.length) return;
  
  const row = constPatternRows[idx];
  currentConstInstances = row.instances || [];
  
  // Update display
  const featureEl = document.getElementById('constConcordanceFeature');
  const countEl = document.getElementById('constConcordanceCount');
  if (featureEl) featureEl.textContent = row.feature || row.word;
  if (countEl) countEl.textContent = currentConstInstances.length.toLocaleString();
  
  // Expand concordance section
  const concContent = document.getElementById('sectionConst12b-content');
  if (concContent && concContent.style.display === 'none') {
    toggleCollapsibleSection('sectionConst12b');
  }
  
  updateConstConcordanceDisplay();
}

// Apply filter
function applyConstFilter() {
  const minFreq = parseInt(document.getElementById('constFilterFreq')?.value) || 0;
  const filterText = (document.getElementById('constFilterFeature')?.value || '').trim().toLowerCase();
  const mode = document.getElementById('constFilterMode')?.value || 'partial';
  
  constPatternRows = lastConstPatternRows.filter(r => {
    if (r.freqT < minFreq) return false;
    if (filterText) {
      const f = r.feature.toLowerCase();
      if (mode === 'exact') {
        const words = f.split(/\s+/);
        if (!words.includes(filterText)) return false;
      } else {
        if (!f.includes(filterText)) return false;
      }
    }
    return true;
  });
  
  displayConstPatternResults();
}

// Clear filter
function clearConstFilter() {
  document.getElementById('constFilterFreq').value = '1';
  document.getElementById('constFilterFeature').value = '';
  constPatternRows = [...lastConstPatternRows];
  displayConstPatternResults();
}

// Show all concordance
function showAllConstConcordance() {
  currentConstInstances = [];
  for (const row of constPatternRows) {
    if (row.instances) {
      currentConstInstances.push(...row.instances.slice(0, 100));
    }
    if (currentConstInstances.length > 5000) break;
  }
  
  // Update display
  const featureEl = document.getElementById('constConcordanceFeature');
  const countEl = document.getElementById('constConcordanceCount');
  if (featureEl) featureEl.textContent = '(All patterns)';
  if (countEl) countEl.textContent = currentConstInstances.length.toLocaleString();
  
  const concContent = document.getElementById('sectionConst12b-content');
  if (concContent && concContent.style.display === 'none') {
    toggleCollapsibleSection('sectionConst12b');
  }
  
  updateConstConcordanceDisplay();
}

// Sort table
function sortConstTable(colIdx) {
  const colMap = {
    1: 'feature', 2: 'fullPhrase', 3: 'chunk', 4: 'depth',
    5: 'parent', 6: 'path', 7: 'freqT', 8: 'normT',
    9: 'freqR', 10: 'normR', 11: 'freqLL', 12: 'textLL', 13: 'mtk'
  };
  
  const col = colMap[colIdx];
  if (!col) return;
  
  if (constSortCol === col) {
    constSortDir = constSortDir === 'asc' ? 'desc' : 'asc';
  } else {
    constSortCol = col;
    constSortDir = 'desc';
  }
  
  const factor = constSortDir === 'asc' ? 1 : -1;
  
  constPatternRows.sort((a, b) => {
    let va = a[col], vb = b[col];
    if (typeof va === 'string') {
      return (va || '').localeCompare(vb || '') * factor;
    }
    return ((va || 0) - (vb || 0)) * factor;
  });
  
  displayConstPatternResults();
}

// Export to Excel
function exportConstPatternExcel() {
  if (constPatternRows.length === 0) {
    alert('No data to export.');
    return;
  }
  
  let csv = 'Feature,Full Phrase,Chunk,Depth,Parent,Path,freq_T,norm_T,freq_R,norm_R,Freq-LL,Text-LL,MTK\n';
  for (const row of constPatternRows) {
    csv += `"${(row.feature || '').replace(/"/g, '""')}","${(row.fullPhrase || '').replace(/"/g, '""')}","${row.chunk || ''}",${row.depth},${row.parent || ''},"${(row.path || '').replace(/"/g, '""')}",${row.freqT},${row.normT.toFixed(2)},${row.freqR},${row.normR.toFixed(2)},${row.freqLL.toFixed(2)},${row.textLL.toFixed(2)},"${row.mtk}"\n`;
  }
  
  const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
  const link = document.createElement('a');
  link.href = URL.createObjectURL(blob);
  link.download = 'constituent_patterns.csv';
  link.click();
}
function showConstConcordance(rowIdx) {
  const row = constPatternRows[rowIdx];
  if (!row) return;
  
  currentConstInstances = row.instances;
  
  // Update display
  document.getElementById('constConcordanceFeature').textContent = row.word;
  document.getElementById('constConcordanceCount').textContent = row.instances.length.toLocaleString();
  
  // Expand section
  const content = document.getElementById('sectionConst12b-content');
  const arrow = document.getElementById('sectionConst12b-arrow');
  if (content && content.style.display === 'none') {
    content.style.display = 'block';
    if (arrow) arrow.textContent = '▼';
  }
  
  updateConstConcordanceDisplay();
  
  // Scroll to section
  document.getElementById('constConcordanceSection')?.scrollIntoView({ behavior: 'smooth' });
}

// Update concordance display (like 11b style)
function updateConstConcordanceDisplay() {
  const tbody = document.getElementById('constConcordanceTbody');
  if (!tbody || !currentConstInstances || currentConstInstances.length === 0) {
    if (tbody) tbody.innerHTML = '<tr><td colspan="4" class="text-xs">No concordance data. Click a row in 12a) to view.</td></tr>';
    return;
  }
  
  const maxRows = parseInt(document.getElementById('constConcMax')?.value) || 500;
  const scope = document.getElementById('constConcScope')?.value || 'all';
  const removeDuplicates = document.getElementById('constConcRemoveDuplicates')?.checked || false;
  
  // Filter by scope
  let filteredInstances = currentConstInstances;
  if (scope === 'target') {
    filteredInstances = currentConstInstances.filter(i => i.side === 'T' || i.side === 'B');
  } else if (scope === 'reference') {
    filteredInstances = currentConstInstances.filter(i => i.side === 'R' || i.side === 'B');
  }
  
  // Remove duplicates if requested
  if (removeDuplicates) {
    const seen = new Set();
    filteredInstances = filteredInstances.filter(inst => {
      const key = `${inst.sentText || ''}`;
      if (seen.has(key)) return false;
      seen.add(key);
      return true;
    });
  }
  
  document.getElementById('constConcordanceCount').textContent = filteredInstances.length.toLocaleString();
  
  // Sort using state variables
  let sortedInstances = [...filteredInstances];
  const sortFactor = constConcSortDir === 'asc' ? 1 : -1;
  
  if (constConcSortCol === 'feature') {
    sortedInstances.sort((a, b) => (a.fullPhrase || a.word || '').localeCompare(b.fullPhrase || b.word || '') * sortFactor);
  } else if (constConcSortCol === 'file') {
    sortedInstances.sort((a, b) => (a.fileName || '').localeCompare(b.fileName || '') * sortFactor);
  } else if (constConcSortCol === 'side') {
    sortedInstances.sort((a, b) => (a.side || '').localeCompare(b.side || '') * sortFactor);
  } else if (constConcSortCol === 'concordance') {
    sortedInstances.sort((a, b) => (a.sentText || '').localeCompare(b.sentText || '') * sortFactor);
  }
  
  // Display
  const displayInstances = sortedInstances.slice(0, maxRows);
  
  let html = '';
  for (const inst of displayInstances) {
    const feature = inst.fullPhrase || inst.word || '';
    let sentText = inst.sentText || '';
    
    // If sentText is empty, try to reconstruct from corpus
    if (!sentText && inst.fileId && inst.sentId) {
      const file = corpus?.files?.[inst.fileId];
      if (file && file.tokens) {
        const sentTokens = file.tokens.filter(t => t.sent_id === inst.sentId);
        // Include punctuation in reconstruction
        sentText = sentTokens.map(t => t.word || '').join(' ');
        // Fix spacing around punctuation
        sentText = sentText.replace(/ ([.,!?;:])/g, '$1');
      }
    }
    
    // Highlight the feature word in concordance (like 11b style)
    let highlightedText = sentText;
    if (feature && sentText) {
      const regex = new RegExp(`\\b(${escapeRegex(feature)})\\b`, 'gi');
      highlightedText = escapeHtml(sentText).replace(regex, '<span style="color:#dc2626; font-weight:600;">$1</span>');
    } else {
      highlightedText = escapeHtml(sentText);
    }
    
    html += `<tr>
      <td class="text-xs">${escapeHtml(feature)}</td>
      <td class="text-xs" title="${escapeHtml(inst.fileName || '')}">${escapeHtml((inst.fileName || '').substring(0, 25))}${(inst.fileName || '').length > 25 ? '...' : ''}</td>
      <td class="text-xs text-center">${inst.side || '-'}</td>
      <td class="text-xs">${highlightedText}</td>
    </tr>`;
  }
  
  tbody.innerHTML = html || '<tr><td colspan="4" class="text-xs">No matching instances.</td></tr>';
}

// Sort concordance table by clicking header
function sortConstConcTable(col) {
  if (constConcSortCol === col) {
    // Toggle direction
    constConcSortDir = constConcSortDir === 'asc' ? 'desc' : 'asc';
  } else {
    constConcSortCol = col;
    constConcSortDir = 'asc';
  }
  updateConstConcordanceDisplay();
}

// Helper: Split sentence into left/right context around KWIC word
function splitContextKWIC(sentText, kwic) {
  if (!sentText || !kwic) return { left: '', right: sentText || '' };
  
  // Try to find the KWIC word in the sentence (case insensitive)
  const lowerSent = sentText.toLowerCase();
  const lowerKwic = kwic.toLowerCase();
  const idx = lowerSent.indexOf(lowerKwic);
  
  if (idx === -1) {
    // If not found, try finding individual words
    const words = kwic.split(/\s+/);
    if (words.length > 0) {
      const firstWordIdx = lowerSent.indexOf(words[0].toLowerCase());
      if (firstWordIdx !== -1) {
        return {
          left: sentText.substring(0, firstWordIdx).trim(),
          right: sentText.substring(firstWordIdx + kwic.length).trim()
        };
      }
    }
    return { left: sentText, right: '' };
  }
  
  return {
    left: sentText.substring(0, idx).trim(),
    right: sentText.substring(idx + kwic.length).trim()
  };
}

// Helper: Get left context
function getLeftContext(sentText, kwic) {
  const { left } = splitContextKWIC(sentText, kwic);
  return left;
}

// Helper: Get right context
function getRightContext(sentText, kwic) {
  const { right } = splitContextKWIC(sentText, kwic);
  return right;
}

// Helper function
function escapeRegex(str) {
  return str.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
}

// Clear functions
function clearConstPattern() {
  constPatternRows = [];
  lastConstPatternRows = [];
  document.getElementById('constPatternTbody').innerHTML = '<tr><td colspan="10" class="text-xs">No data. Click Compute to search patterns.</td></tr>';
  document.getElementById('constPatternStatus').textContent = '';
  document.getElementById('constPatternSummary').style.display = 'none';
}

function clearConstConcordance() {
  currentConstInstances = [];
  document.getElementById('constConcordanceTbody').innerHTML = '<tr><td colspan="4" class="text-xs">No concordance data. Click a row in 12a) to view.</td></tr>';
  document.getElementById('constConcordanceFeature').textContent = '-';
  document.getElementById('constConcordanceCount').textContent = '0';
}

function backToConstPatternSearch() {
  // Collapse concordance section
  const content = document.getElementById('sectionConst12b-content');
  const arrow = document.getElementById('sectionConst12b-arrow');
  if (content) content.style.display = 'none';
  if (arrow) arrow.textContent = '▶';
  
  // Expand search section
  const searchContent = document.getElementById('sectionConst12a-content');
  const searchArrow = document.getElementById('sectionConst12a-arrow');
  if (searchContent && searchContent.style.display === 'none') {
    searchContent.style.display = 'block';
    if (searchArrow) searchArrow.textContent = '▼';
  }
}

// Filter functions
function applyConstFilter() {
  const freqFilter = parseInt(document.getElementById('constFilterFreq')?.value) || 0;
  const featureFilter = (document.getElementById('constFilterFeature')?.value || '').toLowerCase();
  const filterMode = document.getElementById('constFilterMode')?.value || 'partial';
  
  constPatternRows = lastConstPatternRows.filter(row => {
    const totalFreq = row.freqT + row.freqR + row.freqN;
    if (totalFreq < freqFilter) return false;
    
    if (featureFilter) {
      const feature = (row.word || '').toLowerCase();
      if (filterMode === 'exact') {
        const words = feature.split(/\s+/);
        if (!words.some(w => w === featureFilter)) return false;
      } else {
        if (!feature.includes(featureFilter)) return false;
      }
    }
    
    return true;
  });
  
  displayConstPatternResults();
}

function clearConstFilter() {
  document.getElementById('constFilterFreq').value = '1';
  document.getElementById('constFilterFeature').value = '';
  constPatternRows = [...lastConstPatternRows];
  displayConstPatternResults();
}

// Show all concordance
function showAllConstConcordance() {
  if (!lastConstPatternRows || lastConstPatternRows.length === 0) {
    alert('No pattern data. Please compute first.');
    return;
  }
  
  // Collect all instances
  const allInstances = [];
  for (const row of lastConstPatternRows) {
    if (row.instances) {
      for (const inst of row.instances) {
        allInstances.push({ ...inst, feature: row.word });
      }
    }
  }
  
  if (allInstances.length > 10000) {
    if (!confirm(`This will display ${allInstances.length.toLocaleString()} instances (limited to 10,000). Continue?`)) {
      return;
    }
  }
  
  currentConstInstances = allInstances.slice(0, 10000);
  
  document.getElementById('constConcordanceFeature').textContent = `[All ${lastConstPatternRows.length} filtered types]`;
  document.getElementById('constConcordanceCount').textContent = currentConstInstances.length.toLocaleString();
  
  // Expand section
  const content = document.getElementById('sectionConst12b-content');
  const arrow = document.getElementById('sectionConst12b-arrow');
  if (content && content.style.display === 'none') {
    content.style.display = 'block';
    if (arrow) arrow.textContent = '▼';
  }
  
  updateConstConcordanceDisplay();
  document.getElementById('constConcordanceSection')?.scrollIntoView({ behavior: 'smooth' });
}

// Sort table
function sortConstTable(colIdx) {
  const cols = ['', 'feature', 'chunk', 'freqT', 'normT', 'freqR', 'normR', 'freqLL', 'textLL', 'mtk'];
  const col = cols[colIdx];
  if (!col) return;
  
  if (constSortCol === col) {
    constSortDir = constSortDir === 'asc' ? 'desc' : 'asc';
  } else {
    constSortCol = col;
    constSortDir = 'asc';
  }
  
  const mult = constSortDir === 'asc' ? 1 : -1;
  
  constPatternRows.sort((a, b) => {
    if (col === 'feature' || col === 'chunk') {
      return mult * (a[col] || '').localeCompare(b[col] || '');
    } else {
      return mult * ((a[col] || 0) - (b[col] || 0));
    }
  });
  
  displayConstPatternResults();
}

// Export functions
function exportConstPatternExcel() {
  if (!constPatternRows || constPatternRows.length === 0) {
    alert('No data to export.');
    return;
  }
  
  let csv = 'Feature,Full Phrase,Chunk,Depth,Parent,Path,freq_T,norm_T,freq_R,norm_R,Freq-LL,Text-LL,MTK\n';
  for (const row of constPatternRows) {
    csv += `"${(row.feature || row.word || '').replace(/"/g, '""')}","${(row.fullPhrase || '').replace(/"/g, '""')}","${row.chunk || ''}",${row.depth || 0},"${row.parent || ''}","${(row.path || '').replace(/"/g, '""')}",${row.freqT},${row.normT.toFixed(2)},${row.freqR},${row.normR.toFixed(2)},${row.freqLL.toFixed(2)},${row.textLL.toFixed(2)},"${row.mtk}"\n`;
  }
  
  const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
  const link = document.createElement('a');
  link.href = URL.createObjectURL(blob);
  link.download = 'constituent_patterns.csv';
  link.click();
}

function exportConstConcordanceExcel() {
  if (!currentConstInstances || currentConstInstances.length === 0) {
    alert('No concordance data to export.');
    return;
  }
  
  let csv = 'Feature,File,Side,Concordance\n';
  for (const inst of currentConstInstances) {
    const feature = inst.fullPhrase || inst.word || '';
    csv += `"${feature.replace(/"/g, '""')}","${(inst.fileName || '').replace(/"/g, '""')}","${inst.side}","${(inst.sentText || '').replace(/"/g, '""')}"\n`;
  }
  
  const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
  const link = document.createElement('a');
  link.href = URL.createObjectURL(blob);
  link.download = 'constituent_concordance.csv';
  link.click();
}

// Check if constituent data is available in corpus
function hasConstituentData() {
  if (!corpus || !corpus.files) return false;
  const files = Object.values(corpus.files);
  if (files.length === 0) return false;
  
  // Check first file with tokens
  for (const file of files) {
    if (file.tokens && file.tokens.length > 0) {
      const tok = file.tokens[0];
      if (tok.chunk || tok.cpath || tok.cpath_norm) {
        return true;
      }
    }
  }
  return false;
}

// Initialize constituent UI
function initConstituentUI() {
  updateConstPresetList();
  
  // Initialize column resize for const pattern table
  initConstTableResize();
  
  // Check if constituent data is available
  const hasConstData = hasConstituentData();
  
  // Show/hide warning
  const warning = document.getElementById('constGrammarNotAvailable');
  const patternCard = document.getElementById('constPatternSearchCard');
  const concCard = document.getElementById('constConcordanceSection');
  
  if (!hasConstData) {
    if (warning) warning.style.display = 'block';
    if (patternCard) patternCard.style.opacity = '0.5';
    if (concCard) concCard.style.opacity = '0.5';
  } else {
    if (warning) warning.style.display = 'none';
    if (patternCard) patternCard.style.opacity = '1';
    if (concCard) concCard.style.opacity = '1';
  }
}

// Initialize column resize for constituent tables
function initConstTableResize() {
  // Pattern table
  const patternTable = document.getElementById('constPatternTable');
  if (patternTable) {
    const resizers = patternTable.querySelectorAll('.col-resizer');
    resizers.forEach(resizer => {
      resizer.addEventListener('mousedown', initConstResize);
    });
  }
  
  // Concordance table - use const-conc-resizer
  initConstConcTableResize();
}

// Initialize const concordance table resize (like dep conc table)
function initConstConcTableResize() {
  const table = document.getElementById('constConcordanceTable');
  if (!table) return;
  
  const cols = table.querySelectorAll('colgroup col');
  const resizers = table.querySelectorAll('.const-conc-resizer');

  resizers.forEach((resizer) => {
    const colIndex = parseInt(resizer.dataset.col, 10);
    const col = cols[colIndex];
    if (!col) return;

    let startX = 0;
    let startWidth = 0;

    const onMouseMove = (e) => {
      const dx = e.pageX - startX;
      const newWidth = Math.max(40, startWidth + dx);
      col.style.width = newWidth + 'px';
    };

    const onMouseUp = () => {
      document.removeEventListener('mousemove', onMouseMove);
      document.removeEventListener('mouseup', onMouseUp);
    };

    resizer.addEventListener('mousedown', (e) => {
      e.preventDefault();
      e.stopPropagation();
      startX = e.pageX;
      const colStyle = window.getComputedStyle(col);
      const width = parseFloat(colStyle.width);
      startWidth = isNaN(width) ? resizer.parentElement.offsetWidth : width;
      document.addEventListener('mousemove', onMouseMove);
      document.addEventListener('mouseup', onMouseUp);
    });
  });
}

function initConstResize(e) {
  const th = e.target.parentElement;
  const table = th.closest('table');
  const startX = e.pageX;
  const startWidth = th.offsetWidth;
  
  function doResize(e) {
    const width = startWidth + (e.pageX - startX);
    if (width > 30) {
      th.style.width = width + 'px';
    }
  }
  
  function stopResize() {
    document.removeEventListener('mousemove', doResize);
    document.removeEventListener('mouseup', stopResize);
  }
  
  document.addEventListener('mousemove', doResize);
  document.addEventListener('mouseup', stopResize);
  
  e.preventDefault();
  e.stopPropagation();
}

// Also init when document ready
document.addEventListener('DOMContentLoaded', () => {
  setTimeout(() => {
    populateDepRelationDropdowns();
    populateDepPosDropdowns();
    updateDepPresetList();
    setupDepElementCheckboxes();
    initDepTableResize();
    initDepConcTableResize();
    initConstituentUI();
  }, 100);
});

</script>

</body>
</html>
